{"version":3,"file":"account-provider/tokenCache.js","sourceRoot":"../src","sources":["account-provider/tokenCache.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the Source EULA. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport * as adal from 'adal-node';\nimport * as sqlops from 'sqlops';\nimport * as crypto from 'crypto';\nimport * as fs from 'fs';\n\nexport default class TokenCache implements adal.TokenCache {\n\tprivate static CipherAlgorithm = 'aes256';\n\tprivate static CipherAlgorithmIvLength = 16;\n\tprivate static CipherKeyLength = 32;\n\tprivate static FsOptions = { encoding: 'ascii' };\n\n\tprivate _activeOperation: Thenable<any>;\n\n\tconstructor(\n\t\tprivate _credentialProvider: sqlops.CredentialProvider,\n\t\tprivate _credentialServiceKey: string,\n\t\tprivate _cacheSerializationPath: string\n\t) {\n\t}\n\n\t// PUBLIC METHODS //////////////////////////////////////////////////////\n\tpublic add(entries: adal.TokenResponse[], callback: (error: Error, result: boolean) => void): void {\n\t\tlet self = this;\n\n\t\tthis.doOperation(() => {\n\t\t\treturn self.readCache()\n\t\t\t\t.then(cache => self.addToCache(cache, entries))\n\t\t\t\t.then(updatedCache => self.writeCache(updatedCache))\n\t\t\t\t.then(\n\t\t\t\t() => callback(null, false),\n\t\t\t\t(err) => callback(err, true)\n\t\t\t\t);\n\t\t});\n\t}\n\n\tpublic clear(): Thenable<void> {\n\t\tlet self = this;\n\n\t\t// 1) Delete encrypted serialization file\n\t\t//    If we got an 'ENOENT' response, the file doesn't exist, which is fine\n\t\t// 3) Delete the encryption key\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tfs.unlink(self._cacheSerializationPath, err => {\n\t\t\t\tif (err && err.code !== 'ENOENT') {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t})\n\t\t\t.then(() => { return self._credentialProvider.deleteCredential(self._credentialServiceKey); })\n\t\t\t.then(() => { });\n\t}\n\n\tpublic find(query: any, callback: (error: Error, results: any[]) => void): void {\n\t\tlet self = this;\n\n\t\tthis.doOperation(() => {\n\t\t\treturn self.readCache()\n\t\t\t\t.then(cache => {\n\t\t\t\t\treturn cache.filter(\n\t\t\t\t\t\tentry => TokenCache.findByPartial(entry, query)\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t\t.then(\n\t\t\t\tresults => callback(null, results),\n\t\t\t\t(err) => callback(err, null)\n\t\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Wrapper to make callback-based find method into a thenable method\n\t * @param query Partial object to use to look up tokens. Ideally should be partial of adal.TokenResponse\n\t * @returns {Thenable<any[]>} Promise to return the matching adal.TokenResponse objects.\n\t *     Rejected if an error was sent in the callback\n\t */\n\tpublic findThenable(query: any): Thenable<any[]> {\n\t\tlet self = this;\n\n\t\treturn new Promise<any[]>((resolve, reject) => {\n\t\t\tself.find(query, (error: Error, results: any[]) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(results);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic remove(entries: adal.TokenResponse[], callback: (error: Error, result: null) => void): void {\n\t\tlet self = this;\n\n\t\tthis.doOperation(() => {\n\t\t\treturn this.readCache()\n\t\t\t\t.then(cache => self.removeFromCache(cache, entries))\n\t\t\t\t.then(updatedCache => self.writeCache(updatedCache))\n\t\t\t\t.then(\n\t\t\t\t() => callback(null, null),\n\t\t\t\t(err) => callback(err, null)\n\t\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Wrapper to make callback-based remove method into a thenable method\n\t * @param {TokenResponse[]} entries Array of entries to remove from the token cache\n\t * @returns {Thenable<void>} Promise to remove the given tokens from the token cache\n\t *     Rejected if an error was sent in the callback\n\t */\n\tpublic removeThenable(entries: adal.TokenResponse[]): Thenable<void> {\n\t\tlet self = this;\n\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tself.remove(entries, (error: Error, result: null) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// PRIVATE METHODS /////////////////////////////////////////////////////\n\tprivate static findByKeyHelper(entry1: adal.TokenResponse, entry2: adal.TokenResponse): boolean {\n\t\treturn entry1._authority === entry2._authority\n\t\t\t&& entry1._clientId === entry2._clientId\n\t\t\t&& entry1.userId === entry2.userId\n\t\t\t&& entry1.resource === entry2.resource;\n\t}\n\n\tprivate static findByPartial(entry: adal.TokenResponse, query: object): boolean {\n\t\tfor (let key in query) {\n\t\t\tif (entry[key] === undefined || entry[key] !== query[key]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate doOperation<T>(op: () => Thenable<T>): void {\n\t\t// Initialize the active operation to an empty promise if necessary\n\t\tlet activeOperation = this._activeOperation || Promise.resolve<any>(null);\n\n\t\t// Chain the operation to perform to the end of the existing promise\n\t\tactiveOperation = activeOperation.then(op);\n\n\t\t// Add a catch at the end to make sure we can continue after any errors\n\t\tactiveOperation = activeOperation.then(null, err => {\n\t\t\tconsole.error(`Failed to perform token cache operation: ${err}`);\n\t\t});\n\n\t\t// Point the current active operation to this one\n\t\tthis._activeOperation = activeOperation;\n\t}\n\n\tprivate addToCache(cache: adal.TokenResponse[], entries: adal.TokenResponse[]): adal.TokenResponse[] {\n\t\t// First remove entries from the db that are being updated\n\t\tcache = this.removeFromCache(cache, entries);\n\n\t\t// Then add the new entries to the cache\n\t\tentries.forEach((entry: adal.TokenResponse) => {\n\t\t\tcache.push(entry);\n\t\t});\n\n\t\treturn cache;\n\t}\n\n\tprivate getOrCreateEncryptionParams(): Thenable<EncryptionParams> {\n\t\tlet self = this;\n\n\t\treturn this._credentialProvider.readCredential(this._credentialServiceKey)\n\t\t\t.then(credential => {\n\t\t\t\tif (credential.password) {\n\t\t\t\t\t// We already have encryption params, deserialize them\n\t\t\t\t\tlet splitValues = credential.password.split('|');\n\t\t\t\t\tif (splitValues.length === 2 && splitValues[0] && splitValues[1]) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn <EncryptionParams>{\n\t\t\t\t\t\t\t\tkey: new Buffer(splitValues[0], 'hex'),\n\t\t\t\t\t\t\t\tinitializationVector: new Buffer(splitValues[1], 'hex')\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t// Swallow the error and fall through to generate new params\n\t\t\t\t\t\t\tconsole.warn('Failed to deserialize encryption params, new ones will be generated.');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We haven't stored encryption values, so generate them\n\t\t\t\tlet encryptKey = crypto.randomBytes(TokenCache.CipherKeyLength);\n\t\t\t\tlet initializationVector = crypto.randomBytes(TokenCache.CipherAlgorithmIvLength);\n\n\t\t\t\t// Serialize the values\n\t\t\t\tlet serializedValues = `${encryptKey.toString('hex')}|${initializationVector.toString('hex')}`;\n\t\t\t\treturn self._credentialProvider.saveCredential(self._credentialServiceKey, serializedValues)\n\t\t\t\t\t.then(() => {\n\t\t\t\t\t\treturn <EncryptionParams>{\n\t\t\t\t\t\t\tkey: encryptKey,\n\t\t\t\t\t\t\tinitializationVector: initializationVector\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\tprivate readCache(): Thenable<adal.TokenResponse[]> {\n\t\tlet self = this;\n\n\t\t// NOTE: File system operations are performed synchronously to avoid annoying nested callbacks\n\t\t// 1) Get the encryption key\n\t\t// 2) Read the encrypted token cache file\n\t\t// 3) Decrypt the file contents\n\t\t// 4) Deserialize and return\n\t\treturn this.getOrCreateEncryptionParams()\n\t\t\t.then(encryptionParams => {\n\t\t\t\ttry {\n\t\t\t\t\treturn self.decryptCache('utf8', encryptionParams);\n\t\t\t\t} catch (e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// try to parse using 'binary' encoding and rewrite cache as UTF8\n\t\t\t\t\t\tlet response = self.decryptCache('binary', encryptionParams);\n\t\t\t\t\t\tself.writeCache(response);\n\t\t\t\t\t\treturn response;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(null, err => {\n\t\t\t\t// If reading the token cache fails, we'll just assume the tokens are garbage\n\t\t\t\tconsole.warn(`Failed to read token cache: ${err}`);\n\t\t\t\treturn [];\n\t\t\t});\n\t}\n\n\tprivate decryptCache(encoding: crypto.Utf8AsciiBinaryEncoding, encryptionParams: EncryptionParams): adal.TokenResponse[] {\n\t\tlet cacheCipher = fs.readFileSync(this._cacheSerializationPath, TokenCache.FsOptions);\n\t\tlet decipher = crypto.createDecipheriv(TokenCache.CipherAlgorithm, encryptionParams.key, encryptionParams.initializationVector);\n\t\tlet cacheJson = decipher.update(cacheCipher, 'hex', encoding);\n\t\tcacheJson += decipher.final(encoding);\n\n\t\t// Deserialize the JSON into the array of tokens\n\t\tlet cacheObj = <adal.TokenResponse[]>JSON.parse(cacheJson);\n\t\tfor (let objIndex in cacheObj) {\n\t\t\t// Rehydrate Date objects since they will always serialize as a string\n\t\t\tcacheObj[objIndex].expiresOn = new Date(<string>cacheObj[objIndex].expiresOn);\n\t\t}\n\n\t\treturn cacheObj;\n\t}\n\n\tprivate removeFromCache(cache: adal.TokenResponse[], entries: adal.TokenResponse[]): adal.TokenResponse[] {\n\t\tentries.forEach((entry: adal.TokenResponse) => {\n\t\t\t// Check to see if the entry exists\n\t\t\tlet match = cache.findIndex(entry2 => TokenCache.findByKeyHelper(entry, entry2));\n\t\t\tif (match >= 0) {\n\t\t\t\t// Entry exists, remove it from cache\n\t\t\t\tcache.splice(match, 1);\n\t\t\t}\n\t\t});\n\n\t\treturn cache;\n\t}\n\n\tprivate writeCache(cache: adal.TokenResponse[]): Thenable<void> {\n\t\tlet self = this;\n\t\t// NOTE: File system operations are being done synchronously to avoid annoying callback nesting\n\t\t// 1) Get (or generate) the encryption key\n\t\t// 2) Stringify the token cache entries\n\t\t// 4) Encrypt the JSON\n\t\t// 3) Write to the file\n\t\treturn this.getOrCreateEncryptionParams()\n\t\t\t.then(encryptionParams => {\n\t\t\t\ttry {\n\t\t\t\t\tlet cacheJson = JSON.stringify(cache);\n\n\t\t\t\t\tlet cipher = crypto.createCipheriv(TokenCache.CipherAlgorithm, encryptionParams.key, encryptionParams.initializationVector);\n\t\t\t\t\tlet cacheCipher = cipher.update(cacheJson, 'utf8', 'hex');\n\t\t\t\t\tcacheCipher += cipher.final('hex');\n\n\t\t\t\t\tfs.writeFileSync(self._cacheSerializationPath, cacheCipher, TokenCache.FsOptions);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t});\n\t}\n}\n\ninterface EncryptionParams {\n\tkey: Buffer;\n\tinitializationVector: Buffer;\n}\n"]}