{"version":3,"file":"objectExplorerNodeProvider/fileSources.js","sourceRoot":"../src","sources":["objectExplorerNodeProvider/fileSources.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the Source EULA. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\nimport * as fspath from 'path';\nimport * as webhdfs from 'webhdfs';\nimport * as fs from 'fs';\nimport * as meter from 'stream-meter';\nimport * as bytes from 'bytes';\nimport * as https from 'https';\nimport * as readline from 'readline';\nimport * as os from 'os';\n\nimport * as constants from '../constants';\nimport * as utils from '../utils';\n\nexport function joinHdfsPath(parent: string, child: string): string {\n\tif (parent === constants.hdfsRootPath) {\n\t\treturn `/${child}`;\n\t}\n\treturn `${parent}/${child}`;\n}\n\nexport interface IFile {\n\tpath: string;\n\tisDirectory: boolean;\n}\n\nexport class File implements IFile {\n\tconstructor(public path: string, public isDirectory: boolean) {\n\n\t}\n\n\tpublic static createPath(path: string, fileName: string): string {\n\t\treturn joinHdfsPath(path, fileName);\n\t}\n\n\tpublic static createChild(parent: IFile, fileName: string, isDirectory: boolean): IFile {\n\t\treturn new File(File.createPath(parent.path, fileName), isDirectory);\n\t}\n\n\tpublic static createFile(parent: IFile, fileName: string): File {\n\t\treturn File.createChild(parent, fileName, false);\n\t}\n\n\tpublic static createDirectory(parent: IFile, fileName: string): IFile {\n\t\treturn File.createChild(parent, fileName, true);\n\t}\n\n\tpublic static getBasename(file: IFile): string {\n\t\treturn fspath.basename(file.path);\n\t}\n}\n\nexport interface IFileSource {\n\n\tenumerateFiles(path: string): Promise<IFile[]>;\n\tmkdir(dirName: string, remoteBasePath: string): Promise<void>;\n\tcreateReadStream(path: string): fs.ReadStream;\n\treadFile(path: string, maxBytes?: number): Promise<Buffer>;\n\treadFileLines(path: string, maxLines: number): Promise<Buffer>;\n\twriteFile(localFile: IFile, remoteDir: string): Promise<string>;\n\tdelete(path: string, recursive?: boolean): Promise<void>;\n\texists(path: string): Promise<boolean>;\n}\n\nexport interface IHttpAuthentication {\n\tuser: string;\n\tpass: string;\n}\nexport interface IHdfsOptions {\n\thost?: string;\n\tport?: string;\n\tprotocol?: string;\n\tuser?: string;\n\tpath?: string;\n\trequestParams?: IRequestParams;\n}\n\nexport interface IRequestParams {\n\tauth?: IHttpAuthentication;\n\t/**\n\t * Timeout in milliseconds to wait for response\n\t */\n\ttimeout?: number;\n\tagent?: https.Agent;\n}\n\nexport interface IHdfsFileStatus {\n\ttype: 'FILE' | 'DIRECTORY';\n\tpathSuffix: string;\n}\n\nexport interface IHdfsClient {\n\treaddir(path: string, callback: (err: Error, files: any[]) => void): void;\n\n\t/**\n\t * Create readable stream for given path\n\t *\n\t * @method createReadStream\n\t * @fires Request#data\n\t * @fires WebHDFS#finish\n\t *\n\t * @param {String} path\n\t * @param {Object} [opts]\n\t *\n\t * @returns {Object}\n\t */\n\tcreateReadStream (path: string, opts?: object): fs.ReadStream;\n\n\t/**\n\t * Create writable stream for given path\n\t *\n\t * @example\n\t *\n\t * var WebHDFS = require('webhdfs');\n\t * var hdfs = WebHDFS.createClient();\n\t *\n\t * var localFileStream = fs.createReadStream('/path/to/local/file');\n\t * var remoteFileStream = hdfs.createWriteStream('/path/to/remote/file');\n\t *\n\t * localFileStream.pipe(remoteFileStream);\n\t *\n\t * remoteFileStream.on('error', function onError (err) {\n\t *   // Do something with the error\n\t * });\n\t *\n\t * remoteFileStream.on('finish', function onFinish () {\n\t *  // Upload is done\n\t * });\n\t *\n\t * @method createWriteStream\n\t * @fires WebHDFS#finish\n\t *\n\t * @param {String} path\n\t * @param {Boolean} [append] If set to true then append data to the file\n\t * @param {Object} [opts]\n\t *\n\t * @returns {Object}\n\t */\n\tcreateWriteStream(path: string, append?: boolean, opts?: object): fs.WriteStream;\n\n\t/**\n\t * Make new directory\n\t *\n\t * @method mkdir\n\t *\n\t * @param {String} path\n\t * @param {String} [mode=0777]\n\t * @param {Function} callback\n\t *\n\t * @returns {Object}\n\t */\n\tmkdir (path: string, callback: Function): void;\n\tmkdir (path: string, mode: string, callback: Function): void;\n\n\t/**\n\t * Delete directory or file path\n\t *\n\t * @method unlink\n\t *\n\t * @param {String} path\n\t * @param {Boolean} [recursive=false]\n\t * @param {Function} callback\n\t *\n\t * @returns {Object}\n\t */\n\trmdir (path: string, recursive: boolean, callback: Function): void;\n\n\t/**\n\t * Check file existence\n\t * Wraps stat method\n\t *\n\t * @method stat\n\t * @see WebHDFS.stat\n\t *\n\t * @param {String} path\n\t * @param {Function} callback\n\t *\n\t * @returns {Object}\n\t */\n\texists (path: string, callback: Function): boolean;\n}\n\nexport class FileSourceFactory {\n\tprivate static _instance: FileSourceFactory;\n\n\tpublic static get instance(): FileSourceFactory {\n\t\tif (!FileSourceFactory._instance) {\n\t\t\tFileSourceFactory._instance = new FileSourceFactory();\n\t\t}\n\t\treturn FileSourceFactory._instance;\n\t}\n\n\tpublic createHdfsFileSource(options: IHdfsOptions): IFileSource {\n\t\toptions = options && options.host ? FileSourceFactory.removePortFromHost(options) : options;\n\t\tlet requestParams: IRequestParams = options.requestParams ? options.requestParams : {};\n\t\tif (requestParams.auth) {\n\t\t\t// TODO Remove handling of unsigned cert once we have real certs in our Knox service\n\t\t\tlet agentOptions = {\n\t\t\t\thost: options.host,\n\t\t\t\tport: options.port,\n\t\t\t\tpath: constants.hdfsRootPath,\n\t\t\t\trejectUnauthorized: false\n\t\t\t  };\n\t\t\tlet agent = new https.Agent(agentOptions);\n\t\t\trequestParams['agent'] = agent;\n\t\t}\n\t\treturn new HdfsFileSource(webhdfs.createClient(options, requestParams));\n\t}\n\n\t// remove port from host when port is specified after a comma or colon\n\tprivate static removePortFromHost(options: IHdfsOptions): IHdfsOptions {\n\t\t// determine whether the host has either a ',' or ':' in it\n\t\toptions = this.setHostAndPort(options, ',');\n\t\toptions = this.setHostAndPort(options, ':');\n\t\treturn options;\n\t}\n\n\t// set port and host correctly after we've identified that a delimiter exists in the host name\n\tprivate static setHostAndPort(options: IHdfsOptions, delimeter: string): IHdfsOptions {\n\t\tlet optionsHost: string = options.host;\n\t\tif (options.host.indexOf(delimeter) > -1) {\n\t\t\toptions.host = options.host.slice(0, options.host.indexOf(delimeter));\n\t\t\toptions.port = optionsHost.replace(options.host + delimeter, '');\n\t\t}\n\t\treturn options;\n\t}\n}\n\nexport class HdfsFileSource implements IFileSource {\n\tconstructor(private client: IHdfsClient) {\n\t}\n\n\tpublic enumerateFiles(path: string): Promise<IFile[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.client.readdir(path, (error, files) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error.message);\n\t\t\t\t} else {\n\t\t\t\t\tlet hdfsFiles: IFile[] = files.map(file => {\n\t\t\t\t\t\tlet hdfsFile = <IHdfsFileStatus> file;\n\t\t\t\t\t\treturn new File(File.createPath(path, hdfsFile.pathSuffix), hdfsFile.type === 'DIRECTORY');\n\t\t\t\t\t});\n\t\t\t\t\tresolve(hdfsFiles);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic mkdir(dirName: string, remoteBasePath: string): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet remotePath = joinHdfsPath(remoteBasePath, dirName);\n\t\t\tthis.client.mkdir(remotePath, (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic createReadStream(path: string): fs.ReadStream {\n\t\treturn this.client.createReadStream(path);\n\t}\n\n\tpublic readFile(path: string, maxBytes?: number): Promise<Buffer> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet remoteFileStream = this.client.createReadStream(path);\n\t\t\tif (maxBytes) {\n\t\t\t\tremoteFileStream = remoteFileStream.pipe(meter(maxBytes));\n\t\t\t}\n\t\t\tlet data = [];\n\t\t\tlet error = undefined;\n\t\t\tremoteFileStream.on('error', (err) => {\n\t\t\t\terror = err.toString();\n\t\t\t\tif (error.includes('Stream exceeded specified max')) {\n\t\t\t\t\terror = `File exceeds max size of ${bytes(maxBytes)}`;\n\t\t\t\t}\n\t\t\t\treject(error);\n\t\t\t});\n\n\t\t\tremoteFileStream.on('data', (chunk) => {\n\t\t\t\tdata.push(chunk);\n\t\t\t});\n\n\t\t\tremoteFileStream.once('finish', () => {\n\t\t\t\tif (!error) {\n\t\t\t\t\tresolve(Buffer.concat(data));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic readFileLines(path: string, maxLines: number): Promise<Buffer> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet lineReader = readline.createInterface({\n\t\t\t\tinput: this.client.createReadStream(path)\n\t\t\t});\n\n\t\t\tlet lineCount = 0;\n\t\t\tlet lineData: string[] = [];\n\t\t\tlet errorMsg = undefined;\n\t\t\tlineReader.on('line', (line: string) => {\n\t\t\t\tlineCount++;\n\t\t\t\tlineData.push(line);\n\t\t\t\tif (lineCount >= maxLines) {\n\t\t\t\t\tresolve(Buffer.from(lineData.join(os.EOL)));\n\t\t\t\t\tlineReader.close();\n\t\t\t\t}\n\t\t\t})\n\t\t\t.on('error', (err) => {\n\t\t\t\terrorMsg = utils.getErrorMessage(err);\n\t\t\t\treject(errorMsg);\n\t\t\t})\n\t\t\t.on('close', () => {\n\t\t\t\tif (!errorMsg) {\n\t\t\t\t\tresolve(Buffer.from(lineData.join(os.EOL)));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic writeFile(localFile: IFile, remoteDirPath: string): Promise<string> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet fileName = fspath.basename(localFile.path);\n\t\t\tlet remotePath = joinHdfsPath(remoteDirPath, fileName);\n\n\t\t\tlet writeStream = this.client.createWriteStream(remotePath);\n\n\t\t\tlet readStream = fs.createReadStream(localFile.path);\n\t\t\treadStream.pipe(writeStream);\n\n\t\t\tlet error: string | Error = undefined;\n\n\t\t\t// API always calls finish, so catch error then handle exit in the finish event\n\t\t\twriteStream.on('error', (err => {\n\t\t\t\terror = err;\n\t\t\t\treject(error);\n\t\t\t}));\n\t\t\twriteStream.on('finish', (location) => {\n\t\t\t\tif (!error) {\n\t\t\t\t\tresolve(location);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic delete(path: string, recursive: boolean = false): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.client.rmdir(path, recursive, (error) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic exists(path: string): Promise<boolean> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.client.exists(path, (result) => {\n\t\t\t\tresolve(result);\n\t\t\t});\n\t\t});\n\t}\n}\n"]}