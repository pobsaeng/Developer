/*!--------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
(function() {
var __m = ["require","exports","vs/base/common/winjs.base","vs/base/common/event","vs/base/common/uri","vs/workbench/api/node/extHostTypes","vs/workbench/api/node/extHost.protocol","vs/platform/instantiation/common/instantiation","vs/base/common/strings","vs/base/common/lifecycle","vs/base/common/platform","sql/workbench/api/node/sqlExtHost.protocol","vs/base/common/async","vs/base/common/arrays","vs/base/common/errors","vs/nls","vs/base/common/paths","vs/nls!vs/workbench/node/extensionHostProcess","vs/base/common/types","vs/workbench/api/node/extHostTypeConverters","vs/base/common/objects","vs/base/common/map","path","vs/base/common/network","vs/editor/common/core/range","vs/editor/common/model","vs/base/common/resources","vs/editor/common/core/position","sql/workbench/api/common/sqlExtHostTypes","vs/base/common/cancellation","vs/platform/configuration/common/configuration","vs/platform/registry/common/platform","vs/base/common/assert","vs/base/common/glob","vs/base/common/severity","vs/editor/common/modes/languageConfiguration","vs/editor/common/modes","os","vs/platform/log/common/log","vs/editor/common/services/modelService","vs/platform/configuration/common/configurationRegistry","vs/editor/common/model/wordHelper","vs/platform/contextkey/common/contextkey","vs/platform/files/common/files","vs/base/common/uuid","vs/editor/common/modes/supports/richEditBrackets","vs/editor/common/modes/supports","vs/base/node/pfs","vs/workbench/api/node/extHostExtensionActivator","fs","child_process","vs/base/common/linkedList","vs/base/common/decorators","vs/base/parts/ipc/common/ipc","vs/editor/common/core/selection","vs/editor/common/services/modeService","vs/editor/common/core/uint","net","vs/editor/common/modes/nullMode","vs/editor/common/model/textModelSearch","vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase","vs/platform/environment/common/environment","vs/base/common/labels","vs/base/common/functional","vs/platform/markers/common/markers","vs/platform/node/package","vs/editor/common/modes/languageSelector","vs/editor/common/modes/modesRegistry","vs/base/node/extfs","vs/base/common/htmlContent","vs/platform/configuration/common/configurationModels","vs/platform/search/common/search","vs/platform/workspace/common/workspace","vs/editor/common/modes/languageConfigurationRegistry","vs/base/common/mime","vs/base/common/comparers","vs/workbench/api/node/extHostDocumentData","vs/workbench/api/node/extHostTreeViews","vs/workbench/common/editor","vs/workbench/services/extensions/node/proxyIdentifier","vs/base/common/errorMessage","vs/workbench/api/node/extHost.api.impl","vs/workbench/services/textfile/common/textfiles","vs/editor/common/config/editorOptions","vs/workbench/api/node/extHostTextEditor","vs/editor/common/model/textModelTokens","vs/editor/common/viewModel/prefixSumComputer","vs/editor/common/model/mirrorTextModel","vs/nls!sql/workbench/api/node/extHostModelView","vs/base/common/filters","vs/base/node/encoding","vs/nls!sql/workbench/api/node/extHostModelViewDialog","vs/nls!sql/workbench/api/node/extHostModelViewTree","vs/nls!sql/workbench/api/node/extHostNotebook","vs/nls!vs/base/common/errorMessage","vs/workbench/services/search/node/searchService","vs/nls!vs/base/common/severity","vs/workbench/services/untitled/common/untitledEditorService","vs/nls!vs/base/node/processes","vs/base/node/processes","vs/base/parts/ipc/node/ipc.cp","vs/nls!vs/editor/common/config/editorOptions","vs/base/common/marshalling","vs/nls!vs/editor/common/modes/modesRegistry","vs/nls!vs/platform/configuration/common/configurationRegistry","vs/nls!vs/platform/markers/common/markers","vs/nls!vs/platform/workspaces/common/workspaces","vs/nls!vs/workbench/api/node/extHostDiagnostics","vs/nls!vs/workbench/api/node/extHostExtensionActivator","vs/nls!vs/workbench/api/node/extHostProgress","vs/nls!vs/workbench/api/node/extHostTask","vs/nls!vs/workbench/api/node/extHostTreeViews","vs/nls!vs/workbench/api/node/extHostWorkspace","vs/nls!vs/workbench/node/extensionHostMain","vs/base/common/normalization","vs/base/common/stopwatch","vs/base/parts/ipc/node/ipc.net","vs/editor/common/modes/languageFeatureRegistry","vs/base/parts/quickopen/common/quickOpenScorer","vs/editor/common/core/lineTokens","vs/base/common/idGenerator","vs/base/common/scrollable","vs/editor/common/model/textModel","vs/editor/common/services/resourceConfiguration","vs/platform/commands/common/commands","vs/base/node/console","vs/editor/common/core/token","vs/base/node/decoder","vs/platform/keybinding/common/keybinding","vs/editor/common/core/characterClassifier","vs/platform/log/node/spdlogService","vs/editor/common/controller/wordCharacterClassifier","vs/workbench/node/extensionHostMain","vs/platform/node/product","vs/platform/notification/common/notification","vs/platform/progress/common/progress","vs/editor/common/model/editStack","vs/editor/common/model/indentationGuesser","vs/platform/jsonschemas/common/jsonContributionRegistry","vs/editor/common/model/intervalTree","vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase","vs/editor/common/model/textModelEvents","vs/base/node/flow","vs/platform/statusbar/common/statusbar","vs/platform/telemetry/common/telemetry","vs/platform/telemetry/common/telemetryUtils","vs/platform/workspaces/common/workspaces","assert","vs/platform/uriDisplay/common/uriDisplay","vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer","vs/workbench/api/node/extHostHeapService","vs/workbench/api/node/extHostLogService","vs/workbench/api/node/extHostSearch.fileIndex","vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder","vs/workbench/common/editor/untitledEditorInput","vs/base/node/stdFork","sql/workbench/api/node/extHostNotebookDocumentData","sql/workbench/api/node/extHostNotebookEditor","vs/base/common/json","sql/base/common/map","vs/base/common/processes","vs/workbench/common/editor/textEditorModel","vs/workbench/parts/tasks/common/tasks","vs/workbench/parts/terminal/common/terminal","vs/workbench/parts/terminal/node/terminalEnvironment","vs/workbench/parts/terminal/node/terminalProcess","vs/workbench/api/node/extHostExtensionService","vs/workbench/services/backup/common/backup","vs/workbench/common/editor/untitledEditorModel","vs/workbench/services/configuration/common/configurationModels","vs/workbench/api/node/extHostConfiguration","vs/workbench/services/editor/common/editorService","vs/workbench/services/extensions/common/extensions","vs/workbench/services/extensions/node/extensionDescriptionRegistry","vs/workbench/services/extensions/node/lazyPromise","vs/editor/common/modes/supports/characterPair","vs/editor/common/modes/supports/indentRules","sql/workbench/api/node/extHostAccountManagement","sql/workbench/api/node/extHostBackgroundTaskManagement","sql/workbench/api/node/extHostConnectionManagement","sql/workbench/api/node/extHostCredentialManagement","sql/workbench/api/node/extHostDashboard","sql/workbench/api/node/extHostDashboardWebview","sql/workbench/api/node/extHostDataProtocol","sql/workbench/api/node/extHostExtensionManagement","sql/workbench/api/node/extHostModalDialog","sql/workbench/api/node/extHostModelView","sql/workbench/api/node/extHostModelViewDialog","sql/workbench/api/node/extHostModelViewTree","sql/workbench/api/node/extHostNotebook","sql/workbench/api/node/extHostObjectExplorer","sql/workbench/api/node/extHostQueryEditor","sql/workbench/api/node/extHostResourceProvider","sql/workbench/api/node/extHostSerializationProvider","sql/workbench/api/node/extHostTasks","vs/editor/common/modes/supports/onEnter","vs/workbench/api/node/extHostDecorations","vs/workbench/api/node/extHostDialogs","vs/workbench/api/node/extHostDocumentContentProviders","vs/workbench/api/node/extHostFileSystem","vs/workbench/api/node/extHostLanguages","vs/workbench/api/node/extHostMessageService","vs/workbench/api/node/extHostOutputService","vs/workbench/api/node/extHostQuickOpen","vs/workbench/api/node/extHostSCM","vs/workbench/api/node/extHostSearch","vs/workbench/api/node/extHostStatusBar","vs/workbench/api/node/extHostStorage","vs/workbench/api/node/extHostTask","vs/workbench/api/node/extHostTerminalService","vs/workbench/api/node/extHostUrls","vs/workbench/api/node/extHostWindow","vs/workbench/api/node/extHostWorkspace","vs/workbench/services/extensions/node/rpcProtocol","vs/workbench/services/hash/common/hashService","vs/workbench/services/progress/common/progress","vs/workbench/services/search/node/search","vs/workbench/services/search/node/searchIpc","vs/base/common/actions","vs/editor/common/modes/supports/electricCharacter","sql/workbench/api/node/extHostNotebookDocumentsAndEditors","vs/workbench/api/node/apiCommands","vs/workbench/api/node/extHostApiCommands","vs/workbench/api/node/extHostCommands","vs/workbench/api/node/extHostComments","vs/workbench/api/node/extHostDiagnostics","vs/workbench/api/node/extHostDocumentSaveParticipant","vs/workbench/api/node/extHostDocuments","vs/workbench/api/node/extHostFileSystemEventService","vs/workbench/api/node/extHostLanguageFeatures","vs/workbench/api/node/extHostProgress","vs/base/node/stream","vs/workbench/api/node/extHostDocumentsAndEditors","vs/workbench/api/node/extHostTextEditors","vs/workbench/api/node/extHostWebview","vs/editor/common/modes/tokenizationRegistry","sql/workbench/api/node/sqlExtHost.api.impl","node-pty","crypto","stream","iconv-lite","string_decoder","vs/workbench/node/extensionHostProcess"];
var __M = function(deps) {
  var result = [];
  for (var i = 0, len = deps.length; i < len; i++) {
    result[i] = __m[deps[i]];
  }
  return result;
};
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[159/*sql/base/common/map*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // --- trie'ish datastructure
    var Node = /** @class */ (function () {
        function Node() {
            this.children = new Map();
        }
        return Node;
    }());
    /**
     * A trie map that allows for fast look up when keys are substrings
     * to the actual search keys (dir/subdir-problem).
     */
    var TrieMap = /** @class */ (function () {
        function TrieMap(splitter) {
            if (splitter === void 0) { splitter = TrieMap.PathSplitter; }
            this._root = new Node();
            this._splitter = function (s) { return splitter(s).filter(function (s) { return Boolean(s); }); };
        }
        TrieMap.prototype.insert = function (path, element) {
            var parts = this._splitter(path);
            var i = 0;
            // find insertion node
            var node = this._root;
            for (; i < parts.length; i++) {
                var child = node.children.get(parts[i]);
                if (child) {
                    node = child;
                    continue;
                }
                break;
            }
            // create new nodes
            var newNode;
            for (; i < parts.length; i++) {
                newNode = new Node();
                node.children.set(parts[i], newNode);
                node = newNode;
            }
            node.element = element;
        };
        TrieMap.prototype.lookUp = function (path) {
            var parts = this._splitter(path);
            var children = this._root.children;
            var node;
            for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
                var part = parts_1[_i];
                node = children.get(part);
                if (!node) {
                    return undefined;
                }
                children = node.children;
            }
            return node.element;
        };
        TrieMap.prototype.findSubstr = function (path) {
            var parts = this._splitter(path);
            var lastNode;
            var children = this._root.children;
            for (var _i = 0, parts_2 = parts; _i < parts_2.length; _i++) {
                var part = parts_2[_i];
                var node = children.get(part);
                if (!node) {
                    break;
                }
                if (node.element) {
                    lastNode = node;
                }
                children = node.children;
            }
            // return the last matching node
            // that had an element
            if (lastNode) {
                return lastNode.element;
            }
            return undefined;
        };
        TrieMap.prototype.findSuperstr = function (path) {
            var parts = this._splitter(path);
            var children = this._root.children;
            var node;
            for (var _i = 0, parts_3 = parts; _i < parts_3.length; _i++) {
                var part = parts_3[_i];
                node = children.get(part);
                if (!node) {
                    return undefined;
                }
                children = node.children;
            }
            var result = new TrieMap(this._splitter);
            result._root = node;
            return result;
        };
        TrieMap.PathSplitter = function (s) { return s.split(/[\\/]/).filter(function (s) { return !!s; }); };
        return TrieMap;
    }());
    exports.TrieMap = TrieMap;
    function toObject(map) {
        if (map) {
            var rt_1 = Object.create(null);
            map.forEach(function (v, k) {
                rt_1[k] = v;
            });
            return rt_1;
        }
        return {};
    }
    exports.toObject = toObject;
});

define(__m[32/*vs/base/common/assert*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.
     */
    function ok(value, message) {
        if (!value || value === null) {
            throw new Error(message ? 'Assertion failed (' + message + ')' : 'Assertion Failed');
        }
    }
    exports.ok = ok;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[52/*vs/base/common/decorators*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function createDecorator(mapFn) {
        return function (target, key, descriptor) {
            var fnKey = null;
            var fn = null;
            if (typeof descriptor.value === 'function') {
                fnKey = 'value';
                fn = descriptor.value;
            }
            else if (typeof descriptor.get === 'function') {
                fnKey = 'get';
                fn = descriptor.get;
            }
            if (!fn) {
                throw new Error('not supported');
            }
            descriptor[fnKey] = mapFn(fn, key);
        };
    }
    exports.createDecorator = createDecorator;
    function memoize(target, key, descriptor) {
        var fnKey = null;
        var fn = null;
        if (typeof descriptor.value === 'function') {
            fnKey = 'value';
            fn = descriptor.value;
            if (fn.length !== 0) {
                console.warn('Memoize should only be used in functions with zero parameters');
            }
        }
        else if (typeof descriptor.get === 'function') {
            fnKey = 'get';
            fn = descriptor.get;
        }
        if (!fn) {
            throw new Error('not supported');
        }
        var memoizeKey = "$memoize$" + key;
        descriptor[fnKey] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!this.hasOwnProperty(memoizeKey)) {
                Object.defineProperty(this, memoizeKey, {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: fn.apply(this, args)
                });
            }
            return this[memoizeKey];
        };
    }
    exports.memoize = memoize;
    function debounce(delay, reducer, initialValueProvider) {
        return createDecorator(function (fn, key) {
            var timerKey = "$debounce$" + key;
            var resultKey = "$debounce$result$" + key;
            return function () {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (!this[resultKey]) {
                    this[resultKey] = initialValueProvider ? initialValueProvider() : void 0;
                }
                clearTimeout(this[timerKey]);
                if (reducer) {
                    this[resultKey] = reducer.apply(void 0, [this[resultKey]].concat(args));
                    args = [this[resultKey]];
                }
                this[timerKey] = setTimeout(function () {
                    fn.apply(_this, args);
                    _this[resultKey] = initialValueProvider ? initialValueProvider() : void 0;
                }, delay);
            };
        });
    }
    exports.debounce = debounce;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[63/*vs/base/common/functional*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function once(fn) {
        var _this = this;
        var didCall = false;
        var result;
        return function () {
            if (didCall) {
                return result;
            }
            didCall = true;
            result = fn.apply(_this, arguments);
            return result;
        };
    }
    exports.once = once;
});

define(__m[120/*vs/base/common/idGenerator*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var IdGenerator = /** @class */ (function () {
        function IdGenerator(prefix) {
            this._prefix = prefix;
            this._lastId = 0;
        }
        IdGenerator.prototype.nextId = function () {
            return this._prefix + (++this._lastId);
        };
        return IdGenerator;
    }());
    exports.IdGenerator = IdGenerator;
    exports.defaultGenerator = new IdGenerator('id#');
});

define(__m[158/*vs/base/common/json*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ScanError;
    (function (ScanError) {
        ScanError[ScanError["None"] = 0] = "None";
        ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
        ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
        ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
        ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
        ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
        ScanError[ScanError["InvalidCharacter"] = 6] = "InvalidCharacter";
    })(ScanError = exports.ScanError || (exports.ScanError = {}));
    var SyntaxKind;
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["Unknown"] = 0] = "Unknown";
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
        SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
        SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
        SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
        SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
        SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
        SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
        SyntaxKind[SyntaxKind["EOF"] = 16] = "EOF";
    })(SyntaxKind = exports.SyntaxKind || (exports.SyntaxKind = {}));
    /**
     * Creates a JSON scanner on the given text.
     * If ignoreTrivia is set, whitespaces or comments are ignored.
     */
    function createScanner(text, ignoreTrivia) {
        if (ignoreTrivia === void 0) { ignoreTrivia = false; }
        var pos = 0, len = text.length, value = '', tokenOffset = 0, token = SyntaxKind.Unknown, scanError = ScanError.None;
        function scanHexDigits(count, exact) {
            var digits = 0;
            var value = 0;
            while (digits < count || !exact) {
                var ch = text.charCodeAt(pos);
                if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {
                    value = value * 16 + ch - 48 /* _0 */;
                }
                else if (ch >= 65 /* A */ && ch <= 70 /* F */) {
                    value = value * 16 + ch - 65 /* A */ + 10;
                }
                else if (ch >= 97 /* a */ && ch <= 102 /* f */) {
                    value = value * 16 + ch - 97 /* a */ + 10;
                }
                else {
                    break;
                }
                pos++;
                digits++;
            }
            if (digits < count) {
                value = -1;
            }
            return value;
        }
        function setPosition(newPosition) {
            pos = newPosition;
            value = '';
            tokenOffset = 0;
            token = SyntaxKind.Unknown;
            scanError = ScanError.None;
        }
        function scanNumber() {
            var start = pos;
            if (text.charCodeAt(pos) === 48 /* _0 */) {
                pos++;
            }
            else {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
            }
            if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {
                pos++;
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                }
                else {
                    scanError = ScanError.UnexpectedEndOfNumber;
                    return text.substring(start, pos);
                }
            }
            var end = pos;
            if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {
                pos++;
                if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {
                    pos++;
                }
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                    end = pos;
                }
                else {
                    scanError = ScanError.UnexpectedEndOfNumber;
                }
            }
            return text.substring(start, end);
        }
        function scanString() {
            var result = '', start = pos;
            while (true) {
                if (pos >= len) {
                    result += text.substring(start, pos);
                    scanError = ScanError.UnexpectedEndOfString;
                    break;
                }
                var ch = text.charCodeAt(pos);
                if (ch === 34 /* doubleQuote */) {
                    result += text.substring(start, pos);
                    pos++;
                    break;
                }
                if (ch === 92 /* backslash */) {
                    result += text.substring(start, pos);
                    pos++;
                    if (pos >= len) {
                        scanError = ScanError.UnexpectedEndOfString;
                        break;
                    }
                    ch = text.charCodeAt(pos++);
                    switch (ch) {
                        case 34 /* doubleQuote */:
                            result += '\"';
                            break;
                        case 92 /* backslash */:
                            result += '\\';
                            break;
                        case 47 /* slash */:
                            result += '/';
                            break;
                        case 98 /* b */:
                            result += '\b';
                            break;
                        case 102 /* f */:
                            result += '\f';
                            break;
                        case 110 /* n */:
                            result += '\n';
                            break;
                        case 114 /* r */:
                            result += '\r';
                            break;
                        case 116 /* t */:
                            result += '\t';
                            break;
                        case 117 /* u */:
                            var ch_1 = scanHexDigits(4, true);
                            if (ch_1 >= 0) {
                                result += String.fromCharCode(ch_1);
                            }
                            else {
                                scanError = ScanError.InvalidUnicode;
                            }
                            break;
                        default:
                            scanError = ScanError.InvalidEscapeCharacter;
                    }
                    start = pos;
                    continue;
                }
                if (ch >= 0 && ch <= 0x1f) {
                    if (isLineBreak(ch)) {
                        result += text.substring(start, pos);
                        scanError = ScanError.UnexpectedEndOfString;
                        break;
                    }
                    else {
                        scanError = ScanError.InvalidCharacter;
                        // mark as error but continue with string
                    }
                }
                pos++;
            }
            return result;
        }
        function scanNext() {
            value = '';
            scanError = ScanError.None;
            tokenOffset = pos;
            if (pos >= len) {
                // at the end
                tokenOffset = len;
                return token = SyntaxKind.EOF;
            }
            var code = text.charCodeAt(pos);
            // trivia: whitespace
            if (isWhiteSpace(code)) {
                do {
                    pos++;
                    value += String.fromCharCode(code);
                    code = text.charCodeAt(pos);
                } while (isWhiteSpace(code));
                return token = SyntaxKind.Trivia;
            }
            // trivia: newlines
            if (isLineBreak(code)) {
                pos++;
                value += String.fromCharCode(code);
                if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {
                    pos++;
                    value += '\n';
                }
                return token = SyntaxKind.LineBreakTrivia;
            }
            switch (code) {
                // tokens: []{}:,
                case 123 /* openBrace */:
                    pos++;
                    return token = SyntaxKind.OpenBraceToken;
                case 125 /* closeBrace */:
                    pos++;
                    return token = SyntaxKind.CloseBraceToken;
                case 91 /* openBracket */:
                    pos++;
                    return token = SyntaxKind.OpenBracketToken;
                case 93 /* closeBracket */:
                    pos++;
                    return token = SyntaxKind.CloseBracketToken;
                case 58 /* colon */:
                    pos++;
                    return token = SyntaxKind.ColonToken;
                case 44 /* comma */:
                    pos++;
                    return token = SyntaxKind.CommaToken;
                // strings
                case 34 /* doubleQuote */:
                    pos++;
                    value = scanString();
                    return token = SyntaxKind.StringLiteral;
                // comments
                case 47 /* slash */:
                    var start = pos - 1;
                    // Single-line comment
                    if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                        pos += 2;
                        while (pos < len) {
                            if (isLineBreak(text.charCodeAt(pos))) {
                                break;
                            }
                            pos++;
                        }
                        value = text.substring(start, pos);
                        return token = SyntaxKind.LineCommentTrivia;
                    }
                    // Multi-line comment
                    if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                        pos += 2;
                        var safeLength = len - 1; // For lookahead.
                        var commentClosed = false;
                        while (pos < safeLength) {
                            var ch = text.charCodeAt(pos);
                            if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                pos += 2;
                                commentClosed = true;
                                break;
                            }
                            pos++;
                        }
                        if (!commentClosed) {
                            pos++;
                            scanError = ScanError.UnexpectedEndOfComment;
                        }
                        value = text.substring(start, pos);
                        return token = SyntaxKind.BlockCommentTrivia;
                    }
                    // just a single slash
                    value += String.fromCharCode(code);
                    pos++;
                    return token = SyntaxKind.Unknown;
                // numbers
                case 45 /* minus */:
                    value += String.fromCharCode(code);
                    pos++;
                    if (pos === len || !isDigit(text.charCodeAt(pos))) {
                        return token = SyntaxKind.Unknown;
                    }
                // found a minus, followed by a number so
                // we fall through to proceed with scanning
                // numbers
                case 48 /* _0 */:
                case 49 /* _1 */:
                case 50 /* _2 */:
                case 51 /* _3 */:
                case 52 /* _4 */:
                case 53 /* _5 */:
                case 54 /* _6 */:
                case 55 /* _7 */:
                case 56 /* _8 */:
                case 57 /* _9 */:
                    value += scanNumber();
                    return token = SyntaxKind.NumericLiteral;
                // literals and unknown symbols
                default:
                    // is a literal? Read the full word.
                    while (pos < len && isUnknownContentCharacter(code)) {
                        pos++;
                        code = text.charCodeAt(pos);
                    }
                    if (tokenOffset !== pos) {
                        value = text.substring(tokenOffset, pos);
                        // keywords: true, false, null
                        switch (value) {
                            case 'true': return token = SyntaxKind.TrueKeyword;
                            case 'false': return token = SyntaxKind.FalseKeyword;
                            case 'null': return token = SyntaxKind.NullKeyword;
                        }
                        return token = SyntaxKind.Unknown;
                    }
                    // some
                    value += String.fromCharCode(code);
                    pos++;
                    return token = SyntaxKind.Unknown;
            }
        }
        function isUnknownContentCharacter(code) {
            if (isWhiteSpace(code) || isLineBreak(code)) {
                return false;
            }
            switch (code) {
                case 125 /* closeBrace */:
                case 93 /* closeBracket */:
                case 123 /* openBrace */:
                case 91 /* openBracket */:
                case 34 /* doubleQuote */:
                case 58 /* colon */:
                case 44 /* comma */:
                case 47 /* slash */:
                    return false;
            }
            return true;
        }
        function scanNextNonTrivia() {
            var result;
            do {
                result = scanNext();
            } while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);
            return result;
        }
        return {
            setPosition: setPosition,
            getPosition: function () { return pos; },
            scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
            getToken: function () { return token; },
            getTokenValue: function () { return value; },
            getTokenOffset: function () { return tokenOffset; },
            getTokenLength: function () { return pos - tokenOffset; },
            getTokenError: function () { return scanError; }
        };
    }
    exports.createScanner = createScanner;
    function isWhiteSpace(ch) {
        return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||
            ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||
            ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
    }
    function isLineBreak(ch) {
        return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;
    }
    function isDigit(ch) {
        return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
    }
    var CharacterCodes;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 8232] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 8233] = "paragraphSeparator";
        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems
        // like an odd disparity?  (Or maybe it's completely fine for them to be different).
        CharacterCodes[CharacterCodes["nextLine"] = 133] = "nextLine";
        // Unicode 3.0 space characters
        CharacterCodes[CharacterCodes["space"] = 32] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 160] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 8192] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 8193] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 8194] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 8195] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 8196] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 8197] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 8198] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 8199] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 8200] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 8201] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 8202] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 8203] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 8239] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 12288] = "ideographicSpace";
        CharacterCodes[CharacterCodes["mathematicalSpace"] = 8287] = "mathematicalSpace";
        CharacterCodes[CharacterCodes["ogham"] = 5760] = "ogham";
        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["j"] = 106] = "j";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";
        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["B"] = 66] = "B";
        CharacterCodes[CharacterCodes["C"] = 67] = "C";
        CharacterCodes[CharacterCodes["D"] = 68] = "D";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["G"] = 71] = "G";
        CharacterCodes[CharacterCodes["H"] = 72] = "H";
        CharacterCodes[CharacterCodes["I"] = 73] = "I";
        CharacterCodes[CharacterCodes["J"] = 74] = "J";
        CharacterCodes[CharacterCodes["K"] = 75] = "K";
        CharacterCodes[CharacterCodes["L"] = 76] = "L";
        CharacterCodes[CharacterCodes["M"] = 77] = "M";
        CharacterCodes[CharacterCodes["N"] = 78] = "N";
        CharacterCodes[CharacterCodes["O"] = 79] = "O";
        CharacterCodes[CharacterCodes["P"] = 80] = "P";
        CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
        CharacterCodes[CharacterCodes["R"] = 82] = "R";
        CharacterCodes[CharacterCodes["S"] = 83] = "S";
        CharacterCodes[CharacterCodes["T"] = 84] = "T";
        CharacterCodes[CharacterCodes["U"] = 85] = "U";
        CharacterCodes[CharacterCodes["V"] = 86] = "V";
        CharacterCodes[CharacterCodes["W"] = 87] = "W";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 65279] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(CharacterCodes || (CharacterCodes = {}));
    var ParseErrorCode;
    (function (ParseErrorCode) {
        ParseErrorCode[ParseErrorCode["InvalidSymbol"] = 0] = "InvalidSymbol";
        ParseErrorCode[ParseErrorCode["InvalidNumberFormat"] = 1] = "InvalidNumberFormat";
        ParseErrorCode[ParseErrorCode["PropertyNameExpected"] = 2] = "PropertyNameExpected";
        ParseErrorCode[ParseErrorCode["ValueExpected"] = 3] = "ValueExpected";
        ParseErrorCode[ParseErrorCode["ColonExpected"] = 4] = "ColonExpected";
        ParseErrorCode[ParseErrorCode["CommaExpected"] = 5] = "CommaExpected";
        ParseErrorCode[ParseErrorCode["CloseBraceExpected"] = 6] = "CloseBraceExpected";
        ParseErrorCode[ParseErrorCode["CloseBracketExpected"] = 7] = "CloseBracketExpected";
        ParseErrorCode[ParseErrorCode["EndOfFileExpected"] = 8] = "EndOfFileExpected";
    })(ParseErrorCode = exports.ParseErrorCode || (exports.ParseErrorCode = {}));
    function getLiteralNodeType(value) {
        switch (typeof value) {
            case 'boolean': return 'boolean';
            case 'number': return 'number';
            case 'string': return 'string';
            default: return 'null';
        }
    }
    /**
     * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
     * Therefore always check the errors list to find out if the input was valid.
     */
    function parse(text, errors, options) {
        if (errors === void 0) { errors = []; }
        var currentProperty = null;
        var currentParent = [];
        var previousParents = [];
        function onValue(value) {
            if (Array.isArray(currentParent)) {
                currentParent.push(value);
            }
            else if (currentProperty) {
                currentParent[currentProperty] = value;
            }
        }
        var visitor = {
            onObjectBegin: function () {
                var object = {};
                onValue(object);
                previousParents.push(currentParent);
                currentParent = object;
                currentProperty = null;
            },
            onObjectProperty: function (name) {
                currentProperty = name;
            },
            onObjectEnd: function () {
                currentParent = previousParents.pop();
            },
            onArrayBegin: function () {
                var array = [];
                onValue(array);
                previousParents.push(currentParent);
                currentParent = array;
                currentProperty = null;
            },
            onArrayEnd: function () {
                currentParent = previousParents.pop();
            },
            onLiteralValue: onValue,
            onError: function (error) {
                errors.push({ error: error });
            }
        };
        visit(text, visitor, options);
        return currentParent[0];
    }
    exports.parse = parse;
    /**
     * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
     */
    function parseTree(text, errors, options) {
        if (errors === void 0) { errors = []; }
        var currentParent = { type: 'array', offset: -1, length: -1, children: [] }; // artificial root
        function ensurePropertyComplete(endOffset) {
            if (currentParent.type === 'property') {
                currentParent.length = endOffset - currentParent.offset;
                currentParent = currentParent.parent;
            }
        }
        function onValue(valueNode) {
            currentParent.children.push(valueNode);
            return valueNode;
        }
        var visitor = {
            onObjectBegin: function (offset) {
                currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });
            },
            onObjectProperty: function (name, offset, length) {
                currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });
                currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });
            },
            onObjectEnd: function (offset, length) {
                currentParent.length = offset + length - currentParent.offset;
                currentParent = currentParent.parent;
                ensurePropertyComplete(offset + length);
            },
            onArrayBegin: function (offset, length) {
                currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });
            },
            onArrayEnd: function (offset, length) {
                currentParent.length = offset + length - currentParent.offset;
                currentParent = currentParent.parent;
                ensurePropertyComplete(offset + length);
            },
            onLiteralValue: function (value, offset, length) {
                onValue({ type: getLiteralNodeType(value), offset: offset, length: length, parent: currentParent, value: value });
                ensurePropertyComplete(offset + length);
            },
            onSeparator: function (sep, offset, length) {
                if (currentParent.type === 'property') {
                    if (sep === ':') {
                        currentParent.columnOffset = offset;
                    }
                    else if (sep === ',') {
                        ensurePropertyComplete(offset);
                    }
                }
            },
            onError: function (error) {
                errors.push({ error: error });
            }
        };
        visit(text, visitor, options);
        var result = currentParent.children[0];
        if (result) {
            delete result.parent;
        }
        return result;
    }
    exports.parseTree = parseTree;
    function findNodeAtLocation(root, path) {
        if (!root) {
            return void 0;
        }
        var node = root;
        for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
            var segment = path_1[_i];
            if (typeof segment === 'string') {
                if (node.type !== 'object') {
                    return void 0;
                }
                var found = false;
                for (var _a = 0, _b = node.children; _a < _b.length; _a++) {
                    var propertyNode = _b[_a];
                    if (propertyNode.children[0].value === segment) {
                        node = propertyNode.children[1];
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    return void 0;
                }
            }
            else {
                var index = segment;
                if (node.type !== 'array' || index < 0 || index >= node.children.length) {
                    return void 0;
                }
                node = node.children[index];
            }
        }
        return node;
    }
    exports.findNodeAtLocation = findNodeAtLocation;
    function getNodeValue(node) {
        if (node.type === 'array') {
            return node.children.map(getNodeValue);
        }
        else if (node.type === 'object') {
            var obj = {};
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var prop = _a[_i];
                obj[prop.children[0].value] = getNodeValue(prop.children[1]);
            }
            return obj;
        }
        return node.value;
    }
    exports.getNodeValue = getNodeValue;
    /**
     * Parses the given text and invokes the visitor functions for each object, array and literal reached.
     */
    function visit(text, visitor, options) {
        var _scanner = createScanner(text, false);
        function toNoArgVisit(visitFunction) {
            return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
        }
        function toOneArgVisit(visitFunction) {
            return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
        }
        var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onError = toOneArgVisit(visitor.onError);
        var disallowComments = options && options.disallowComments;
        var disallowTrailingComma = options && options.disallowTrailingComma;
        function scanNext() {
            while (true) {
                var token = _scanner.scan();
                switch (token) {
                    case SyntaxKind.LineCommentTrivia:
                    case SyntaxKind.BlockCommentTrivia:
                        if (disallowComments) {
                            handleError(ParseErrorCode.InvalidSymbol);
                        }
                        break;
                    case SyntaxKind.Unknown:
                        handleError(ParseErrorCode.InvalidSymbol);
                        break;
                    case SyntaxKind.Trivia:
                    case SyntaxKind.LineBreakTrivia:
                        break;
                    default:
                        return token;
                }
            }
        }
        function handleError(error, skipUntilAfter, skipUntil) {
            if (skipUntilAfter === void 0) { skipUntilAfter = []; }
            if (skipUntil === void 0) { skipUntil = []; }
            onError(error);
            if (skipUntilAfter.length + skipUntil.length > 0) {
                var token = _scanner.getToken();
                while (token !== SyntaxKind.EOF) {
                    if (skipUntilAfter.indexOf(token) !== -1) {
                        scanNext();
                        break;
                    }
                    else if (skipUntil.indexOf(token) !== -1) {
                        break;
                    }
                    token = scanNext();
                }
            }
        }
        function parseString(isValue) {
            var value = _scanner.getTokenValue();
            if (isValue) {
                onLiteralValue(value);
            }
            else {
                onObjectProperty(value);
            }
            scanNext();
            return true;
        }
        function parseLiteral() {
            switch (_scanner.getToken()) {
                case SyntaxKind.NumericLiteral:
                    var value = 0;
                    try {
                        value = JSON.parse(_scanner.getTokenValue());
                        if (typeof value !== 'number') {
                            handleError(ParseErrorCode.InvalidNumberFormat);
                            value = 0;
                        }
                    }
                    catch (e) {
                        handleError(ParseErrorCode.InvalidNumberFormat);
                    }
                    onLiteralValue(value);
                    break;
                case SyntaxKind.NullKeyword:
                    onLiteralValue(null);
                    break;
                case SyntaxKind.TrueKeyword:
                    onLiteralValue(true);
                    break;
                case SyntaxKind.FalseKeyword:
                    onLiteralValue(false);
                    break;
                default:
                    return false;
            }
            scanNext();
            return true;
        }
        function parseProperty() {
            if (_scanner.getToken() !== SyntaxKind.StringLiteral) {
                handleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                return false;
            }
            parseString(false);
            if (_scanner.getToken() === SyntaxKind.ColonToken) {
                onSeparator(':');
                scanNext(); // consume colon
                if (!parseValue()) {
                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                }
            }
            else {
                handleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
            }
            return true;
        }
        function parseObject() {
            onObjectBegin();
            scanNext(); // consume open brace
            var needsComma = false;
            while (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {
                if (_scanner.getToken() === SyntaxKind.CommaToken) {
                    if (!needsComma) {
                        handleError(ParseErrorCode.ValueExpected, [], []);
                    }
                    onSeparator(',');
                    scanNext(); // consume comma
                    if (_scanner.getToken() === SyntaxKind.CloseBraceToken && !disallowTrailingComma) {
                        break;
                    }
                }
                else if (needsComma) {
                    handleError(ParseErrorCode.CommaExpected, [], []);
                }
                if (!parseProperty()) {
                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                }
                needsComma = true;
            }
            onObjectEnd();
            if (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {
                handleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);
            }
            else {
                scanNext(); // consume close brace
            }
            return true;
        }
        function parseArray() {
            onArrayBegin();
            scanNext(); // consume open bracket
            var needsComma = false;
            while (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {
                if (_scanner.getToken() === SyntaxKind.CommaToken) {
                    if (!needsComma) {
                        handleError(ParseErrorCode.ValueExpected, [], []);
                    }
                    onSeparator(',');
                    scanNext(); // consume comma
                    if (_scanner.getToken() === SyntaxKind.CloseBracketToken && !disallowTrailingComma) {
                        break;
                    }
                }
                else if (needsComma) {
                    handleError(ParseErrorCode.CommaExpected, [], []);
                }
                if (!parseValue()) {
                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);
                }
                needsComma = true;
            }
            onArrayEnd();
            if (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {
                handleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);
            }
            else {
                scanNext(); // consume close bracket
            }
            return true;
        }
        function parseValue() {
            switch (_scanner.getToken()) {
                case SyntaxKind.OpenBracketToken:
                    return parseArray();
                case SyntaxKind.OpenBraceToken:
                    return parseObject();
                case SyntaxKind.StringLiteral:
                    return parseString(true);
                default:
                    return parseLiteral();
            }
        }
        scanNext();
        if (_scanner.getToken() === SyntaxKind.EOF) {
            return true;
        }
        if (!parseValue()) {
            handleError(ParseErrorCode.ValueExpected, [], []);
            return false;
        }
        if (_scanner.getToken() !== SyntaxKind.EOF) {
            handleError(ParseErrorCode.EndOfFileExpected, [], []);
        }
        return true;
    }
    exports.visit = visit;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[9/*vs/base/common/lifecycle*/], __M([0/*require*/,1/*exports*/,63/*vs/base/common/functional*/]), function (require, exports, functional_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function isDisposable(thing) {
        return typeof thing.dispose === 'function'
            && thing.dispose.length === 0;
    }
    exports.isDisposable = isDisposable;
    function dispose(first) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        if (Array.isArray(first)) {
            first.forEach(function (d) { return d && d.dispose(); });
            return [];
        }
        else if (rest.length === 0) {
            if (first) {
                first.dispose();
                return first;
            }
            return undefined;
        }
        else {
            dispose(first);
            dispose(rest);
            return [];
        }
    }
    exports.dispose = dispose;
    function combinedDisposable(disposables) {
        return { dispose: function () { return dispose(disposables); } };
    }
    exports.combinedDisposable = combinedDisposable;
    function toDisposable(fn) {
        return { dispose: function () { fn(); } };
    }
    exports.toDisposable = toDisposable;
    var Disposable = /** @class */ (function () {
        function Disposable() {
            this._toDispose = [];
        }
        Object.defineProperty(Disposable.prototype, "toDispose", {
            get: function () { return this._toDispose; },
            enumerable: true,
            configurable: true
        });
        Disposable.prototype.dispose = function () {
            this._toDispose = dispose(this._toDispose);
        };
        Disposable.prototype._register = function (t) {
            this._toDispose.push(t);
            return t;
        };
        Disposable.None = Object.freeze({ dispose: function () { } });
        return Disposable;
    }());
    exports.Disposable = Disposable;
    var ReferenceCollection = /** @class */ (function () {
        function ReferenceCollection() {
            this.references = Object.create(null);
        }
        ReferenceCollection.prototype.acquire = function (key) {
            var _this = this;
            var reference = this.references[key];
            if (!reference) {
                reference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };
            }
            var object = reference.object;
            var dispose = functional_1.once(function () {
                if (--reference.counter === 0) {
                    _this.destroyReferencedObject(reference.object);
                    delete _this.references[key];
                }
            });
            reference.counter++;
            return { object: object, dispose: dispose };
        };
        return ReferenceCollection;
    }());
    exports.ReferenceCollection = ReferenceCollection;
    var ImmortalReference = /** @class */ (function () {
        function ImmortalReference(object) {
            this.object = object;
        }
        ImmortalReference.prototype.dispose = function () { };
        return ImmortalReference;
    }());
    exports.ImmortalReference = ImmortalReference;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[51/*vs/base/common/linkedList*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Node = /** @class */ (function () {
        function Node(element) {
            this.element = element;
        }
        return Node;
    }());
    var LinkedList = /** @class */ (function () {
        function LinkedList() {
        }
        LinkedList.prototype.isEmpty = function () {
            return !this._first;
        };
        LinkedList.prototype.clear = function () {
            this._first = undefined;
            this._last = undefined;
        };
        LinkedList.prototype.unshift = function (element) {
            return this.insert(element, false);
        };
        LinkedList.prototype.push = function (element) {
            return this.insert(element, true);
        };
        LinkedList.prototype.insert = function (element, atTheEnd) {
            var _this = this;
            var newNode = new Node(element);
            if (!this._first) {
                this._first = newNode;
                this._last = newNode;
            }
            else if (atTheEnd) {
                // push
                var oldLast = this._last;
                this._last = newNode;
                newNode.prev = oldLast;
                oldLast.next = newNode;
            }
            else {
                // unshift
                var oldFirst = this._first;
                this._first = newNode;
                newNode.next = oldFirst;
                oldFirst.prev = newNode;
            }
            return function () {
                for (var candidate = _this._first; candidate instanceof Node; candidate = candidate.next) {
                    if (candidate !== newNode) {
                        continue;
                    }
                    if (candidate.prev && candidate.next) {
                        // middle
                        var anchor = candidate.prev;
                        anchor.next = candidate.next;
                        candidate.next.prev = anchor;
                    }
                    else if (!candidate.prev && !candidate.next) {
                        // only node
                        _this._first = undefined;
                        _this._last = undefined;
                    }
                    else if (!candidate.next) {
                        // last
                        _this._last = _this._last.prev;
                        _this._last.next = undefined;
                    }
                    else if (!candidate.prev) {
                        // first
                        _this._first = _this._first.next;
                        _this._first.prev = undefined;
                    }
                    // done
                    break;
                }
            };
        };
        LinkedList.prototype.iterator = function () {
            var element = {
                done: undefined,
                value: undefined,
            };
            var node = this._first;
            return {
                next: function () {
                    if (!node) {
                        element.done = true;
                        element.value = undefined;
                    }
                    else {
                        element.done = false;
                        element.value = node.element;
                        node = node.next;
                    }
                    return element;
                }
            };
        };
        LinkedList.prototype.toArray = function () {
            var result = [];
            for (var node = this._first; node instanceof Node; node = node.next) {
                result.push(node.element);
            }
            return result;
        };
        return LinkedList;
    }());
    exports.LinkedList = LinkedList;
});

define(__m[23/*vs/base/common/network*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Schemas;
    (function (Schemas) {
        /**
         * A schema that is used for models that exist in memory
         * only and that have no correspondence on a server or such.
         */
        Schemas.inMemory = 'inmemory';
        /**
         * A schema that is used for setting files
         */
        Schemas.vscode = 'vscode';
        /**
         * A schema that is used for internal private files
         */
        Schemas.internal = 'private';
        /**
         * A walk-through document.
         */
        Schemas.walkThrough = 'walkThrough';
        /**
         * An embedded code snippet.
         */
        Schemas.walkThroughSnippet = 'walkThroughSnippet';
        Schemas.http = 'http';
        Schemas.https = 'https';
        Schemas.file = 'file';
        Schemas.mailto = 'mailto';
        Schemas.untitled = 'untitled';
        Schemas.data = 'data';
    })(Schemas = exports.Schemas || (exports.Schemas = {}));
});

define(__m[10/*vs/base/common/platform*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var _isWindows = false;
    var _isMacintosh = false;
    var _isLinux = false;
    var _isNative = false;
    var _isWeb = false;
    var _locale = undefined;
    var _language = undefined;
    var _translationsConfigFile = undefined;
    exports.LANGUAGE_DEFAULT = 'en';
    // OS detection
    if (typeof process === 'object' && typeof process.nextTick === 'function' && typeof process.platform === 'string') {
        _isWindows = (process.platform === 'win32');
        _isMacintosh = (process.platform === 'darwin');
        _isLinux = (process.platform === 'linux');
        _locale = exports.LANGUAGE_DEFAULT;
        _language = exports.LANGUAGE_DEFAULT;
        var rawNlsConfig = process.env['VSCODE_NLS_CONFIG'];
        if (rawNlsConfig) {
            try {
                var nlsConfig = JSON.parse(rawNlsConfig);
                var resolved = nlsConfig.availableLanguages['*'];
                _locale = nlsConfig.locale;
                // VSCode's default language is 'en'
                _language = resolved ? resolved : exports.LANGUAGE_DEFAULT;
                _translationsConfigFile = nlsConfig._translationsConfigFile;
            }
            catch (e) {
            }
        }
        _isNative = true;
    }
    else if (typeof navigator === 'object') {
        var userAgent = navigator.userAgent;
        _isWindows = userAgent.indexOf('Windows') >= 0;
        _isMacintosh = userAgent.indexOf('Macintosh') >= 0;
        _isLinux = userAgent.indexOf('Linux') >= 0;
        _isWeb = true;
        _locale = navigator.language;
        _language = _locale;
    }
    var Platform;
    (function (Platform) {
        Platform[Platform["Web"] = 0] = "Web";
        Platform[Platform["Mac"] = 1] = "Mac";
        Platform[Platform["Linux"] = 2] = "Linux";
        Platform[Platform["Windows"] = 3] = "Windows";
    })(Platform = exports.Platform || (exports.Platform = {}));
    var _platform = Platform.Web;
    if (_isNative) {
        if (_isMacintosh) {
            _platform = Platform.Mac;
        }
        else if (_isWindows) {
            _platform = Platform.Windows;
        }
        else if (_isLinux) {
            _platform = Platform.Linux;
        }
    }
    exports.isWindows = _isWindows;
    exports.isMacintosh = _isMacintosh;
    exports.isLinux = _isLinux;
    exports.isNative = _isNative;
    exports.isWeb = _isWeb;
    exports.platform = _platform;
    function isRootUser() {
        return _isNative && !_isWindows && (process.getuid() === 0);
    }
    exports.isRootUser = isRootUser;
    /**
     * The language used for the user interface. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese)
     */
    exports.language = _language;
    /**
     * The OS locale or the locale specified by --locale. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese). The UI is not necessarily shown in the provided locale.
     */
    exports.locale = _locale;
    /**
     * The translatios that are available through language packs.
     */
    exports.translationsConfigFile = _translationsConfigFile;
    var _globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {});
    exports.globals = _globals;
    var _setImmediate = null;
    function setImmediate(callback) {
        if (_setImmediate === null) {
            if (exports.globals.setImmediate) {
                _setImmediate = exports.globals.setImmediate.bind(exports.globals);
            }
            else if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
                _setImmediate = process.nextTick.bind(process);
            }
            else {
                _setImmediate = exports.globals.setTimeout.bind(exports.globals);
            }
        }
        return _setImmediate(callback);
    }
    exports.setImmediate = setImmediate;
    var OperatingSystem;
    (function (OperatingSystem) {
        OperatingSystem[OperatingSystem["Windows"] = 1] = "Windows";
        OperatingSystem[OperatingSystem["Macintosh"] = 2] = "Macintosh";
        OperatingSystem[OperatingSystem["Linux"] = 3] = "Linux";
    })(OperatingSystem = exports.OperatingSystem || (exports.OperatingSystem = {}));
    exports.OS = (_isMacintosh ? 2 /* Macintosh */ : (_isWindows ? 1 /* Windows */ : 3 /* Linux */));
    var AccessibilitySupport;
    (function (AccessibilitySupport) {
        /**
         * This should be the browser case where it is not known if a screen reader is attached or no.
         */
        AccessibilitySupport[AccessibilitySupport["Unknown"] = 0] = "Unknown";
        AccessibilitySupport[AccessibilitySupport["Disabled"] = 1] = "Disabled";
        AccessibilitySupport[AccessibilitySupport["Enabled"] = 2] = "Enabled";
    })(AccessibilitySupport = exports.AccessibilitySupport || (exports.AccessibilitySupport = {}));
});

define(__m[160/*vs/base/common/processes*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Source;
    (function (Source) {
        Source[Source["stdout"] = 0] = "stdout";
        Source[Source["stderr"] = 1] = "stderr";
    })(Source = exports.Source || (exports.Source = {}));
    var TerminateResponseCode;
    (function (TerminateResponseCode) {
        TerminateResponseCode[TerminateResponseCode["Success"] = 0] = "Success";
        TerminateResponseCode[TerminateResponseCode["Unknown"] = 1] = "Unknown";
        TerminateResponseCode[TerminateResponseCode["AccessDenied"] = 2] = "AccessDenied";
        TerminateResponseCode[TerminateResponseCode["ProcessNotFound"] = 3] = "ProcessNotFound";
    })(TerminateResponseCode = exports.TerminateResponseCode || (exports.TerminateResponseCode = {}));
});

define(__m[115/*vs/base/common/stopwatch*/], __M([0/*require*/,1/*exports*/,10/*vs/base/common/platform*/]), function (require, exports, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var hasPerformanceNow = (platform_1.globals.performance && typeof platform_1.globals.performance.now === 'function');
    var StopWatch = /** @class */ (function () {
        function StopWatch(highResolution) {
            this._highResolution = hasPerformanceNow && highResolution;
            this._startTime = this._now();
            this._stopTime = -1;
        }
        StopWatch.create = function (highResolution) {
            if (highResolution === void 0) { highResolution = true; }
            return new StopWatch(highResolution);
        };
        StopWatch.prototype.stop = function () {
            this._stopTime = this._now();
        };
        StopWatch.prototype.elapsed = function () {
            if (this._stopTime !== -1) {
                return this._stopTime - this._startTime;
            }
            return this._now() - this._startTime;
        };
        StopWatch.prototype._now = function () {
            return this._highResolution ? platform_1.globals.performance.now() : new Date().getTime();
        };
        return StopWatch;
    }());
    exports.StopWatch = StopWatch;
});

define(__m[8/*vs/base/common/strings*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The empty string.
     */
    exports.empty = '';
    function isFalsyOrWhitespace(str) {
        if (!str || typeof str !== 'string') {
            return true;
        }
        return str.trim().length === 0;
    }
    exports.isFalsyOrWhitespace = isFalsyOrWhitespace;
    /**
     * @returns the provided number with the given number of preceding zeros.
     */
    function pad(n, l, char) {
        if (char === void 0) { char = '0'; }
        var str = '' + n;
        var r = [str];
        for (var i = str.length; i < l; i++) {
            r.push(char);
        }
        return r.reverse().join('');
    }
    exports.pad = pad;
    var _formatRegexp = /{(\d+)}/g;
    /**
     * Helper to produce a string with a variable number of arguments. Insert variable segments
     * into the string using the {n} notation where N is the index of the argument following the string.
     * @param value string to which formatting is applied
     * @param args replacements for {n}-entries
     */
    function format(value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (args.length === 0) {
            return value;
        }
        return value.replace(_formatRegexp, function (match, group) {
            var idx = parseInt(group, 10);
            return isNaN(idx) || idx < 0 || idx >= args.length ?
                match :
                args[idx];
        });
    }
    exports.format = format;
    /**
     * Converts HTML characters inside the string to use entities instead. Makes the string safe from
     * being used e.g. in HTMLElement.innerHTML.
     */
    function escape(html) {
        return html.replace(/[<|>|&]/g, function (match) {
            switch (match) {
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '&': return '&amp;';
                default: return match;
            }
        });
    }
    exports.escape = escape;
    /**
     * Escapes regular expression characters in a given string
     */
    function escapeRegExpCharacters(value) {
        return value.replace(/[\-\\\{\}\*\+\?\|\^\$\.\[\]\(\)\#]/g, '\\$&');
    }
    exports.escapeRegExpCharacters = escapeRegExpCharacters;
    /**
     * Removes all occurrences of needle from the beginning and end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim (default is a blank)
     */
    function trim(haystack, needle) {
        if (needle === void 0) { needle = ' '; }
        var trimmed = ltrim(haystack, needle);
        return rtrim(trimmed, needle);
    }
    exports.trim = trim;
    /**
     * Removes all occurrences of needle from the beginning of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function ltrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length;
        if (needleLen === 0 || haystack.length === 0) {
            return haystack;
        }
        var offset = 0, idx = -1;
        while ((idx = haystack.indexOf(needle, offset)) === offset) {
            offset = offset + needleLen;
        }
        return haystack.substring(offset);
    }
    exports.ltrim = ltrim;
    /**
     * Removes all occurrences of needle from the end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function rtrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length, haystackLen = haystack.length;
        if (needleLen === 0 || haystackLen === 0) {
            return haystack;
        }
        var offset = haystackLen, idx = -1;
        while (true) {
            idx = haystack.lastIndexOf(needle, offset - 1);
            if (idx === -1 || idx + needleLen !== offset) {
                break;
            }
            if (idx === 0) {
                return '';
            }
            offset = idx;
        }
        return haystack.substring(0, offset);
    }
    exports.rtrim = rtrim;
    function convertSimple2RegExpPattern(pattern) {
        return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
    }
    exports.convertSimple2RegExpPattern = convertSimple2RegExpPattern;
    function stripWildcards(pattern) {
        return pattern.replace(/\*/g, '');
    }
    exports.stripWildcards = stripWildcards;
    /**
     * Determines if haystack starts with needle.
     */
    function startsWith(haystack, needle) {
        if (haystack.length < needle.length) {
            return false;
        }
        if (haystack === needle) {
            return true;
        }
        for (var i = 0; i < needle.length; i++) {
            if (haystack[i] !== needle[i]) {
                return false;
            }
        }
        return true;
    }
    exports.startsWith = startsWith;
    /**
     * Determines if haystack ends with needle.
     */
    function endsWith(haystack, needle) {
        var diff = haystack.length - needle.length;
        if (diff > 0) {
            return haystack.indexOf(needle, diff) === diff;
        }
        else if (diff === 0) {
            return haystack === needle;
        }
        else {
            return false;
        }
    }
    exports.endsWith = endsWith;
    function createRegExp(searchString, isRegex, options) {
        if (options === void 0) { options = {}; }
        if (!searchString) {
            throw new Error('Cannot create regex from empty string');
        }
        if (!isRegex) {
            searchString = escapeRegExpCharacters(searchString);
        }
        if (options.wholeWord) {
            if (!/\B/.test(searchString.charAt(0))) {
                searchString = '\\b' + searchString;
            }
            if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
                searchString = searchString + '\\b';
            }
        }
        var modifiers = '';
        if (options.global) {
            modifiers += 'g';
        }
        if (!options.matchCase) {
            modifiers += 'i';
        }
        if (options.multiline) {
            modifiers += 'm';
        }
        return new RegExp(searchString, modifiers);
    }
    exports.createRegExp = createRegExp;
    function regExpLeadsToEndlessLoop(regexp) {
        // Exit early if it's one of these special cases which are meant to match
        // against an empty string
        if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\s*$') {
            return false;
        }
        // We check against an empty string. If the regular expression doesn't advance
        // (e.g. ends in an endless loop) it will match an empty string.
        var match = regexp.exec('');
        return (match && regexp.lastIndex === 0);
    }
    exports.regExpLeadsToEndlessLoop = regExpLeadsToEndlessLoop;
    function regExpContainsBackreference(regexpValue) {
        return !!regexpValue.match(/([^\\]|^)(\\\\)*\\\d+/);
    }
    exports.regExpContainsBackreference = regExpContainsBackreference;
    /**
     * Returns first index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function firstNonWhitespaceIndex(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return i;
            }
        }
        return -1;
    }
    exports.firstNonWhitespaceIndex = firstNonWhitespaceIndex;
    /**
     * Returns the leading whitespace of the string.
     * If the string contains only whitespaces, returns entire string
     */
    function getLeadingWhitespace(str, start, end) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = str.length; }
        for (var i = start; i < end; i++) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return str.substring(start, i);
            }
        }
        return str.substring(start, end);
    }
    exports.getLeadingWhitespace = getLeadingWhitespace;
    /**
     * Returns last index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function lastNonWhitespaceIndex(str, startIndex) {
        if (startIndex === void 0) { startIndex = str.length - 1; }
        for (var i = startIndex; i >= 0; i--) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return i;
            }
        }
        return -1;
    }
    exports.lastNonWhitespaceIndex = lastNonWhitespaceIndex;
    function compare(a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    }
    exports.compare = compare;
    function compareIgnoreCase(a, b) {
        var len = Math.min(a.length, b.length);
        for (var i = 0; i < len; i++) {
            var codeA = a.charCodeAt(i);
            var codeB = b.charCodeAt(i);
            if (codeA === codeB) {
                // equal
                continue;
            }
            if (isUpperAsciiLetter(codeA)) {
                codeA += 32;
            }
            if (isUpperAsciiLetter(codeB)) {
                codeB += 32;
            }
            var diff = codeA - codeB;
            if (diff === 0) {
                // equal -> ignoreCase
                continue;
            }
            else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {
                //
                return diff;
            }
            else {
                return compare(a.toLowerCase(), b.toLowerCase());
            }
        }
        if (a.length < b.length) {
            return -1;
        }
        else if (a.length > b.length) {
            return 1;
        }
        else {
            return 0;
        }
    }
    exports.compareIgnoreCase = compareIgnoreCase;
    function isLowerAsciiLetter(code) {
        return code >= 97 /* a */ && code <= 122 /* z */;
    }
    exports.isLowerAsciiLetter = isLowerAsciiLetter;
    function isUpperAsciiLetter(code) {
        return code >= 65 /* A */ && code <= 90 /* Z */;
    }
    exports.isUpperAsciiLetter = isUpperAsciiLetter;
    function isAsciiLetter(code) {
        return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);
    }
    function equalsIgnoreCase(a, b) {
        var len1 = a ? a.length : 0;
        var len2 = b ? b.length : 0;
        if (len1 !== len2) {
            return false;
        }
        return doEqualsIgnoreCase(a, b);
    }
    exports.equalsIgnoreCase = equalsIgnoreCase;
    function doEqualsIgnoreCase(a, b, stopAt) {
        if (stopAt === void 0) { stopAt = a.length; }
        if (typeof a !== 'string' || typeof b !== 'string') {
            return false;
        }
        for (var i = 0; i < stopAt; i++) {
            var codeA = a.charCodeAt(i);
            var codeB = b.charCodeAt(i);
            if (codeA === codeB) {
                continue;
            }
            // a-z A-Z
            if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {
                var diff = Math.abs(codeA - codeB);
                if (diff !== 0 && diff !== 32) {
                    return false;
                }
            }
            // Any other charcode
            else {
                if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {
                    return false;
                }
            }
        }
        return true;
    }
    function startsWithIgnoreCase(str, candidate) {
        var candidateLength = candidate.length;
        if (candidate.length > str.length) {
            return false;
        }
        return doEqualsIgnoreCase(str, candidate, candidateLength);
    }
    exports.startsWithIgnoreCase = startsWithIgnoreCase;
    /**
     * @returns the length of the common prefix of the two strings.
     */
    function commonPrefixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(i) !== b.charCodeAt(i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonPrefixLength = commonPrefixLength;
    /**
     * @returns the length of the common suffix of the two strings.
     */
    function commonSuffixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        var aLastIndex = a.length - 1;
        var bLastIndex = b.length - 1;
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonSuffixLength = commonSuffixLength;
    function substrEquals(a, aStart, aEnd, b, bStart, bEnd) {
        while (aStart < aEnd && bStart < bEnd) {
            if (a[aStart] !== b[bStart]) {
                return false;
            }
            aStart += 1;
            bStart += 1;
        }
        return true;
    }
    /**
     * Return the overlap between the suffix of `a` and the prefix of `b`.
     * For instance `overlap("foobar", "arr, I'm a pirate") === 2`.
     */
    function overlap(a, b) {
        var aEnd = a.length;
        var bEnd = b.length;
        var aStart = aEnd - bEnd;
        if (aStart === 0) {
            return a === b ? aEnd : 0;
        }
        else if (aStart < 0) {
            bEnd += aStart;
            aStart = 0;
        }
        while (aStart < aEnd && bEnd > 0) {
            if (substrEquals(a, aStart, aEnd, b, 0, bEnd)) {
                return bEnd;
            }
            bEnd -= 1;
            aStart += 1;
        }
        return 0;
    }
    exports.overlap = overlap;
    // --- unicode
    // http://en.wikipedia.org/wiki/Surrogate_pair
    // Returns the code point starting at a specified index in a string
    // Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character
    // Code points U+10000 to U+10FFFF are represented on two consecutive characters
    //export function getUnicodePoint(str:string, index:number, len:number):number {
    //	let chrCode = str.charCodeAt(index);
    //	if (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {
    //		let nextChrCode = str.charCodeAt(index + 1);
    //		if (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {
    //			return (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;
    //		}
    //	}
    //	return chrCode;
    //}
    function isHighSurrogate(charCode) {
        return (0xD800 <= charCode && charCode <= 0xDBFF);
    }
    exports.isHighSurrogate = isHighSurrogate;
    function isLowSurrogate(charCode) {
        return (0xDC00 <= charCode && charCode <= 0xDFFF);
    }
    exports.isLowSurrogate = isLowSurrogate;
    /**
     * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js
     */
    var CONTAINS_RTL = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE33\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDCFF]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD50-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
    /**
     * Returns true if `str` contains any Unicode character that is classified as "R" or "AL".
     */
    function containsRTL(str) {
        return CONTAINS_RTL.test(str);
    }
    exports.containsRTL = containsRTL;
    /**
     * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js
     */
    var CONTAINS_EMOJI = /(?:[\u231A\u231B\u23F0\u23F3\u2600-\u27BF\u2B50\u2B55]|\uD83C[\uDDE6-\uDDFF\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F\uDE80-\uDEF8]|\uD83E[\uDD00-\uDDE6])/;
    function containsEmoji(str) {
        return CONTAINS_EMOJI.test(str);
    }
    exports.containsEmoji = containsEmoji;
    var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
    /**
     * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \n, \r, \t
     */
    function isBasicASCII(str) {
        return IS_BASIC_ASCII.test(str);
    }
    exports.isBasicASCII = isBasicASCII;
    function containsFullWidthCharacter(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            if (isFullWidthCharacter(str.charCodeAt(i))) {
                return true;
            }
        }
        return false;
    }
    exports.containsFullWidthCharacter = containsFullWidthCharacter;
    function isFullWidthCharacter(charCode) {
        // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
        // http://jrgraphix.net/research/unicode_blocks.php
        //          2E80 — 2EFF   CJK Radicals Supplement
        //          2F00 — 2FDF   Kangxi Radicals
        //          2FF0 — 2FFF   Ideographic Description Characters
        //          3000 — 303F   CJK Symbols and Punctuation
        //          3040 — 309F   Hiragana
        //          30A0 — 30FF   Katakana
        //          3100 — 312F   Bopomofo
        //          3130 — 318F   Hangul Compatibility Jamo
        //          3190 — 319F   Kanbun
        //          31A0 — 31BF   Bopomofo Extended
        //          31F0 — 31FF   Katakana Phonetic Extensions
        //          3200 — 32FF   Enclosed CJK Letters and Months
        //          3300 — 33FF   CJK Compatibility
        //          3400 — 4DBF   CJK Unified Ideographs Extension A
        //          4DC0 — 4DFF   Yijing Hexagram Symbols
        //          4E00 — 9FFF   CJK Unified Ideographs
        //          A000 — A48F   Yi Syllables
        //          A490 — A4CF   Yi Radicals
        //          AC00 — D7AF   Hangul Syllables
        // [IGNORE] D800 — DB7F   High Surrogates
        // [IGNORE] DB80 — DBFF   High Private Use Surrogates
        // [IGNORE] DC00 — DFFF   Low Surrogates
        // [IGNORE] E000 — F8FF   Private Use Area
        //          F900 — FAFF   CJK Compatibility Ideographs
        // [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms
        // [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A
        // [IGNORE] FE00 — FE0F   Variation Selectors
        // [IGNORE] FE20 — FE2F   Combining Half Marks
        // [IGNORE] FE30 — FE4F   CJK Compatibility Forms
        // [IGNORE] FE50 — FE6F   Small Form Variants
        // [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B
        //          FF00 — FFEF   Halfwidth and Fullwidth Forms
        //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
        //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
        // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
        // [IGNORE] FFF0 — FFFF   Specials
        charCode = +charCode; // @perf
        return ((charCode >= 0x2E80 && charCode <= 0xD7AF)
            || (charCode >= 0xF900 && charCode <= 0xFAFF)
            || (charCode >= 0xFF01 && charCode <= 0xFF5E));
    }
    exports.isFullWidthCharacter = isFullWidthCharacter;
    /**
     * Given a string and a max length returns a shorted version. Shorting
     * happens at favorable positions - such as whitespace or punctuation characters.
     */
    function lcut(text, n) {
        if (text.length < n) {
            return text;
        }
        var re = /\b/g;
        var i = 0;
        while (re.test(text)) {
            if (text.length - re.lastIndex < n) {
                break;
            }
            i = re.lastIndex;
            re.lastIndex += 1;
        }
        return text.substring(i).replace(/^\s/, exports.empty);
    }
    exports.lcut = lcut;
    // Escape codes
    // http://en.wikipedia.org/wiki/ANSI_escape_code
    var EL = /\x1B\x5B[12]?K/g; // Erase in line
    var COLOR_START = /\x1b\[\d+m/g; // Color
    var COLOR_END = /\x1b\[0?m/g; // Color
    function removeAnsiEscapeCodes(str) {
        if (str) {
            str = str.replace(EL, '');
            str = str.replace(COLOR_START, '');
            str = str.replace(COLOR_END, '');
        }
        return str;
    }
    exports.removeAnsiEscapeCodes = removeAnsiEscapeCodes;
    // -- UTF-8 BOM
    exports.UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);
    function startsWithUTF8BOM(str) {
        return (str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);
    }
    exports.startsWithUTF8BOM = startsWithUTF8BOM;
    function stripUTF8BOM(str) {
        return startsWithUTF8BOM(str) ? str.substr(1) : str;
    }
    exports.stripUTF8BOM = stripUTF8BOM;
    function safeBtoa(str) {
        return btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values
    }
    exports.safeBtoa = safeBtoa;
    function repeat(s, count) {
        var result = '';
        for (var i = 0; i < count; i++) {
            result += s;
        }
        return result;
    }
    exports.repeat = repeat;
    /**
     * Checks if the characters of the provided query string are included in the
     * target string. The characters do not have to be contiguous within the string.
     */
    function fuzzyContains(target, query) {
        if (!target || !query) {
            return false; // return early if target or query are undefined
        }
        if (target.length < query.length) {
            return false; // impossible for query to be contained in target
        }
        var queryLen = query.length;
        var targetLower = target.toLowerCase();
        var index = 0;
        var lastIndexOf = -1;
        while (index < queryLen) {
            var indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);
            if (indexOf < 0) {
                return false;
            }
            lastIndexOf = indexOf;
            index++;
        }
        return true;
    }
    exports.fuzzyContains = fuzzyContains;
    function containsUppercaseCharacter(target, ignoreEscapedChars) {
        if (ignoreEscapedChars === void 0) { ignoreEscapedChars = false; }
        if (!target) {
            return false;
        }
        if (ignoreEscapedChars) {
            target = target.replace(/\\./g, '');
        }
        return target.toLowerCase() !== target;
    }
    exports.containsUppercaseCharacter = containsUppercaseCharacter;
});

define(__m[16/*vs/base/common/paths*/], __M([0/*require*/,1/*exports*/,10/*vs/base/common/platform*/,8/*vs/base/common/strings*/]), function (require, exports, platform_1, strings_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The forward slash path separator.
     */
    exports.sep = '/';
    /**
     * The native path separator depending on the OS.
     */
    exports.nativeSep = platform_1.isWindows ? '\\' : '/';
    /**
     * @returns the directory name of a path.
     */
    function dirname(path) {
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return '.';
        }
        else if (~idx === 0) {
            return path[0];
        }
        else if (~idx === path.length - 1) {
            return dirname(path.substring(0, path.length - 1));
        }
        else {
            var res = path.substring(0, ~idx);
            if (platform_1.isWindows && res[res.length - 1] === ':') {
                res += exports.nativeSep; // make sure drive letters end with backslash
            }
            return res;
        }
    }
    exports.dirname = dirname;
    /**
     * @returns the base name of a path.
     */
    function basename(path) {
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return path;
        }
        else if (~idx === path.length - 1) {
            return basename(path.substring(0, path.length - 1));
        }
        else {
            return path.substr(~idx + 1);
        }
    }
    exports.basename = basename;
    /**
     * @returns `.far` from `boo.far` or the empty string.
     */
    function extname(path) {
        path = basename(path);
        var idx = ~path.lastIndexOf('.');
        return idx ? path.substring(~idx) : '';
    }
    exports.extname = extname;
    var _posixBadPath = /(\/\.\.?\/)|(\/\.\.?)$|^(\.\.?\/)|(\/\/+)|(\\)/;
    var _winBadPath = /(\\\.\.?\\)|(\\\.\.?)$|^(\.\.?\\)|(\\\\+)|(\/)/;
    function _isNormal(path, win) {
        return win
            ? !_winBadPath.test(path)
            : !_posixBadPath.test(path);
    }
    function normalize(path, toOSPath) {
        if (path === null || path === void 0) {
            return path;
        }
        var len = path.length;
        if (len === 0) {
            return '.';
        }
        var wantsBackslash = platform_1.isWindows && toOSPath;
        if (_isNormal(path, wantsBackslash)) {
            return path;
        }
        var sep = wantsBackslash ? '\\' : '/';
        var root = getRoot(path, sep);
        // skip the root-portion of the path
        var start = root.length;
        var skip = false;
        var res = '';
        for (var end = root.length; end <= len; end++) {
            // either at the end or at a path-separator character
            if (end === len || path.charCodeAt(end) === 47 /* Slash */ || path.charCodeAt(end) === 92 /* Backslash */) {
                if (streql(path, start, end, '..')) {
                    // skip current and remove parent (if there is already something)
                    var prev_start = res.lastIndexOf(sep);
                    var prev_part = res.slice(prev_start + 1);
                    if ((root || prev_part.length > 0) && prev_part !== '..') {
                        res = prev_start === -1 ? '' : res.slice(0, prev_start);
                        skip = true;
                    }
                }
                else if (streql(path, start, end, '.') && (root || res || end < len - 1)) {
                    // skip current (if there is already something or if there is more to come)
                    skip = true;
                }
                if (!skip) {
                    var part = path.slice(start, end);
                    if (res !== '' && res[res.length - 1] !== sep) {
                        res += sep;
                    }
                    res += part;
                }
                start = end + 1;
                skip = false;
            }
        }
        return root + res;
    }
    exports.normalize = normalize;
    function streql(value, start, end, other) {
        return start + other.length === end && value.indexOf(other, start) === start;
    }
    /**
     * Computes the _root_ this path, like `getRoot('c:\files') === c:\`,
     * `getRoot('files:///files/path') === files:///`,
     * or `getRoot('\\server\shares\path') === \\server\shares\`
     */
    function getRoot(path, sep) {
        if (sep === void 0) { sep = '/'; }
        if (!path) {
            return '';
        }
        var len = path.length;
        var code = path.charCodeAt(0);
        if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
            code = path.charCodeAt(1);
            if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                // UNC candidate \\localhost\shares\ddd
                //               ^^^^^^^^^^^^^^^^^^^
                code = path.charCodeAt(2);
                if (code !== 47 /* Slash */ && code !== 92 /* Backslash */) {
                    var pos_1 = 3;
                    var start = pos_1;
                    for (; pos_1 < len; pos_1++) {
                        code = path.charCodeAt(pos_1);
                        if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                            break;
                        }
                    }
                    code = path.charCodeAt(pos_1 + 1);
                    if (start !== pos_1 && code !== 47 /* Slash */ && code !== 92 /* Backslash */) {
                        pos_1 += 1;
                        for (; pos_1 < len; pos_1++) {
                            code = path.charCodeAt(pos_1);
                            if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                                return path.slice(0, pos_1 + 1) // consume this separator
                                    .replace(/[\\/]/g, sep);
                            }
                        }
                    }
                }
            }
            // /user/far
            // ^
            return sep;
        }
        else if ((code >= 65 /* A */ && code <= 90 /* Z */) || (code >= 97 /* a */ && code <= 122 /* z */)) {
            // check for windows drive letter c:\ or c:
            if (path.charCodeAt(1) === 58 /* Colon */) {
                code = path.charCodeAt(2);
                if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                    // C:\fff
                    // ^^^
                    return path.slice(0, 2) + sep;
                }
                else {
                    // C:
                    // ^^
                    return path.slice(0, 2);
                }
            }
        }
        // check for URI
        // scheme://authority/path
        // ^^^^^^^^^^^^^^^^^^^
        var pos = path.indexOf('://');
        if (pos !== -1) {
            pos += 3; // 3 -> "://".length
            for (; pos < len; pos++) {
                code = path.charCodeAt(pos);
                if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                    return path.slice(0, pos + 1); // consume this separator
                }
            }
        }
        return '';
    }
    exports.getRoot = getRoot;
    exports.join = function () {
        // Not using a function with var-args because of how TS compiles
        // them to JS - it would result in 2*n runtime cost instead
        // of 1*n, where n is parts.length.
        var value = '';
        for (var i = 0; i < arguments.length; i++) {
            var part = arguments[i];
            if (i > 0) {
                // add the separater between two parts unless
                // there already is one
                var last = value.charCodeAt(value.length - 1);
                if (last !== 47 /* Slash */ && last !== 92 /* Backslash */) {
                    var next = part.charCodeAt(0);
                    if (next !== 47 /* Slash */ && next !== 92 /* Backslash */) {
                        value += exports.sep;
                    }
                }
            }
            value += part;
        }
        return normalize(value);
    };
    /**
     * Check if the path follows this pattern: `\\hostname\sharename`.
     *
     * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx
     * @return A boolean indication if the path is a UNC path, on none-windows
     * always false.
     */
    function isUNC(path) {
        if (!platform_1.isWindows) {
            // UNC is a windows concept
            return false;
        }
        if (!path || path.length < 5) {
            // at least \\a\b
            return false;
        }
        var code = path.charCodeAt(0);
        if (code !== 92 /* Backslash */) {
            return false;
        }
        code = path.charCodeAt(1);
        if (code !== 92 /* Backslash */) {
            return false;
        }
        var pos = 2;
        var start = pos;
        for (; pos < path.length; pos++) {
            code = path.charCodeAt(pos);
            if (code === 92 /* Backslash */) {
                break;
            }
        }
        if (start === pos) {
            return false;
        }
        code = path.charCodeAt(pos + 1);
        if (isNaN(code) || code === 92 /* Backslash */) {
            return false;
        }
        return true;
    }
    exports.isUNC = isUNC;
    // Reference: https://en.wikipedia.org/wiki/Filename
    var INVALID_FILE_CHARS = platform_1.isWindows ? /[\\/:\*\?"<>\|]/g : /[\\/]/g;
    var WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])$/i;
    function isValidBasename(name) {
        if (!name || name.length === 0 || /^\s+$/.test(name)) {
            return false; // require a name that is not just whitespace
        }
        INVALID_FILE_CHARS.lastIndex = 0; // the holy grail of software development
        if (INVALID_FILE_CHARS.test(name)) {
            return false; // check for certain invalid file characters
        }
        if (platform_1.isWindows && WINDOWS_FORBIDDEN_NAMES.test(name)) {
            return false; // check for certain invalid file names
        }
        if (name === '.' || name === '..') {
            return false; // check for reserved values
        }
        if (platform_1.isWindows && name[name.length - 1] === '.') {
            return false; // Windows: file cannot end with a "."
        }
        if (platform_1.isWindows && name.length !== name.trim().length) {
            return false; // Windows: file cannot end with a whitespace
        }
        return true;
    }
    exports.isValidBasename = isValidBasename;
    function isEqual(pathA, pathB, ignoreCase) {
        var identityEquals = (pathA === pathB);
        if (!ignoreCase || identityEquals) {
            return identityEquals;
        }
        if (!pathA || !pathB) {
            return false;
        }
        return strings_1.equalsIgnoreCase(pathA, pathB);
    }
    exports.isEqual = isEqual;
    function isEqualOrParent(path, candidate, ignoreCase, separator) {
        if (separator === void 0) { separator = exports.nativeSep; }
        if (path === candidate) {
            return true;
        }
        if (!path || !candidate) {
            return false;
        }
        if (candidate.length > path.length) {
            return false;
        }
        if (ignoreCase) {
            var beginsWith = strings_1.startsWithIgnoreCase(path, candidate);
            if (!beginsWith) {
                return false;
            }
            if (candidate.length === path.length) {
                return true; // same path, different casing
            }
            var sepOffset = candidate.length;
            if (candidate.charAt(candidate.length - 1) === separator) {
                sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character
            }
            return path.charAt(sepOffset) === separator;
        }
        if (candidate.charAt(candidate.length - 1) !== separator) {
            candidate += separator;
        }
        return path.indexOf(candidate) === 0;
    }
    exports.isEqualOrParent = isEqualOrParent;
    /**
     * Adapted from Node's path.isAbsolute functions
     */
    function isAbsolute(path) {
        return platform_1.isWindows ?
            isAbsolute_win32(path) :
            isAbsolute_posix(path);
    }
    exports.isAbsolute = isAbsolute;
    function isAbsolute_win32(path) {
        if (!path) {
            return false;
        }
        var char0 = path.charCodeAt(0);
        if (char0 === 47 /* Slash */ || char0 === 92 /* Backslash */) {
            return true;
        }
        else if ((char0 >= 65 /* A */ && char0 <= 90 /* Z */) || (char0 >= 97 /* a */ && char0 <= 122 /* z */)) {
            if (path.length > 2 && path.charCodeAt(1) === 58 /* Colon */) {
                var char2 = path.charCodeAt(2);
                if (char2 === 47 /* Slash */ || char2 === 92 /* Backslash */) {
                    return true;
                }
            }
        }
        return false;
    }
    exports.isAbsolute_win32 = isAbsolute_win32;
    function isAbsolute_posix(path) {
        return path && path.charCodeAt(0) === 47 /* Slash */;
    }
    exports.isAbsolute_posix = isAbsolute_posix;
});

define(__m[75/*vs/base/common/comparers*/], __M([0/*require*/,1/*exports*/,8/*vs/base/common/strings*/,16/*vs/base/common/paths*/]), function (require, exports, strings, paths) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var intlFileNameCollator;
    var intlFileNameCollatorIsNumeric;
    function setFileNameComparer(collator) {
        intlFileNameCollator = collator;
        intlFileNameCollatorIsNumeric = collator.resolvedOptions().numeric;
    }
    exports.setFileNameComparer = setFileNameComparer;
    function compareFileNames(one, other, caseSensitive) {
        if (caseSensitive === void 0) { caseSensitive = false; }
        if (intlFileNameCollator) {
            var a = one || '';
            var b = other || '';
            var result = intlFileNameCollator.compare(a, b);
            // Using the numeric option in the collator will
            // make compare(`foo1`, `foo01`) === 0. We must disambiguate.
            if (intlFileNameCollatorIsNumeric && result === 0 && a !== b) {
                return a < b ? -1 : 1;
            }
            return result;
        }
        return noIntlCompareFileNames(one, other, caseSensitive);
    }
    exports.compareFileNames = compareFileNames;
    var FileNameMatch = /^(.*?)(\.([^.]*))?$/;
    function noIntlCompareFileNames(one, other, caseSensitive) {
        if (caseSensitive === void 0) { caseSensitive = false; }
        if (!caseSensitive) {
            one = one && one.toLowerCase();
            other = other && other.toLowerCase();
        }
        var _a = extractNameAndExtension(one), oneName = _a[0], oneExtension = _a[1];
        var _b = extractNameAndExtension(other), otherName = _b[0], otherExtension = _b[1];
        if (oneName !== otherName) {
            return oneName < otherName ? -1 : 1;
        }
        if (oneExtension === otherExtension) {
            return 0;
        }
        return oneExtension < otherExtension ? -1 : 1;
    }
    exports.noIntlCompareFileNames = noIntlCompareFileNames;
    function compareFileExtensions(one, other) {
        if (intlFileNameCollator) {
            var _a = extractNameAndExtension(one), oneName = _a[0], oneExtension = _a[1];
            var _b = extractNameAndExtension(other), otherName = _b[0], otherExtension = _b[1];
            var result = intlFileNameCollator.compare(oneExtension, otherExtension);
            if (result === 0) {
                // Using the numeric option in the collator will
                // make compare(`foo1`, `foo01`) === 0. We must disambiguate.
                if (intlFileNameCollatorIsNumeric && oneExtension !== otherExtension) {
                    return oneExtension < otherExtension ? -1 : 1;
                }
                // Extensions are equal, compare filenames
                result = intlFileNameCollator.compare(oneName, otherName);
                if (intlFileNameCollatorIsNumeric && result === 0 && oneName !== otherName) {
                    return oneName < otherName ? -1 : 1;
                }
            }
            return result;
        }
        return noIntlCompareFileExtensions(one, other);
    }
    exports.compareFileExtensions = compareFileExtensions;
    function noIntlCompareFileExtensions(one, other) {
        var _a = extractNameAndExtension(one && one.toLowerCase()), oneName = _a[0], oneExtension = _a[1];
        var _b = extractNameAndExtension(other && other.toLowerCase()), otherName = _b[0], otherExtension = _b[1];
        if (oneExtension !== otherExtension) {
            return oneExtension < otherExtension ? -1 : 1;
        }
        if (oneName === otherName) {
            return 0;
        }
        return oneName < otherName ? -1 : 1;
    }
    function extractNameAndExtension(str) {
        var match = str ? FileNameMatch.exec(str) : [];
        return [(match && match[1]) || '', (match && match[3]) || ''];
    }
    function comparePathComponents(one, other, caseSensitive) {
        if (caseSensitive === void 0) { caseSensitive = false; }
        if (!caseSensitive) {
            one = one && one.toLowerCase();
            other = other && other.toLowerCase();
        }
        if (one === other) {
            return 0;
        }
        return one < other ? -1 : 1;
    }
    function comparePaths(one, other, caseSensitive) {
        if (caseSensitive === void 0) { caseSensitive = false; }
        var oneParts = one.split(paths.nativeSep);
        var otherParts = other.split(paths.nativeSep);
        var lastOne = oneParts.length - 1;
        var lastOther = otherParts.length - 1;
        var endOne, endOther;
        for (var i = 0;; i++) {
            endOne = lastOne === i;
            endOther = lastOther === i;
            if (endOne && endOther) {
                return compareFileNames(oneParts[i], otherParts[i], caseSensitive);
            }
            else if (endOne) {
                return -1;
            }
            else if (endOther) {
                return 1;
            }
            var result = comparePathComponents(oneParts[i], otherParts[i], caseSensitive);
            if (result !== 0) {
                return result;
            }
        }
    }
    exports.comparePaths = comparePaths;
    function compareAnything(one, other, lookFor) {
        var elementAName = one.toLowerCase();
        var elementBName = other.toLowerCase();
        // Sort prefix matches over non prefix matches
        var prefixCompare = compareByPrefix(one, other, lookFor);
        if (prefixCompare) {
            return prefixCompare;
        }
        // Sort suffix matches over non suffix matches
        var elementASuffixMatch = strings.endsWith(elementAName, lookFor);
        var elementBSuffixMatch = strings.endsWith(elementBName, lookFor);
        if (elementASuffixMatch !== elementBSuffixMatch) {
            return elementASuffixMatch ? -1 : 1;
        }
        // Understand file names
        var r = compareFileNames(elementAName, elementBName);
        if (r !== 0) {
            return r;
        }
        // Compare by name
        return elementAName.localeCompare(elementBName);
    }
    exports.compareAnything = compareAnything;
    function compareByPrefix(one, other, lookFor) {
        var elementAName = one.toLowerCase();
        var elementBName = other.toLowerCase();
        // Sort prefix matches over non prefix matches
        var elementAPrefixMatch = strings.startsWith(elementAName, lookFor);
        var elementBPrefixMatch = strings.startsWith(elementBName, lookFor);
        if (elementAPrefixMatch !== elementBPrefixMatch) {
            return elementAPrefixMatch ? -1 : 1;
        }
        // Same prefix: Sort shorter matches to the top to have those on top that match more precisely
        else if (elementAPrefixMatch && elementBPrefixMatch) {
            if (elementAName.length < elementBName.length) {
                return -1;
            }
            if (elementAName.length > elementBName.length) {
                return 1;
            }
        }
        return 0;
    }
    exports.compareByPrefix = compareByPrefix;
});

define(__m[26/*vs/base/common/resources*/], __M([0/*require*/,1/*exports*/,16/*vs/base/common/paths*/,8/*vs/base/common/strings*/,23/*vs/base/common/network*/,10/*vs/base/common/platform*/]), function (require, exports, paths, strings_1, network_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getComparisonKey(resource) {
        return hasToIgnoreCase(resource) ? resource.toString().toLowerCase() : resource.toString();
    }
    exports.getComparisonKey = getComparisonKey;
    function hasToIgnoreCase(resource) {
        // A file scheme resource is in the same platform as code, so ignore case for non linux platforms
        // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider
        return resource && resource.scheme === network_1.Schemas.file ? !platform_1.isLinux : true;
    }
    exports.hasToIgnoreCase = hasToIgnoreCase;
    function basenameOrAuthority(resource) {
        return paths.basename(resource.path) || resource.authority;
    }
    exports.basenameOrAuthority = basenameOrAuthority;
    function isEqualOrParent(resource, candidate, ignoreCase) {
        if (resource.scheme === candidate.scheme && resource.authority === candidate.authority) {
            if (resource.scheme === 'file') {
                return paths.isEqualOrParent(resource.fsPath, candidate.fsPath, ignoreCase);
            }
            return paths.isEqualOrParent(resource.path, candidate.path, ignoreCase, '/');
        }
        return false;
    }
    exports.isEqualOrParent = isEqualOrParent;
    function isEqual(first, second, ignoreCase) {
        var identityEquals = (first === second);
        if (identityEquals) {
            return true;
        }
        if (!first || !second) {
            return false;
        }
        if (ignoreCase) {
            return strings_1.equalsIgnoreCase(first.toString(), second.toString());
        }
        return first.toString() === second.toString();
    }
    exports.isEqual = isEqual;
    function dirname(resource) {
        var dirname = paths.dirname(resource.path);
        if (resource.authority && dirname && !paths.isAbsolute(dirname)) {
            return null; // If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character
        }
        return resource.with({
            path: dirname
        });
    }
    exports.dirname = dirname;
    function joinPath(resource, pathFragment) {
        var joinedPath = paths.join(resource.path || '/', pathFragment);
        return resource.with({
            path: joinedPath
        });
    }
    exports.joinPath = joinPath;
    function distinctParents(items, resourceAccessor) {
        var distinctParents = [];
        var _loop_1 = function (i) {
            var candidateResource = resourceAccessor(items[i]);
            if (items.some(function (otherItem, index) {
                if (index === i) {
                    return false;
                }
                return isEqualOrParent(candidateResource, resourceAccessor(otherItem));
            })) {
                return "continue";
            }
            distinctParents.push(items[i]);
        };
        for (var i = 0; i < items.length; i++) {
            _loop_1(i);
        }
        return distinctParents;
    }
    exports.distinctParents = distinctParents;
});

define(__m[18/*vs/base/common/types*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var _typeof = {
        number: 'number',
        string: 'string',
        undefined: 'undefined',
        object: 'object',
        function: 'function'
    };
    /**
     * @returns whether the provided parameter is a JavaScript Array or not.
     */
    function isArray(array) {
        if (Array.isArray) {
            return Array.isArray(array);
        }
        if (array && typeof (array.length) === _typeof.number && array.constructor === Array) {
            return true;
        }
        return false;
    }
    exports.isArray = isArray;
    /**
     * @returns whether the provided parameter is a JavaScript String or not.
     */
    function isString(str) {
        if (typeof (str) === _typeof.string || str instanceof String) {
            return true;
        }
        return false;
    }
    exports.isString = isString;
    /**
     * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.
     */
    function isStringArray(value) {
        return isArray(value) && value.every(function (elem) { return isString(elem); });
    }
    exports.isStringArray = isStringArray;
    /**
     *
     * @returns whether the provided parameter is of type `object` but **not**
     *	`null`, an `array`, a `regexp`, nor a `date`.
     */
    function isObject(obj) {
        // The method can't do a type cast since there are type (like strings) which
        // are subclasses of any put not positvely matched by the function. Hence type
        // narrowing results in wrong results.
        return typeof obj === _typeof.object
            && obj !== null
            && !Array.isArray(obj)
            && !(obj instanceof RegExp)
            && !(obj instanceof Date);
    }
    exports.isObject = isObject;
    /**
     * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
     * @returns whether the provided parameter is a JavaScript Number or not.
     */
    function isNumber(obj) {
        if ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {
            return true;
        }
        return false;
    }
    exports.isNumber = isNumber;
    /**
     * @returns whether the provided parameter is a JavaScript Boolean or not.
     */
    function isBoolean(obj) {
        return obj === true || obj === false;
    }
    exports.isBoolean = isBoolean;
    /**
     * @returns whether the provided parameter is undefined.
     */
    function isUndefined(obj) {
        return typeof (obj) === _typeof.undefined;
    }
    exports.isUndefined = isUndefined;
    /**
     * @returns whether the provided parameter is undefined or null.
     */
    function isUndefinedOrNull(obj) {
        return isUndefined(obj) || obj === null;
    }
    exports.isUndefinedOrNull = isUndefinedOrNull;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * @returns whether the provided parameter is an empty JavaScript Object or not.
     */
    function isEmptyObject(obj) {
        if (!isObject(obj)) {
            return false;
        }
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                return false;
            }
        }
        return true;
    }
    exports.isEmptyObject = isEmptyObject;
    /**
     * @returns whether the provided parameter is a JavaScript Function or not.
     */
    function isFunction(obj) {
        return typeof obj === _typeof.function;
    }
    exports.isFunction = isFunction;
    /**
     * @returns whether the provided parameters is are JavaScript Function or not.
     */
    function areFunctions() {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i] = arguments[_i];
        }
        return objects && objects.length > 0 && objects.every(isFunction);
    }
    exports.areFunctions = areFunctions;
    function validateConstraints(args, constraints) {
        var len = Math.min(args.length, constraints.length);
        for (var i = 0; i < len; i++) {
            validateConstraint(args[i], constraints[i]);
        }
    }
    exports.validateConstraints = validateConstraints;
    function validateConstraint(arg, constraint) {
        if (isString(constraint)) {
            if (typeof arg !== constraint) {
                throw new Error("argument does not match constraint: typeof " + constraint);
            }
        }
        else if (isFunction(constraint)) {
            if (arg instanceof constraint) {
                return;
            }
            if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
                return;
            }
            if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
                return;
            }
            throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
        }
    }
    exports.validateConstraint = validateConstraint;
    /**
     * Creates a new object of the provided class and will call the constructor with
     * any additional argument supplied.
     */
    function create(ctor) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var obj = Object.create(ctor.prototype);
        ctor.apply(obj, args);
        return obj;
    }
    exports.create = create;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[20/*vs/base/common/objects*/], __M([0/*require*/,1/*exports*/,18/*vs/base/common/types*/]), function (require, exports, types_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function deepClone(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        if (obj instanceof RegExp) {
            // See https://github.com/Microsoft/TypeScript/issues/10990
            return obj;
        }
        var result = Array.isArray(obj) ? [] : {};
        Object.keys(obj).forEach(function (key) {
            if (obj[key] && typeof obj[key] === 'object') {
                result[key] = deepClone(obj[key]);
            }
            else {
                result[key] = obj[key];
            }
        });
        return result;
    }
    exports.deepClone = deepClone;
    function deepFreeze(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        var stack = [obj];
        while (stack.length > 0) {
            var obj_1 = stack.shift();
            Object.freeze(obj_1);
            for (var key in obj_1) {
                if (_hasOwnProperty.call(obj_1, key)) {
                    var prop = obj_1[key];
                    if (typeof prop === 'object' && !Object.isFrozen(prop)) {
                        stack.push(prop);
                    }
                }
            }
        }
        return obj;
    }
    exports.deepFreeze = deepFreeze;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function cloneAndChange(obj, changer) {
        return _cloneAndChange(obj, changer, []);
    }
    exports.cloneAndChange = cloneAndChange;
    function _cloneAndChange(obj, changer, encounteredObjects) {
        if (types_1.isUndefinedOrNull(obj)) {
            return obj;
        }
        var changed = changer(obj);
        if (typeof changed !== 'undefined') {
            return changed;
        }
        if (types_1.isArray(obj)) {
            var r1 = [];
            for (var i1 = 0; i1 < obj.length; i1++) {
                r1.push(_cloneAndChange(obj[i1], changer, encounteredObjects));
            }
            return r1;
        }
        if (types_1.isObject(obj)) {
            if (encounteredObjects.indexOf(obj) >= 0) {
                throw new Error('Cannot clone recursive data-structure');
            }
            encounteredObjects.push(obj);
            var r2 = {};
            for (var i2 in obj) {
                if (_hasOwnProperty.call(obj, i2)) {
                    r2[i2] = _cloneAndChange(obj[i2], changer, encounteredObjects);
                }
            }
            encounteredObjects.pop();
            return r2;
        }
        return obj;
    }
    /**
     * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
     * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
     */
    function mixin(destination, source, overwrite) {
        if (overwrite === void 0) { overwrite = true; }
        if (!types_1.isObject(destination)) {
            return source;
        }
        if (types_1.isObject(source)) {
            Object.keys(source).forEach(function (key) {
                if (key in destination) {
                    if (overwrite) {
                        if (types_1.isObject(destination[key]) && types_1.isObject(source[key])) {
                            mixin(destination[key], source[key], overwrite);
                        }
                        else {
                            destination[key] = source[key];
                        }
                    }
                }
                else {
                    destination[key] = source[key];
                }
            });
        }
        return destination;
    }
    exports.mixin = mixin;
    function assign(destination) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        sources.forEach(function (source) { return Object.keys(source).forEach(function (key) { return destination[key] = source[key]; }); });
        return destination;
    }
    exports.assign = assign;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        if ((Array.isArray(one)) !== (Array.isArray(other))) {
            return false;
        }
        var i;
        var key;
        if (Array.isArray(one)) {
            if (one.length !== other.length) {
                return false;
            }
            for (i = 0; i < one.length; i++) {
                if (!equals(one[i], other[i])) {
                    return false;
                }
            }
        }
        else {
            var oneKeys = [];
            for (key in one) {
                oneKeys.push(key);
            }
            oneKeys.sort();
            var otherKeys = [];
            for (key in other) {
                otherKeys.push(key);
            }
            otherKeys.sort();
            if (!equals(oneKeys, otherKeys)) {
                return false;
            }
            for (i = 0; i < oneKeys.length; i++) {
                if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                    return false;
                }
            }
        }
        return true;
    }
    exports.equals = equals;
    function arrayToHash(array) {
        var result = {};
        for (var i = 0; i < array.length; ++i) {
            result[array[i]] = true;
        }
        return result;
    }
    exports.arrayToHash = arrayToHash;
    /**
     * Given an array of strings, returns a function which, given a string
     * returns true or false whether the string is in that array.
     */
    function createKeywordMatcher(arr, caseInsensitive) {
        if (caseInsensitive === void 0) { caseInsensitive = false; }
        if (caseInsensitive) {
            arr = arr.map(function (x) { return x.toLowerCase(); });
        }
        var hash = arrayToHash(arr);
        if (caseInsensitive) {
            return function (word) {
                return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());
            };
        }
        else {
            return function (word) {
                return hash[word] !== undefined && hash.hasOwnProperty(word);
            };
        }
    }
    exports.createKeywordMatcher = createKeywordMatcher;
    /**
     * Calls JSON.Stringify with a replacer to break apart any circular references.
     * This prevents JSON.stringify from throwing the exception
     *  "Uncaught TypeError: Converting circular structure to JSON"
     */
    function safeStringify(obj) {
        var seen = [];
        return JSON.stringify(obj, function (key, value) {
            if (types_1.isObject(value) || Array.isArray(value)) {
                if (seen.indexOf(value) !== -1) {
                    return '[Circular]';
                }
                else {
                    seen.push(value);
                }
            }
            return value;
        });
    }
    exports.safeStringify = safeStringify;
    function getOrDefault(obj, fn, defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        var result = fn(obj);
        return typeof result === 'undefined' ? defaultValue : result;
    }
    exports.getOrDefault = getOrDefault;
    /**
     * Returns an object that has keys for each value that is different in the base object. Keys
     * that do not exist in the target but in the base object are not considered.
     *
     * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting
     * object if they differ.
     *
     * @param base the object to diff against
     * @param obj the object to use for diffing
     */
    function distinct(base, target) {
        var result = Object.create(null);
        if (!base || !target) {
            return result;
        }
        var targetKeys = Object.keys(target);
        targetKeys.forEach(function (k) {
            var baseValue = base[k];
            var targetValue = target[k];
            if (!equals(baseValue, targetValue)) {
                result[k] = targetValue;
            }
        });
        return result;
    }
    exports.distinct = distinct;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define(__m[4/*vs/base/common/uri*/], __M([0/*require*/,1/*exports*/,10/*vs/base/common/platform*/]), function (require, exports, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var _a;
    var _schemePattern = /^\w[\w\d+.-]*$/;
    var _singleSlashStart = /^\//;
    var _doubleSlashStart = /^\/\//;
    function _validateUri(ret) {
        // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
        // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
        if (ret.scheme && !_schemePattern.test(ret.scheme)) {
            throw new Error('[UriError]: Scheme contains illegal characters.');
        }
        // path, http://tools.ietf.org/html/rfc3986#section-3.3
        // If a URI contains an authority component, then the path component
        // must either be empty or begin with a slash ("/") character.  If a URI
        // does not contain an authority component, then the path cannot begin
        // with two slash characters ("//").
        if (ret.path) {
            if (ret.authority) {
                if (!_singleSlashStart.test(ret.path)) {
                    throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                }
            }
            else {
                if (_doubleSlashStart.test(ret.path)) {
                    throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
                }
            }
        }
    }
    // implements a bit of https://tools.ietf.org/html/rfc3986#section-5
    function _referenceResolution(scheme, path) {
        // the slash-character is our 'default base' as we don't
        // support constructing URIs relative to other URIs. This
        // also means that we alter and potentially break paths.
        // see https://tools.ietf.org/html/rfc3986#section-5.1.4
        switch (scheme) {
            case 'https':
            case 'http':
            case 'file':
                if (!path) {
                    path = _slash;
                }
                else if (path[0] !== _slash) {
                    path = _slash + path;
                }
                break;
        }
        return path;
    }
    var _empty = '';
    var _slash = '/';
    var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    /**
     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
     * This class is a simple parser which creates the basic component paths
     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
     * and encoding.
     *
     *       foo://example.com:8042/over/there?name=ferret#nose
     *       \_/   \______________/\_________/ \_________/ \__/
     *        |           |            |            |        |
     *     scheme     authority       path        query   fragment
     *        |   _____________________|__
     *       / \ /                        \
     *       urn:example:animal:ferret:nose
     *
     *
     */
    var URI = /** @class */ (function () {
        /**
         * @internal
         */
        function URI(schemeOrData, authority, path, query, fragment) {
            if (typeof schemeOrData === 'object') {
                this.scheme = schemeOrData.scheme || _empty;
                this.authority = schemeOrData.authority || _empty;
                this.path = schemeOrData.path || _empty;
                this.query = schemeOrData.query || _empty;
                this.fragment = schemeOrData.fragment || _empty;
                // no validation because it's this URI
                // that creates uri components.
                // _validateUri(this);
            }
            else {
                this.scheme = schemeOrData || _empty;
                this.authority = authority || _empty;
                this.path = _referenceResolution(this.scheme, path || _empty);
                this.query = query || _empty;
                this.fragment = fragment || _empty;
                _validateUri(this);
            }
        }
        URI.isUri = function (thing) {
            if (thing instanceof URI) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return typeof thing.authority === 'string'
                && typeof thing.fragment === 'string'
                && typeof thing.path === 'string'
                && typeof thing.query === 'string'
                && typeof thing.scheme === 'string';
        };
        Object.defineProperty(URI.prototype, "fsPath", {
            // ---- filesystem path -----------------------
            /**
             * Returns a string representing the corresponding file system path of this URI.
             * Will handle UNC paths and normalize windows drive letters to lower-case. Also
             * uses the platform specific path separator. Will *not* validate the path for
             * invalid characters and semantics. Will *not* look at the scheme of this URI.
             */
            get: function () {
                return _makeFsPath(this);
            },
            enumerable: true,
            configurable: true
        });
        // ---- modify to new -------------------------
        URI.prototype.with = function (change) {
            if (!change) {
                return this;
            }
            var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;
            if (scheme === void 0) {
                scheme = this.scheme;
            }
            else if (scheme === null) {
                scheme = _empty;
            }
            if (authority === void 0) {
                authority = this.authority;
            }
            else if (authority === null) {
                authority = _empty;
            }
            if (path === void 0) {
                path = this.path;
            }
            else if (path === null) {
                path = _empty;
            }
            if (query === void 0) {
                query = this.query;
            }
            else if (query === null) {
                query = _empty;
            }
            if (fragment === void 0) {
                fragment = this.fragment;
            }
            else if (fragment === null) {
                fragment = _empty;
            }
            if (scheme === this.scheme
                && authority === this.authority
                && path === this.path
                && query === this.query
                && fragment === this.fragment) {
                return this;
            }
            return new _URI(scheme, authority, path, query, fragment);
        };
        // ---- parse & validate ------------------------
        URI.parse = function (value) {
            var match = _regexp.exec(value);
            if (!match) {
                return new _URI(_empty, _empty, _empty, _empty, _empty);
            }
            return new _URI(match[2] || _empty, decodeURIComponent(match[4] || _empty), decodeURIComponent(match[5] || _empty), decodeURIComponent(match[7] || _empty), decodeURIComponent(match[9] || _empty));
        };
        URI.file = function (path) {
            var authority = _empty;
            // normalize to fwd-slashes on windows,
            // on other systems bwd-slashes are valid
            // filename character, eg /f\oo/ba\r.txt
            if (platform_1.isWindows) {
                path = path.replace(/\\/g, _slash);
            }
            // check for authority as used in UNC shares
            // or use the path as given
            if (path[0] === _slash && path[1] === _slash) {
                var idx = path.indexOf(_slash, 2);
                if (idx === -1) {
                    authority = path.substring(2);
                    path = _slash;
                }
                else {
                    authority = path.substring(2, idx);
                    path = path.substring(idx) || _slash;
                }
            }
            return new _URI('file', authority, path, _empty, _empty);
        };
        URI.from = function (components) {
            return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);
        };
        // ---- printing/externalize ---------------------------
        /**
         *
         * @param skipEncoding Do not encode the result, default is `false`
         */
        URI.prototype.toString = function (skipEncoding) {
            if (skipEncoding === void 0) { skipEncoding = false; }
            return _asFormatted(this, skipEncoding);
        };
        URI.prototype.toJSON = function () {
            return this;
        };
        URI.revive = function (data) {
            if (!data) {
                return data;
            }
            else if (data instanceof URI) {
                return data;
            }
            else {
                var result = new _URI(data);
                result._fsPath = data.fsPath;
                result._formatted = data.external;
                return result;
            }
        };
        return URI;
    }());
    exports.default = URI;
    // tslint:disable-next-line:class-name
    var _URI = /** @class */ (function (_super) {
        __extends(_URI, _super);
        function _URI() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._formatted = null;
            _this._fsPath = null;
            return _this;
        }
        Object.defineProperty(_URI.prototype, "fsPath", {
            get: function () {
                if (!this._fsPath) {
                    this._fsPath = _makeFsPath(this);
                }
                return this._fsPath;
            },
            enumerable: true,
            configurable: true
        });
        _URI.prototype.toString = function (skipEncoding) {
            if (skipEncoding === void 0) { skipEncoding = false; }
            if (!skipEncoding) {
                if (!this._formatted) {
                    this._formatted = _asFormatted(this, false);
                }
                return this._formatted;
            }
            else {
                // we don't cache that
                return _asFormatted(this, true);
            }
        };
        _URI.prototype.toJSON = function () {
            var res = {
                $mid: 1
            };
            // cached state
            if (this._fsPath) {
                res.fsPath = this._fsPath;
            }
            if (this._formatted) {
                res.external = this._formatted;
            }
            // uri components
            if (this.path) {
                res.path = this.path;
            }
            if (this.scheme) {
                res.scheme = this.scheme;
            }
            if (this.authority) {
                res.authority = this.authority;
            }
            if (this.query) {
                res.query = this.query;
            }
            if (this.fragment) {
                res.fragment = this.fragment;
            }
            return res;
        };
        return _URI;
    }(URI));
    // reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2
    var encodeTable = (_a = {},
        _a[58 /* Colon */] = '%3A',
        _a[47 /* Slash */] = '%2F',
        _a[63 /* QuestionMark */] = '%3F',
        _a[35 /* Hash */] = '%23',
        _a[91 /* OpenSquareBracket */] = '%5B',
        _a[93 /* CloseSquareBracket */] = '%5D',
        _a[64 /* AtSign */] = '%40',
        _a[33 /* ExclamationMark */] = '%21',
        _a[36 /* DollarSign */] = '%24',
        _a[38 /* Ampersand */] = '%26',
        _a[39 /* SingleQuote */] = '%27',
        _a[40 /* OpenParen */] = '%28',
        _a[41 /* CloseParen */] = '%29',
        _a[42 /* Asterisk */] = '%2A',
        _a[43 /* Plus */] = '%2B',
        _a[44 /* Comma */] = '%2C',
        _a[59 /* Semicolon */] = '%3B',
        _a[61 /* Equals */] = '%3D',
        _a[32 /* Space */] = '%20',
        _a);
    function encodeURIComponentFast(uriComponent, allowSlash) {
        var res = undefined;
        var nativeEncodePos = -1;
        for (var pos = 0; pos < uriComponent.length; pos++) {
            var code = uriComponent.charCodeAt(pos);
            // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3
            if ((code >= 97 /* a */ && code <= 122 /* z */)
                || (code >= 65 /* A */ && code <= 90 /* Z */)
                || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)
                || code === 45 /* Dash */
                || code === 46 /* Period */
                || code === 95 /* Underline */
                || code === 126 /* Tilde */
                || (allowSlash && code === 47 /* Slash */)) {
                // check if we are delaying native encode
                if (nativeEncodePos !== -1) {
                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                    nativeEncodePos = -1;
                }
                // check if we write into a new string (by default we try to return the param)
                if (res !== undefined) {
                    res += uriComponent.charAt(pos);
                }
            }
            else {
                // encoding needed, we need to allocate a new string
                if (res === undefined) {
                    res = uriComponent.substr(0, pos);
                }
                // check with default table first
                var escaped = encodeTable[code];
                if (escaped !== undefined) {
                    // check if we are delaying native encode
                    if (nativeEncodePos !== -1) {
                        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                        nativeEncodePos = -1;
                    }
                    // append escaped variant to result
                    res += escaped;
                }
                else if (nativeEncodePos === -1) {
                    // use native encode only when needed
                    nativeEncodePos = pos;
                }
            }
        }
        if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
        }
        return res !== undefined ? res : uriComponent;
    }
    function encodeURIComponentMinimal(path) {
        var res = undefined;
        for (var pos = 0; pos < path.length; pos++) {
            var code = path.charCodeAt(pos);
            if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {
                if (res === undefined) {
                    res = path.substr(0, pos);
                }
                res += encodeTable[code];
            }
            else {
                if (res !== undefined) {
                    res += path[pos];
                }
            }
        }
        return res !== undefined ? res : path;
    }
    /**
     * Compute `fsPath` for the given uri
     * @param uri
     */
    function _makeFsPath(uri) {
        var value;
        if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
            // unc path: file://shares/c$/far/boo
            value = "//" + uri.authority + uri.path;
        }
        else if (uri.path.charCodeAt(0) === 47 /* Slash */
            && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)
            && uri.path.charCodeAt(2) === 58 /* Colon */) {
            // windows drive letter: file:///c:/far/boo
            value = uri.path[1].toLowerCase() + uri.path.substr(2);
        }
        else {
            // other path
            value = uri.path;
        }
        if (platform_1.isWindows) {
            value = value.replace(/\//g, '\\');
        }
        return value;
    }
    /**
     * Create the external version of a uri
     */
    function _asFormatted(uri, skipEncoding) {
        var encoder = !skipEncoding
            ? encodeURIComponentFast
            : encodeURIComponentMinimal;
        var res = '';
        var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;
        if (scheme) {
            res += scheme;
            res += ':';
        }
        if (authority || scheme === 'file') {
            res += _slash;
            res += _slash;
        }
        if (authority) {
            var idx = authority.indexOf('@');
            if (idx !== -1) {
                // <user>@<auth>
                var userinfo = authority.substr(0, idx);
                authority = authority.substr(idx + 1);
                idx = userinfo.indexOf(':');
                if (idx === -1) {
                    res += encoder(userinfo, false);
                }
                else {
                    // <user>:<pass>@<auth>
                    res += encoder(userinfo.substr(0, idx), false);
                    res += ':';
                    res += encoder(userinfo.substr(idx + 1), false);
                }
                res += '@';
            }
            authority = authority.toLowerCase();
            idx = authority.indexOf(':');
            if (idx === -1) {
                res += encoder(authority, false);
            }
            else {
                // <auth>:<port>
                res += encoder(authority.substr(0, idx), false);
                res += authority.substr(idx);
            }
        }
        if (path) {
            // lower-case windows drive letters in /C:/fff or C:/fff
            if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {
                var code = path.charCodeAt(1);
                if (code >= 65 /* A */ && code <= 90 /* Z */) {
                    path = "/" + String.fromCharCode(code + 32) + ":" + path.substr(3); // "/c:".length === 3
                }
            }
            else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {
                var code = path.charCodeAt(0);
                if (code >= 65 /* A */ && code <= 90 /* Z */) {
                    path = String.fromCharCode(code + 32) + ":" + path.substr(2); // "/c:".length === 3
                }
            }
            // encode the rest of the path
            res += encoder(path, true);
        }
        if (query) {
            res += '?';
            res += encoder(query, false);
        }
        if (fragment) {
            res += '#';
            res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
        }
        return res;
    }
});

define(__m[62/*vs/base/common/labels*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,16/*vs/base/common/paths*/,8/*vs/base/common/strings*/,23/*vs/base/common/network*/,10/*vs/base/common/platform*/,26/*vs/base/common/resources*/]), function (require, exports, uri_1, paths_1, strings_1, network_1, platform_1, resources_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @deprecated use UriLabelService instead
     */
    function getPathLabel(resource, userHomeProvider, rootProvider) {
        if (!resource) {
            return null;
        }
        if (typeof resource === 'string') {
            resource = uri_1.default.file(resource);
        }
        // return early if we can resolve a relative path label from the root
        var baseResource = rootProvider ? rootProvider.getWorkspaceFolder(resource) : null;
        if (baseResource) {
            var hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;
            var pathLabel = void 0;
            if (resources_1.isEqual(baseResource.uri, resource, !platform_1.isLinux)) {
                pathLabel = ''; // no label if paths are identical
            }
            else {
                pathLabel = paths_1.normalize(strings_1.ltrim(resource.path.substr(baseResource.uri.path.length), paths_1.sep), true);
            }
            if (hasMultipleRoots) {
                var rootName = (baseResource && baseResource.name) ? baseResource.name : paths_1.basename(baseResource.uri.fsPath);
                pathLabel = pathLabel ? (rootName + ' • ' + pathLabel) : rootName; // always show root basename if there are multiple
            }
            return pathLabel;
        }
        // return if the resource is neither file:// nor untitled:// and no baseResource was provided
        if (resource.scheme !== network_1.Schemas.file && resource.scheme !== network_1.Schemas.untitled) {
            return resource.with({ query: null, fragment: null }).toString(true);
        }
        // convert c:\something => C:\something
        if (hasDriveLetter(resource.fsPath)) {
            return paths_1.normalize(normalizeDriveLetter(resource.fsPath), true);
        }
        // normalize and tildify (macOS, Linux only)
        var res = paths_1.normalize(resource.fsPath, true);
        if (!platform_1.isWindows && userHomeProvider) {
            res = tildify(res, userHomeProvider.userHome);
        }
        return res;
    }
    exports.getPathLabel = getPathLabel;
    function getBaseLabel(resource) {
        if (!resource) {
            return null;
        }
        if (typeof resource === 'string') {
            resource = uri_1.default.file(resource);
        }
        var base = paths_1.basename(resource.path) || (resource.scheme === network_1.Schemas.file ? resource.fsPath : resource.path) /* can be empty string if '/' is passed in */;
        // convert c: => C:
        if (hasDriveLetter(base)) {
            return normalizeDriveLetter(base);
        }
        return base;
    }
    exports.getBaseLabel = getBaseLabel;
    function hasDriveLetter(path) {
        return platform_1.isWindows && path && path[1] === ':';
    }
    function normalizeDriveLetter(path) {
        if (hasDriveLetter(path)) {
            return path.charAt(0).toUpperCase() + path.slice(1);
        }
        return path;
    }
    exports.normalizeDriveLetter = normalizeDriveLetter;
    var normalizedUserHomeCached = Object.create(null);
    function tildify(path, userHome) {
        if (platform_1.isWindows || !path || !userHome) {
            return path; // unsupported
        }
        // Keep a normalized user home path as cache to prevent accumulated string creation
        var normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : void 0;
        if (!normalizedUserHome) {
            normalizedUserHome = "" + strings_1.rtrim(userHome, paths_1.sep) + paths_1.sep;
            normalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };
        }
        // Linux: case sensitive, macOS: case insensitive
        if (platform_1.isLinux ? strings_1.startsWith(path, normalizedUserHome) : strings_1.startsWithIgnoreCase(path, normalizedUserHome)) {
            path = "~/" + path.substr(normalizedUserHome.length);
        }
        return path;
    }
    exports.tildify = tildify;
    function untildify(path, userHome) {
        return path.replace(/^~($|\/|\\)/, userHome + "$1");
    }
    exports.untildify = untildify;
    /**
     * Shortens the paths but keeps them easy to distinguish.
     * Replaces not important parts with ellipsis.
     * Every shorten path matches only one original path and vice versa.
     *
     * Algorithm for shortening paths is as follows:
     * 1. For every path in list, find unique substring of that path.
     * 2. Unique substring along with ellipsis is shortened path of that path.
     * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string
     *    and if present segment is not substring to any other paths then present segment is unique path,
     *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,
     *    if it is true take present segment as unique path.
     * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.
     *
     * Example 1
     * 1. consider 2 paths i.e. ['a\\b\\c\\d', 'a\\f\\b\\c\\d']
     * 2. find unique path of first path,
     * 	a. 'd' is present in path2 and is suffix of path2, hence not unique of present path.
     * 	b. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.
     * 	c. 'd\\c' is suffix of path2.
     *  d. 'b\\c' is not suffix of present path.
     *  e. 'a\\b' is not present in path2, hence unique path is 'a\\b...'.
     * 3. for path2, 'f' is not present in path1 hence unique is '...\\f\\...'.
     *
     * Example 2
     * 1. consider 2 paths i.e. ['a\\b', 'a\\b\\c'].
     * 	a. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\b'.
     * 2. for path2, 'c' is not present in path1 hence unique path is '..\\c'.
     */
    var ellipsis = '\u2026';
    var unc = '\\\\';
    var home = '~';
    function shorten(paths) {
        var shortenedPaths = new Array(paths.length);
        // for every path
        var match = false;
        for (var pathIndex = 0; pathIndex < paths.length; pathIndex++) {
            var path = paths[pathIndex];
            if (path === '') {
                shortenedPaths[pathIndex] = "." + paths_1.nativeSep;
                continue;
            }
            if (!path) {
                shortenedPaths[pathIndex] = path;
                continue;
            }
            match = true;
            // trim for now and concatenate unc path (e.g. \\network) or root path (/etc, ~/etc) later
            var prefix = '';
            if (path.indexOf(unc) === 0) {
                prefix = path.substr(0, path.indexOf(unc) + unc.length);
                path = path.substr(path.indexOf(unc) + unc.length);
            }
            else if (path.indexOf(paths_1.nativeSep) === 0) {
                prefix = path.substr(0, path.indexOf(paths_1.nativeSep) + paths_1.nativeSep.length);
                path = path.substr(path.indexOf(paths_1.nativeSep) + paths_1.nativeSep.length);
            }
            else if (path.indexOf(home) === 0) {
                prefix = path.substr(0, path.indexOf(home) + home.length);
                path = path.substr(path.indexOf(home) + home.length);
            }
            // pick the first shortest subpath found
            var segments = path.split(paths_1.nativeSep);
            for (var subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {
                for (var start = segments.length - subpathLength; match && start >= 0; start--) {
                    match = false;
                    var subpath = segments.slice(start, start + subpathLength).join(paths_1.nativeSep);
                    // that is unique to any other path
                    for (var otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {
                        // suffix subpath treated specially as we consider no match 'x' and 'x/...'
                        if (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {
                            var isSubpathEnding = (start + subpathLength === segments.length);
                            // Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.
                            // prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.
                            var subpathWithSep = (start > 0 && paths[otherPathIndex].indexOf(paths_1.nativeSep) > -1) ? paths_1.nativeSep + subpath : subpath;
                            var isOtherPathEnding = strings_1.endsWith(paths[otherPathIndex], subpathWithSep);
                            match = !isSubpathEnding || isOtherPathEnding;
                        }
                    }
                    // found unique subpath
                    if (!match) {
                        var result = '';
                        // preserve disk drive or root prefix
                        if (strings_1.endsWith(segments[0], ':') || prefix !== '') {
                            if (start === 1) {
                                // extend subpath to include disk drive prefix
                                start = 0;
                                subpathLength++;
                                subpath = segments[0] + paths_1.nativeSep + subpath;
                            }
                            if (start > 0) {
                                result = segments[0] + paths_1.nativeSep;
                            }
                            result = prefix + result;
                        }
                        // add ellipsis at the beginning if neeeded
                        if (start > 0) {
                            result = result + ellipsis + paths_1.nativeSep;
                        }
                        result = result + subpath;
                        // add ellipsis at the end if needed
                        if (start + subpathLength < segments.length) {
                            result = result + paths_1.nativeSep + ellipsis;
                        }
                        shortenedPaths[pathIndex] = result;
                    }
                }
            }
            if (match) {
                shortenedPaths[pathIndex] = path; // use full path if no unique subpaths found
            }
        }
        return shortenedPaths;
    }
    exports.shorten = shorten;
    var Type;
    (function (Type) {
        Type[Type["TEXT"] = 0] = "TEXT";
        Type[Type["VARIABLE"] = 1] = "VARIABLE";
        Type[Type["SEPARATOR"] = 2] = "SEPARATOR";
    })(Type || (Type = {}));
    /**
     * Helper to insert values for specific template variables into the string. E.g. "this $(is) a $(template)" can be
     * passed to this function together with an object that maps "is" and "template" to strings to have them replaced.
     * @param value string to which templating is applied
     * @param values the values of the templates to use
     */
    function template(template, values) {
        if (values === void 0) { values = Object.create(null); }
        var segments = [];
        var inVariable = false;
        var char;
        var curVal = '';
        for (var i = 0; i < template.length; i++) {
            char = template[i];
            // Beginning of variable
            if (char === '$' || (inVariable && char === '{')) {
                if (curVal) {
                    segments.push({ value: curVal, type: Type.TEXT });
                }
                curVal = '';
                inVariable = true;
            }
            // End of variable
            else if (char === '}' && inVariable) {
                var resolved = values[curVal];
                // Variable
                if (typeof resolved === 'string') {
                    if (resolved.length) {
                        segments.push({ value: resolved, type: Type.VARIABLE });
                    }
                }
                // Separator
                else if (resolved) {
                    var prevSegment = segments[segments.length - 1];
                    if (!prevSegment || prevSegment.type !== Type.SEPARATOR) {
                        segments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators
                    }
                }
                curVal = '';
                inVariable = false;
            }
            // Text or Variable Name
            else {
                curVal += char;
            }
        }
        // Tail
        if (curVal && !inVariable) {
            segments.push({ value: curVal, type: Type.TEXT });
        }
        return segments.filter(function (segment, index) {
            // Only keep separator if we have values to the left and right
            if (segment.type === Type.SEPARATOR) {
                var left = segments[index - 1];
                var right = segments[index + 1];
                return [left, right].every(function (segment) { return segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0; });
            }
            // accept any TEXT and VARIABLE
            return true;
        }).map(function (segment) { return segment.value; }).join('');
    }
    exports.template = template;
    /**
     * Handles mnemonics for menu items. Depending on OS:
     * - Windows: Supported via & character (replace && with &)
     * -   Linux: Supported via & character (replace && with &)
     * -   macOS: Unsupported (replace && with empty string)
     */
    function mnemonicMenuLabel(label, forceDisableMnemonics) {
        if (platform_1.isMacintosh || forceDisableMnemonics) {
            return label.replace(/\(&&\w\)|&&/g, '');
        }
        return label.replace(/&&/g, '&');
    }
    exports.mnemonicMenuLabel = mnemonicMenuLabel;
    /**
     * Handles mnemonics for buttons. Depending on OS:
     * - Windows: Supported via & character (replace && with &)
     * -   Linux: Supported via _ character (replace && with _)
     * -   macOS: Unsupported (replace && with empty string)
     */
    function mnemonicButtonLabel(label) {
        if (platform_1.isMacintosh) {
            return label.replace(/\(&&\w\)|&&/g, '');
        }
        return label.replace(/&&/g, platform_1.isWindows ? '&' : '_');
    }
    exports.mnemonicButtonLabel = mnemonicButtonLabel;
    function unmnemonicLabel(label) {
        return label.replace(/&/g, '&&');
    }
    exports.unmnemonicLabel = unmnemonicLabel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[21/*vs/base/common/map*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/]), function (require, exports, uri_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function values(forEachable) {
        var result = [];
        forEachable.forEach(function (value) { return result.push(value); });
        return result;
    }
    exports.values = values;
    function keys(map) {
        var result = [];
        map.forEach(function (value, key) { return result.push(key); });
        return result;
    }
    exports.keys = keys;
    function getOrSet(map, key, value) {
        var result = map.get(key);
        if (result === void 0) {
            result = value;
            map.set(key, result);
        }
        return result;
    }
    exports.getOrSet = getOrSet;
    var StringIterator = /** @class */ (function () {
        function StringIterator() {
            this._value = '';
            this._pos = 0;
        }
        StringIterator.prototype.reset = function (key) {
            this._value = key;
            this._pos = 0;
            return this;
        };
        StringIterator.prototype.next = function () {
            this._pos += 1;
            return this;
        };
        StringIterator.prototype.hasNext = function () {
            return this._pos < this._value.length - 1;
        };
        StringIterator.prototype.cmp = function (a) {
            var aCode = a.charCodeAt(0);
            var thisCode = this._value.charCodeAt(this._pos);
            return aCode - thisCode;
        };
        StringIterator.prototype.value = function () {
            return this._value[this._pos];
        };
        return StringIterator;
    }());
    exports.StringIterator = StringIterator;
    var PathIterator = /** @class */ (function () {
        function PathIterator() {
        }
        PathIterator.prototype.reset = function (key) {
            this._value = key.replace(/\\$|\/$/, '');
            this._from = 0;
            this._to = 0;
            return this.next();
        };
        PathIterator.prototype.hasNext = function () {
            return this._to < this._value.length;
        };
        PathIterator.prototype.next = function () {
            // this._data = key.split(/[\\/]/).filter(s => !!s);
            this._from = this._to;
            var justSeps = true;
            for (; this._to < this._value.length; this._to++) {
                var ch = this._value.charCodeAt(this._to);
                if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {
                    if (justSeps) {
                        this._from++;
                    }
                    else {
                        break;
                    }
                }
                else {
                    justSeps = false;
                }
            }
            return this;
        };
        PathIterator.prototype.cmp = function (a) {
            var aPos = 0;
            var aLen = a.length;
            var thisPos = this._from;
            while (aPos < aLen && thisPos < this._to) {
                var cmp = a.charCodeAt(aPos) - this._value.charCodeAt(thisPos);
                if (cmp !== 0) {
                    return cmp;
                }
                aPos += 1;
                thisPos += 1;
            }
            if (aLen === this._to - this._from) {
                return 0;
            }
            else if (aPos < aLen) {
                return -1;
            }
            else {
                return 1;
            }
        };
        PathIterator.prototype.value = function () {
            return this._value.substring(this._from, this._to);
        };
        return PathIterator;
    }());
    exports.PathIterator = PathIterator;
    var TernarySearchTreeNode = /** @class */ (function () {
        function TernarySearchTreeNode() {
        }
        TernarySearchTreeNode.prototype.isEmpty = function () {
            return !this.left && !this.mid && !this.right && !this.value;
        };
        return TernarySearchTreeNode;
    }());
    var TernarySearchTree = /** @class */ (function () {
        function TernarySearchTree(segments) {
            this._iter = segments;
        }
        TernarySearchTree.forPaths = function () {
            return new TernarySearchTree(new PathIterator());
        };
        TernarySearchTree.forStrings = function () {
            return new TernarySearchTree(new StringIterator());
        };
        TernarySearchTree.prototype.clear = function () {
            this._root = undefined;
        };
        TernarySearchTree.prototype.set = function (key, element) {
            var iter = this._iter.reset(key);
            var node;
            if (!this._root) {
                this._root = new TernarySearchTreeNode();
                this._root.segment = iter.value();
            }
            node = this._root;
            while (true) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    if (!node.left) {
                        node.left = new TernarySearchTreeNode();
                        node.left.segment = iter.value();
                    }
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    if (!node.right) {
                        node.right = new TernarySearchTreeNode();
                        node.right.segment = iter.value();
                    }
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    if (!node.mid) {
                        node.mid = new TernarySearchTreeNode();
                        node.mid.segment = iter.value();
                    }
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            var oldElement = node.value;
            node.value = element;
            node.key = key;
            return oldElement;
        };
        TernarySearchTree.prototype.get = function (key) {
            var iter = this._iter.reset(key);
            var node = this._root;
            while (node) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            return node ? node.value : undefined;
        };
        TernarySearchTree.prototype.delete = function (key) {
            var iter = this._iter.reset(key);
            var stack = [];
            var node = this._root;
            // find and unset node
            while (node) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    stack.push([1, node]);
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    stack.push([-1, node]);
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    stack.push([0, node]);
                    node = node.mid;
                }
                else {
                    // remove element
                    node.value = undefined;
                    // clean up empty nodes
                    while (stack.length > 0 && node.isEmpty()) {
                        var _a = stack.pop(), dir = _a[0], parent_1 = _a[1];
                        switch (dir) {
                            case 1:
                                parent_1.left = undefined;
                                break;
                            case 0:
                                parent_1.mid = undefined;
                                break;
                            case -1:
                                parent_1.right = undefined;
                                break;
                        }
                        node = parent_1;
                    }
                    break;
                }
            }
        };
        TernarySearchTree.prototype.findSubstr = function (key) {
            var iter = this._iter.reset(key);
            var node = this._root;
            var candidate;
            while (node) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    candidate = node.value || candidate;
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            return node && node.value || candidate;
        };
        TernarySearchTree.prototype.findSuperstr = function (key) {
            var iter = this._iter.reset(key);
            var node = this._root;
            while (node) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    node = node.mid;
                }
                else {
                    // collect
                    if (!node.mid) {
                        return undefined;
                    }
                    else {
                        return this._nodeIterator(node.mid);
                    }
                }
            }
            return undefined;
        };
        TernarySearchTree.prototype._nodeIterator = function (node) {
            var _this = this;
            var res = {
                done: false,
                value: undefined
            };
            var idx;
            var data;
            var next = function () {
                if (!data) {
                    // lazy till first invocation
                    data = [];
                    idx = 0;
                    _this._forEach(node, function (value) { return data.push(value); });
                }
                if (idx >= data.length) {
                    res.done = true;
                    res.value = undefined;
                }
                else {
                    res.done = false;
                    res.value = data[idx++];
                }
                return res;
            };
            return { next: next };
        };
        TernarySearchTree.prototype.forEach = function (callback) {
            this._forEach(this._root, callback);
        };
        TernarySearchTree.prototype._forEach = function (node, callback) {
            if (node) {
                // left
                this._forEach(node.left, callback);
                // node
                if (node.value) {
                    // callback(node.value, this._iter.join(parts));
                    callback(node.value, node.key);
                }
                // mid
                this._forEach(node.mid, callback);
                // right
                this._forEach(node.right, callback);
            }
        };
        return TernarySearchTree;
    }());
    exports.TernarySearchTree = TernarySearchTree;
    var ResourceMap = /** @class */ (function () {
        function ResourceMap() {
            this.map = new Map();
            this.ignoreCase = false; // in the future this should be an uri-comparator
        }
        ResourceMap.prototype.set = function (resource, value) {
            this.map.set(this.toKey(resource), value);
        };
        ResourceMap.prototype.get = function (resource) {
            return this.map.get(this.toKey(resource));
        };
        ResourceMap.prototype.has = function (resource) {
            return this.map.has(this.toKey(resource));
        };
        Object.defineProperty(ResourceMap.prototype, "size", {
            get: function () {
                return this.map.size;
            },
            enumerable: true,
            configurable: true
        });
        ResourceMap.prototype.clear = function () {
            this.map.clear();
        };
        ResourceMap.prototype.delete = function (resource) {
            return this.map.delete(this.toKey(resource));
        };
        ResourceMap.prototype.forEach = function (clb) {
            this.map.forEach(clb);
        };
        ResourceMap.prototype.values = function () {
            return values(this.map);
        };
        ResourceMap.prototype.toKey = function (resource) {
            var key = resource.toString();
            if (this.ignoreCase) {
                key = key.toLowerCase();
            }
            return key;
        };
        ResourceMap.prototype.keys = function () {
            return keys(this.map).map(uri_1.default.parse);
        };
        ResourceMap.prototype.clone = function () {
            var resourceMap = new ResourceMap();
            this.map.forEach(function (value, key) { return resourceMap.map.set(key, value); });
            return resourceMap;
        };
        return ResourceMap;
    }());
    exports.ResourceMap = ResourceMap;
    var Touch;
    (function (Touch) {
        Touch[Touch["None"] = 0] = "None";
        Touch[Touch["AsOld"] = 1] = "AsOld";
        Touch[Touch["AsNew"] = 2] = "AsNew";
    })(Touch = exports.Touch || (exports.Touch = {}));
    var LinkedMap = /** @class */ (function () {
        function LinkedMap() {
            this._map = new Map();
            this._head = undefined;
            this._tail = undefined;
            this._size = 0;
        }
        LinkedMap.prototype.clear = function () {
            this._map.clear();
            this._head = undefined;
            this._tail = undefined;
            this._size = 0;
        };
        LinkedMap.prototype.isEmpty = function () {
            return !this._head && !this._tail;
        };
        Object.defineProperty(LinkedMap.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        LinkedMap.prototype.has = function (key) {
            return this._map.has(key);
        };
        LinkedMap.prototype.get = function (key, touch) {
            if (touch === void 0) { touch = Touch.None; }
            var item = this._map.get(key);
            if (!item) {
                return undefined;
            }
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
            return item.value;
        };
        LinkedMap.prototype.set = function (key, value, touch) {
            if (touch === void 0) { touch = Touch.None; }
            var item = this._map.get(key);
            if (item) {
                item.value = value;
                if (touch !== Touch.None) {
                    this.touch(item, touch);
                }
            }
            else {
                item = { key: key, value: value, next: undefined, previous: undefined };
                switch (touch) {
                    case Touch.None:
                        this.addItemLast(item);
                        break;
                    case Touch.AsOld:
                        this.addItemFirst(item);
                        break;
                    case Touch.AsNew:
                        this.addItemLast(item);
                        break;
                    default:
                        this.addItemLast(item);
                        break;
                }
                this._map.set(key, item);
                this._size++;
            }
        };
        LinkedMap.prototype.delete = function (key) {
            return !!this.remove(key);
        };
        LinkedMap.prototype.remove = function (key) {
            var item = this._map.get(key);
            if (!item) {
                return undefined;
            }
            this._map.delete(key);
            this.removeItem(item);
            this._size--;
            return item.value;
        };
        LinkedMap.prototype.shift = function () {
            if (!this._head && !this._tail) {
                return undefined;
            }
            if (!this._head || !this._tail) {
                throw new Error('Invalid list');
            }
            var item = this._head;
            this._map.delete(item.key);
            this.removeItem(item);
            this._size--;
            return item.value;
        };
        LinkedMap.prototype.forEach = function (callbackfn, thisArg) {
            var current = this._head;
            while (current) {
                if (thisArg) {
                    callbackfn.bind(thisArg)(current.value, current.key, this);
                }
                else {
                    callbackfn(current.value, current.key, this);
                }
                current = current.next;
            }
        };
        LinkedMap.prototype.values = function () {
            var result = [];
            var current = this._head;
            while (current) {
                result.push(current.value);
                current = current.next;
            }
            return result;
        };
        LinkedMap.prototype.keys = function () {
            var result = [];
            var current = this._head;
            while (current) {
                result.push(current.key);
                current = current.next;
            }
            return result;
        };
        /* VS Code / Monaco editor runs on es5 which has no Symbol.iterator
        public keys(): IterableIterator<K> {
            let current = this._head;
            let iterator: IterableIterator<K> = {
                [Symbol.iterator]() {
                    return iterator;
                },
                next():IteratorResult<K> {
                    if (current) {
                        let result = { value: current.key, done: false };
                        current = current.next;
                        return result;
                    } else {
                        return { value: undefined, done: true };
                    }
                }
            };
            return iterator;
        }
    
        public values(): IterableIterator<V> {
            let current = this._head;
            let iterator: IterableIterator<V> = {
                [Symbol.iterator]() {
                    return iterator;
                },
                next():IteratorResult<V> {
                    if (current) {
                        let result = { value: current.value, done: false };
                        current = current.next;
                        return result;
                    } else {
                        return { value: undefined, done: true };
                    }
                }
            };
            return iterator;
        }
        */
        LinkedMap.prototype.trimOld = function (newSize) {
            if (newSize >= this.size) {
                return;
            }
            if (newSize === 0) {
                this.clear();
                return;
            }
            var current = this._head;
            var currentSize = this.size;
            while (current && currentSize > newSize) {
                this._map.delete(current.key);
                current = current.next;
                currentSize--;
            }
            this._head = current;
            this._size = currentSize;
            current.previous = void 0;
        };
        LinkedMap.prototype.addItemFirst = function (item) {
            // First time Insert
            if (!this._head && !this._tail) {
                this._tail = item;
            }
            else if (!this._head) {
                throw new Error('Invalid list');
            }
            else {
                item.next = this._head;
                this._head.previous = item;
            }
            this._head = item;
        };
        LinkedMap.prototype.addItemLast = function (item) {
            // First time Insert
            if (!this._head && !this._tail) {
                this._head = item;
            }
            else if (!this._tail) {
                throw new Error('Invalid list');
            }
            else {
                item.previous = this._tail;
                this._tail.next = item;
            }
            this._tail = item;
        };
        LinkedMap.prototype.removeItem = function (item) {
            if (item === this._head && item === this._tail) {
                this._head = void 0;
                this._tail = void 0;
            }
            else if (item === this._head) {
                this._head = item.next;
            }
            else if (item === this._tail) {
                this._tail = item.previous;
            }
            else {
                var next = item.next;
                var previous = item.previous;
                if (!next || !previous) {
                    throw new Error('Invalid list');
                }
                next.previous = previous;
                previous.next = next;
            }
        };
        LinkedMap.prototype.touch = function (item, touch) {
            if (!this._head || !this._tail) {
                throw new Error('Invalid list');
            }
            if ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {
                return;
            }
            if (touch === Touch.AsOld) {
                if (item === this._head) {
                    return;
                }
                var next = item.next;
                var previous = item.previous;
                // Unlink the item
                if (item === this._tail) {
                    // previous must be defined since item was not head but is tail
                    // So there are more than on item in the map
                    previous.next = void 0;
                    this._tail = previous;
                }
                else {
                    // Both next and previous are not undefined since item was neither head nor tail.
                    next.previous = previous;
                    previous.next = next;
                }
                // Insert the node at head
                item.previous = void 0;
                item.next = this._head;
                this._head.previous = item;
                this._head = item;
            }
            else if (touch === Touch.AsNew) {
                if (item === this._tail) {
                    return;
                }
                var next = item.next;
                var previous = item.previous;
                // Unlink the item.
                if (item === this._head) {
                    // next must be defined since item was not tail but is head
                    // So there are more than on item in the map
                    next.previous = void 0;
                    this._head = next;
                }
                else {
                    // Both next and previous are not undefined since item was neither head nor tail.
                    next.previous = previous;
                    previous.next = next;
                }
                item.next = void 0;
                item.previous = this._tail;
                this._tail.next = item;
                this._tail = item;
            }
        };
        LinkedMap.prototype.toJSON = function () {
            var data = [];
            this.forEach(function (value, key) {
                data.push([key, value]);
            });
            return data;
        };
        LinkedMap.prototype.fromJSON = function (data) {
            this.clear();
            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                var _a = data_1[_i], key = _a[0], value = _a[1];
                this.set(key, value);
            }
        };
        return LinkedMap;
    }());
    exports.LinkedMap = LinkedMap;
    var LRUCache = /** @class */ (function (_super) {
        __extends(LRUCache, _super);
        function LRUCache(limit, ratio) {
            if (ratio === void 0) { ratio = 1; }
            var _this = _super.call(this) || this;
            _this._limit = limit;
            _this._ratio = Math.min(Math.max(0, ratio), 1);
            return _this;
        }
        Object.defineProperty(LRUCache.prototype, "limit", {
            get: function () {
                return this._limit;
            },
            set: function (limit) {
                this._limit = limit;
                this.checkTrim();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LRUCache.prototype, "ratio", {
            get: function () {
                return this._ratio;
            },
            set: function (ratio) {
                this._ratio = Math.min(Math.max(0, ratio), 1);
                this.checkTrim();
            },
            enumerable: true,
            configurable: true
        });
        LRUCache.prototype.get = function (key) {
            return _super.prototype.get.call(this, key, Touch.AsNew);
        };
        LRUCache.prototype.peek = function (key) {
            return _super.prototype.get.call(this, key, Touch.None);
        };
        LRUCache.prototype.set = function (key, value) {
            _super.prototype.set.call(this, key, value, Touch.AsNew);
            this.checkTrim();
        };
        LRUCache.prototype.checkTrim = function () {
            if (this.size > this._limit) {
                this.trimOld(Math.round(this._limit * this._ratio));
            }
        };
        return LRUCache;
    }(LinkedMap));
    exports.LRUCache = LRUCache;
});

define(__m[89/*vs/base/common/filters*/], __M([0/*require*/,1/*exports*/,8/*vs/base/common/strings*/,21/*vs/base/common/map*/]), function (require, exports, strings, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // Combined filters
    /**
     * @returns A filter which combines the provided set
     * of filters with an or. The *first* filters that
     * matches defined the return value of the returned
     * filter.
     */
    function or() {
        var filter = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            filter[_i] = arguments[_i];
        }
        return function (word, wordToMatchAgainst) {
            for (var i = 0, len = filter.length; i < len; i++) {
                var match = filter[i](word, wordToMatchAgainst);
                if (match) {
                    return match;
                }
            }
            return null;
        };
    }
    exports.or = or;
    // Prefix
    exports.matchesStrictPrefix = _matchesPrefix.bind(undefined, false);
    exports.matchesPrefix = _matchesPrefix.bind(undefined, true);
    function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
        if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {
            return null;
        }
        var matches;
        if (ignoreCase) {
            matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);
        }
        else {
            matches = wordToMatchAgainst.indexOf(word) === 0;
        }
        if (!matches) {
            return null;
        }
        return word.length > 0 ? [{ start: 0, end: word.length }] : [];
    }
    // Contiguous Substring
    function matchesContiguousSubString(word, wordToMatchAgainst) {
        var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
        if (index === -1) {
            return null;
        }
        return [{ start: index, end: index + word.length }];
    }
    exports.matchesContiguousSubString = matchesContiguousSubString;
    // Substring
    function matchesSubString(word, wordToMatchAgainst) {
        return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
    }
    exports.matchesSubString = matchesSubString;
    function _matchesSubString(word, wordToMatchAgainst, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === wordToMatchAgainst.length) {
            return null;
        }
        else {
            if (word[i] === wordToMatchAgainst[j]) {
                var result = null;
                if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
                    return join({ start: j, end: j + 1 }, result);
                }
                return null;
            }
            return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
        }
    }
    // CamelCase
    function isLower(code) {
        return 97 /* a */ <= code && code <= 122 /* z */;
    }
    function isUpper(code) {
        return 65 /* A */ <= code && code <= 90 /* Z */;
    }
    exports.isUpper = isUpper;
    function isNumber(code) {
        return 48 /* Digit0 */ <= code && code <= 57 /* Digit9 */;
    }
    function isWhitespace(code) {
        return (code === 32 /* Space */
            || code === 9 /* Tab */
            || code === 10 /* LineFeed */
            || code === 13 /* CarriageReturn */);
    }
    function isAlphanumeric(code) {
        return isLower(code) || isUpper(code) || isNumber(code);
    }
    function join(head, tail) {
        if (tail.length === 0) {
            tail = [head];
        }
        else if (head.end === tail[0].start) {
            tail[0].start = head.start;
        }
        else {
            tail.unshift(head);
        }
        return tail;
    }
    function nextAnchor(camelCaseWord, start) {
        for (var i = start; i < camelCaseWord.length; i++) {
            var c = camelCaseWord.charCodeAt(i);
            if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {
                return i;
            }
        }
        return camelCaseWord.length;
    }
    function _matchesCamelCase(word, camelCaseWord, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === camelCaseWord.length) {
            return null;
        }
        else if (word[i] !== camelCaseWord[j].toLowerCase()) {
            return null;
        }
        else {
            var result = null;
            var nextUpperIndex = j + 1;
            result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);
            while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
                result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
                nextUpperIndex++;
            }
            return result === null ? null : join({ start: j, end: j + 1 }, result);
        }
    }
    // Heuristic to avoid computing camel case matcher for words that don't
    // look like camelCaseWords.
    function analyzeCamelCaseWord(word) {
        var upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;
        for (var i = 0; i < word.length; i++) {
            code = word.charCodeAt(i);
            if (isUpper(code)) {
                upper++;
            }
            if (isLower(code)) {
                lower++;
            }
            if (isAlphanumeric(code)) {
                alpha++;
            }
            if (isNumber(code)) {
                numeric++;
            }
        }
        var upperPercent = upper / word.length;
        var lowerPercent = lower / word.length;
        var alphaPercent = alpha / word.length;
        var numericPercent = numeric / word.length;
        return { upperPercent: upperPercent, lowerPercent: lowerPercent, alphaPercent: alphaPercent, numericPercent: numericPercent };
    }
    function isUpperCaseWord(analysis) {
        var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent;
        return lowerPercent === 0 && upperPercent > 0.6;
    }
    function isCamelCaseWord(analysis) {
        var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent, alphaPercent = analysis.alphaPercent, numericPercent = analysis.numericPercent;
        return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
    }
    // Heuristic to avoid computing camel case matcher for words that don't
    // look like camel case patterns.
    function isCamelCasePattern(word) {
        var upper = 0, lower = 0, code = 0, whitespace = 0;
        for (var i = 0; i < word.length; i++) {
            code = word.charCodeAt(i);
            if (isUpper(code)) {
                upper++;
            }
            if (isLower(code)) {
                lower++;
            }
            if (isWhitespace(code)) {
                whitespace++;
            }
        }
        if ((upper === 0 || lower === 0) && whitespace === 0) {
            return word.length <= 30;
        }
        else {
            return upper <= 5;
        }
    }
    function matchesCamelCase(word, camelCaseWord) {
        if (!camelCaseWord) {
            return null;
        }
        camelCaseWord = camelCaseWord.trim();
        if (camelCaseWord.length === 0) {
            return null;
        }
        if (!isCamelCasePattern(word)) {
            return null;
        }
        if (camelCaseWord.length > 60) {
            return null;
        }
        var analysis = analyzeCamelCaseWord(camelCaseWord);
        if (!isCamelCaseWord(analysis)) {
            if (!isUpperCaseWord(analysis)) {
                return null;
            }
            camelCaseWord = camelCaseWord.toLowerCase();
        }
        var result = null;
        var i = 0;
        word = word.toLowerCase();
        while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {
            i = nextAnchor(camelCaseWord, i + 1);
        }
        return result;
    }
    exports.matchesCamelCase = matchesCamelCase;
    // Matches beginning of words supporting non-ASCII languages
    // If `contiguous` is true then matches word with beginnings of the words in the target. E.g. "pul" will match "Git: Pull"
    // Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. "gp" or "g p" will match "Git: Pull"
    // Useful in cases where the target is words (e.g. command labels)
    function matchesWords(word, target, contiguous) {
        if (contiguous === void 0) { contiguous = false; }
        if (!target || target.length === 0) {
            return null;
        }
        var result = null;
        var i = 0;
        word = word.toLowerCase();
        target = target.toLowerCase();
        while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {
            i = nextWord(target, i + 1);
        }
        return result;
    }
    exports.matchesWords = matchesWords;
    function _matchesWords(word, target, i, j, contiguous) {
        if (i === word.length) {
            return [];
        }
        else if (j === target.length) {
            return null;
        }
        else if (word[i] !== target[j]) {
            return null;
        }
        else {
            var result = null;
            var nextWordIndex = j + 1;
            result = _matchesWords(word, target, i + 1, j + 1, contiguous);
            if (!contiguous) {
                while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {
                    result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);
                    nextWordIndex++;
                }
            }
            return result === null ? null : join({ start: j, end: j + 1 }, result);
        }
    }
    function nextWord(word, start) {
        for (var i = start; i < word.length; i++) {
            var c = word.charCodeAt(i);
            if (isWhitespace(c) || (i > 0 && isWhitespace(word.charCodeAt(i - 1)))) {
                return i;
            }
        }
        return word.length;
    }
    // Fuzzy
    exports.fuzzyContiguousFilter = or(exports.matchesPrefix, matchesCamelCase, matchesContiguousSubString);
    var fuzzySeparateFilter = or(exports.matchesPrefix, matchesCamelCase, matchesSubString);
    var fuzzyRegExpCache = new map_1.LRUCache(10000); // bounded to 10000 elements
    function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {
        if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }
        if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {
            return null; // return early for invalid input
        }
        // Form RegExp for wildcard matches
        var regexp = fuzzyRegExpCache.get(word);
        if (!regexp) {
            regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');
            fuzzyRegExpCache.set(word, regexp);
        }
        // RegExp Filter
        var match = regexp.exec(wordToMatchAgainst);
        if (match) {
            return [{ start: match.index, end: match.index + match[0].length }];
        }
        // Default Filter
        return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : exports.fuzzyContiguousFilter(word, wordToMatchAgainst);
    }
    exports.matchesFuzzy = matchesFuzzy;
    function anyScore(pattern, word, patternMaxWhitespaceIgnore) {
        pattern = pattern.toLowerCase();
        word = word.toLowerCase();
        var matches = [];
        var idx = 0;
        for (var pos = 0; pos < pattern.length; ++pos) {
            var thisIdx = word.indexOf(pattern.charAt(pos), idx);
            if (thisIdx >= 0) {
                matches.push(thisIdx);
                idx = thisIdx + 1;
            }
        }
        return [matches.length, matches];
    }
    exports.anyScore = anyScore;
    //#region --- fuzzyScore ---
    function createMatches(position) {
        var ret = [];
        if (!position) {
            return ret;
        }
        var last;
        for (var _i = 0, position_1 = position; _i < position_1.length; _i++) {
            var pos = position_1[_i];
            if (last && last.end === pos) {
                last.end += 1;
            }
            else {
                last = { start: pos, end: pos + 1 };
                ret.push(last);
            }
        }
        return ret;
    }
    exports.createMatches = createMatches;
    function initTable() {
        var table = [];
        var row = [0];
        for (var i = 1; i <= 100; i++) {
            row.push(-i);
        }
        for (var i = 0; i <= 100; i++) {
            var thisRow = row.slice(0);
            thisRow[0] = -i;
            table.push(thisRow);
        }
        return table;
    }
    var _table = initTable();
    var _scores = initTable();
    var _arrows = initTable();
    var _debug = false;
    function printTable(table, pattern, patternLen, word, wordLen) {
        function pad(s, n, pad) {
            if (pad === void 0) { pad = ' '; }
            while (s.length < n) {
                s = pad + s;
            }
            return s;
        }
        var ret = " |   |" + word.split('').map(function (c) { return pad(c, 3); }).join('|') + "\n";
        for (var i = 0; i <= patternLen; i++) {
            if (i === 0) {
                ret += ' |';
            }
            else {
                ret += pattern[i - 1] + "|";
            }
            ret += table[i].slice(0, wordLen + 1).map(function (n) { return pad(n.toString(), 3); }).join('|') + '\n';
        }
        return ret;
    }
    function isSeparatorAtPos(value, index) {
        if (index < 0 || index >= value.length) {
            return false;
        }
        var code = value.charCodeAt(index);
        switch (code) {
            case 95 /* Underline */:
            case 45 /* Dash */:
            case 46 /* Period */:
            case 32 /* Space */:
            case 47 /* Slash */:
            case 92 /* Backslash */:
            case 39 /* SingleQuote */:
            case 34 /* DoubleQuote */:
            case 58 /* Colon */:
                return true;
            default:
                return false;
        }
    }
    function isWhitespaceAtPos(value, index) {
        if (index < 0 || index >= value.length) {
            return false;
        }
        var code = value.charCodeAt(index);
        switch (code) {
            case 32 /* Space */:
            case 9 /* Tab */:
                return true;
            default:
                return false;
        }
    }
    var Arrow;
    (function (Arrow) {
        Arrow[Arrow["Top"] = 1] = "Top";
        Arrow[Arrow["Diag"] = 2] = "Diag";
        Arrow[Arrow["Left"] = 4] = "Left";
    })(Arrow || (Arrow = {}));
    function fuzzyScore(pattern, word, patternMaxWhitespaceIgnore, firstMatchCanBeWeak) {
        var patternLen = pattern.length > 100 ? 100 : pattern.length;
        var wordLen = word.length > 100 ? 100 : word.length;
        // Check for leading whitespace in the pattern and
        // start matching just after that position. This is
        // like `pattern = pattern.rtrim()` but doesn't create
        // a new string
        var patternStartPos = 0;
        if (patternMaxWhitespaceIgnore === undefined) {
            patternMaxWhitespaceIgnore = patternLen;
        }
        while (patternStartPos < patternMaxWhitespaceIgnore) {
            if (isWhitespaceAtPos(pattern, patternStartPos)) {
                patternStartPos += 1;
            }
            else {
                break;
            }
        }
        if (patternStartPos === patternLen) {
            return [-100, []];
        }
        if (patternLen > wordLen) {
            return undefined;
        }
        var lowPattern = pattern.toLowerCase();
        var lowWord = word.toLowerCase();
        var patternPos = patternStartPos;
        var wordPos = 0;
        // Run a simple check if the characters of pattern occur
        // (in order) at all in word. If that isn't the case we
        // stop because no match will be possible
        while (patternPos < patternLen && wordPos < wordLen) {
            if (lowPattern[patternPos] === lowWord[wordPos]) {
                patternPos += 1;
            }
            wordPos += 1;
        }
        if (patternPos !== patternLen) {
            return undefined;
        }
        // There will be a mach, fill in tables
        for (patternPos = patternStartPos + 1; patternPos <= patternLen; patternPos++) {
            for (wordPos = 1; wordPos <= wordLen; wordPos++) {
                var score = -1;
                var lowWordChar = lowWord[wordPos - 1];
                if (lowPattern[patternPos - 1] === lowWordChar) {
                    if (wordPos === (patternPos - patternStartPos)) {
                        // common prefix: `foobar <-> foobaz`
                        if (pattern[patternPos - 1] === word[wordPos - 1]) {
                            score = 7;
                        }
                        else {
                            score = 5;
                        }
                    }
                    else if (lowWordChar !== word[wordPos - 1] && (wordPos === 1 || lowWord[wordPos - 2] === word[wordPos - 2])) {
                        // hitting upper-case: `foo <-> forOthers`
                        if (pattern[patternPos - 1] === word[wordPos - 1]) {
                            score = 7;
                        }
                        else {
                            score = 5;
                        }
                    }
                    else if (isSeparatorAtPos(lowWord, wordPos - 2) || isWhitespaceAtPos(lowWord, wordPos - 2)) {
                        // post separator: `foo <-> bar_foo`
                        score = 5;
                    }
                    else {
                        score = 1;
                    }
                }
                _scores[patternPos][wordPos] = score;
                var diag = _table[patternPos - 1][wordPos - 1] + (score > 1 ? 1 : score);
                var top_1 = _table[patternPos - 1][wordPos] + -1;
                var left = _table[patternPos][wordPos - 1] + -1;
                if (left >= top_1) {
                    // left or diag
                    if (left > diag) {
                        _table[patternPos][wordPos] = left;
                        _arrows[patternPos][wordPos] = 4 /* Left */;
                    }
                    else if (left === diag) {
                        _table[patternPos][wordPos] = left;
                        _arrows[patternPos][wordPos] = 4 /* Left */ | 2 /* Diag */;
                    }
                    else {
                        _table[patternPos][wordPos] = diag;
                        _arrows[patternPos][wordPos] = 2 /* Diag */;
                    }
                }
                else {
                    // top or diag
                    if (top_1 > diag) {
                        _table[patternPos][wordPos] = top_1;
                        _arrows[patternPos][wordPos] = 1 /* Top */;
                    }
                    else if (top_1 === diag) {
                        _table[patternPos][wordPos] = top_1;
                        _arrows[patternPos][wordPos] = 1 /* Top */ | 2 /* Diag */;
                    }
                    else {
                        _table[patternPos][wordPos] = diag;
                        _arrows[patternPos][wordPos] = 2 /* Diag */;
                    }
                }
            }
        }
        if (_debug) {
            console.log(printTable(_table, pattern, patternLen, word, wordLen));
            console.log(printTable(_arrows, pattern, patternLen, word, wordLen));
            console.log(printTable(_scores, pattern, patternLen, word, wordLen));
        }
        // _bucket is an array of [PrefixArray] we use to keep
        // track of scores and matches. After calling `_findAllMatches`
        // the best match (if available) is the first item in the array
        _matchesCount = 0;
        _topScore = -100;
        _patternStartPos = patternStartPos;
        _firstMatchCanBeWeak = firstMatchCanBeWeak;
        _findAllMatches(patternLen, wordLen, patternLen === wordLen ? 1 : 0, new LazyArray(), false);
        if (_matchesCount === 0) {
            return undefined;
        }
        return [_topScore, _topMatch.toArray()];
    }
    exports.fuzzyScore = fuzzyScore;
    var _matchesCount = 0;
    var _topMatch;
    var _topScore = 0;
    var _patternStartPos = 0;
    var _firstMatchCanBeWeak = false;
    function _findAllMatches(patternPos, wordPos, total, matches, lastMatched) {
        if (_matchesCount >= 10 || total < -25) {
            // stop when having already 10 results, or
            // when a potential alignment as already 5 gaps
            return;
        }
        var simpleMatchCount = 0;
        while (patternPos > _patternStartPos && wordPos > 0) {
            var score = _scores[patternPos][wordPos];
            var arrow = _arrows[patternPos][wordPos];
            if (arrow === 4 /* Left */) {
                // left
                wordPos -= 1;
                if (lastMatched) {
                    total -= 5; // new gap penalty
                }
                else if (!matches.isEmpty()) {
                    total -= 1; // gap penalty after first match
                }
                lastMatched = false;
                simpleMatchCount = 0;
            }
            else if (arrow & 2 /* Diag */) {
                if (arrow & 4 /* Left */) {
                    // left
                    _findAllMatches(patternPos, wordPos - 1, !matches.isEmpty() ? total - 1 : total, // gap penalty after first match
                    matches.slice(), lastMatched);
                }
                // diag
                total += score;
                patternPos -= 1;
                wordPos -= 1;
                matches.unshift(wordPos);
                lastMatched = true;
                // count simple matches and boost a row of
                // simple matches when they yield in a
                // strong match.
                if (score === 1) {
                    simpleMatchCount += 1;
                    if (patternPos === _patternStartPos && !_firstMatchCanBeWeak) {
                        // when the first match is a weak
                        // match we discard it
                        return undefined;
                    }
                }
                else {
                    // boost
                    total += 1 + (simpleMatchCount * (score - 1));
                    simpleMatchCount = 0;
                }
            }
            else {
                return undefined;
            }
        }
        total -= wordPos >= 3 ? 9 : wordPos * 3; // late start penalty
        // dynamically keep track of the current top score
        // and insert the current best score at head, the rest at tail
        _matchesCount += 1;
        if (total > _topScore) {
            _topScore = total;
            _topMatch = matches;
        }
    }
    var LazyArray = /** @class */ (function () {
        function LazyArray() {
        }
        LazyArray.prototype.isEmpty = function () {
            return !this._data && (!this._parent || this._parent.isEmpty());
        };
        LazyArray.prototype.unshift = function (n) {
            if (!this._data) {
                this._data = [n];
            }
            else {
                this._data.unshift(n);
            }
        };
        LazyArray.prototype.slice = function () {
            var ret = new LazyArray();
            ret._parent = this;
            ret._parentLen = this._data ? this._data.length : 0;
            return ret;
        };
        LazyArray.prototype.toArray = function () {
            if (!this._data) {
                return this._parent.toArray();
            }
            var bucket = [];
            var element = this;
            while (element) {
                if (element._parent && element._parent._data) {
                    bucket.push(element._parent._data.slice(element._parent._data.length - element._parentLen));
                }
                element = element._parent;
            }
            return Array.prototype.concat.apply(this._data, bucket);
        };
        return LazyArray;
    }());
    //#endregion
    //#region --- graceful ---
    function fuzzyScoreGracefulAggressive(pattern, word, patternMaxWhitespaceIgnore) {
        return fuzzyScoreWithPermutations(pattern, word, true, patternMaxWhitespaceIgnore);
    }
    exports.fuzzyScoreGracefulAggressive = fuzzyScoreGracefulAggressive;
    function fuzzyScoreGraceful(pattern, word, patternMaxWhitespaceIgnore) {
        return fuzzyScoreWithPermutations(pattern, word, false, patternMaxWhitespaceIgnore);
    }
    exports.fuzzyScoreGraceful = fuzzyScoreGraceful;
    function fuzzyScoreWithPermutations(pattern, word, aggressive, patternMaxWhitespaceIgnore) {
        var top = fuzzyScore(pattern, word, patternMaxWhitespaceIgnore);
        if (top && !aggressive) {
            // when using the original pattern yield a result we`
            // return it unless we are aggressive and try to find
            // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.
            return top;
        }
        if (pattern.length >= 3) {
            // When the pattern is long enough then try a few (max 7)
            // permutations of the pattern to find a better match. The
            // permutations only swap neighbouring characters, e.g
            // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.
            var tries = Math.min(7, pattern.length - 1);
            for (var patternPos = 1; patternPos < tries; patternPos++) {
                var newPattern = nextTypoPermutation(pattern, patternPos);
                if (newPattern) {
                    var candidate = fuzzyScore(newPattern, word, patternMaxWhitespaceIgnore);
                    if (candidate) {
                        candidate[0] -= 3; // permutation penalty
                        if (!top || candidate[0] > top[0]) {
                            top = candidate;
                        }
                    }
                }
            }
        }
        return top;
    }
    function nextTypoPermutation(pattern, patternPos) {
        if (patternPos + 1 >= pattern.length) {
            return undefined;
        }
        var swap1 = pattern[patternPos];
        var swap2 = pattern[patternPos + 1];
        if (swap1 === swap2) {
            return undefined;
        }
        return pattern.slice(0, patternPos)
            + swap2
            + swap1
            + pattern.slice(patternPos + 2);
    }
});
//#endregion

define(__m[102/*vs/base/common/marshalling*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/]), function (require, exports, uri_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function stringify(obj) {
        return JSON.stringify(obj, replacer);
    }
    exports.stringify = stringify;
    function parse(text) {
        var data = JSON.parse(text);
        data = revive(data, 0);
        return data;
    }
    exports.parse = parse;
    function replacer(key, value) {
        // URI is done via toJSON-member
        if (value instanceof RegExp) {
            return {
                $mid: 2,
                source: value.source,
                flags: (value.global ? 'g' : '') + (value.ignoreCase ? 'i' : '') + (value.multiline ? 'm' : ''),
            };
        }
        return value;
    }
    function revive(obj, depth) {
        if (!obj || depth > 200) {
            return obj;
        }
        if (typeof obj === 'object') {
            switch (obj.$mid) {
                case 1: return uri_1.default.revive(obj);
                case 2: return new RegExp(obj.source, obj.flags);
            }
            // walk object (or array)
            for (var key in obj) {
                if (Object.hasOwnProperty.call(obj, key)) {
                    obj[key] = revive(obj[key], depth + 1);
                }
            }
        }
        return obj;
    }
    exports.revive = revive;
});

define(__m[114/*vs/base/common/normalization*/], __M([0/*require*/,1/*exports*/,21/*vs/base/common/map*/]), function (require, exports, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The normalize() method returns the Unicode Normalization Form of a given string. The form will be
     * the Normalization Form Canonical Composition.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}
     */
    exports.canNormalize = typeof (''.normalize) === 'function';
    var nfcCache = new map_1.LRUCache(10000); // bounded to 10000 elements
    function normalizeNFC(str) {
        return normalize(str, 'NFC', nfcCache);
    }
    exports.normalizeNFC = normalizeNFC;
    var nfdCache = new map_1.LRUCache(10000); // bounded to 10000 elements
    function normalizeNFD(str) {
        return normalize(str, 'NFD', nfdCache);
    }
    exports.normalizeNFD = normalizeNFD;
    var nonAsciiCharactersPattern = /[^\u0000-\u0080]/;
    function normalize(str, form, normalizedCache) {
        if (!exports.canNormalize || !str) {
            return str;
        }
        var cached = normalizedCache.get(str);
        if (cached) {
            return cached;
        }
        var res;
        if (nonAsciiCharactersPattern.test(str)) {
            res = str.normalize(form);
        }
        else {
            res = str;
        }
        // Use the cache for fast lookup
        normalizedCache.set(str, res);
        return res;
    }
});











define(__m[44/*vs/base/common/uuid*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValueUUID = /** @class */ (function () {
        function ValueUUID(_value) {
            this._value = _value;
            // empty
        }
        ValueUUID.prototype.asHex = function () {
            return this._value;
        };
        return ValueUUID;
    }());
    var V4UUID = /** @class */ (function (_super) {
        __extends(V4UUID, _super);
        function V4UUID() {
            return _super.call(this, [
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                '4',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._oneOf(V4UUID._timeHighBits),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
            ].join('')) || this;
        }
        V4UUID._oneOf = function (array) {
            return array[Math.floor(array.length * Math.random())];
        };
        V4UUID._randomHex = function () {
            return V4UUID._oneOf(V4UUID._chars);
        };
        V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
        return V4UUID;
    }(ValueUUID));
    function v4() {
        return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
        return _UUIDPattern.test(value);
    }
    exports.isUUID = isUUID;
    /**
     * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
     * @param value A uuid string.
     */
    function parse(value) {
        if (!isUUID(value)) {
            throw new Error('invalid uuid');
        }
        return new ValueUUID(value);
    }
    exports.parse = parse;
    function generateUuid() {
        return v4().asHex();
    }
    exports.generateUuid = generateUuid;
});

/**
 * Extracted from https://github.com/winjs/winjs
 * Version: 4.4.0(ec3258a9f3a36805a187848984e3bb938044178d)
 * Copyright (c) Microsoft Corporation.
 * All Rights Reserved.
 * Licensed under the Source EULA.
 */
var __winjs_exports;

(function() {

var _modules = Object.create(null);//{};
_modules["WinJS/Core/_WinJS"] = {};

var _winjs = function(moduleId, deps, factory) {
    var exports = {};
    var exportsPassedIn = false;

    var depsValues = deps.map(function(dep) {
        if (dep === 'exports') {
            exportsPassedIn = true;
            return exports;
        }
        return _modules[dep];
    });

    var result = factory.apply({}, depsValues);

    _modules[moduleId] = exportsPassedIn ? exports : result;
};


_winjs("WinJS/Core/_Global", [], function () {
    "use strict";

    // Appease jshint
    /* global window, self, global */

    var globalObject =
        typeof window !== 'undefined' ? window :
        typeof self !== 'undefined' ? self :
        typeof global !== 'undefined' ? global :
        {};
    return globalObject;
});

_winjs("WinJS/Core/_BaseCoreUtils", ["WinJS/Core/_Global"], function baseCoreUtilsInit(_Global) {
    "use strict";

    var hasWinRT = !!_Global.Windows;

    function markSupportedForProcessing(func) {
        /// <signature helpKeyword="WinJS.Utilities.markSupportedForProcessing">
        /// <summary locid="WinJS.Utilities.markSupportedForProcessing">
        /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll
        /// or WinJS.Binding.processAll.
        /// </summary>
        /// <param name="func" type="Function" locid="WinJS.Utilities.markSupportedForProcessing_p:func">
        /// The function to be marked as compatible with declarative processing.
        /// </param>
        /// <returns type="Function" locid="WinJS.Utilities.markSupportedForProcessing_returnValue">
        /// The input function.
        /// </returns>
        /// </signature>
        func.supportedForProcessing = true;
        return func;
    }

    var actualSetImmediate = null;

    return {
        hasWinRT: hasWinRT,
        markSupportedForProcessing: markSupportedForProcessing,
        _setImmediate: function (callback) {
            // BEGIN monaco change
            if (actualSetImmediate === null) {
                if (_Global.setImmediate) {
                    actualSetImmediate = _Global.setImmediate.bind(_Global);
                } else if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
                    actualSetImmediate = process.nextTick.bind(process);
                } else {
                    actualSetImmediate = _Global.setTimeout.bind(_Global);
                }
            }
            actualSetImmediate(callback);
            // END monaco change
        }
    };
});
_winjs("WinJS/Core/_WriteProfilerMark", ["WinJS/Core/_Global"], function profilerInit(_Global) {
    "use strict";

    return _Global.msWriteProfilerMark || function () { };
});
_winjs("WinJS/Core/_Base", ["WinJS/Core/_WinJS","WinJS/Core/_Global","WinJS/Core/_BaseCoreUtils","WinJS/Core/_WriteProfilerMark"], function baseInit(_WinJS, _Global, _BaseCoreUtils, _WriteProfilerMark) {
    "use strict";

    function initializeProperties(target, members, prefix) {
        var keys = Object.keys(members);
        var isArray = Array.isArray(target);
        var properties;
        var i, len;
        for (i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            var enumerable = key.charCodeAt(0) !== /*_*/95;
            var member = members[key];
            if (member && typeof member === 'object') {
                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {
                    if (member.enumerable === undefined) {
                        member.enumerable = enumerable;
                    }
                    if (prefix && member.setName && typeof member.setName === 'function') {
                        member.setName(prefix + "." + key);
                    }
                    properties = properties || {};
                    properties[key] = member;
                    continue;
                }
            }
            if (!enumerable) {
                properties = properties || {};
                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true };
                continue;
            }
            if (isArray) {
                target.forEach(function (target) {
                    target[key] = member;
                });
            } else {
                target[key] = member;
            }
        }
        if (properties) {
            if (isArray) {
                target.forEach(function (target) {
                    Object.defineProperties(target, properties);
                });
            } else {
                Object.defineProperties(target, properties);
            }
        }
    }

    (function () {

        var _rootNamespace = _WinJS;
        if (!_rootNamespace.Namespace) {
            _rootNamespace.Namespace = Object.create(Object.prototype);
        }

        function createNamespace(parentNamespace, name) {
            var currentNamespace = parentNamespace || {};
            if (name) {
                var namespaceFragments = name.split(".");
                if (currentNamespace === _Global && namespaceFragments[0] === "WinJS") {
                    currentNamespace = _WinJS;
                    namespaceFragments.splice(0, 1);
                }
                for (var i = 0, len = namespaceFragments.length; i < len; i++) {
                    var namespaceName = namespaceFragments[i];
                    if (!currentNamespace[namespaceName]) {
                        Object.defineProperty(currentNamespace, namespaceName,
                            { value: {}, writable: false, enumerable: true, configurable: true }
                        );
                    }
                    currentNamespace = currentNamespace[namespaceName];
                }
            }
            return currentNamespace;
        }

        function defineWithParent(parentNamespace, name, members) {
            /// <signature helpKeyword="WinJS.Namespace.defineWithParent">
            /// <summary locid="WinJS.Namespace.defineWithParent">
            /// Defines a new namespace with the specified name under the specified parent namespace.
            /// </summary>
            /// <param name="parentNamespace" type="Object" locid="WinJS.Namespace.defineWithParent_p:parentNamespace">
            /// The parent namespace.
            /// </param>
            /// <param name="name" type="String" locid="WinJS.Namespace.defineWithParent_p:name">
            /// The name of the new namespace.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.defineWithParent_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.defineWithParent_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            var currentNamespace = createNamespace(parentNamespace, name);

            if (members) {
                initializeProperties(currentNamespace, members, name || "<ANONYMOUS>");
            }

            return currentNamespace;
        }

        function define(name, members) {
            /// <signature helpKeyword="WinJS.Namespace.define">
            /// <summary locid="WinJS.Namespace.define">
            /// Defines a new namespace with the specified name.
            /// </summary>
            /// <param name="name" type="String" locid="WinJS.Namespace.define_p:name">
            /// The name of the namespace. This could be a dot-separated name for nested namespaces.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.define_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.define_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            return defineWithParent(_Global, name, members);
        }

        var LazyStates = {
            uninitialized: 1,
            working: 2,
            initialized: 3,
        };

        function lazy(f) {
            var name;
            var state = LazyStates.uninitialized;
            var result;
            return {
                setName: function (value) {
                    name = value;
                },
                get: function () {
                    switch (state) {
                        case LazyStates.initialized:
                            return result;

                        case LazyStates.uninitialized:
                            state = LazyStates.working;
                            try {
                                _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StartTM");
                                result = f();
                            } finally {
                                _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StopTM");
                                state = LazyStates.uninitialized;
                            }
                            f = null;
                            state = LazyStates.initialized;
                            return result;

                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            throw "Illegal";
                    }
                },
                set: function (value) {
                    switch (state) {
                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            state = LazyStates.initialized;
                            result = value;
                            break;
                    }
                },
                enumerable: true,
                configurable: true,
            };
        }

        // helper for defining AMD module members
        function moduleDefine(exports, name, members) {
            var target = [exports];
            var publicNS = null;
            if (name) {
                publicNS = createNamespace(_Global, name);
                target.push(publicNS);
            }
            initializeProperties(target, members, name || "<ANONYMOUS>");
            return publicNS;
        }

        // Establish members of the "WinJS.Namespace" namespace
        Object.defineProperties(_rootNamespace.Namespace, {

            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },

            define: { value: define, writable: true, enumerable: true, configurable: true },

            _lazy: { value: lazy, writable: true, enumerable: true, configurable: true },

            _moduleDefine: { value: moduleDefine, writable: true, enumerable: true, configurable: true }

        });

    })();

    (function () {

        function define(constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.define">
            /// <summary locid="WinJS.Class.define">
            /// Defines a class using the given constructor and the specified instance members.
            /// </summary>
            /// <param name="constructor" type="Function" locid="WinJS.Class.define_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.define_p:instanceMembers">
            /// The set of instance fields, properties, and methods made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.define_p:staticMembers">
            /// The set of static fields, properties, and methods made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.define_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            _BaseCoreUtils.markSupportedForProcessing(constructor);
            if (instanceMembers) {
                initializeProperties(constructor.prototype, instanceMembers);
            }
            if (staticMembers) {
                initializeProperties(constructor, staticMembers);
            }
            return constructor;
        }

        function derive(baseClass, constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.derive">
            /// <summary locid="WinJS.Class.derive">
            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.
            /// </summary>
            /// <param name="baseClass" type="Function" locid="WinJS.Class.derive_p:baseClass">
            /// The class to inherit from.
            /// </param>
            /// <param name="constructor" type="Function" locid="WinJS.Class.derive_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.derive_p:instanceMembers">
            /// The set of instance fields, properties, and methods to be made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.derive_p:staticMembers">
            /// The set of static fields, properties, and methods to be made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.derive_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            if (baseClass) {
                constructor = constructor || function () { };
                var basePrototype = baseClass.prototype;
                constructor.prototype = Object.create(basePrototype);
                _BaseCoreUtils.markSupportedForProcessing(constructor);
                Object.defineProperty(constructor.prototype, "constructor", { value: constructor, writable: true, configurable: true, enumerable: true });
                if (instanceMembers) {
                    initializeProperties(constructor.prototype, instanceMembers);
                }
                if (staticMembers) {
                    initializeProperties(constructor, staticMembers);
                }
                return constructor;
            } else {
                return define(constructor, instanceMembers, staticMembers);
            }
        }

        function mix(constructor) {
            /// <signature helpKeyword="WinJS.Class.mix">
            /// <summary locid="WinJS.Class.mix">
            /// Defines a class using the given constructor and the union of the set of instance members
            /// specified by all the mixin objects. The mixin parameter list is of variable length.
            /// </summary>
            /// <param name="constructor" locid="WinJS.Class.mix_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.mix_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            var i, len;
            for (i = 1, len = arguments.length; i < len; i++) {
                initializeProperties(constructor.prototype, arguments[i]);
            }
            return constructor;
        }

        // Establish members of "WinJS.Class" namespace
        _WinJS.Namespace.define("WinJS.Class", {
            define: define,
            derive: derive,
            mix: mix
        });

    })();

    return {
        Namespace: _WinJS.Namespace,
        Class: _WinJS.Class
    };

});
_winjs("WinJS/Core/_ErrorFromName", ["WinJS/Core/_Base"], function errorsInit(_Base) {
    "use strict";

    var ErrorFromName = _Base.Class.derive(Error, function (name, message) {
        /// <signature helpKeyword="WinJS.ErrorFromName">
        /// <summary locid="WinJS.ErrorFromName">
        /// Creates an Error object with the specified name and message properties.
        /// </summary>
        /// <param name="name" type="String" locid="WinJS.ErrorFromName_p:name">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>
        /// <param name="message" type="String" optional="true" locid="WinJS.ErrorFromName_p:message">The message for this error. The message is meant to be consumed by humans and should be localized.</param>
        /// <returns type="Error" locid="WinJS.ErrorFromName_returnValue">Error instance with .name and .message properties populated</returns>
        /// </signature>
        this.name = name;
        this.message = message || name;
    }, {
        /* empty */
    }, {
        supportedForProcessing: false,
    });

    _Base.Namespace.define("WinJS", {
        // ErrorFromName establishes a simple pattern for returning error codes.
        //
        ErrorFromName: ErrorFromName
    });

    return ErrorFromName;

});


_winjs("WinJS/Core/_Events", ["exports","WinJS/Core/_Base"], function eventsInit(exports, _Base) {
    "use strict";


    function createEventProperty(name) {
        var eventPropStateName = "_on" + name + "state";

        return {
            get: function () {
                var state = this[eventPropStateName];
                return state && state.userHandler;
            },
            set: function (handler) {
                var state = this[eventPropStateName];
                if (handler) {
                    if (!state) {
                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };
                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });
                        this.addEventListener(name, state.wrapper, false);
                    }
                    state.userHandler = handler;
                } else if (state) {
                    this.removeEventListener(name, state.wrapper, false);
                    this[eventPropStateName] = null;
                }
            },
            enumerable: true
        };
    }

    function createEventProperties() {
        /// <signature helpKeyword="WinJS.Utilities.createEventProperties">
        /// <summary locid="WinJS.Utilities.createEventProperties">
        /// Creates an object that has one property for each name passed to the function.
        /// </summary>
        /// <param name="events" locid="WinJS.Utilities.createEventProperties_p:events">
        /// A variable list of property names.
        /// </param>
        /// <returns type="Object" locid="WinJS.Utilities.createEventProperties_returnValue">
        /// The object with the specified properties. The names of the properties are prefixed with 'on'.
        /// </returns>
        /// </signature>
        var props = {};
        for (var i = 0, len = arguments.length; i < len; i++) {
            var name = arguments[i];
            props["on" + name] = createEventProperty(name);
        }
        return props;
    }

    var EventMixinEvent = _Base.Class.define(
        function EventMixinEvent_ctor(type, detail, target) {
            this.detail = detail;
            this.target = target;
            this.timeStamp = Date.now();
            this.type = type;
        },
        {
            bubbles: { value: false, writable: false },
            cancelable: { value: false, writable: false },
            currentTarget: {
                get: function () { return this.target; }
            },
            defaultPrevented: {
                get: function () { return this._preventDefaultCalled; }
            },
            trusted: { value: false, writable: false },
            eventPhase: { value: 0, writable: false },
            target: null,
            timeStamp: null,
            type: null,

            preventDefault: function () {
                this._preventDefaultCalled = true;
            },
            stopImmediatePropagation: function () {
                this._stopImmediatePropagationCalled = true;
            },
            stopPropagation: function () {
            }
        }, {
            supportedForProcessing: false,
        }
    );

    var eventMixin = {
        _listeners: null,

        addEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.addEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.addEventListener">
            /// Adds an event listener to the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.addEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.addEventListener_p:listener">
            /// The listener to invoke when the event is raised.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.addEventListener_p:useCapture">
            /// if true initiates capture, otherwise false.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            this._listeners = this._listeners || {};
            var eventListeners = (this._listeners[type] = this._listeners[type] || []);
            for (var i = 0, len = eventListeners.length; i < len; i++) {
                var l = eventListeners[i];
                if (l.useCapture === useCapture && l.listener === listener) {
                    return;
                }
            }
            eventListeners.push({ listener: listener, useCapture: useCapture });
        },
        dispatchEvent: function (type, details) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.dispatchEvent">
            /// <summary locid="WinJS.Utilities.eventMixin.dispatchEvent">
            /// Raises an event of the specified type and with the specified additional properties.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="details" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:details">
            /// The set of additional properties to be attached to the event object when the event is raised.
            /// </param>
            /// <returns type="Boolean" locid="WinJS.Utilities.eventMixin.dispatchEvent_returnValue">
            /// true if preventDefault was called on the event.
            /// </returns>
            /// </signature>
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                var eventValue = new EventMixinEvent(type, details, this);
                // Need to copy the array to protect against people unregistering while we are dispatching
                listeners = listeners.slice(0, listeners.length);
                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {
                    listeners[i].listener(eventValue);
                }
                return eventValue.defaultPrevented || false;
            }
            return false;
        },
        removeEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.removeEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.removeEventListener">
            /// Removes an event listener from the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.removeEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.removeEventListener_p:listener">
            /// The listener to remove.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.removeEventListener_p:useCapture">
            /// Specifies whether to initiate capture.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var l = listeners[i];
                    if (l.listener === listener && l.useCapture === useCapture) {
                        listeners.splice(i, 1);
                        if (listeners.length === 0) {
                            delete this._listeners[type];
                        }
                        // Only want to remove one element for each call to removeEventListener
                        break;
                    }
                }
            }
        }
    };

    _Base.Namespace._moduleDefine(exports, "WinJS.Utilities", {
        _createEventProperty: createEventProperty,
        createEventProperties: createEventProperties,
        eventMixin: eventMixin
    });

});


_winjs("WinJS/Core/_Trace", ["WinJS/Core/_Global"], function traceInit(_Global) {
    "use strict";

    function nop(v) {
        return v;
    }

    return {
        _traceAsyncOperationStarting: (_Global.Debug && _Global.Debug.msTraceAsyncOperationStarting && _Global.Debug.msTraceAsyncOperationStarting.bind(_Global.Debug)) || nop,
        _traceAsyncOperationCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncOperationCompleted && _Global.Debug.msTraceAsyncOperationCompleted.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackStarting: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackStarting && _Global.Debug.msTraceAsyncCallbackStarting.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackCompleted && _Global.Debug.msTraceAsyncCallbackCompleted.bind(_Global.Debug)) || nop
    };
});
_winjs("WinJS/Promise/_StateMachine", ["WinJS/Core/_Global","WinJS/Core/_BaseCoreUtils","WinJS/Core/_Base","WinJS/Core/_ErrorFromName","WinJS/Core/_Events","WinJS/Core/_Trace"], function promiseStateMachineInit(_Global, _BaseCoreUtils, _Base, _ErrorFromName, _Events, _Trace) {
    "use strict";

    _Global.Debug && (_Global.Debug.setNonUserCodeExceptions = true);

    var ListenerType = _Base.Class.mix(_Base.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), _Events.eventMixin);
    var promiseEventListeners = new ListenerType();
    // make sure there is a listeners collection so that we can do a more trivial check below
    promiseEventListeners._listeners = {};
    var errorET = "error";
    var canceledName = "Canceled";
    var tagWithStack = false;
    var tag = {
        promise: 0x01,
        thenPromise: 0x02,
        errorPromise: 0x04,
        exceptionPromise: 0x08,
        completePromise: 0x10,
    };
    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;

    //
    // Global error counter, for each error which enters the system we increment this once and then
    // the error number travels with the error as it traverses the tree of potential handlers.
    //
    // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises
    // which are in error will get tagged with a ._errorId field. This tagged field is the
    // contract by which nested promises with errors will be identified as chaining for the
    // purposes of the callonerror semantics. If a nested promise in error is encountered without
    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and
    // a new error id will be minted.
    //
    var error_number = 1;

    //
    // The state machine has a interesting hiccup in it with regards to notification, in order
    // to flatten out notification and avoid recursion for synchronous completion we have an
    // explicit set of *_notify states which are responsible for notifying their entire tree
    // of children. They can do this because they know that immediate children are always
    // ThenPromise instances and we can therefore reach into their state to access the
    // _listeners collection.
    //
    // So, what happens is that a Promise will be fulfilled through the _completed or _error
    // messages at which point it will enter a *_notify state and be responsible for to move
    // its children into an (as appropriate) success or error state and also notify that child's
    // listeners of the state transition, until leaf notes are reached.
    //

    var state_created,              // -> working
        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting
        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled
        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling
        state_canceled,             // -> error | error_notify | success | success_notify | canceling
        state_canceling,            // -> error_notify
        state_success_notify,       // -> success
        state_success,              // -> .
        state_error_notify,         // -> error
        state_error;                // -> .

    // Noop function, used in the various states to indicate that they don't support a given
    // message. Named with the somewhat cute name '_' because it reads really well in the states.

    function _() { }

    // Initial state
    //
    state_created = {
        name: "created",
        enter: function (promise) {
            promise._setState(state_working);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Ready state, waiting for a message (completed/error/progress), able to be canceled
    //
    state_working = {
        name: "working",
        enter: _,
        cancel: function (promise) {
            promise._setState(state_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting state, if a promise is completed with a value which is itself a promise
    // (has a then() method) it signs up to be informed when that child promise is
    // fulfilled at which point it will be fulfilled with that value.
    //
    state_waiting = {
        name: "waiting",
        enter: function (promise) {
            var waitedUpon = promise._value;
            // We can special case our own intermediate promises which are not in a
            //  terminal state by just pushing this promise as a listener without
            //  having to create new indirection functions
            if (waitedUpon instanceof ThenPromise &&
                waitedUpon._state !== state_error &&
                waitedUpon._state !== state_success) {
                pushListener(waitedUpon, { promise: promise });
            } else {
                var error = function (value) {
                    if (waitedUpon._errorId) {
                        promise._chainedError(value, waitedUpon);
                    } else {
                        // Because this is an interop boundary we want to indicate that this
                        //  error has been handled by the promise infrastructure before we
                        //  begin a new handling chain.
                        //
                        callonerror(promise, value, detailsForHandledError, waitedUpon, error);
                        promise._error(value);
                    }
                };
                error.handlesOnError = true;
                waitedUpon.then(
                    promise._completed.bind(promise),
                    error,
                    promise._progress.bind(promise)
                );
            }
        },
        cancel: function (promise) {
            promise._setState(state_waiting_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting canceled state, when a promise has been in a waiting state and receives a
    // request to cancel its pending work it will forward that request to the child promise
    // and then waits to be informed of the result. This promise moves itself into the
    // canceling state but understands that the child promise may instead push it to a
    // different state.
    //
    state_waiting_canceled = {
        name: "waiting_canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. Triggering a cancel on the promise
            // that we are waiting upon may result in a different state transition
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            var waitedUpon = promise._value;
            if (waitedUpon.cancel) {
                waitedUpon.cancel();
            }
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceled state, moves to the canceling state and then tells the promise to do
    // whatever it might need to do on cancelation.
    //
    state_canceled = {
        name: "canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. The _cancelAction may change the state
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            promise._cancelAction();
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceling state, commits to the promise moving to an error state with an error
    // object whose 'name' and 'message' properties contain the string "Canceled"
    //
    state_canceling = {
        name: "canceling",
        enter: function (promise) {
            var error = new Error(canceledName);
            error.name = error.message;
            promise._value = error;
            promise._setState(state_error_notify);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success notify state, moves a promise to the success state and notifies all children
    //
    state_success_notify = {
        name: "complete_notify",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_success);
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success state, moves a promise to the success state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_success = {
        name: "success",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error notify state, moves a promise to the error state and notifies all children
    //
    state_error_notify = {
        name: "error_notify",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_error);
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error state, moves a promise to the error state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_error = {
        name: "error",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    //
    // The statemachine implementation follows a very particular pattern, the states are specified
    // as static stateless bags of functions which are then indirected through the state machine
    // instance (a Promise). As such all of the functions on each state have the promise instance
    // passed to them explicitly as a parameter and the Promise instance members do a little
    // dance where they indirect through the state and insert themselves in the argument list.
    //
    // We could instead call directly through the promise states however then every caller
    // would have to remember to do things like pumping the state machine to catch state transitions.
    //

    var PromiseStateMachine = _Base.Class.define(null, {
        _listeners: null,
        _nextState: null,
        _state: null,
        _value: null,

        cancel: function () {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
            /// <summary locid="WinJS.PromiseStateMachine.cancel">
            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
            /// already been fulfilled and cancellation is supported, the promise enters
            /// the error state with a value of Error("Canceled").
            /// </summary>
            /// </signature>
            this._state.cancel(this);
            this._run();
        },
        done: function Promise_done(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
            /// <summary locid="WinJS.PromiseStateMachine.done">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            ///
            /// After the handlers have finished executing, this function throws any error that would have been returned
            /// from then() as a promise in the error state.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The fulfilled value is passed as the single argument. If the value is null,
            /// the fulfilled value is returned. The value returned
            /// from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while executing the function, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function is the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
            /// the function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// </signature>
            this._state.done(this, onComplete, onError, onProgress);
        },
        then: function Promise_then(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
            /// <summary locid="WinJS.PromiseStateMachine.then">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The value is passed as the single argument. If the value is null, the value is returned.
            /// The value returned from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while this function is being executed, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function becomes the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
            /// The function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
            /// The promise whose value is the result of executing the complete or
            /// error function.
            /// </returns>
            /// </signature>
            // BEGIN monaco change
            if (this.then !== Promise_then) {
                this.then(onComplete, onError, onProgress);
                return;
            }
            // END monaco change
            return this._state.then(this, onComplete, onError, onProgress);
        },

        _chainedError: function (value, context) {
            var result = this._state._error(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _completed: function (value) {
            var result = this._state._completed(this, value);
            this._run();
            return result;
        },
        _error: function (value) {
            var result = this._state._error(this, value, detailsForError);
            this._run();
            return result;
        },
        _progress: function (value) {
            this._state._progress(this, value);
        },
        _setState: function (state) {
            this._nextState = state;
        },
        _setCompleteValue: function (value) {
            this._state._setCompleteValue(this, value);
            this._run();
        },
        _setChainedErrorValue: function (value, context) {
            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _setExceptionValue: function (value) {
            var result = this._state._setErrorValue(this, value, detailsForException);
            this._run();
            return result;
        },
        _run: function () {
            while (this._nextState) {
                this._state = this._nextState;
                this._nextState = null;
                this._state.enter(this);
            }
        }
    }, {
        supportedForProcessing: false
    });

    //
    // Implementations of shared state machine code.
    //

    function completed(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success_notify;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function createErrorDetails(exception, error, promise, id, parent, handler) {
        return {
            exception: exception,
            error: error,
            promise: promise,
            handler: handler,
            id: id,
            parent: parent
        };
    }
    function detailsForHandledError(promise, errorValue, context, handler) {
        var exception = context._isException;
        var errorId = context._errorId;
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context,
            handler
        );
    }
    function detailsForChainedError(promise, errorValue, context) {
        var exception = context._isException;
        var errorId = context._errorId;
        setErrorInfo(promise, errorId, exception);
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context
        );
    }
    function detailsForError(promise, errorValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId);
        return createErrorDetails(
            null,
            errorValue,
            promise,
            errorId
        );
    }
    function detailsForException(promise, exceptionValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId, true);
        return createErrorDetails(
            exceptionValue,
            null,
            promise,
            errorId
        );
    }
    function done(promise, onComplete, onError, onProgress) {
        var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.done");
        pushListener(promise, { c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
    }
    function error(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error_notify);
    }
    function notifySuccess(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onComplete = listener.c;
            var target = listener.promise;

            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, _Global.Debug && _Global.Debug.MS_ASYNC_OP_STATUS_SUCCESS);

            if (target) {
                _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                try {
                    target._setCompleteValue(onComplete ? onComplete(value) : value);
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    _Trace._traceAsyncCallbackCompleted();
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                CompletePromise.prototype.done.call(promise, onComplete);
            }
        }
    }
    function notifyError(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onError = listener.e;
            var target = listener.promise;

            var errorID = _Global.Debug && (value && value.name === canceledName ? _Global.Debug.MS_ASYNC_OP_STATUS_CANCELED : _Global.Debug.MS_ASYNC_OP_STATUS_ERROR);
            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, errorID);

            if (target) {
                var asyncCallbackStarted = false;
                try {
                    if (onError) {
                        _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                        asyncCallbackStarted = true;
                        if (!onError.handlesOnError) {
                            callonerror(target, value, detailsForHandledError, promise, onError);
                        }
                        target._setCompleteValue(onError(value));
                    } else {
                        target._setChainedErrorValue(value, promise);
                    }
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    if (asyncCallbackStarted) {
                        _Trace._traceAsyncCallbackCompleted();
                    }
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                ErrorPromise.prototype.done.call(promise, null, onError);
            }
        }
    }
    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
        if (promiseEventListeners._listeners[errorET]) {
            if (value instanceof Error && value.message === canceledName) {
                return;
            }
            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));
        }
    }
    function progress(promise, value) {
        var listeners = promise._listeners;
        if (listeners) {
            var i, len;
            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
                var listener = len === 1 ? listeners : listeners[i];
                var onProgress = listener.p;
                if (onProgress) {
                    try { onProgress(value); } catch (ex) { }
                }
                if (!(listener.c || listener.e) && listener.promise) {
                    listener.promise._progress(value);
                }
            }
        }
    }
    function pushListener(promise, listener) {
        var listeners = promise._listeners;
        if (listeners) {
            // We may have either a single listener (which will never be wrapped in an array)
            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener
            // we may have to wrap the single listener before adding the second.
            listeners = Array.isArray(listeners) ? listeners : [listeners];
            listeners.push(listener);
        } else {
            listeners = listener;
        }
        promise._listeners = listeners;
    }
    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
    // a promise directly to the success/error state without starting another notification pass (because one
    // is already ongoing).
    function setErrorInfo(promise, errorId, isException) {
        promise._isException = isException || false;
        promise._errorId = errorId;
    }
    function setErrorValue(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error);
    }
    function setCompleteValue(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function then(promise, onComplete, onError, onProgress) {
        var result = new ThenPromise(promise);
        var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.then");
        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
        return result;
    }

    //
    // Internal implementation detail promise, ThenPromise is created when a promise needs
    // to be returned from a then() method.
    //
    var ThenPromise = _Base.Class.derive(PromiseStateMachine,
        function (creator) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {
                this._stack = Promise._getStack();
            }

            this._creator = creator;
            this._setState(state_created);
            this._run();
        }, {
            _creator: null,

            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },
            _cleanupAction: function () { this._creator = null; }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Slim promise implementations for already completed promises, these are created
    // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap
    // and WinJS.Promise.wrapError.
    //

    var ErrorPromise = _Base.Class.define(
        function ErrorPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForError);
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function ErrorPromise_done(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                var value = this._value;
                if (onError) {
                    try {
                        if (!onError.handlesOnError) {
                            callonerror(null, value, detailsForHandledError, this, onError);
                        }
                        var result = onError(value);
                        if (result && typeof result === "object" && typeof result.done === "function") {
                            // If a promise is returned we need to wait on it.
                            result.done();
                        }
                        return;
                    } catch (ex) {
                        value = ex;
                    }
                }
                if (value instanceof Error && value.message === canceledName) {
                    // suppress cancel
                    return;
                }
                // force the exception to be thrown asyncronously to avoid any try/catch blocks
                //
                Promise._doneHandler(value);
            },
            then: function ErrorPromise_then(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>

                // If the promise is already in a error state and no error handler is provided
                // we optimize by simply returning the promise instead of creating a new one.
                //
                if (!onError) { return this; }
                var result;
                var value = this._value;
                try {
                    if (!onError.handlesOnError) {
                        callonerror(null, value, detailsForHandledError, this, onError);
                    }
                    result = new CompletePromise(onError(value));
                } catch (ex) {
                    // If the value throw from the error handler is the same as the value
                    // provided to the error handler then there is no need for a new promise.
                    //
                    if (ex === value) {
                        result = this;
                    } else {
                        result = new ExceptionPromise(ex);
                    }
                }
                return result;
            }
        }, {
            supportedForProcessing: false
        }
    );

    var ExceptionPromise = _Base.Class.derive(ErrorPromise,
        function ExceptionPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForException);
        }, {
            /* empty */
        }, {
            supportedForProcessing: false
        }
    );

    var CompletePromise = _Base.Class.define(
        function CompletePromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {
                this._stack = Promise._getStack();
            }

            if (value && typeof value === "object" && typeof value.then === "function") {
                var result = new ThenPromise(null);
                result._setCompleteValue(value);
                return result;
            }
            this._value = value;
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function CompletePromise_done(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                if (!onComplete) { return; }
                try {
                    var result = onComplete(this._value);
                    if (result && typeof result === "object" && typeof result.done === "function") {
                        result.done();
                    }
                } catch (ex) {
                    // force the exception to be thrown asynchronously to avoid any try/catch blocks
                    Promise._doneHandler(ex);
                }
            },
            then: function CompletePromise_then(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>
                try {
                    // If the value returned from the completion handler is the same as the value
                    // provided to the completion handler then there is no need for a new promise.
                    //
                    var newValue = onComplete ? onComplete(this._value) : this._value;
                    return newValue === this._value ? this : new CompletePromise(newValue);
                } catch (ex) {
                    return new ExceptionPromise(ex);
                }
            }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Promise is the user-creatable WinJS.Promise object.
    //

    function timeout(timeoutMS) {
        var id;
        return new Promise(
            function (c) {
                if (timeoutMS) {
                    id = _Global.setTimeout(c, timeoutMS);
                } else {
                    _BaseCoreUtils._setImmediate(c);
                }
            },
            function () {
                if (id) {
                    _Global.clearTimeout(id);
                }
            }
        );
    }

    function timeoutWithPromise(timeout, promise) {
        var cancelPromise = function () { promise.cancel(); };
        var cancelTimeout = function () { timeout.cancel(); };
        timeout.then(cancelPromise);
        promise.then(cancelTimeout, cancelTimeout);
        return promise;
    }

    var staticCanceledPromise;

    var Promise = _Base.Class.derive(PromiseStateMachine,
        function Promise_ctor(init, oncancel) {
            /// <signature helpKeyword="WinJS.Promise">
            /// <summary locid="WinJS.Promise">
            /// A promise provides a mechanism to schedule work to be done on a value that
            /// has not yet been computed. It is a convenient abstraction for managing
            /// interactions with asynchronous APIs.
            /// </summary>
            /// <param name="init" type="Function" locid="WinJS.Promise_p:init">
            /// The function that is called during construction of the  promise. The function
            /// is given three arguments (complete, error, progress). Inside this function
            /// you should add event listeners for the notifications supported by this value.
            /// </param>
            /// <param name="oncancel" optional="true" locid="WinJS.Promise_p:oncancel">
            /// The function to call if a consumer of this promise wants
            /// to cancel its undone work. Promises are not required to
            /// support cancellation.
            /// </param>
            /// </signature>

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {
                this._stack = Promise._getStack();
            }

            this._oncancel = oncancel;
            this._setState(state_created);
            this._run();

            try {
                var complete = this._completed.bind(this);
                var error = this._error.bind(this);
                var progress = this._progress.bind(this);
                init(complete, error, progress);
            } catch (ex) {
                this._setExceptionValue(ex);
            }
        }, {
            _oncancel: null,

            _cancelAction: function () {
                // BEGIN monaco change
                try {
                    if (this._oncancel) {
                        this._oncancel();
                    } else {
                        throw new Error('Promise did not implement oncancel');
                    }
                } catch (ex) {
                    // Access fields to get them created
                    var msg = ex.message;
                    var stack = ex.stack;
                    promiseEventListeners.dispatchEvent('error', ex);
                }
                // END monaco change
            },
            _cleanupAction: function () { this._oncancel = null; }
        }, {

            addEventListener: function Promise_addEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.addEventListener">
                /// <summary locid="WinJS.Promise.addEventListener">
                /// Adds an event listener to the control.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.addEventListener_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="listener" locid="WinJS.Promise.addEventListener_p:listener">
                /// The listener to invoke when the event is raised.
                /// </param>
                /// <param name="capture" locid="WinJS.Promise.addEventListener_p:capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.addEventListener(eventType, listener, capture);
            },
            any: function Promise_any(values) {
                /// <signature helpKeyword="WinJS.Promise.any">
                /// <summary locid="WinJS.Promise.any">
                /// Returns a promise that is fulfilled when one of the input promises
                /// has been fulfilled.
                /// </summary>
                /// <param name="values" type="Array" locid="WinJS.Promise.any_p:values">
                /// An array that contains promise objects or objects whose property
                /// values include promise objects.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.any_returnValue">
                /// A promise that on fulfillment yields the value of the input (complete or error).
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error) {
                        var keys = Object.keys(values);
                        if (keys.length === 0) {
                            complete();
                        }
                        var canceled = 0;
                        keys.forEach(function (key) {
                            Promise.as(values[key]).then(
                                function () { complete({ key: key, value: values[key] }); },
                                function (e) {
                                    if (e instanceof Error && e.name === canceledName) {
                                        if ((++canceled) === keys.length) {
                                            complete(Promise.cancel);
                                        }
                                        return;
                                    }
                                    error({ key: key, value: values[key] });
                                }
                            );
                        });
                    },
                    function () {
                        var keys = Object.keys(values);
                        keys.forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            as: function Promise_as(value) {
                /// <signature helpKeyword="WinJS.Promise.as">
                /// <summary locid="WinJS.Promise.as">
                /// Returns a promise. If the object is already a promise it is returned;
                /// otherwise the object is wrapped in a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.as_p:value">
                /// The value to be treated as a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.as_returnValue">
                /// A promise.
                /// </returns>
                /// </signature>
                if (value && typeof value === "object" && typeof value.then === "function") {
                    return value;
                }
                return new CompletePromise(value);
            },
            /// <field type="WinJS.Promise" helpKeyword="WinJS.Promise.cancel" locid="WinJS.Promise.cancel">
            /// Canceled promise value, can be returned from a promise completion handler
            /// to indicate cancelation of the promise chain.
            /// </field>
            cancel: {
                get: function () {
                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new _ErrorFromName(canceledName)));
                }
            },
            dispatchEvent: function Promise_dispatchEvent(eventType, details) {
                /// <signature helpKeyword="WinJS.Promise.dispatchEvent">
                /// <summary locid="WinJS.Promise.dispatchEvent">
                /// Raises an event of the specified type and properties.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.dispatchEvent_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="details" locid="WinJS.Promise.dispatchEvent_p:details">
                /// The set of additional properties to be attached to the event object.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.dispatchEvent_returnValue">
                /// Specifies whether preventDefault was called on the event.
                /// </returns>
                /// </signature>
                return promiseEventListeners.dispatchEvent(eventType, details);
            },
            is: function Promise_is(value) {
                /// <signature helpKeyword="WinJS.Promise.is">
                /// <summary locid="WinJS.Promise.is">
                /// Determines whether a value fulfills the promise contract.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.is_p:value">
                /// A value that may be a promise.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.is_returnValue">
                /// true if the specified value is a promise, otherwise false.
                /// </returns>
                /// </signature>
                return value && typeof value === "object" && typeof value.then === "function";
            },
            join: function Promise_join(values) {
                /// <signature helpKeyword="WinJS.Promise.join">
                /// <summary locid="WinJS.Promise.join">
                /// Creates a promise that is fulfilled when all the values are fulfilled.
                /// </summary>
                /// <param name="values" type="Object" locid="WinJS.Promise.join_p:values">
                /// An object whose fields contain values, some of which may be promises.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.join_returnValue">
                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where
                /// each field value is the fulfilled value of a promise.
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        var results = Array.isArray(values) ? [] : {};
                        var undefineds = 0;
                        var pending = keys.length;
                        var argDone = function (key) {
                            if ((--pending) === 0) {
                                var errorCount = Object.keys(errors).length;
                                if (errorCount === 0) {
                                    complete(results);
                                } else {
                                    var canceledCount = 0;
                                    keys.forEach(function (key) {
                                        var e = errors[key];
                                        if (e instanceof Error && e.name === canceledName) {
                                            canceledCount++;
                                        }
                                    });
                                    if (canceledCount === errorCount) {
                                        complete(Promise.cancel);
                                    } else {
                                        error(errors);
                                    }
                                }
                            } else {
                                progress({ Key: key, Done: true });
                            }
                        };
                        keys.forEach(function (key) {
                            var value = values[key];
                            if (value === undefined) {
                                undefineds++;
                            } else {
                                Promise.then(value,
                                    function (value) { results[key] = value; argDone(key); },
                                    function (value) { errors[key] = value; argDone(key); }
                                );
                            }
                        });
                        pending -= undefineds;
                        if (pending === 0) {
                            complete(results);
                            return;
                        }
                    },
                    function () {
                        Object.keys(values).forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.removeEventListener">
                /// <summary locid="WinJS.Promise.removeEventListener">
                /// Removes an event listener from the control.
                /// </summary>
                /// <param name='eventType' locid="WinJS.Promise.removeEventListener_eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name='listener' locid="WinJS.Promise.removeEventListener_listener">
                /// The listener to remove.
                /// </param>
                /// <param name='capture' locid="WinJS.Promise.removeEventListener_capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.removeEventListener(eventType, listener, capture);
            },
            supportedForProcessing: false,
            then: function Promise_then(value, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.then">
                /// <summary locid="WinJS.Promise.then">
                /// A static version of the promise instance method then().
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.then_p:value">
                /// the value to be treated as a promise.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.then_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If it is null, the promise simply
                /// returns the value. The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.then_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.then_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.then_returnValue">
                /// A promise whose value is the result of executing the provided complete function.
                /// </returns>
                /// </signature>
                return Promise.as(value).then(onComplete, onError, onProgress);
            },
            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.thenEach">
                /// <summary locid="WinJS.Promise.thenEach">
                /// Performs an operation on all the input promises and returns a promise
                /// that has the shape of the input and contains the result of the operation
                /// that has been performed on each input.
                /// </summary>
                /// <param name="values" locid="WinJS.Promise.thenEach_p:values">
                /// A set of values (which could be either an array or an object) of which some or all are promises.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.thenEach_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If the value is null, the promise returns the value.
                /// The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.thenEach_returnValue">
                /// A promise that is the result of calling Promise.join on the values parameter.
                /// </returns>
                /// </signature>
                var result = Array.isArray(values) ? [] : {};
                Object.keys(values).forEach(function (key) {
                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);
                });
                return Promise.join(result);
            },
            timeout: function Promise_timeout(time, promise) {
                /// <signature helpKeyword="WinJS.Promise.timeout">
                /// <summary locid="WinJS.Promise.timeout">
                /// Creates a promise that is fulfilled after a timeout.
                /// </summary>
                /// <param name="timeout" type="Number" optional="true" locid="WinJS.Promise.timeout_p:timeout">
                /// The timeout period in milliseconds. If this value is zero or not specified
                /// setImmediate is called, otherwise setTimeout is called.
                /// </param>
                /// <param name="promise" type="Promise" optional="true" locid="WinJS.Promise.timeout_p:promise">
                /// A promise that will be canceled if it doesn't complete before the
                /// timeout has expired.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.timeout_returnValue">
                /// A promise that is completed asynchronously after the specified timeout.
                /// </returns>
                /// </signature>
                var to = timeout(time);
                return promise ? timeoutWithPromise(to, promise) : to;
            },
            wrap: function Promise_wrap(value) {
                /// <signature helpKeyword="WinJS.Promise.wrap">
                /// <summary locid="WinJS.Promise.wrap">
                /// Wraps a non-promise value in a promise. You can use this function if you need
                /// to pass a value to a function that requires a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.wrap_p:value">
                /// Some non-promise value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrap_returnValue">
                /// A promise that is successfully fulfilled with the specified value
                /// </returns>
                /// </signature>
                return new CompletePromise(value);
            },
            wrapError: function Promise_wrapError(error) {
                /// <signature helpKeyword="WinJS.Promise.wrapError">
                /// <summary locid="WinJS.Promise.wrapError">
                /// Wraps a non-promise error value in a promise. You can use this function if you need
                /// to pass an error to a function that requires a promise.
                /// </summary>
                /// <param name="error" locid="WinJS.Promise.wrapError_p:error">
                /// A non-promise error value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrapError_returnValue">
                /// A promise that is in an error state with the specified value.
                /// </returns>
                /// </signature>
                return new ErrorPromise(error);
            },

            _veryExpensiveTagWithStack: {
                get: function () { return tagWithStack; },
                set: function (value) { tagWithStack = value; }
            },
            _veryExpensiveTagWithStack_tag: tag,
            _getStack: function () {
                if (_Global.Debug && _Global.Debug.debuggerEnabled) {
                    try { throw new Error(); } catch (e) { return e.stack; }
                }
            },

            _cancelBlocker: function Promise__cancelBlocker(input, oncancel) {
                //
                // Returns a promise which on cancelation will still result in downstream cancelation while
                //  protecting the promise 'input' from being  canceled which has the effect of allowing
                //  'input' to be shared amoung various consumers.
                //
                if (!Promise.is(input)) {
                    return Promise.wrap(input);
                }
                var complete;
                var error;
                var output = new Promise(
                    function (c, e) {
                        complete = c;
                        error = e;
                    },
                    function () {
                        complete = null;
                        error = null;
                        oncancel && oncancel();
                    }
                );
                input.then(
                    function (v) { complete && complete(v); },
                    function (e) { error && error(e); }
                );
                return output;
            },

        }
    );
    Object.defineProperties(Promise, _Events.createEventProperties(errorET));

    Promise._doneHandler = function (value) {
        _BaseCoreUtils._setImmediate(function Promise_done_rethrow() {
            throw value;
        });
    };

    return {
        PromiseStateMachine: PromiseStateMachine,
        Promise: Promise,
        state_created: state_created
    };
});

_winjs("WinJS/Promise", ["WinJS/Core/_Base","WinJS/Promise/_StateMachine"], function promiseInit( _Base, _StateMachine) {
    "use strict";

    _Base.Namespace.define("WinJS", {
        Promise: _StateMachine.Promise
    });

    return _StateMachine.Promise;
});

__winjs_exports = _modules["WinJS/Core/_WinJS"];
__winjs_exports.TPromise = __winjs_exports.Promise;
__winjs_exports.PPromise = __winjs_exports.Promise;

// ESM-comment-begin
if (typeof exports === 'undefined' && typeof define === 'function' && define.amd) {
    define("vs/base/common/winjs.base", [], __winjs_exports);
} else {
    module.exports = __winjs_exports;
}
// ESM-comment-end

})();

// ESM-uncomment-begin
// export var Promise = __winjs_exports.Promise;
// export var TPromise = __winjs_exports.TPromise;
// export var PPromise = __winjs_exports.PPromise;
// ESM-uncomment-end

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
define(__m[13/*vs/base/common/arrays*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/]), function (require, exports, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the last element of an array.
     * @param array The array.
     * @param n Which element from the end (default is zero).
     */
    function tail(array, n) {
        if (n === void 0) { n = 0; }
        return array[array.length - (1 + n)];
    }
    exports.tail = tail;
    function tail2(arr) {
        if (arr.length === 0) {
            throw new Error('Invalid tail call');
        }
        return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
    }
    exports.tail2 = tail2;
    function equals(one, other, itemEquals) {
        if (itemEquals === void 0) { itemEquals = function (a, b) { return a === b; }; }
        if (one.length !== other.length) {
            return false;
        }
        for (var i = 0, len = one.length; i < len; i++) {
            if (!itemEquals(one[i], other[i])) {
                return false;
            }
        }
        return true;
    }
    exports.equals = equals;
    function binarySearch(array, key, comparator) {
        var low = 0, high = array.length - 1;
        while (low <= high) {
            var mid = ((low + high) / 2) | 0;
            var comp = comparator(array[mid], key);
            if (comp < 0) {
                low = mid + 1;
            }
            else if (comp > 0) {
                high = mid - 1;
            }
            else {
                return mid;
            }
        }
        return -(low + 1);
    }
    exports.binarySearch = binarySearch;
    /**
     * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
     * are located before all elements where p(x) is true.
     * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
     */
    function findFirstInSorted(array, p) {
        var low = 0, high = array.length;
        if (high === 0) {
            return 0; // no children
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (p(array[mid])) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        return low;
    }
    exports.findFirstInSorted = findFirstInSorted;
    /**
     * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`
     * so only use this when actually needing stable sort.
     */
    function mergeSort(data, compare) {
        _sort(data, compare, 0, data.length - 1, []);
        return data;
    }
    exports.mergeSort = mergeSort;
    function _merge(a, compare, lo, mid, hi, aux) {
        var leftIdx = lo, rightIdx = mid + 1;
        for (var i = lo; i <= hi; i++) {
            aux[i] = a[i];
        }
        for (var i = lo; i <= hi; i++) {
            if (leftIdx > mid) {
                // left side consumed
                a[i] = aux[rightIdx++];
            }
            else if (rightIdx > hi) {
                // right side consumed
                a[i] = aux[leftIdx++];
            }
            else if (compare(aux[rightIdx], aux[leftIdx]) < 0) {
                // right element is less -> comes first
                a[i] = aux[rightIdx++];
            }
            else {
                // left element comes first (less or equal)
                a[i] = aux[leftIdx++];
            }
        }
    }
    function _sort(a, compare, lo, hi, aux) {
        if (hi <= lo) {
            return;
        }
        var mid = lo + ((hi - lo) / 2) | 0;
        _sort(a, compare, lo, mid, aux);
        _sort(a, compare, mid + 1, hi, aux);
        if (compare(a[mid], a[mid + 1]) <= 0) {
            // left and right are sorted and if the last-left element is less
            // or equals than the first-right element there is nothing else
            // to do
            return;
        }
        _merge(a, compare, lo, mid, hi, aux);
    }
    function groupBy(data, compare) {
        var result = [];
        var currentGroup;
        for (var _i = 0, _a = mergeSort(data.slice(0), compare); _i < _a.length; _i++) {
            var element = _a[_i];
            if (!currentGroup || compare(currentGroup[0], element) !== 0) {
                currentGroup = [element];
                result.push(currentGroup);
            }
            else {
                currentGroup.push(element);
            }
        }
        return result;
    }
    exports.groupBy = groupBy;
    /**
     * Diffs two *sorted* arrays and computes the splices which apply the diff.
     */
    function sortedDiff(before, after, compare) {
        var result = [];
        function pushSplice(start, deleteCount, toInsert) {
            var _a;
            if (deleteCount === 0 && toInsert.length === 0) {
                return;
            }
            var latest = result[result.length - 1];
            if (latest && latest.start + latest.deleteCount === start) {
                latest.deleteCount += deleteCount;
                (_a = latest.toInsert).push.apply(_a, toInsert);
            }
            else {
                result.push({ start: start, deleteCount: deleteCount, toInsert: toInsert });
            }
        }
        var beforeIdx = 0;
        var afterIdx = 0;
        while (true) {
            if (beforeIdx === before.length) {
                pushSplice(beforeIdx, 0, after.slice(afterIdx));
                break;
            }
            if (afterIdx === after.length) {
                pushSplice(beforeIdx, before.length - beforeIdx, []);
                break;
            }
            var beforeElement = before[beforeIdx];
            var afterElement = after[afterIdx];
            var n = compare(beforeElement, afterElement);
            if (n === 0) {
                // equal
                beforeIdx += 1;
                afterIdx += 1;
            }
            else if (n < 0) {
                // beforeElement is smaller -> before element removed
                pushSplice(beforeIdx, 1, []);
                beforeIdx += 1;
            }
            else if (n > 0) {
                // beforeElement is greater -> after element added
                pushSplice(beforeIdx, 0, [afterElement]);
                afterIdx += 1;
            }
        }
        return result;
    }
    exports.sortedDiff = sortedDiff;
    /**
     * Takes two *sorted* arrays and computes their delta (removed, added elements).
     * Finishes in `Math.min(before.length, after.length)` steps.
     * @param before
     * @param after
     * @param compare
     */
    function delta(before, after, compare) {
        var splices = sortedDiff(before, after, compare);
        var removed = [];
        var added = [];
        for (var _i = 0, splices_1 = splices; _i < splices_1.length; _i++) {
            var splice = splices_1[_i];
            removed.push.apply(removed, before.slice(splice.start, splice.start + splice.deleteCount));
            added.push.apply(added, splice.toInsert);
        }
        return { removed: removed, added: added };
    }
    exports.delta = delta;
    /**
     * Returns the top N elements from the array.
     *
     * Faster than sorting the entire array when the array is a lot larger than N.
     *
     * @param array The unsorted array.
     * @param compare A sort function for the elements.
     * @param n The number of elements to return.
     * @return The first n elemnts from array when sorted with compare.
     */
    function top(array, compare, n) {
        if (n === 0) {
            return [];
        }
        var result = array.slice(0, n).sort(compare);
        topStep(array, compare, result, n, array.length);
        return result;
    }
    exports.top = top;
    /**
     * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.
     *
     * Returns the top N elements from the array.
     *
     * Faster than sorting the entire array when the array is a lot larger than N.
     *
     * @param array The unsorted array.
     * @param compare A sort function for the elements.
     * @param n The number of elements to return.
     * @param batch The number of elements to examine before yielding to the event loop.
     * @return The first n elemnts from array when sorted with compare.
     */
    function topAsync(array, compare, n, batch) {
        var _this = this;
        if (n === 0) {
            return winjs_base_1.TPromise.as([]);
        }
        var canceled = false;
        return new winjs_base_1.TPromise(function (resolve, reject) {
            (function () { return __awaiter(_this, void 0, void 0, function () {
                var o, result, i, m;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            o = array.length;
                            result = array.slice(0, n).sort(compare);
                            i = n, m = Math.min(n + batch, o);
                            _a.label = 1;
                        case 1:
                            if (!(i < o)) return [3 /*break*/, 5];
                            if (!(i > n)) return [3 /*break*/, 3];
                            return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve); })];
                        case 2:
                            _a.sent(); // nextTick() would starve I/O.
                            _a.label = 3;
                        case 3:
                            if (canceled) {
                                throw new Error('canceled');
                            }
                            topStep(array, compare, result, i, m);
                            _a.label = 4;
                        case 4:
                            i = m, m = Math.min(m + batch, o);
                            return [3 /*break*/, 1];
                        case 5: return [2 /*return*/, result];
                    }
                });
            }); })()
                .then(resolve, reject);
        }, function () {
            canceled = true;
        });
    }
    exports.topAsync = topAsync;
    function topStep(array, compare, result, i, m) {
        var _loop_1 = function (n) {
            var element = array[i];
            if (compare(element, result[n - 1]) < 0) {
                result.pop();
                var j = findFirstInSorted(result, function (e) { return compare(element, e) < 0; });
                result.splice(j, 0, element);
            }
        };
        for (var n = result.length; i < m; i++) {
            _loop_1(n);
        }
    }
    function coalesce(array, inplace) {
        if (!array) {
            if (!inplace) {
                return array;
            }
        }
        if (!inplace) {
            return array.filter(function (e) { return !!e; });
        }
        else {
            var to = 0;
            for (var i = 0; i < array.length; i++) {
                if (!!array[i]) {
                    array[to] = array[i];
                    to += 1;
                }
            }
            array.length = to;
        }
    }
    exports.coalesce = coalesce;
    /**
     * Moves the element in the array for the provided positions.
     */
    function move(array, from, to) {
        array.splice(to, 0, array.splice(from, 1)[0]);
    }
    exports.move = move;
    /**
     * @returns {{false}} if the provided object is an array
     * 	and not empty.
     */
    function isFalsyOrEmpty(obj) {
        return !Array.isArray(obj) || obj.length === 0;
    }
    exports.isFalsyOrEmpty = isFalsyOrEmpty;
    /**
     * Removes duplicates from the given array. The optional keyFn allows to specify
     * how elements are checked for equalness by returning a unique string for each.
     */
    function distinct(array, keyFn) {
        if (!keyFn) {
            return array.filter(function (element, position) {
                return array.indexOf(element) === position;
            });
        }
        var seen = Object.create(null);
        return array.filter(function (elem) {
            var key = keyFn(elem);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        });
    }
    exports.distinct = distinct;
    function uniqueFilter(keyFn) {
        var seen = Object.create(null);
        return function (element) {
            var key = keyFn(element);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        };
    }
    exports.uniqueFilter = uniqueFilter;
    function firstIndex(array, fn) {
        for (var i = 0; i < array.length; i++) {
            var element = array[i];
            if (fn(element)) {
                return i;
            }
        }
        return -1;
    }
    exports.firstIndex = firstIndex;
    function first(array, fn, notFoundValue) {
        if (notFoundValue === void 0) { notFoundValue = null; }
        var index = firstIndex(array, fn);
        return index < 0 ? notFoundValue : array[index];
    }
    exports.first = first;
    function commonPrefixLength(one, other, equals) {
        if (equals === void 0) { equals = function (a, b) { return a === b; }; }
        var result = 0;
        for (var i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {
            result++;
        }
        return result;
    }
    exports.commonPrefixLength = commonPrefixLength;
    function flatten(arr) {
        return [].concat.apply([], arr);
    }
    exports.flatten = flatten;
    function range(arg, to) {
        var from = typeof to === 'number' ? arg : 0;
        if (typeof to === 'number') {
            from = arg;
        }
        else {
            from = 0;
            to = arg;
        }
        var result = [];
        if (from <= to) {
            for (var i = from; i < to; i++) {
                result.push(i);
            }
        }
        else {
            for (var i = from; i > to; i--) {
                result.push(i);
            }
        }
        return result;
    }
    exports.range = range;
    function fill(num, valueFn, arr) {
        if (arr === void 0) { arr = []; }
        for (var i = 0; i < num; i++) {
            arr[i] = valueFn();
        }
        return arr;
    }
    exports.fill = fill;
    function index(array, indexer, merger) {
        if (merger === void 0) { merger = function (t) { return t; }; }
        return array.reduce(function (r, t) {
            var key = indexer(t);
            r[key] = merger(t, r[key]);
            return r;
        }, Object.create(null));
    }
    exports.index = index;
    /**
     * Inserts an element into an array. Returns a function which, when
     * called, will remove that element from the array.
     */
    function insert(array, element) {
        array.push(element);
        return function () {
            var index = array.indexOf(element);
            if (index > -1) {
                array.splice(index, 1);
            }
        };
    }
    exports.insert = insert;
    /**
     * Insert `insertArr` inside `target` at `insertIndex`.
     * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array
     */
    function arrayInsert(target, insertIndex, insertArr) {
        var before = target.slice(0, insertIndex);
        var after = target.slice(insertIndex);
        return before.concat(insertArr, after);
    }
    exports.arrayInsert = arrayInsert;
    /**
     * Uses Fisher-Yates shuffle to shuffle the given array
     * @param array
     */
    function shuffle(array, seed) {
        // Seeded random number generator in JS. Modified from:
        // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
        var random = function () {
            var x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias
            return x - Math.floor(x);
        };
        var rand = typeof seed === 'number' ? random : Math.random;
        for (var i = array.length - 1; i > 0; i -= 1) {
            var j = Math.floor(rand() * (i + 1));
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }
    exports.shuffle = shuffle;
    /**
     * Pushes an element to the start of the array, if found.
     */
    function pushToStart(arr, value) {
        var index = arr.indexOf(value);
        if (index > -1) {
            arr.splice(index, 1);
            arr.unshift(value);
        }
    }
    exports.pushToStart = pushToStart;
    /**
     * Pushes an element to the end of the array, if found.
     */
    function pushToEnd(arr, value) {
        var index = arr.indexOf(value);
        if (index > -1) {
            arr.splice(index, 1);
            arr.push(value);
        }
    }
    exports.pushToEnd = pushToEnd;
});

define(__m[14/*vs/base/common/errors*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/]), function (require, exports, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // ------ BEGIN Hook up error listeners to winjs promises
    var outstandingPromiseErrors = {};
    function promiseErrorHandler(e) {
        //
        // e.detail looks like: { exception, error, promise, handler, id, parent }
        //
        var details = e.detail;
        var id = details.id;
        // If the error has a parent promise then this is not the origination of the
        //  error so we check if it has a handler, and if so we mark that the error
        //  was handled by removing it from outstandingPromiseErrors
        //
        if (details.parent) {
            if (details.handler && outstandingPromiseErrors) {
                delete outstandingPromiseErrors[id];
            }
            return;
        }
        // Indicate that this error was originated and needs to be handled
        outstandingPromiseErrors[id] = details;
        // The first time the queue fills up this iteration, schedule a timeout to
        // check if any errors are still unhandled.
        if (Object.keys(outstandingPromiseErrors).length === 1) {
            setTimeout(function () {
                var errors = outstandingPromiseErrors;
                outstandingPromiseErrors = {};
                Object.keys(errors).forEach(function (errorId) {
                    var error = errors[errorId];
                    if (error.exception) {
                        onUnexpectedError(error.exception);
                    }
                    else if (error.error) {
                        onUnexpectedError(error.error);
                    }
                    console.log('WARNING: Promise with no error callback:' + error.id);
                    console.log(error);
                    if (error.exception) {
                        console.log(error.exception.stack);
                    }
                });
            }, 0);
        }
    }
    winjs_base_1.TPromise.addEventListener('error', promiseErrorHandler);
    // Avoid circular dependency on EventEmitter by implementing a subset of the interface.
    var ErrorHandler = /** @class */ (function () {
        function ErrorHandler() {
            this.listeners = [];
            this.unexpectedErrorHandler = function (e) {
                setTimeout(function () {
                    if (e.stack) {
                        throw new Error(e.message + '\n\n' + e.stack);
                    }
                    throw e;
                }, 0);
            };
        }
        ErrorHandler.prototype.addListener = function (listener) {
            var _this = this;
            this.listeners.push(listener);
            return function () {
                _this._removeListener(listener);
            };
        };
        ErrorHandler.prototype.emit = function (e) {
            this.listeners.forEach(function (listener) {
                listener(e);
            });
        };
        ErrorHandler.prototype._removeListener = function (listener) {
            this.listeners.splice(this.listeners.indexOf(listener), 1);
        };
        ErrorHandler.prototype.setUnexpectedErrorHandler = function (newUnexpectedErrorHandler) {
            this.unexpectedErrorHandler = newUnexpectedErrorHandler;
        };
        ErrorHandler.prototype.getUnexpectedErrorHandler = function () {
            return this.unexpectedErrorHandler;
        };
        ErrorHandler.prototype.onUnexpectedError = function (e) {
            this.unexpectedErrorHandler(e);
            this.emit(e);
        };
        // For external errors, we don't want the listeners to be called
        ErrorHandler.prototype.onUnexpectedExternalError = function (e) {
            this.unexpectedErrorHandler(e);
        };
        return ErrorHandler;
    }());
    exports.ErrorHandler = ErrorHandler;
    exports.errorHandler = new ErrorHandler();
    function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
        exports.errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
    }
    exports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;
    function onUnexpectedError(e) {
        // ignore errors from cancelled promises
        if (!isPromiseCanceledError(e)) {
            exports.errorHandler.onUnexpectedError(e);
        }
        return undefined;
    }
    exports.onUnexpectedError = onUnexpectedError;
    function onUnexpectedExternalError(e) {
        // ignore errors from cancelled promises
        if (!isPromiseCanceledError(e)) {
            exports.errorHandler.onUnexpectedExternalError(e);
        }
        return undefined;
    }
    exports.onUnexpectedExternalError = onUnexpectedExternalError;
    function transformErrorForSerialization(error) {
        if (error instanceof Error) {
            var name_1 = error.name, message = error.message;
            var stack = error.stacktrace || error.stack;
            return {
                $isError: true,
                name: name_1,
                message: message,
                stack: stack
            };
        }
        // return as is
        return error;
    }
    exports.transformErrorForSerialization = transformErrorForSerialization;
    var canceledName = 'Canceled';
    /**
     * Checks if the given error is a promise in canceled state
     */
    function isPromiseCanceledError(error) {
        return error instanceof Error && error.name === canceledName && error.message === canceledName;
    }
    exports.isPromiseCanceledError = isPromiseCanceledError;
    /**
     * Returns an error that signals cancellation.
     */
    function canceled() {
        var error = new Error(canceledName);
        error.name = error.message;
        return error;
    }
    exports.canceled = canceled;
    function illegalArgument(name) {
        if (name) {
            return new Error("Illegal argument: " + name);
        }
        else {
            return new Error('Illegal argument');
        }
    }
    exports.illegalArgument = illegalArgument;
    function illegalState(name) {
        if (name) {
            return new Error("Illegal state: " + name);
        }
        else {
            return new Error('Illegal state');
        }
    }
    exports.illegalState = illegalState;
    function readonly(name) {
        return name
            ? new Error("readonly property '" + name + " cannot be changed'")
            : new Error('readonly property cannot be changed');
    }
    exports.readonly = readonly;
    function disposed(what) {
        var result = new Error(what + " has been disposed");
        result.name = 'DISPOSED';
        return result;
    }
    exports.disposed = disposed;
    function isErrorWithActions(obj) {
        return obj instanceof Error && Array.isArray(obj.actions);
    }
    exports.isErrorWithActions = isErrorWithActions;
    function create(message, options) {
        if (options === void 0) { options = Object.create(null); }
        var result = new Error(message);
        if (options.actions) {
            result.actions = options.actions;
        }
        return result;
    }
    exports.create = create;
    function getErrorMessage(err) {
        if (!err) {
            return 'Error';
        }
        if (err.message) {
            return err.message;
        }
        if (err.stack) {
            return err.stack.split('\n')[0];
        }
        return String(err);
    }
    exports.getErrorMessage = getErrorMessage;
});














































define(__m[3/*vs/base/common/event*/], __M([0/*require*/,1/*exports*/,14/*vs/base/common/errors*/,63/*vs/base/common/functional*/,9/*vs/base/common/lifecycle*/,51/*vs/base/common/linkedList*/,2/*vs/base/common/winjs.base*/]), function (require, exports, errors_1, functional_1, lifecycle_1, linkedList_1, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Event;
    (function (Event) {
        var _disposable = { dispose: function () { } };
        Event.None = function () { return _disposable; };
    })(Event = exports.Event || (exports.Event = {}));
    /**
     * The Emitter can be used to expose an Event to the public
     * to fire it from the insides.
     * Sample:
        class Document {
    
            private _onDidChange = new Emitter<(value:string)=>any>();
    
            public onDidChange = this._onDidChange.event;
    
            // getter-style
            // get onDidChange(): Event<(value:string)=>any> {
            // 	return this._onDidChange.event;
            // }
    
            private _doIt() {
                //...
                this._onDidChange.fire(value);
            }
        }
     */
    var Emitter = /** @class */ (function () {
        function Emitter(_options) {
            this._options = _options;
        }
        Object.defineProperty(Emitter.prototype, "event", {
            /**
             * For the public to allow to subscribe
             * to events from this Emitter
             */
            get: function () {
                var _this = this;
                if (!this._event) {
                    this._event = function (listener, thisArgs, disposables) {
                        if (!_this._listeners) {
                            _this._listeners = new linkedList_1.LinkedList();
                        }
                        var firstListener = _this._listeners.isEmpty();
                        if (firstListener && _this._options && _this._options.onFirstListenerAdd) {
                            _this._options.onFirstListenerAdd(_this);
                        }
                        var remove = _this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);
                        if (firstListener && _this._options && _this._options.onFirstListenerDidAdd) {
                            _this._options.onFirstListenerDidAdd(_this);
                        }
                        if (_this._options && _this._options.onListenerDidAdd) {
                            _this._options.onListenerDidAdd(_this, listener, thisArgs);
                        }
                        var result;
                        result = {
                            dispose: function () {
                                result.dispose = Emitter._noop;
                                if (!_this._disposed) {
                                    remove();
                                    if (_this._options && _this._options.onLastListenerRemove && _this._listeners.isEmpty()) {
                                        _this._options.onLastListenerRemove(_this);
                                    }
                                }
                            }
                        };
                        if (Array.isArray(disposables)) {
                            disposables.push(result);
                        }
                        return result;
                    };
                }
                return this._event;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        Emitter.prototype.fire = function (event) {
            if (this._listeners) {
                // put all [listener,event]-pairs into delivery queue
                // then emit all event. an inner/nested event might be
                // the driver of this
                if (!this._deliveryQueue) {
                    this._deliveryQueue = [];
                }
                for (var iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {
                    this._deliveryQueue.push([e.value, event]);
                }
                while (this._deliveryQueue.length > 0) {
                    var _a = this._deliveryQueue.shift(), listener = _a[0], event_1 = _a[1];
                    try {
                        if (typeof listener === 'function') {
                            listener.call(undefined, event_1);
                        }
                        else {
                            listener[0].call(listener[1], event_1);
                        }
                    }
                    catch (e) {
                        errors_1.onUnexpectedError(e);
                    }
                }
            }
        };
        Emitter.prototype.dispose = function () {
            if (this._listeners) {
                this._listeners = undefined;
            }
            if (this._deliveryQueue) {
                this._deliveryQueue.length = 0;
            }
            this._disposed = true;
        };
        Emitter._noop = function () { };
        return Emitter;
    }());
    exports.Emitter = Emitter;
    var AsyncEmitter = /** @class */ (function (_super) {
        __extends(AsyncEmitter, _super);
        function AsyncEmitter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AsyncEmitter.prototype.fireAsync = function (eventFn) {
            return __awaiter(this, void 0, void 0, function () {
                var iter, e, thenables, _a, listener, event_2, thenables;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this._listeners) {
                                return [2 /*return*/];
                            }
                            // put all [listener,event]-pairs into delivery queue
                            // then emit all event. an inner/nested event might be
                            // the driver of this
                            if (!this._asyncDeliveryQueue) {
                                this._asyncDeliveryQueue = [];
                            }
                            for (iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {
                                thenables = [];
                                this._asyncDeliveryQueue.push([e.value, eventFn(thenables, typeof e.value === 'function' ? e.value : e.value[0]), thenables]);
                            }
                            _b.label = 1;
                        case 1:
                            if (!(this._asyncDeliveryQueue.length > 0)) return [3 /*break*/, 3];
                            _a = this._asyncDeliveryQueue.shift(), listener = _a[0], event_2 = _a[1], thenables = _a[2];
                            try {
                                if (typeof listener === 'function') {
                                    listener.call(undefined, event_2);
                                }
                                else {
                                    listener[0].call(listener[1], event_2);
                                }
                            }
                            catch (e) {
                                errors_1.onUnexpectedError(e);
                                return [3 /*break*/, 1];
                            }
                            // freeze thenables-collection to enforce sync-calls to
                            // wait until and then wait for all thenables to resolve
                            Object.freeze(thenables);
                            return [4 /*yield*/, Promise.all(thenables)];
                        case 2:
                            _b.sent();
                            return [3 /*break*/, 1];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        return AsyncEmitter;
    }(Emitter));
    exports.AsyncEmitter = AsyncEmitter;
    var EventMultiplexer = /** @class */ (function () {
        function EventMultiplexer() {
            var _this = this;
            this.hasListeners = false;
            this.events = [];
            this.emitter = new Emitter({
                onFirstListenerAdd: function () { return _this.onFirstListenerAdd(); },
                onLastListenerRemove: function () { return _this.onLastListenerRemove(); }
            });
        }
        Object.defineProperty(EventMultiplexer.prototype, "event", {
            get: function () {
                return this.emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        EventMultiplexer.prototype.add = function (event) {
            var _this = this;
            var e = { event: event, listener: null };
            this.events.push(e);
            if (this.hasListeners) {
                this.hook(e);
            }
            var dispose = function () {
                if (_this.hasListeners) {
                    _this.unhook(e);
                }
                var idx = _this.events.indexOf(e);
                _this.events.splice(idx, 1);
            };
            return lifecycle_1.toDisposable(functional_1.once(dispose));
        };
        EventMultiplexer.prototype.onFirstListenerAdd = function () {
            var _this = this;
            this.hasListeners = true;
            this.events.forEach(function (e) { return _this.hook(e); });
        };
        EventMultiplexer.prototype.onLastListenerRemove = function () {
            var _this = this;
            this.hasListeners = false;
            this.events.forEach(function (e) { return _this.unhook(e); });
        };
        EventMultiplexer.prototype.hook = function (e) {
            var _this = this;
            e.listener = e.event(function (r) { return _this.emitter.fire(r); });
        };
        EventMultiplexer.prototype.unhook = function (e) {
            e.listener.dispose();
            e.listener = null;
        };
        EventMultiplexer.prototype.dispose = function () {
            this.emitter.dispose();
        };
        return EventMultiplexer;
    }());
    exports.EventMultiplexer = EventMultiplexer;
    function fromCallback(fn) {
        var listener;
        var emitter = new Emitter({
            onFirstListenerAdd: function () { return listener = fn(function (e) { return emitter.fire(e); }); },
            onLastListenerRemove: function () { return listener.dispose(); }
        });
        return emitter.event;
    }
    exports.fromCallback = fromCallback;
    function fromPromise(promise) {
        var emitter = new Emitter();
        var shouldEmit = false;
        promise
            .then(null, function () { return null; })
            .then(function () {
            if (!shouldEmit) {
                setTimeout(function () { return emitter.fire(); }, 0);
            }
            else {
                emitter.fire();
            }
        });
        shouldEmit = true;
        return emitter.event;
    }
    exports.fromPromise = fromPromise;
    function toPromise(event) {
        return new winjs_base_1.TPromise(function (complete) {
            var sub = event(function (e) {
                sub.dispose();
                complete(e);
            });
        });
    }
    exports.toPromise = toPromise;
    function once(event) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            var result = event(function (e) {
                result.dispose();
                return listener.call(thisArgs, e);
            }, null, disposables);
            return result;
        };
    }
    exports.once = once;
    function anyEvent() {
        var events = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            events[_i] = arguments[_i];
        }
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return lifecycle_1.combinedDisposable(events.map(function (event) { return event(function (e) { return listener.call(thisArgs, e); }, null, disposables); }));
        };
    }
    exports.anyEvent = anyEvent;
    function debounceEvent(event, merger, delay, leading) {
        if (delay === void 0) { delay = 100; }
        if (leading === void 0) { leading = false; }
        var subscription;
        var output = undefined;
        var handle = undefined;
        var numDebouncedCalls = 0;
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                subscription = event(function (cur) {
                    numDebouncedCalls++;
                    output = merger(output, cur);
                    if (leading && !handle) {
                        emitter.fire(output);
                    }
                    clearTimeout(handle);
                    handle = setTimeout(function () {
                        var _output = output;
                        output = undefined;
                        handle = undefined;
                        if (!leading || numDebouncedCalls > 1) {
                            emitter.fire(_output);
                        }
                        numDebouncedCalls = 0;
                    }, delay);
                });
            },
            onLastListenerRemove: function () {
                subscription.dispose();
            }
        });
        return emitter.event;
    }
    exports.debounceEvent = debounceEvent;
    /**
     * The EventDelayer is useful in situations in which you want
     * to delay firing your events during some code.
     * You can wrap that code and be sure that the event will not
     * be fired during that wrap.
     *
     * ```
     * const emitter: Emitter;
     * const delayer = new EventDelayer();
     * const delayedEvent = delayer.wrapEvent(emitter.event);
     *
     * delayedEvent(console.log);
     *
     * delayer.bufferEvents(() => {
     *   emitter.fire(); // event will not be fired yet
     * });
     *
     * // event will only be fired at this point
     * ```
     */
    var EventBufferer = /** @class */ (function () {
        function EventBufferer() {
            this.buffers = [];
        }
        EventBufferer.prototype.wrapEvent = function (event) {
            var _this = this;
            return function (listener, thisArgs, disposables) {
                return event(function (i) {
                    var buffer = _this.buffers[_this.buffers.length - 1];
                    if (buffer) {
                        buffer.push(function () { return listener.call(thisArgs, i); });
                    }
                    else {
                        listener.call(thisArgs, i);
                    }
                }, void 0, disposables);
            };
        };
        EventBufferer.prototype.bufferEvents = function (fn) {
            var buffer = [];
            this.buffers.push(buffer);
            fn();
            this.buffers.pop();
            buffer.forEach(function (flush) { return flush(); });
        };
        return EventBufferer;
    }());
    exports.EventBufferer = EventBufferer;
    function mapEvent(event, map) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (i) { return listener.call(thisArgs, map(i)); }, null, disposables);
        };
    }
    exports.mapEvent = mapEvent;
    function forEach(event, each) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (i) { each(i); listener.call(thisArgs, i); }, null, disposables);
        };
    }
    exports.forEach = forEach;
    function filterEvent(event, filter) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (e) { return filter(e) && listener.call(thisArgs, e); }, null, disposables);
        };
    }
    exports.filterEvent = filterEvent;
    var ChainableEvent = /** @class */ (function () {
        function ChainableEvent(_event) {
            this._event = _event;
        }
        Object.defineProperty(ChainableEvent.prototype, "event", {
            get: function () { return this._event; },
            enumerable: true,
            configurable: true
        });
        ChainableEvent.prototype.map = function (fn) {
            return new ChainableEvent(mapEvent(this._event, fn));
        };
        ChainableEvent.prototype.forEach = function (fn) {
            return new ChainableEvent(forEach(this._event, fn));
        };
        ChainableEvent.prototype.filter = function (fn) {
            return new ChainableEvent(filterEvent(this._event, fn));
        };
        ChainableEvent.prototype.latch = function () {
            return new ChainableEvent(latch(this._event));
        };
        ChainableEvent.prototype.on = function (listener, thisArgs, disposables) {
            return this._event(listener, thisArgs, disposables);
        };
        ChainableEvent.prototype.once = function (listener, thisArgs, disposables) {
            return once(this._event)(listener, thisArgs, disposables);
        };
        return ChainableEvent;
    }());
    function chain(event) {
        return new ChainableEvent(event);
    }
    exports.chain = chain;
    function stopwatch(event) {
        var start = new Date().getTime();
        return mapEvent(once(event), function (_) { return new Date().getTime() - start; });
    }
    exports.stopwatch = stopwatch;
    /**
     * Buffers the provided event until a first listener comes
     * along, at which point fire all the events at once and
     * pipe the event from then on.
     *
     * ```typescript
     * const emitter = new Emitter<number>();
     * const event = emitter.event;
     * const bufferedEvent = buffer(event);
     *
     * emitter.fire(1);
     * emitter.fire(2);
     * emitter.fire(3);
     * // nothing...
     *
     * const listener = bufferedEvent(num => console.log(num));
     * // 1, 2, 3
     *
     * emitter.fire(4);
     * // 4
     * ```
     */
    function buffer(event, nextTick, buffer) {
        if (nextTick === void 0) { nextTick = false; }
        if (buffer === void 0) { buffer = []; }
        buffer = buffer.slice();
        var listener = event(function (e) {
            if (buffer) {
                buffer.push(e);
            }
            else {
                emitter.fire(e);
            }
        });
        var flush = function () {
            buffer.forEach(function (e) { return emitter.fire(e); });
            buffer = null;
        };
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                if (!listener) {
                    listener = event(function (e) { return emitter.fire(e); });
                }
            },
            onFirstListenerDidAdd: function () {
                if (buffer) {
                    if (nextTick) {
                        setTimeout(flush);
                    }
                    else {
                        flush();
                    }
                }
            },
            onLastListenerRemove: function () {
                listener.dispose();
                listener = null;
            }
        });
        return emitter.event;
    }
    exports.buffer = buffer;
    /**
     * Similar to `buffer` but it buffers indefinitely and repeats
     * the buffered events to every new listener.
     */
    function echo(event, nextTick, buffer) {
        if (nextTick === void 0) { nextTick = false; }
        if (buffer === void 0) { buffer = []; }
        buffer = buffer.slice();
        event(function (e) {
            buffer.push(e);
            emitter.fire(e);
        });
        var flush = function (listener, thisArgs) { return buffer.forEach(function (e) { return listener.call(thisArgs, e); }); };
        var emitter = new Emitter({
            onListenerDidAdd: function (emitter, listener, thisArgs) {
                if (nextTick) {
                    setTimeout(function () { return flush(listener, thisArgs); });
                }
                else {
                    flush(listener, thisArgs);
                }
            }
        });
        return emitter.event;
    }
    exports.echo = echo;
    var Relay = /** @class */ (function () {
        function Relay() {
            this.emitter = new Emitter();
            this.event = this.emitter.event;
            this.disposable = lifecycle_1.Disposable.None;
        }
        Object.defineProperty(Relay.prototype, "input", {
            set: function (event) {
                this.disposable.dispose();
                this.disposable = event(this.emitter.fire, this.emitter);
            },
            enumerable: true,
            configurable: true
        });
        Relay.prototype.dispose = function () {
            this.disposable.dispose();
            this.emitter.dispose();
        };
        return Relay;
    }());
    exports.Relay = Relay;
    function fromNodeEventEmitter(emitter, eventName, map) {
        if (map === void 0) { map = function (id) { return id; }; }
        var fn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return result.fire(map.apply(void 0, args));
        };
        var onFirstListenerAdd = function () { return emitter.on(eventName, fn); };
        var onLastListenerRemove = function () { return emitter.removeListener(eventName, fn); };
        var result = new Emitter({ onFirstListenerAdd: onFirstListenerAdd, onLastListenerRemove: onLastListenerRemove });
        return result.event;
    }
    exports.fromNodeEventEmitter = fromNodeEventEmitter;
    function latch(event) {
        var firstCall = true;
        var cache;
        return filterEvent(event, function (value) {
            var shouldEmit = firstCall || value !== cache;
            firstCall = false;
            cache = value;
            return shouldEmit;
        });
    }
    exports.latch = latch;
});

define(__m[218/*vs/base/common/actions*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,9/*vs/base/common/lifecycle*/,3/*vs/base/common/event*/]), function (require, exports, winjs_base_1, lifecycle_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Action = /** @class */ (function () {
        function Action(id, label, cssClass, enabled, actionCallback) {
            if (label === void 0) { label = ''; }
            if (cssClass === void 0) { cssClass = ''; }
            if (enabled === void 0) { enabled = true; }
            this._onDidChange = new event_1.Emitter();
            this._id = id;
            this._label = label;
            this._cssClass = cssClass;
            this._enabled = enabled;
            this._actionCallback = actionCallback;
        }
        Action.prototype.dispose = function () {
            this._onDidChange.dispose();
        };
        Object.defineProperty(Action.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "label", {
            get: function () {
                return this._label;
            },
            set: function (value) {
                this._setLabel(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setLabel = function (value) {
            if (this._label !== value) {
                this._label = value;
                this._onDidChange.fire({ label: value });
            }
        };
        Object.defineProperty(Action.prototype, "tooltip", {
            get: function () {
                return this._tooltip;
            },
            set: function (value) {
                this._setTooltip(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setTooltip = function (value) {
            if (this._tooltip !== value) {
                this._tooltip = value;
                this._onDidChange.fire({ tooltip: value });
            }
        };
        Object.defineProperty(Action.prototype, "class", {
            get: function () {
                return this._cssClass;
            },
            set: function (value) {
                this._setClass(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setClass = function (value) {
            if (this._cssClass !== value) {
                this._cssClass = value;
                this._onDidChange.fire({ class: value });
            }
        };
        Object.defineProperty(Action.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                this._setEnabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setEnabled = function (value) {
            if (this._enabled !== value) {
                this._enabled = value;
                this._onDidChange.fire({ enabled: value });
            }
        };
        Object.defineProperty(Action.prototype, "checked", {
            get: function () {
                return this._checked;
            },
            set: function (value) {
                this._setChecked(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "radio", {
            get: function () {
                return this._radio;
            },
            set: function (value) {
                this._setRadio(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setChecked = function (value) {
            if (this._checked !== value) {
                this._checked = value;
                this._onDidChange.fire({ checked: value });
            }
        };
        Action.prototype._setRadio = function (value) {
            if (this._radio !== value) {
                this._radio = value;
                this._onDidChange.fire({ radio: value });
            }
        };
        Object.defineProperty(Action.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (value) {
                this._order = value;
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype.run = function (event, data) {
            if (this._actionCallback !== void 0) {
                return this._actionCallback(event);
            }
            return winjs_base_1.TPromise.as(true);
        };
        return Action;
    }());
    exports.Action = Action;
    var ActionRunner = /** @class */ (function () {
        function ActionRunner() {
            this._onDidBeforeRun = new event_1.Emitter();
            this._onDidRun = new event_1.Emitter();
        }
        Object.defineProperty(ActionRunner.prototype, "onDidRun", {
            get: function () {
                return this._onDidRun.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActionRunner.prototype, "onDidBeforeRun", {
            get: function () {
                return this._onDidBeforeRun.event;
            },
            enumerable: true,
            configurable: true
        });
        ActionRunner.prototype.run = function (action, context) {
            var _this = this;
            if (!action.enabled) {
                return winjs_base_1.TPromise.as(null);
            }
            this._onDidBeforeRun.fire({ action: action });
            return this.runAction(action, context).then(function (result) {
                _this._onDidRun.fire({ action: action, result: result });
            }, function (error) {
                _this._onDidRun.fire({ action: action, error: error });
            });
        };
        ActionRunner.prototype.runAction = function (action, context) {
            var res = context ? action.run(context) : action.run();
            if (winjs_base_1.TPromise.is(res)) {
                return res;
            }
            return winjs_base_1.TPromise.wrap(res);
        };
        ActionRunner.prototype.dispose = function () {
            this._onDidBeforeRun.dispose();
            this._onDidRun.dispose();
        };
        return ActionRunner;
    }());
    exports.ActionRunner = ActionRunner;
    var RadioGroup = /** @class */ (function () {
        function RadioGroup(actions) {
            this.actions = actions;
            this._disposable = lifecycle_1.combinedDisposable(actions.map(function (action) {
                return action.onDidChange(function (e) {
                    if (e.checked && action.checked) {
                        for (var _i = 0, actions_1 = actions; _i < actions_1.length; _i++) {
                            var candidate = actions_1[_i];
                            if (candidate !== action) {
                                candidate.checked = false;
                            }
                        }
                    }
                });
            }));
        }
        RadioGroup.prototype.dispose = function () {
            this._disposable.dispose();
        };
        return RadioGroup;
    }());
    exports.RadioGroup = RadioGroup;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[29/*vs/base/common/cancellation*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/]), function (require, exports, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var shortcutEvent = Object.freeze(function (callback, context) {
        var handle = setTimeout(callback.bind(context), 0);
        return { dispose: function () { clearTimeout(handle); } };
    });
    var CancellationToken;
    (function (CancellationToken) {
        CancellationToken.None = Object.freeze({
            isCancellationRequested: false,
            onCancellationRequested: event_1.Event.None
        });
        CancellationToken.Cancelled = Object.freeze({
            isCancellationRequested: true,
            onCancellationRequested: shortcutEvent
        });
    })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
    var MutableToken = /** @class */ (function () {
        function MutableToken() {
            this._isCancelled = false;
        }
        MutableToken.prototype.cancel = function () {
            if (!this._isCancelled) {
                this._isCancelled = true;
                if (this._emitter) {
                    this._emitter.fire(undefined);
                    this.dispose();
                }
            }
        };
        Object.defineProperty(MutableToken.prototype, "isCancellationRequested", {
            get: function () {
                return this._isCancelled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableToken.prototype, "onCancellationRequested", {
            get: function () {
                if (this._isCancelled) {
                    return shortcutEvent;
                }
                if (!this._emitter) {
                    this._emitter = new event_1.Emitter();
                }
                return this._emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        MutableToken.prototype.dispose = function () {
            if (this._emitter) {
                this._emitter.dispose();
                this._emitter = undefined;
            }
        };
        return MutableToken;
    }());
    var CancellationTokenSource = /** @class */ (function () {
        function CancellationTokenSource() {
        }
        Object.defineProperty(CancellationTokenSource.prototype, "token", {
            get: function () {
                if (!this._token) {
                    // be lazy and create the token only when
                    // actually needed
                    this._token = new MutableToken();
                }
                return this._token;
            },
            enumerable: true,
            configurable: true
        });
        CancellationTokenSource.prototype.cancel = function () {
            if (!this._token) {
                // save an object by returning the default
                // cancelled token when cancellation happens
                // before someone asks for the token
                this._token = CancellationToken.Cancelled;
            }
            else if (this._token instanceof MutableToken) {
                // actually cancel
                this._token.cancel();
            }
        };
        CancellationTokenSource.prototype.dispose = function () {
            if (!this._token) {
                // ensure to initialize with an empty token if we had none
                this._token = CancellationToken.None;
            }
            else if (this._token instanceof MutableToken) {
                // actually dispose
                this._token.dispose();
            }
        };
        return CancellationTokenSource;
    }());
    exports.CancellationTokenSource = CancellationTokenSource;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[12/*vs/base/common/async*/], __M([0/*require*/,1/*exports*/,14/*vs/base/common/errors*/,2/*vs/base/common/winjs.base*/,29/*vs/base/common/cancellation*/,9/*vs/base/common/lifecycle*/,3/*vs/base/common/event*/]), function (require, exports, errors, winjs_base_1, cancellation_1, lifecycle_1, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function isThenable(obj) {
        return obj && typeof obj.then === 'function';
    }
    exports.isThenable = isThenable;
    function toThenable(arg) {
        if (isThenable(arg)) {
            return arg;
        }
        else {
            return winjs_base_1.TPromise.as(arg);
        }
    }
    exports.toThenable = toThenable;
    function toWinJsPromise(arg) {
        if (arg instanceof winjs_base_1.TPromise) {
            return arg;
        }
        return new winjs_base_1.TPromise(function (resolve, reject) { return arg.then(resolve, reject); });
    }
    exports.toWinJsPromise = toWinJsPromise;
    function createCancelablePromise(callback) {
        var source = new cancellation_1.CancellationTokenSource();
        var thenable = callback(source.token);
        var promise = new Promise(function (resolve, reject) {
            source.token.onCancellationRequested(function () {
                reject(errors.canceled());
            });
            Promise.resolve(thenable).then(function (value) {
                source.dispose();
                resolve(value);
            }, function (err) {
                source.dispose();
                reject(err);
            });
        });
        return new /** @class */ (function () {
            function class_1() {
            }
            class_1.prototype.cancel = function () {
                source.cancel();
            };
            class_1.prototype.then = function (resolve, reject) {
                return promise.then(resolve, reject);
            };
            class_1.prototype.catch = function (reject) {
                return this.then(undefined, reject);
            };
            return class_1;
        }());
    }
    exports.createCancelablePromise = createCancelablePromise;
    function asWinJsPromise(callback) {
        var source = new cancellation_1.CancellationTokenSource();
        return new winjs_base_1.TPromise(function (resolve, reject, progress) {
            var item = callback(source.token);
            if (item instanceof winjs_base_1.TPromise) {
                item.then(function (result) {
                    source.dispose();
                    resolve(result);
                }, function (err) {
                    source.dispose();
                    reject(err);
                }, progress);
            }
            else if (isThenable(item)) {
                item.then(function (result) {
                    source.dispose();
                    resolve(result);
                }, function (err) {
                    source.dispose();
                    reject(err);
                });
            }
            else {
                source.dispose();
                resolve(item);
            }
        }, function () {
            source.cancel();
        });
    }
    exports.asWinJsPromise = asWinJsPromise;
    /**
     * Hook a cancellation token to a WinJS Promise
     */
    function wireCancellationToken(token, promise, resolveAsUndefinedWhenCancelled) {
        var subscription = token.onCancellationRequested(function () { return promise.cancel(); });
        if (resolveAsUndefinedWhenCancelled) {
            promise = promise.then(undefined, function (err) {
                if (!errors.isPromiseCanceledError(err)) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
                return undefined;
            });
        }
        return always(promise, function () { return subscription.dispose(); });
    }
    exports.wireCancellationToken = wireCancellationToken;
    function asDisposablePromise(input, cancelValue, bucket) {
        var dispose;
        var promise = new winjs_base_1.TPromise(function (resolve, reject) {
            dispose = function () {
                resolve(cancelValue);
                if (isWinJSPromise(input)) {
                    input.cancel();
                }
            };
            input.then(resolve, function (err) {
                if (errors.isPromiseCanceledError(err)) {
                    resolve(cancelValue);
                }
                else {
                    reject(err);
                }
            });
        });
        var res = {
            promise: promise,
            dispose: dispose
        };
        if (Array.isArray(bucket)) {
            bucket.push(res);
        }
        return res;
    }
    exports.asDisposablePromise = asDisposablePromise;
    /**
     * A helper to prevent accumulation of sequential async tasks.
     *
     * Imagine a mail man with the sole task of delivering letters. As soon as
     * a letter submitted for delivery, he drives to the destination, delivers it
     * and returns to his base. Imagine that during the trip, N more letters were submitted.
     * When the mail man returns, he picks those N letters and delivers them all in a
     * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.
     *
     * The throttler implements this via the queue() method, by providing it a task
     * factory. Following the example:
     *
     * 		const throttler = new Throttler();
     * 		const letters = [];
     *
     * 		function deliver() {
     * 			const lettersToDeliver = letters;
     * 			letters = [];
     * 			return makeTheTrip(lettersToDeliver);
     * 		}
     *
     * 		function onLetterReceived(l) {
     * 			letters.push(l);
     * 			throttler.queue(deliver);
     * 		}
     */
    var Throttler = /** @class */ (function () {
        function Throttler() {
            this.activePromise = null;
            this.queuedPromise = null;
            this.queuedPromiseFactory = null;
        }
        Throttler.prototype.queue = function (promiseFactory) {
            var _this = this;
            if (this.activePromise) {
                this.queuedPromiseFactory = promiseFactory;
                if (!this.queuedPromise) {
                    var onComplete_1 = function () {
                        _this.queuedPromise = null;
                        var result = _this.queue(_this.queuedPromiseFactory);
                        _this.queuedPromiseFactory = null;
                        return result;
                    };
                    this.queuedPromise = new winjs_base_1.TPromise(function (c, e, p) {
                        _this.activePromise.then(onComplete_1, onComplete_1, p).done(c);
                    }, function () {
                        _this.activePromise.cancel();
                    });
                }
                return new winjs_base_1.TPromise(function (c, e, p) {
                    _this.queuedPromise.then(c, e, p);
                }, function () {
                    // no-op
                });
            }
            this.activePromise = promiseFactory();
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this.activePromise.done(function (result) {
                    _this.activePromise = null;
                    c(result);
                }, function (err) {
                    _this.activePromise = null;
                    e(err);
                }, p);
            }, function () {
                _this.activePromise.cancel();
            });
        };
        return Throttler;
    }());
    exports.Throttler = Throttler;
    // TODO@Joao: can the previous throttler be replaced with this?
    var SimpleThrottler = /** @class */ (function () {
        function SimpleThrottler() {
            this.current = winjs_base_1.TPromise.wrap(null);
        }
        SimpleThrottler.prototype.queue = function (promiseTask) {
            return this.current = this.current.then(function () { return promiseTask(); });
        };
        return SimpleThrottler;
    }());
    exports.SimpleThrottler = SimpleThrottler;
    /**
     * A helper to delay execution of a task that is being requested often.
     *
     * Following the throttler, now imagine the mail man wants to optimize the number of
     * trips proactively. The trip itself can be long, so he decides not to make the trip
     * as soon as a letter is submitted. Instead he waits a while, in case more
     * letters are submitted. After said waiting period, if no letters were submitted, he
     * decides to make the trip. Imagine that N more letters were submitted after the first
     * one, all within a short period of time between each other. Even though N+1
     * submissions occurred, only 1 delivery was made.
     *
     * The delayer offers this behavior via the trigger() method, into which both the task
     * to be executed and the waiting period (delay) must be passed in as arguments. Following
     * the example:
     *
     * 		const delayer = new Delayer(WAITING_PERIOD);
     * 		const letters = [];
     *
     * 		function letterReceived(l) {
     * 			letters.push(l);
     * 			delayer.trigger(() => { return makeTheTrip(); });
     * 		}
     */
    var Delayer = /** @class */ (function () {
        function Delayer(defaultDelay) {
            this.defaultDelay = defaultDelay;
            this.timeout = null;
            this.completionPromise = null;
            this.onSuccess = null;
            this.task = null;
        }
        Delayer.prototype.trigger = function (task, delay) {
            var _this = this;
            if (delay === void 0) { delay = this.defaultDelay; }
            this.task = task;
            this.cancelTimeout();
            if (!this.completionPromise) {
                this.completionPromise = new winjs_base_1.TPromise(function (c) {
                    _this.onSuccess = c;
                }, function () {
                    // no-op
                }).then(function () {
                    _this.completionPromise = null;
                    _this.onSuccess = null;
                    var task = _this.task;
                    _this.task = null;
                    return task();
                });
            }
            this.timeout = setTimeout(function () {
                _this.timeout = null;
                _this.onSuccess(null);
            }, delay);
            return this.completionPromise;
        };
        Delayer.prototype.isTriggered = function () {
            return this.timeout !== null;
        };
        Delayer.prototype.cancel = function () {
            this.cancelTimeout();
            if (this.completionPromise) {
                this.completionPromise.cancel();
                this.completionPromise = null;
            }
        };
        Delayer.prototype.cancelTimeout = function () {
            if (this.timeout !== null) {
                clearTimeout(this.timeout);
                this.timeout = null;
            }
        };
        return Delayer;
    }());
    exports.Delayer = Delayer;
    /**
     * A helper to delay execution of a task that is being requested often, while
     * preventing accumulation of consecutive executions, while the task runs.
     *
     * Simply combine the two mail men's strategies from the Throttler and Delayer
     * helpers, for an analogy.
     */
    var ThrottledDelayer = /** @class */ (function (_super) {
        __extends(ThrottledDelayer, _super);
        function ThrottledDelayer(defaultDelay) {
            var _this = _super.call(this, defaultDelay) || this;
            _this.throttler = new Throttler();
            return _this;
        }
        ThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
            var _this = this;
            return _super.prototype.trigger.call(this, function () { return _this.throttler.queue(promiseFactory); }, delay);
        };
        return ThrottledDelayer;
    }(Delayer));
    exports.ThrottledDelayer = ThrottledDelayer;
    /**
     * A barrier that is initially closed and then becomes opened permanently.
     */
    var Barrier = /** @class */ (function () {
        function Barrier() {
            var _this = this;
            this._isOpen = false;
            this._promise = new winjs_base_1.TPromise(function (c, e) {
                _this._completePromise = c;
            }, function () {
                console.warn('You should really not try to cancel this ready promise!');
            });
        }
        Barrier.prototype.isOpen = function () {
            return this._isOpen;
        };
        Barrier.prototype.open = function () {
            this._isOpen = true;
            this._completePromise(true);
        };
        Barrier.prototype.wait = function () {
            return this._promise;
        };
        return Barrier;
    }());
    exports.Barrier = Barrier;
    var ShallowCancelThenPromise = /** @class */ (function (_super) {
        __extends(ShallowCancelThenPromise, _super);
        function ShallowCancelThenPromise(outer) {
            var _this = this;
            var completeCallback, errorCallback, progressCallback;
            _this = _super.call(this, function (c, e, p) {
                completeCallback = c;
                errorCallback = e;
                progressCallback = p;
            }, function () {
                // cancel this promise but not the
                // outer promise
                errorCallback(errors.canceled());
            }) || this;
            outer.then(completeCallback, errorCallback, progressCallback);
            return _this;
        }
        return ShallowCancelThenPromise;
    }(winjs_base_1.TPromise));
    exports.ShallowCancelThenPromise = ShallowCancelThenPromise;
    /**
     * Replacement for `WinJS.TPromise.timeout`.
     */
    function timeout(n) {
        return createCancelablePromise(function (token) {
            return new Promise(function (resolve, reject) {
                var handle = setTimeout(resolve, n);
                token.onCancellationRequested(function (_) {
                    clearTimeout(handle);
                    reject(errors.canceled());
                });
            });
        });
    }
    exports.timeout = timeout;
    function isWinJSPromise(candidate) {
        return winjs_base_1.TPromise.is(candidate) && typeof candidate.done === 'function';
    }
    function always(winjsPromiseOrThenable, f) {
        if (isWinJSPromise(winjsPromiseOrThenable)) {
            return new winjs_base_1.TPromise(function (c, e, p) {
                winjsPromiseOrThenable.done(function (result) {
                    try {
                        f(result);
                    }
                    catch (e1) {
                        errors.onUnexpectedError(e1);
                    }
                    c(result);
                }, function (err) {
                    try {
                        f(err);
                    }
                    catch (e1) {
                        errors.onUnexpectedError(e1);
                    }
                    e(err);
                }, function (progress) {
                    p(progress);
                });
            }, function () {
                winjsPromiseOrThenable.cancel();
            });
        }
        else {
            // simple
            winjsPromiseOrThenable.then(function (_) { return f(); }, function (_) { return f(); });
            return winjsPromiseOrThenable;
        }
    }
    exports.always = always;
    /**
     * Runs the provided list of promise factories in sequential order. The returned
     * promise will complete to an array of results from each promise.
     */
    function sequence(promiseFactories) {
        var results = [];
        var index = 0;
        var len = promiseFactories.length;
        function next() {
            return index < len ? promiseFactories[index++]() : null;
        }
        function thenHandler(result) {
            if (result !== undefined && result !== null) {
                results.push(result);
            }
            var n = next();
            if (n) {
                return n.then(thenHandler);
            }
            return winjs_base_1.TPromise.as(results);
        }
        return winjs_base_1.TPromise.as(null).then(thenHandler);
    }
    exports.sequence = sequence;
    function first2(promiseFactories, shouldStop, defaultValue) {
        if (shouldStop === void 0) { shouldStop = function (t) { return !!t; }; }
        if (defaultValue === void 0) { defaultValue = null; }
        var index = 0;
        var len = promiseFactories.length;
        var loop = function () {
            if (index >= len) {
                return Promise.resolve(defaultValue);
            }
            var factory = promiseFactories[index++];
            var promise = factory();
            return promise.then(function (result) {
                if (shouldStop(result)) {
                    return Promise.resolve(result);
                }
                return loop();
            });
        };
        return loop();
    }
    exports.first2 = first2;
    function first(promiseFactories, shouldStop, defaultValue) {
        if (shouldStop === void 0) { shouldStop = function (t) { return !!t; }; }
        if (defaultValue === void 0) { defaultValue = null; }
        var index = 0;
        var len = promiseFactories.length;
        var loop = function () {
            if (index >= len) {
                return winjs_base_1.TPromise.as(defaultValue);
            }
            var factory = promiseFactories[index++];
            var promise = factory();
            return promise.then(function (result) {
                if (shouldStop(result)) {
                    return winjs_base_1.TPromise.as(result);
                }
                return loop();
            });
        };
        return loop();
    }
    exports.first = first;
    /**
     * A helper to queue N promises and run them all with a max degree of parallelism. The helper
     * ensures that at any time no more than M promises are running at the same time.
     */
    var Limiter = /** @class */ (function () {
        function Limiter(maxDegreeOfParalellism) {
            this.maxDegreeOfParalellism = maxDegreeOfParalellism;
            this.outstandingPromises = [];
            this.runningPromises = 0;
            this._onFinished = new event_1.Emitter();
        }
        Object.defineProperty(Limiter.prototype, "onFinished", {
            get: function () {
                return this._onFinished.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Limiter.prototype, "size", {
            get: function () {
                return this.runningPromises + this.outstandingPromises.length;
            },
            enumerable: true,
            configurable: true
        });
        Limiter.prototype.queue = function (promiseFactory) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this.outstandingPromises.push({
                    factory: promiseFactory,
                    c: c,
                    e: e,
                    p: p
                });
                _this.consume();
            });
        };
        Limiter.prototype.consume = function () {
            var _this = this;
            while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
                var iLimitedTask = this.outstandingPromises.shift();
                this.runningPromises++;
                var promise = iLimitedTask.factory();
                promise.done(iLimitedTask.c, iLimitedTask.e, iLimitedTask.p);
                promise.done(function () { return _this.consumed(); }, function () { return _this.consumed(); });
            }
        };
        Limiter.prototype.consumed = function () {
            this.runningPromises--;
            if (this.outstandingPromises.length > 0) {
                this.consume();
            }
            else {
                this._onFinished.fire();
            }
        };
        Limiter.prototype.dispose = function () {
            this._onFinished.dispose();
        };
        return Limiter;
    }());
    exports.Limiter = Limiter;
    /**
     * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.
     */
    var Queue = /** @class */ (function (_super) {
        __extends(Queue, _super);
        function Queue() {
            return _super.call(this, 1) || this;
        }
        return Queue;
    }(Limiter));
    exports.Queue = Queue;
    /**
     * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource
     * by disposing them once the queue is empty.
     */
    var ResourceQueue = /** @class */ (function () {
        function ResourceQueue() {
            this.queues = Object.create(null);
        }
        ResourceQueue.prototype.queueFor = function (resource) {
            var _this = this;
            var key = resource.toString();
            if (!this.queues[key]) {
                var queue_1 = new Queue();
                queue_1.onFinished(function () {
                    queue_1.dispose();
                    delete _this.queues[key];
                });
                this.queues[key] = queue_1;
            }
            return this.queues[key];
        };
        return ResourceQueue;
    }());
    exports.ResourceQueue = ResourceQueue;
    function setDisposableTimeout(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var handle = setTimeout.apply(void 0, [handler, timeout].concat(args));
        return { dispose: function () { clearTimeout(handle); } };
    }
    exports.setDisposableTimeout = setDisposableTimeout;
    var TimeoutTimer = /** @class */ (function (_super) {
        __extends(TimeoutTimer, _super);
        function TimeoutTimer() {
            var _this = _super.call(this) || this;
            _this._token = -1;
            return _this;
        }
        TimeoutTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        TimeoutTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                clearTimeout(this._token);
                this._token = -1;
            }
        };
        TimeoutTimer.prototype.cancelAndSet = function (runner, timeout) {
            var _this = this;
            this.cancel();
            this._token = setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        TimeoutTimer.prototype.setIfNotSet = function (runner, timeout) {
            var _this = this;
            if (this._token !== -1) {
                // timer is already set
                return;
            }
            this._token = setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        return TimeoutTimer;
    }(lifecycle_1.Disposable));
    exports.TimeoutTimer = TimeoutTimer;
    var IntervalTimer = /** @class */ (function (_super) {
        __extends(IntervalTimer, _super);
        function IntervalTimer() {
            var _this = _super.call(this) || this;
            _this._token = -1;
            return _this;
        }
        IntervalTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        IntervalTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                clearInterval(this._token);
                this._token = -1;
            }
        };
        IntervalTimer.prototype.cancelAndSet = function (runner, interval) {
            this.cancel();
            this._token = setInterval(function () {
                runner();
            }, interval);
        };
        return IntervalTimer;
    }(lifecycle_1.Disposable));
    exports.IntervalTimer = IntervalTimer;
    var RunOnceScheduler = /** @class */ (function () {
        function RunOnceScheduler(runner, timeout) {
            this.timeoutToken = -1;
            this.runner = runner;
            this.timeout = timeout;
            this.timeoutHandler = this.onTimeout.bind(this);
        }
        /**
         * Dispose RunOnceScheduler
         */
        RunOnceScheduler.prototype.dispose = function () {
            this.cancel();
            this.runner = null;
        };
        /**
         * Cancel current scheduled runner (if any).
         */
        RunOnceScheduler.prototype.cancel = function () {
            if (this.isScheduled()) {
                clearTimeout(this.timeoutToken);
                this.timeoutToken = -1;
            }
        };
        /**
         * Cancel previous runner (if any) & schedule a new runner.
         */
        RunOnceScheduler.prototype.schedule = function (delay) {
            if (delay === void 0) { delay = this.timeout; }
            this.cancel();
            this.timeoutToken = setTimeout(this.timeoutHandler, delay);
        };
        /**
         * Returns true if scheduled.
         */
        RunOnceScheduler.prototype.isScheduled = function () {
            return this.timeoutToken !== -1;
        };
        RunOnceScheduler.prototype.onTimeout = function () {
            this.timeoutToken = -1;
            if (this.runner) {
                this.doRun();
            }
        };
        RunOnceScheduler.prototype.doRun = function () {
            this.runner();
        };
        return RunOnceScheduler;
    }());
    exports.RunOnceScheduler = RunOnceScheduler;
    var RunOnceWorker = /** @class */ (function (_super) {
        __extends(RunOnceWorker, _super);
        function RunOnceWorker(runner, timeout) {
            var _this = _super.call(this, runner, timeout) || this;
            _this.units = [];
            return _this;
        }
        RunOnceWorker.prototype.work = function (unit) {
            this.units.push(unit);
            if (!this.isScheduled()) {
                this.schedule();
            }
        };
        RunOnceWorker.prototype.doRun = function () {
            var units = this.units;
            this.units = [];
            this.runner(units);
        };
        RunOnceWorker.prototype.dispose = function () {
            this.units = [];
            _super.prototype.dispose.call(this);
        };
        return RunOnceWorker;
    }(RunOnceScheduler));
    exports.RunOnceWorker = RunOnceWorker;
    function nfcall(fn) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return new winjs_base_1.TPromise(function (c, e) { return fn.apply(void 0, args.concat([function (err, result) { return err ? e(err) : c(result); }])); }, function () { return null; });
    }
    exports.nfcall = nfcall;
    function ninvoke(thisArg, fn) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return new winjs_base_1.TPromise(function (c, e) { return fn.call.apply(fn, [thisArg].concat(args, [function (err, result) { return err ? e(err) : c(result); }])); }, function () { return null; });
    }
    exports.ninvoke = ninvoke;
});

define(__m[33/*vs/base/common/glob*/], __M([0/*require*/,1/*exports*/,13/*vs/base/common/arrays*/,8/*vs/base/common/strings*/,16/*vs/base/common/paths*/,21/*vs/base/common/map*/,2/*vs/base/common/winjs.base*/]), function (require, exports, arrays, strings, paths, map_1, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getEmptyExpression() {
        return Object.create(null);
    }
    exports.getEmptyExpression = getEmptyExpression;
    var GLOBSTAR = '**';
    var GLOB_SPLIT = '/';
    var PATH_REGEX = '[/\\\\]'; // any slash or backslash
    var NO_PATH_REGEX = '[^/\\\\]'; // any non-slash and non-backslash
    var ALL_FORWARD_SLASHES = /\//g;
    function starsToRegExp(starCount) {
        switch (starCount) {
            case 0:
                return '';
            case 1:
                return NO_PATH_REGEX + "*?"; // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
            default:
                // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times
                // Group is non capturing because we don't need to capture at all (?:...)
                // Overall we use non-greedy matching because it could be that we match too much
                return "(?:" + PATH_REGEX + "|" + NO_PATH_REGEX + "+" + PATH_REGEX + "|" + PATH_REGEX + NO_PATH_REGEX + "+)*?";
        }
    }
    function splitGlobAware(pattern, splitChar) {
        if (!pattern) {
            return [];
        }
        var segments = [];
        var inBraces = false;
        var inBrackets = false;
        var char;
        var curVal = '';
        for (var i = 0; i < pattern.length; i++) {
            char = pattern[i];
            switch (char) {
                case splitChar:
                    if (!inBraces && !inBrackets) {
                        segments.push(curVal);
                        curVal = '';
                        continue;
                    }
                    break;
                case '{':
                    inBraces = true;
                    break;
                case '}':
                    inBraces = false;
                    break;
                case '[':
                    inBrackets = true;
                    break;
                case ']':
                    inBrackets = false;
                    break;
            }
            curVal += char;
        }
        // Tail
        if (curVal) {
            segments.push(curVal);
        }
        return segments;
    }
    exports.splitGlobAware = splitGlobAware;
    function parseRegExp(pattern) {
        if (!pattern) {
            return '';
        }
        var regEx = '';
        // Split up into segments for each slash found
        var segments = splitGlobAware(pattern, GLOB_SPLIT);
        // Special case where we only have globstars
        if (segments.every(function (s) { return s === GLOBSTAR; })) {
            regEx = '.*';
        }
        // Build regex over segments
        else {
            var previousSegmentWasGlobStar_1 = false;
            segments.forEach(function (segment, index) {
                // Globstar is special
                if (segment === GLOBSTAR) {
                    // if we have more than one globstar after another, just ignore it
                    if (!previousSegmentWasGlobStar_1) {
                        regEx += starsToRegExp(2);
                        previousSegmentWasGlobStar_1 = true;
                    }
                    return;
                }
                // States
                var inBraces = false;
                var braceVal = '';
                var inBrackets = false;
                var bracketVal = '';
                var char;
                for (var i = 0; i < segment.length; i++) {
                    char = segment[i];
                    // Support brace expansion
                    if (char !== '}' && inBraces) {
                        braceVal += char;
                        continue;
                    }
                    // Support brackets
                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {
                        var res = void 0;
                        // range operator
                        if (char === '-') {
                            res = char;
                        }
                        // negation operator (only valid on first index in bracket)
                        else if ((char === '^' || char === '!') && !bracketVal) {
                            res = '^';
                        }
                        // glob split matching is not allowed within character ranges
                        // see http://man7.org/linux/man-pages/man7/glob.7.html
                        else if (char === GLOB_SPLIT) {
                            res = '';
                        }
                        // anything else gets escaped
                        else {
                            res = strings.escapeRegExpCharacters(char);
                        }
                        bracketVal += res;
                        continue;
                    }
                    switch (char) {
                        case '{':
                            inBraces = true;
                            continue;
                        case '[':
                            inBrackets = true;
                            continue;
                        case '}':
                            var choices = splitGlobAware(braceVal, ',');
                            // Converts {foo,bar} => [foo|bar]
                            var braceRegExp = "(?:" + choices.map(function (c) { return parseRegExp(c); }).join('|') + ")";
                            regEx += braceRegExp;
                            inBraces = false;
                            braceVal = '';
                            break;
                        case ']':
                            regEx += ('[' + bracketVal + ']');
                            inBrackets = false;
                            bracketVal = '';
                            break;
                        case '?':
                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \)
                            continue;
                        case '*':
                            regEx += starsToRegExp(1);
                            continue;
                        default:
                            regEx += strings.escapeRegExpCharacters(char);
                    }
                }
                // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar
                // For example if pattern: some/**/*.js we want the "/" after some to be included in the RegEx to prevent
                // a folder called "something" to match as well.
                // However, if pattern: some/**, we tolerate that we also match on "something" because our globstar behaviour
                // is to match 0-N segments.
                if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {
                    regEx += PATH_REGEX;
                }
                // reset state
                previousSegmentWasGlobStar_1 = false;
            });
        }
        return regEx;
    }
    // regexes to check for trival glob patterns that just check for String#endsWith
    var T1 = /^\*\*\/\*\.[\w\.-]+$/; // **/*.something
    var T2 = /^\*\*\/([\w\.-]+)\/?$/; // **/something
    var T3 = /^{\*\*\/[\*\.]?[\w\.-]+\/?(,\*\*\/[\*\.]?[\w\.-]+\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}
    var T3_2 = /^{\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?(,\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?)*}$/; // Like T3, with optional trailing /**
    var T4 = /^\*\*((\/[\w\.-]+)+)\/?$/; // **/something/else
    var T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/; // something/else
    var CACHE = new map_1.LRUCache(10000); // bounded to 10000 elements
    var FALSE = function () {
        return false;
    };
    var NULL = function () {
        return null;
    };
    function parsePattern(arg1, options) {
        if (!arg1) {
            return NULL;
        }
        // Handle IRelativePattern
        var pattern;
        if (typeof arg1 !== 'string') {
            pattern = arg1.pattern;
        }
        else {
            pattern = arg1;
        }
        // Whitespace trimming
        pattern = pattern.trim();
        // Check cache
        var patternKey = pattern + "_" + !!options.trimForExclusions;
        var parsedPattern = CACHE.get(patternKey);
        if (parsedPattern) {
            return wrapRelativePattern(parsedPattern, arg1);
        }
        // Check for Trivias
        var match;
        if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check
            var base_1 = pattern.substr(4); // '**/*'.length === 4
            parsedPattern = function (path, basename) {
                return path && strings.endsWith(path, base_1) ? pattern : null;
            };
        }
        else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check
            parsedPattern = trivia2(match[1], pattern);
        }
        else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}
            parsedPattern = trivia3(pattern, options);
        }
        else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check
            parsedPattern = trivia4and5(match[1].substr(1), pattern, true);
        }
        else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check
            parsedPattern = trivia4and5(match[1], pattern, false);
        }
        // Otherwise convert to pattern
        else {
            parsedPattern = toRegExp(pattern);
        }
        // Cache
        CACHE.set(patternKey, parsedPattern);
        return wrapRelativePattern(parsedPattern, arg1);
    }
    function wrapRelativePattern(parsedPattern, arg2) {
        if (typeof arg2 === 'string') {
            return parsedPattern;
        }
        return function (path, basename) {
            if (!paths.isEqualOrParent(path, arg2.base)) {
                return null;
            }
            return parsedPattern(paths.normalize(arg2.pathToRelative(arg2.base, path)), basename);
        };
    }
    function trimForExclusions(pattern, options) {
        return options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later
    }
    // common pattern: **/some.txt just need basename check
    function trivia2(base, originalPattern) {
        var slashBase = "/" + base;
        var backslashBase = "\\" + base;
        var parsedPattern = function (path, basename) {
            if (!path) {
                return null;
            }
            if (basename) {
                return basename === base ? originalPattern : null;
            }
            return path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;
        };
        var basenames = [base];
        parsedPattern.basenames = basenames;
        parsedPattern.patterns = [originalPattern];
        parsedPattern.allBasenames = basenames;
        return parsedPattern;
    }
    // repetition of common patterns (see above) {**/*.txt,**/*.png}
    function trivia3(pattern, options) {
        var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')
            .map(function (pattern) { return parsePattern(pattern, options); })
            .filter(function (pattern) { return pattern !== NULL; }), pattern);
        var n = parsedPatterns.length;
        if (!n) {
            return NULL;
        }
        if (n === 1) {
            return parsedPatterns[0];
        }
        var parsedPattern = function (path, basename) {
            for (var i = 0, n_1 = parsedPatterns.length; i < n_1; i++) {
                if (parsedPatterns[i](path, basename)) {
                    return pattern;
                }
            }
            return null;
        };
        var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
        if (withBasenames) {
            parsedPattern.allBasenames = withBasenames.allBasenames;
        }
        var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
        if (allPaths.length) {
            parsedPattern.allPaths = allPaths;
        }
        return parsedPattern;
    }
    // common patterns: **/something/else just need endsWith check, something/else just needs and equals check
    function trivia4and5(path, pattern, matchPathEnds) {
        var nativePath = paths.nativeSep !== paths.sep ? path.replace(ALL_FORWARD_SLASHES, paths.nativeSep) : path;
        var nativePathEnd = paths.nativeSep + nativePath;
        var parsedPattern = matchPathEnds ? function (path, basename) {
            return path && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;
        } : function (path, basename) {
            return path && path === nativePath ? pattern : null;
        };
        parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];
        return parsedPattern;
    }
    function toRegExp(pattern) {
        try {
            var regExp_1 = new RegExp("^" + parseRegExp(pattern) + "$");
            return function (path, basename) {
                regExp_1.lastIndex = 0; // reset RegExp to its initial state to reuse it!
                return path && regExp_1.test(path) ? pattern : null;
            };
        }
        catch (error) {
            return NULL;
        }
    }
    function match(arg1, path, hasSibling) {
        if (!arg1 || !path) {
            return false;
        }
        return parse(arg1)(path, undefined, hasSibling);
    }
    exports.match = match;
    function parse(arg1, options) {
        if (options === void 0) { options = {}; }
        if (!arg1) {
            return FALSE;
        }
        // Glob with String
        if (typeof arg1 === 'string' || isRelativePattern(arg1)) {
            var parsedPattern_1 = parsePattern(arg1, options);
            if (parsedPattern_1 === NULL) {
                return FALSE;
            }
            var resultPattern = function (path, basename) {
                return !!parsedPattern_1(path, basename);
            };
            if (parsedPattern_1.allBasenames) {
                resultPattern.allBasenames = parsedPattern_1.allBasenames;
            }
            if (parsedPattern_1.allPaths) {
                resultPattern.allPaths = parsedPattern_1.allPaths;
            }
            return resultPattern;
        }
        // Glob with Expression
        return parsedExpression(arg1, options);
    }
    exports.parse = parse;
    function hasSiblingPromiseFn(siblingsFn) {
        if (!siblingsFn) {
            return undefined;
        }
        var siblings;
        return function (name) {
            if (!siblings) {
                siblings = (siblingsFn() || winjs_base_1.TPromise.as([]))
                    .then(function (list) { return list ? listToMap(list) : {}; });
            }
            return siblings.then(function (map) { return !!map[name]; });
        };
    }
    exports.hasSiblingPromiseFn = hasSiblingPromiseFn;
    function hasSiblingFn(siblingsFn) {
        if (!siblingsFn) {
            return undefined;
        }
        var siblings;
        return function (name) {
            if (!siblings) {
                var list = siblingsFn();
                siblings = list ? listToMap(list) : {};
            }
            return !!siblings[name];
        };
    }
    exports.hasSiblingFn = hasSiblingFn;
    function listToMap(list) {
        var map = {};
        for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
            var key = list_1[_i];
            map[key] = true;
        }
        return map;
    }
    function isRelativePattern(obj) {
        var rp = obj;
        return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string' && typeof rp.pathToRelative === 'function';
    }
    exports.isRelativePattern = isRelativePattern;
    /**
     * Same as `parse`, but the ParsedExpression is guaranteed to return a Promise
     */
    function parseToAsync(expression, options) {
        var parsedExpression = parse(expression, options);
        return function (path, basename, hasSibling) {
            var result = parsedExpression(path, basename, hasSibling);
            return result instanceof winjs_base_1.TPromise ? result : winjs_base_1.TPromise.as(result);
        };
    }
    exports.parseToAsync = parseToAsync;
    function getBasenameTerms(patternOrExpression) {
        return patternOrExpression.allBasenames || [];
    }
    exports.getBasenameTerms = getBasenameTerms;
    function getPathTerms(patternOrExpression) {
        return patternOrExpression.allPaths || [];
    }
    exports.getPathTerms = getPathTerms;
    function parsedExpression(expression, options) {
        var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)
            .map(function (pattern) { return parseExpressionPattern(pattern, expression[pattern], options); })
            .filter(function (pattern) { return pattern !== NULL; }));
        var n = parsedPatterns.length;
        if (!n) {
            return NULL;
        }
        if (!parsedPatterns.some(function (parsedPattern) { return parsedPattern.requiresSiblings; })) {
            if (n === 1) {
                return parsedPatterns[0];
            }
            var resultExpression_1 = function (path, basename) {
                for (var i = 0, n_2 = parsedPatterns.length; i < n_2; i++) {
                    // Pattern matches path
                    var result = parsedPatterns[i](path, basename);
                    if (result) {
                        return result;
                    }
                }
                return null;
            };
            var withBasenames_1 = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
            if (withBasenames_1) {
                resultExpression_1.allBasenames = withBasenames_1.allBasenames;
            }
            var allPaths_1 = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
            if (allPaths_1.length) {
                resultExpression_1.allPaths = allPaths_1;
            }
            return resultExpression_1;
        }
        var resultExpression = function (path, basename, hasSibling) {
            var name;
            for (var i = 0, n_3 = parsedPatterns.length; i < n_3; i++) {
                // Pattern matches path
                var parsedPattern = parsedPatterns[i];
                if (parsedPattern.requiresSiblings && hasSibling) {
                    if (!basename) {
                        basename = paths.basename(path);
                    }
                    if (!name) {
                        name = basename.substr(0, basename.length - paths.extname(path).length);
                    }
                }
                var result = parsedPattern(path, basename, name, hasSibling);
                if (result) {
                    return result;
                }
            }
            return null;
        };
        var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
        if (withBasenames) {
            resultExpression.allBasenames = withBasenames.allBasenames;
        }
        var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
        if (allPaths.length) {
            resultExpression.allPaths = allPaths;
        }
        return resultExpression;
    }
    function parseExpressionPattern(pattern, value, options) {
        if (value === false) {
            return NULL; // pattern is disabled
        }
        var parsedPattern = parsePattern(pattern, options);
        if (parsedPattern === NULL) {
            return NULL;
        }
        // Expression Pattern is <boolean>
        if (typeof value === 'boolean') {
            return parsedPattern;
        }
        // Expression Pattern is <SiblingClause>
        if (value) {
            var when_1 = value.when;
            if (typeof when_1 === 'string') {
                var result = function (path, basename, name, hasSibling) {
                    if (!hasSibling || !parsedPattern(path, basename)) {
                        return null;
                    }
                    var clausePattern = when_1.replace('$(basename)', name);
                    var matched = hasSibling(clausePattern);
                    return winjs_base_1.TPromise.is(matched) ?
                        matched.then(function (m) { return m ? pattern : null; }) :
                        matched ? pattern : null;
                };
                result.requiresSiblings = true;
                return result;
            }
        }
        // Expression is Anything
        return parsedPattern;
    }
    function aggregateBasenameMatches(parsedPatterns, result) {
        var basenamePatterns = parsedPatterns.filter(function (parsedPattern) { return !!parsedPattern.basenames; });
        if (basenamePatterns.length < 2) {
            return parsedPatterns;
        }
        var basenames = basenamePatterns.reduce(function (all, current) { return all.concat(current.basenames); }, []);
        var patterns;
        if (result) {
            patterns = [];
            for (var i = 0, n = basenames.length; i < n; i++) {
                patterns.push(result);
            }
        }
        else {
            patterns = basenamePatterns.reduce(function (all, current) { return all.concat(current.patterns); }, []);
        }
        var aggregate = function (path, basename) {
            if (!path) {
                return null;
            }
            if (!basename) {
                var i = void 0;
                for (i = path.length; i > 0; i--) {
                    var ch = path.charCodeAt(i - 1);
                    if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {
                        break;
                    }
                }
                basename = path.substr(i);
            }
            var index = basenames.indexOf(basename);
            return index !== -1 ? patterns[index] : null;
        };
        aggregate.basenames = basenames;
        aggregate.patterns = patterns;
        aggregate.allBasenames = basenames;
        var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) { return !parsedPattern.basenames; });
        aggregatedPatterns.push(aggregate);
        return aggregatedPatterns;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[69/*vs/base/common/htmlContent*/], __M([0/*require*/,1/*exports*/,13/*vs/base/common/arrays*/]), function (require, exports, arrays_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var MarkdownString = /** @class */ (function () {
        function MarkdownString(value) {
            if (value === void 0) { value = ''; }
            this.value = value;
        }
        MarkdownString.prototype.appendText = function (value) {
            // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
            this.value += value.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&');
            return this;
        };
        MarkdownString.prototype.appendMarkdown = function (value) {
            this.value += value;
            return this;
        };
        MarkdownString.prototype.appendCodeblock = function (langId, code) {
            this.value += '\n```';
            this.value += langId;
            this.value += '\n';
            this.value += code;
            this.value += '\n```\n';
            return this;
        };
        return MarkdownString;
    }());
    exports.MarkdownString = MarkdownString;
    function isEmptyMarkdownString(oneOrMany) {
        if (isMarkdownString(oneOrMany)) {
            return !oneOrMany.value;
        }
        else if (Array.isArray(oneOrMany)) {
            return oneOrMany.every(isEmptyMarkdownString);
        }
        else {
            return true;
        }
    }
    exports.isEmptyMarkdownString = isEmptyMarkdownString;
    function isMarkdownString(thing) {
        if (thing instanceof MarkdownString) {
            return true;
        }
        else if (thing && typeof thing === 'object') {
            return typeof thing.value === 'string'
                && (typeof thing.isTrusted === 'boolean' || thing.isTrusted === void 0);
        }
        return false;
    }
    exports.isMarkdownString = isMarkdownString;
    function markedStringsEquals(a, b) {
        if (!a && !b) {
            return true;
        }
        else if (!a || !b) {
            return false;
        }
        else if (Array.isArray(a) && Array.isArray(b)) {
            return arrays_1.equals(a, b, markdownStringEqual);
        }
        else if (isMarkdownString(a) && isMarkdownString(b)) {
            return markdownStringEqual(a, b);
        }
        else {
            return false;
        }
    }
    exports.markedStringsEquals = markedStringsEquals;
    function markdownStringEqual(a, b) {
        if (a === b) {
            return true;
        }
        else if (!a || !b) {
            return false;
        }
        else {
            return a.value === b.value && a.isTrusted === b.isTrusted;
        }
    }
    function removeMarkdownEscapes(text) {
        if (!text) {
            return text;
        }
        return text.replace(/\\([\\`*_{}[\]()#+\-.!])/g, '$1');
    }
    exports.removeMarkdownEscapes = removeMarkdownEscapes;
});

define(__m[74/*vs/base/common/mime*/], __M([0/*require*/,1/*exports*/,16/*vs/base/common/paths*/,8/*vs/base/common/strings*/,33/*vs/base/common/glob*/]), function (require, exports, paths, strings, glob_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MIME_TEXT = 'text/plain';
    exports.MIME_BINARY = 'application/octet-stream';
    exports.MIME_UNKNOWN = 'application/unknown';
    var registeredAssociations = [];
    var nonUserRegisteredAssociations = [];
    var userRegisteredAssociations = [];
    /**
     * Associate a text mime to the registry.
     */
    function registerTextMime(association, warnOnOverwrite) {
        if (warnOnOverwrite === void 0) { warnOnOverwrite = false; }
        // Register
        var associationItem = toTextMimeAssociationItem(association);
        registeredAssociations.push(associationItem);
        if (!associationItem.userConfigured) {
            nonUserRegisteredAssociations.push(associationItem);
        }
        else {
            userRegisteredAssociations.push(associationItem);
        }
        // Check for conflicts unless this is a user configured association
        if (warnOnOverwrite && !associationItem.userConfigured) {
            registeredAssociations.forEach(function (a) {
                if (a.mime === associationItem.mime || a.userConfigured) {
                    return; // same mime or userConfigured is ok
                }
                if (associationItem.extension && a.extension === associationItem.extension) {
                    console.warn("Overwriting extension <<" + associationItem.extension + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
                if (associationItem.filename && a.filename === associationItem.filename) {
                    console.warn("Overwriting filename <<" + associationItem.filename + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
                if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {
                    console.warn("Overwriting filepattern <<" + associationItem.filepattern + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
                if (associationItem.firstline && a.firstline === associationItem.firstline) {
                    console.warn("Overwriting firstline <<" + associationItem.firstline + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
            });
        }
    }
    exports.registerTextMime = registerTextMime;
    function toTextMimeAssociationItem(association) {
        return {
            id: association.id,
            mime: association.mime,
            filename: association.filename,
            extension: association.extension,
            filepattern: association.filepattern,
            firstline: association.firstline,
            userConfigured: association.userConfigured,
            filenameLowercase: association.filename ? association.filename.toLowerCase() : void 0,
            extensionLowercase: association.extension ? association.extension.toLowerCase() : void 0,
            filepatternLowercase: association.filepattern ? association.filepattern.toLowerCase() : void 0,
            filepatternOnPath: association.filepattern ? association.filepattern.indexOf(paths.sep) >= 0 : false
        };
    }
    /**
     * Clear text mimes from the registry.
     */
    function clearTextMimes(onlyUserConfigured) {
        if (!onlyUserConfigured) {
            registeredAssociations = [];
            nonUserRegisteredAssociations = [];
            userRegisteredAssociations = [];
        }
        else {
            registeredAssociations = registeredAssociations.filter(function (a) { return !a.userConfigured; });
            userRegisteredAssociations = [];
        }
    }
    exports.clearTextMimes = clearTextMimes;
    /**
     * Given a file, return the best matching mime type for it
     */
    function guessMimeTypes(path, firstLine) {
        if (!path) {
            return [exports.MIME_UNKNOWN];
        }
        path = path.toLowerCase();
        var filename = paths.basename(path);
        // 1.) User configured mappings have highest priority
        var configuredMime = guessMimeTypeByPath(path, filename, userRegisteredAssociations);
        if (configuredMime) {
            return [configuredMime, exports.MIME_TEXT];
        }
        // 2.) Registered mappings have middle priority
        var registeredMime = guessMimeTypeByPath(path, filename, nonUserRegisteredAssociations);
        if (registeredMime) {
            return [registeredMime, exports.MIME_TEXT];
        }
        // 3.) Firstline has lowest priority
        if (firstLine) {
            var firstlineMime = guessMimeTypeByFirstline(firstLine);
            if (firstlineMime) {
                return [firstlineMime, exports.MIME_TEXT];
            }
        }
        return [exports.MIME_UNKNOWN];
    }
    exports.guessMimeTypes = guessMimeTypes;
    function guessMimeTypeByPath(path, filename, associations) {
        var filenameMatch;
        var patternMatch;
        var extensionMatch;
        // We want to prioritize associations based on the order they are registered so that the last registered
        // association wins over all other. This is for https://github.com/Microsoft/vscode/issues/20074
        for (var i = associations.length - 1; i >= 0; i--) {
            var association = associations[i];
            // First exact name match
            if (filename === association.filenameLowercase) {
                filenameMatch = association;
                break; // take it!
            }
            // Longest pattern match
            if (association.filepattern) {
                if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {
                    var target = association.filepatternOnPath ? path : filename; // match on full path if pattern contains path separator
                    if (glob_1.match(association.filepatternLowercase, target)) {
                        patternMatch = association;
                    }
                }
            }
            // Longest extension match
            if (association.extension) {
                if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {
                    if (strings.endsWith(filename, association.extensionLowercase)) {
                        extensionMatch = association;
                    }
                }
            }
        }
        // 1.) Exact name match has second highest prio
        if (filenameMatch) {
            return filenameMatch.mime;
        }
        // 2.) Match on pattern
        if (patternMatch) {
            return patternMatch.mime;
        }
        // 3.) Match on extension comes next
        if (extensionMatch) {
            return extensionMatch.mime;
        }
        return null;
    }
    function guessMimeTypeByFirstline(firstLine) {
        if (strings.startsWithUTF8BOM(firstLine)) {
            firstLine = firstLine.substr(1);
        }
        if (firstLine.length > 0) {
            for (var i = 0; i < registeredAssociations.length; ++i) {
                var association = registeredAssociations[i];
                if (!association.firstline) {
                    continue;
                }
                var matches = firstLine.match(association.firstline);
                if (matches && matches.length > 0) {
                    return association.mime;
                }
            }
        }
        return null;
    }
    function isUnspecific(mime) {
        if (!mime) {
            return true;
        }
        if (typeof mime === 'string') {
            return mime === exports.MIME_BINARY || mime === exports.MIME_TEXT || mime === exports.MIME_UNKNOWN;
        }
        return mime.length === 1 && isUnspecific(mime[0]);
    }
    exports.isUnspecific = isUnspecific;
    function suggestFilename(langId, prefix) {
        for (var i = 0; i < registeredAssociations.length; i++) {
            var association = registeredAssociations[i];
            if (association.userConfigured) {
                continue; // only support registered ones
            }
            if (association.id === langId && association.extension) {
                return prefix + association.extension;
            }
        }
        return prefix; // without any known extension, just return the prefix
    }
    exports.suggestFilename = suggestFilename;
    // Known media mimes that we can handle
    var mapExtToMediaMimes = {
        '.bmp': 'image/bmp',
        '.gif': 'image/gif',
        '.jpg': 'image/jpg',
        '.jpeg': 'image/jpg',
        '.jpe': 'image/jpg',
        '.png': 'image/png',
        '.tiff': 'image/tiff',
        '.tif': 'image/tiff',
        '.ico': 'image/x-icon',
        '.tga': 'image/x-tga',
        '.psd': 'image/vnd.adobe.photoshop',
        '.webp': 'image/webp',
        '.mid': 'audio/midi',
        '.midi': 'audio/midi',
        '.mp4a': 'audio/mp4',
        '.mpga': 'audio/mpeg',
        '.mp2': 'audio/mpeg',
        '.mp2a': 'audio/mpeg',
        '.mp3': 'audio/mpeg',
        '.m2a': 'audio/mpeg',
        '.m3a': 'audio/mpeg',
        '.oga': 'audio/ogg',
        '.ogg': 'audio/ogg',
        '.spx': 'audio/ogg',
        '.aac': 'audio/x-aac',
        '.wav': 'audio/x-wav',
        '.wma': 'audio/x-ms-wma',
        '.mp4': 'video/mp4',
        '.mp4v': 'video/mp4',
        '.mpg4': 'video/mp4',
        '.mpeg': 'video/mpeg',
        '.mpg': 'video/mpeg',
        '.mpe': 'video/mpeg',
        '.m1v': 'video/mpeg',
        '.m2v': 'video/mpeg',
        '.ogv': 'video/ogg',
        '.qt': 'video/quicktime',
        '.mov': 'video/quicktime',
        '.webm': 'video/webm',
        '.mkv': 'video/x-matroska',
        '.mk3d': 'video/x-matroska',
        '.mks': 'video/x-matroska',
        '.wmv': 'video/x-ms-wmv',
        '.flv': 'video/x-flv',
        '.avi': 'video/x-msvideo',
        '.movie': 'video/x-sgi-movie'
    };
    function getMediaMime(path) {
        var ext = paths.extname(path);
        return mapExtToMediaMimes[ext.toLowerCase()];
    }
    exports.getMediaMime = getMediaMime;
});











define(__m[121/*vs/base/common/scrollable*/], __M([0/*require*/,1/*exports*/,9/*vs/base/common/lifecycle*/,3/*vs/base/common/event*/]), function (require, exports, lifecycle_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ScrollbarVisibility;
    (function (ScrollbarVisibility) {
        ScrollbarVisibility[ScrollbarVisibility["Auto"] = 1] = "Auto";
        ScrollbarVisibility[ScrollbarVisibility["Hidden"] = 2] = "Hidden";
        ScrollbarVisibility[ScrollbarVisibility["Visible"] = 3] = "Visible";
    })(ScrollbarVisibility = exports.ScrollbarVisibility || (exports.ScrollbarVisibility = {}));
    var ScrollState = /** @class */ (function () {
        function ScrollState(width, scrollWidth, scrollLeft, height, scrollHeight, scrollTop) {
            width = width | 0;
            scrollWidth = scrollWidth | 0;
            scrollLeft = scrollLeft | 0;
            height = height | 0;
            scrollHeight = scrollHeight | 0;
            scrollTop = scrollTop | 0;
            if (width < 0) {
                width = 0;
            }
            if (scrollLeft + width > scrollWidth) {
                scrollLeft = scrollWidth - width;
            }
            if (scrollLeft < 0) {
                scrollLeft = 0;
            }
            if (height < 0) {
                height = 0;
            }
            if (scrollTop + height > scrollHeight) {
                scrollTop = scrollHeight - height;
            }
            if (scrollTop < 0) {
                scrollTop = 0;
            }
            this.width = width;
            this.scrollWidth = scrollWidth;
            this.scrollLeft = scrollLeft;
            this.height = height;
            this.scrollHeight = scrollHeight;
            this.scrollTop = scrollTop;
        }
        ScrollState.prototype.equals = function (other) {
            return (this.width === other.width
                && this.scrollWidth === other.scrollWidth
                && this.scrollLeft === other.scrollLeft
                && this.height === other.height
                && this.scrollHeight === other.scrollHeight
                && this.scrollTop === other.scrollTop);
        };
        ScrollState.prototype.withScrollDimensions = function (update) {
            return new ScrollState((typeof update.width !== 'undefined' ? update.width : this.width), (typeof update.scrollWidth !== 'undefined' ? update.scrollWidth : this.scrollWidth), this.scrollLeft, (typeof update.height !== 'undefined' ? update.height : this.height), (typeof update.scrollHeight !== 'undefined' ? update.scrollHeight : this.scrollHeight), this.scrollTop);
        };
        ScrollState.prototype.withScrollPosition = function (update) {
            return new ScrollState(this.width, this.scrollWidth, (typeof update.scrollLeft !== 'undefined' ? update.scrollLeft : this.scrollLeft), this.height, this.scrollHeight, (typeof update.scrollTop !== 'undefined' ? update.scrollTop : this.scrollTop));
        };
        ScrollState.prototype.createScrollEvent = function (previous) {
            var widthChanged = (this.width !== previous.width);
            var scrollWidthChanged = (this.scrollWidth !== previous.scrollWidth);
            var scrollLeftChanged = (this.scrollLeft !== previous.scrollLeft);
            var heightChanged = (this.height !== previous.height);
            var scrollHeightChanged = (this.scrollHeight !== previous.scrollHeight);
            var scrollTopChanged = (this.scrollTop !== previous.scrollTop);
            return {
                width: this.width,
                scrollWidth: this.scrollWidth,
                scrollLeft: this.scrollLeft,
                height: this.height,
                scrollHeight: this.scrollHeight,
                scrollTop: this.scrollTop,
                widthChanged: widthChanged,
                scrollWidthChanged: scrollWidthChanged,
                scrollLeftChanged: scrollLeftChanged,
                heightChanged: heightChanged,
                scrollHeightChanged: scrollHeightChanged,
                scrollTopChanged: scrollTopChanged,
            };
        };
        return ScrollState;
    }());
    exports.ScrollState = ScrollState;
    var Scrollable = /** @class */ (function (_super) {
        __extends(Scrollable, _super);
        function Scrollable(smoothScrollDuration, scheduleAtNextAnimationFrame) {
            var _this = _super.call(this) || this;
            _this._onScroll = _this._register(new event_1.Emitter());
            _this.onScroll = _this._onScroll.event;
            _this._smoothScrollDuration = smoothScrollDuration;
            _this._scheduleAtNextAnimationFrame = scheduleAtNextAnimationFrame;
            _this._state = new ScrollState(0, 0, 0, 0, 0, 0);
            _this._smoothScrolling = null;
            return _this;
        }
        Scrollable.prototype.dispose = function () {
            if (this._smoothScrolling) {
                this._smoothScrolling.dispose();
                this._smoothScrolling = null;
            }
            _super.prototype.dispose.call(this);
        };
        Scrollable.prototype.setSmoothScrollDuration = function (smoothScrollDuration) {
            this._smoothScrollDuration = smoothScrollDuration;
        };
        Scrollable.prototype.validateScrollPosition = function (scrollPosition) {
            return this._state.withScrollPosition(scrollPosition);
        };
        Scrollable.prototype.getScrollDimensions = function () {
            return this._state;
        };
        Scrollable.prototype.setScrollDimensions = function (dimensions) {
            var newState = this._state.withScrollDimensions(dimensions);
            this._setState(newState);
            // Validate outstanding animated scroll position target
            if (this._smoothScrolling) {
                this._smoothScrolling.acceptScrollDimensions(this._state);
            }
        };
        /**
         * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
         * If no scroll animation is occurring, it will return the current scroll position instead.
         */
        Scrollable.prototype.getFutureScrollPosition = function () {
            if (this._smoothScrolling) {
                return this._smoothScrolling.to;
            }
            return this._state;
        };
        /**
         * Returns the current scroll position.
         * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
         */
        Scrollable.prototype.getCurrentScrollPosition = function () {
            return this._state;
        };
        Scrollable.prototype.setScrollPositionNow = function (update) {
            // no smooth scrolling requested
            var newState = this._state.withScrollPosition(update);
            // Terminate any outstanding smooth scrolling
            if (this._smoothScrolling) {
                this._smoothScrolling.dispose();
                this._smoothScrolling = null;
            }
            this._setState(newState);
        };
        Scrollable.prototype.setScrollPositionSmooth = function (update) {
            var _this = this;
            if (this._smoothScrollDuration === 0) {
                // Smooth scrolling not supported.
                return this.setScrollPositionNow(update);
            }
            if (this._smoothScrolling) {
                // Combine our pending scrollLeft/scrollTop with incoming scrollLeft/scrollTop
                update = {
                    scrollLeft: (typeof update.scrollLeft === 'undefined' ? this._smoothScrolling.to.scrollLeft : update.scrollLeft),
                    scrollTop: (typeof update.scrollTop === 'undefined' ? this._smoothScrolling.to.scrollTop : update.scrollTop)
                };
                // Validate `update`
                var validTarget = this._state.withScrollPosition(update);
                if (this._smoothScrolling.to.scrollLeft === validTarget.scrollLeft && this._smoothScrolling.to.scrollTop === validTarget.scrollTop) {
                    // No need to interrupt or extend the current animation since we're going to the same place
                    return;
                }
                var newSmoothScrolling = this._smoothScrolling.combine(this._state, validTarget, this._smoothScrollDuration);
                this._smoothScrolling.dispose();
                this._smoothScrolling = newSmoothScrolling;
            }
            else {
                // Validate `update`
                var validTarget = this._state.withScrollPosition(update);
                this._smoothScrolling = SmoothScrollingOperation.start(this._state, validTarget, this._smoothScrollDuration);
            }
            // Begin smooth scrolling animation
            this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(function () {
                if (!_this._smoothScrolling) {
                    return;
                }
                _this._smoothScrolling.animationFrameDisposable = null;
                _this._performSmoothScrolling();
            });
        };
        Scrollable.prototype._performSmoothScrolling = function () {
            var _this = this;
            var update = this._smoothScrolling.tick();
            var newState = this._state.withScrollPosition(update);
            this._setState(newState);
            if (update.isDone) {
                this._smoothScrolling.dispose();
                this._smoothScrolling = null;
                return;
            }
            // Continue smooth scrolling animation
            this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(function () {
                if (!_this._smoothScrolling) {
                    return;
                }
                _this._smoothScrolling.animationFrameDisposable = null;
                _this._performSmoothScrolling();
            });
        };
        Scrollable.prototype._setState = function (newState) {
            var oldState = this._state;
            if (oldState.equals(newState)) {
                // no change
                return;
            }
            this._state = newState;
            this._onScroll.fire(this._state.createScrollEvent(oldState));
        };
        return Scrollable;
    }(lifecycle_1.Disposable));
    exports.Scrollable = Scrollable;
    var SmoothScrollingUpdate = /** @class */ (function () {
        function SmoothScrollingUpdate(scrollLeft, scrollTop, isDone) {
            this.scrollLeft = scrollLeft;
            this.scrollTop = scrollTop;
            this.isDone = isDone;
        }
        return SmoothScrollingUpdate;
    }());
    exports.SmoothScrollingUpdate = SmoothScrollingUpdate;
    function createEaseOutCubic(from, to) {
        var delta = to - from;
        return function (completion) {
            return from + delta * easeOutCubic(completion);
        };
    }
    function createComposed(a, b, cut) {
        return function (completion) {
            if (completion < cut) {
                return a(completion / cut);
            }
            return b((completion - cut) / (1 - cut));
        };
    }
    var SmoothScrollingOperation = /** @class */ (function () {
        function SmoothScrollingOperation(from, to, startTime, duration) {
            this.from = from;
            this.to = to;
            this.duration = duration;
            this._startTime = startTime;
            this.animationFrameDisposable = null;
            this._initAnimations();
        }
        SmoothScrollingOperation.prototype._initAnimations = function () {
            this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width);
            this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
        };
        SmoothScrollingOperation.prototype._initAnimation = function (from, to, viewportSize) {
            var delta = Math.abs(from - to);
            if (delta > 2.5 * viewportSize) {
                var stop1 = void 0, stop2 = void 0;
                if (from < to) {
                    // scroll to 75% of the viewportSize
                    stop1 = from + 0.75 * viewportSize;
                    stop2 = to - 0.75 * viewportSize;
                }
                else {
                    stop1 = from - 0.75 * viewportSize;
                    stop2 = to + 0.75 * viewportSize;
                }
                return createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(stop2, to), 0.33);
            }
            return createEaseOutCubic(from, to);
        };
        SmoothScrollingOperation.prototype.dispose = function () {
            if (this.animationFrameDisposable !== null) {
                this.animationFrameDisposable.dispose();
                this.animationFrameDisposable = null;
            }
        };
        SmoothScrollingOperation.prototype.acceptScrollDimensions = function (state) {
            this.to = state.withScrollPosition(this.to);
            this._initAnimations();
        };
        SmoothScrollingOperation.prototype.tick = function () {
            return this._tick(Date.now());
        };
        SmoothScrollingOperation.prototype._tick = function (now) {
            var completion = (now - this._startTime) / this.duration;
            if (completion < 1) {
                var newScrollLeft = this.scrollLeft(completion);
                var newScrollTop = this.scrollTop(completion);
                return new SmoothScrollingUpdate(newScrollLeft, newScrollTop, false);
            }
            return new SmoothScrollingUpdate(this.to.scrollLeft, this.to.scrollTop, true);
        };
        SmoothScrollingOperation.prototype.combine = function (from, to, duration) {
            return SmoothScrollingOperation.start(from, to, duration);
        };
        SmoothScrollingOperation.start = function (from, to, duration) {
            // +10 / -10 : pretend the animation already started for a quicker response to a scroll request
            duration = duration + 10;
            var startTime = Date.now() - 10;
            return new SmoothScrollingOperation(from, to, startTime, duration);
        };
        return SmoothScrollingOperation;
    }());
    exports.SmoothScrollingOperation = SmoothScrollingOperation;
    function easeInCubic(t) {
        return Math.pow(t, 3);
    }
    function easeOutCubic(t) {
        return 1 - easeInCubic(1 - t);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[125/*vs/base/node/console*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/]), function (require, exports, uri_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function isRemoteConsoleLog(obj) {
        var entry = obj;
        return entry && typeof entry.type === 'string' && typeof entry.severity === 'string';
    }
    exports.isRemoteConsoleLog = isRemoteConsoleLog;
    function parse(entry) {
        var args = [];
        var stack;
        // Parse Entry
        try {
            var parsedArguments = JSON.parse(entry.arguments);
            // Check for special stack entry as last entry
            var stackArgument = parsedArguments[parsedArguments.length - 1];
            if (stackArgument && stackArgument.__$stack) {
                parsedArguments.pop(); // stack is handled specially
                stack = stackArgument.__$stack;
            }
            args.push.apply(args, parsedArguments);
        }
        catch (error) {
            args.push('Unable to log remote console arguments', entry.arguments);
        }
        return { args: args, stack: stack };
    }
    exports.parse = parse;
    function getFirstFrame(arg0) {
        if (typeof arg0 !== 'string') {
            return getFirstFrame(parse(arg0).stack);
        }
        // Parse a source information out of the stack if we have one. Format can be:
        // at vscode.commands.registerCommand (/Users/someone/Desktop/test-ts/out/src/extension.js:18:17)
        // or
        // at /Users/someone/Desktop/test-ts/out/src/extension.js:18:17
        // or
        // at c:\Users\someone\Desktop\end-js\extension.js:19:17
        // or
        // at e.$executeContributedCommand(c:\Users\someone\Desktop\end-js\extension.js:19:17)
        var stack = arg0;
        if (stack) {
            var topFrame = findFirstFrame(stack);
            // at [^\/]* => line starts with "at" followed by any character except '/' (to not capture unix paths too late)
            // (?:(?:[a-zA-Z]+:)|(?:[\/])|(?:\\\\) => windows drive letter OR unix root OR unc root
            // (?:.+) => simple pattern for the path, only works because of the line/col pattern after
            // :(?:\d+):(?:\d+) => :line:column data
            var matches = /at [^\/]*((?:(?:[a-zA-Z]+:)|(?:[\/])|(?:\\\\))(?:.+)):(\d+):(\d+)/.exec(topFrame);
            if (matches && matches.length === 4) {
                return {
                    uri: uri_1.default.file(matches[1]),
                    line: Number(matches[2]),
                    column: Number(matches[3])
                };
            }
        }
        return void 0;
    }
    exports.getFirstFrame = getFirstFrame;
    function findFirstFrame(stack) {
        if (!stack) {
            return stack;
        }
        var newlineIndex = stack.indexOf('\n');
        if (newlineIndex === -1) {
            return stack;
        }
        return stack.substring(0, newlineIndex);
    }
    function log(entry, label) {
        var _a = parse(entry), args = _a.args, stack = _a.stack;
        var isOneStringArg = typeof args[0] === 'string' && args.length === 1;
        var topFrame = findFirstFrame(stack);
        if (topFrame) {
            topFrame = "(" + topFrame.trim() + ")";
        }
        var consoleArgs = [];
        // First arg is a string
        if (typeof args[0] === 'string') {
            if (topFrame && isOneStringArg) {
                consoleArgs = ["%c[" + label + "] %c" + args[0] + " %c" + topFrame, color('blue'), color('black'), color('grey')];
            }
            else {
                consoleArgs = ["%c[" + label + "] %c" + args[0], color('blue'), color('black')].concat(args.slice(1));
            }
        }
        // First arg is something else, just apply all
        else {
            consoleArgs = ["%c[" + label + "]%", color('blue')].concat(args);
        }
        // Stack: add to args unless already aded
        if (topFrame && !isOneStringArg) {
            consoleArgs.push(topFrame);
        }
        // Log it
        console[entry.severity].apply(console, consoleArgs);
    }
    exports.log = log;
    function color(color) {
        return "color: " + color;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[127/*vs/base/node/decoder*/], __M([0/*require*/,1/*exports*/,241/*string_decoder*/]), function (require, exports, sd) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Convenient way to iterate over output line by line. This helper accommodates for the fact that
     * a buffer might not end with new lines all the way.
     *
     * To use:
     * - call the write method
     * - forEach() over the result to get the lines
     */
    var LineDecoder = /** @class */ (function () {
        function LineDecoder(encoding) {
            if (encoding === void 0) { encoding = 'utf8'; }
            this.stringDecoder = new sd.StringDecoder(encoding);
            this.remaining = null;
        }
        LineDecoder.prototype.write = function (buffer) {
            var result = [];
            var value = this.remaining
                ? this.remaining + this.stringDecoder.write(buffer)
                : this.stringDecoder.write(buffer);
            if (value.length < 1) {
                return result;
            }
            var start = 0;
            var ch;
            var idx = start;
            while (idx < value.length) {
                ch = value.charCodeAt(idx);
                if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
                    result.push(value.substring(start, idx));
                    idx++;
                    if (idx < value.length) {
                        var lastChar = ch;
                        ch = value.charCodeAt(idx);
                        if ((lastChar === 13 /* CarriageReturn */ && ch === 10 /* LineFeed */) || (lastChar === 10 /* LineFeed */ && ch === 13 /* CarriageReturn */)) {
                            idx++;
                        }
                    }
                    start = idx;
                }
                else {
                    idx++;
                }
            }
            this.remaining = start < value.length ? value.substr(start) : null;
            return result;
        };
        LineDecoder.prototype.end = function () {
            return this.remaining;
        };
        return LineDecoder;
    }());
    exports.LineDecoder = LineDecoder;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[142/*vs/base/node/flow*/], __M([0/*require*/,1/*exports*/,147/*assert*/]), function (require, exports, assert) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Executes the given function (fn) over the given array of items (list) in parallel and returns the resulting errors and results as
     * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function.
     */
    function parallel(list, fn, callback) {
        var results = new Array(list.length);
        var errors = new Array(list.length);
        var didErrorOccur = false;
        var doneCount = 0;
        if (list.length === 0) {
            return callback(null, []);
        }
        list.forEach(function (item, index) {
            fn(item, function (error, result) {
                if (error) {
                    didErrorOccur = true;
                    results[index] = null;
                    errors[index] = error;
                }
                else {
                    results[index] = result;
                    errors[index] = null;
                }
                if (++doneCount === list.length) {
                    return callback(didErrorOccur ? errors : null, results);
                }
            });
        });
    }
    exports.parallel = parallel;
    function loop(param, fn, callback) {
        // Assert
        assert.ok(param, 'Missing first parameter');
        assert.ok(typeof (fn) === 'function', 'Second parameter must be a function that is called for each element');
        assert.ok(typeof (callback) === 'function', 'Third parameter must be a function that is called on error and success');
        // Param is function, execute to retrieve array
        if (typeof (param) === 'function') {
            try {
                param(function (error, result) {
                    if (error) {
                        callback(error, null);
                    }
                    else {
                        loop(result, fn, callback);
                    }
                });
            }
            catch (error) {
                callback(error, null);
            }
        }
        // Expect the param to be an array and loop over it
        else {
            var results_1 = [];
            var looper_1 = function (i) {
                // Still work to do
                if (i < param.length) {
                    // Execute function on array element
                    try {
                        fn(param[i], function (error, result) {
                            // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully
                            if (error === true || error === false) {
                                result = error;
                                error = null;
                            }
                            // Quit looping on error
                            if (error) {
                                callback(error, null);
                            }
                            // Otherwise push result on stack and continue looping
                            else {
                                if (result) { //Could be that provided function is not returning a result
                                    results_1.push(result);
                                }
                                process.nextTick(function () {
                                    looper_1(i + 1);
                                });
                            }
                        }, i, param.length);
                    }
                    catch (error) {
                        callback(error, null);
                    }
                }
                // Done looping, pass back results too callback function
                else {
                    callback(null, results_1);
                }
            };
            // Start looping with first element in array
            looper_1(0);
        }
    }
    exports.loop = loop;
    function Sequence(sequences) {
        // Assert
        assert.ok(sequences.length > 1, 'Need at least one error handler and one function to process sequence');
        sequences.forEach(function (sequence) {
            assert.ok(typeof (sequence) === 'function');
        });
        // Execute in Loop
        var errorHandler = sequences.splice(0, 1)[0]; //Remove error handler
        var sequenceResult = null;
        loop(sequences, function (sequence, clb) {
            var sequenceFunction = function (error, result) {
                // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully
                if (error === true || error === false) {
                    result = error;
                    error = null;
                }
                // Handle Error and Result
                if (error) {
                    clb(error, null);
                }
                else {
                    sequenceResult = result; //Remember result of sequence
                    clb(null, null); //Don't pass on result to Looper as we are not aggregating it
                }
            };
            // We call the sequence function setting "this" to be the callback we define here
            // and we pass in the "sequenceResult" as first argument. Doing all this avoids having
            // to pass in a callback to the sequence because the callback is already "this".
            try {
                sequence.call(sequenceFunction, sequenceResult);
            }
            catch (error) {
                clb(error, null);
            }
        }, function (error, result) {
            if (error) {
                errorHandler(error);
            }
        });
    }
    function sequence(sequences) {
        Sequence((Array.isArray(sequences)) ? sequences : Array.prototype.slice.call(arguments));
    }
    exports.sequence = sequence;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[155/*vs/base/node/stdFork*/], __M([0/*require*/,1/*exports*/,22/*path*/,37/*os*/,57/*net*/,50/*child_process*/,4/*vs/base/common/uri*/]), function (require, exports, path, os, net, cp, uri_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeRandomHexString(length) {
        var chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        var result = '';
        for (var i = 0; i < length; i++) {
            var idx = Math.floor(chars.length * Math.random());
            result += chars[idx];
        }
        return result;
    }
    function generatePipeName() {
        var randomName = 'vscode-std-' + makeRandomHexString(40);
        if (process.platform === 'win32') {
            return '\\\\.\\pipe\\' + randomName + '-sock';
        }
        // Mac/Unix: use socket file
        return path.join(os.tmpdir(), randomName + '.sock');
    }
    function generatePatchedEnv(env, stdInPipeName, stdOutPipeName, stdErrPipeName) {
        // Set the two unique pipe names and the electron flag as process env
        var newEnv = {};
        for (var key in env) {
            newEnv[key] = env[key];
        }
        newEnv['STDIN_PIPE_NAME'] = stdInPipeName;
        newEnv['STDOUT_PIPE_NAME'] = stdOutPipeName;
        newEnv['STDERR_PIPE_NAME'] = stdErrPipeName;
        newEnv['ELECTRON_RUN_AS_NODE'] = '1';
        return newEnv;
    }
    function fork(modulePath, args, options, callback) {
        var callbackCalled = false;
        var resolve = function (result) {
            if (callbackCalled) {
                return;
            }
            callbackCalled = true;
            callback(null, result);
        };
        var reject = function (err) {
            if (callbackCalled) {
                return;
            }
            callbackCalled = true;
            callback(err, null);
        };
        // Generate three unique pipe names
        var stdInPipeName = generatePipeName();
        var stdOutPipeName = generatePipeName();
        var stdErrPipeName = generatePipeName();
        var newEnv = generatePatchedEnv(options.env || process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);
        var childProcess;
        // Begin listening to stderr pipe
        var stdErrServer = net.createServer(function (stdErrStream) {
            // From now on the childProcess.stderr is available for reading
            childProcess.stderr = stdErrStream;
        });
        stdErrServer.listen(stdErrPipeName);
        // Begin listening to stdout pipe
        var stdOutServer = net.createServer(function (stdOutStream) {
            // The child process will write exactly one chunk with content `ready` when it has installed a listener to the stdin pipe
            stdOutStream.once('data', function (chunk) {
                // The child process is sending me the `ready` chunk, time to connect to the stdin pipe
                childProcess.stdin = net.connect(stdInPipeName);
                // From now on the childProcess.stdout is available for reading
                childProcess.stdout = stdOutStream;
                resolve(childProcess);
            });
        });
        stdOutServer.listen(stdOutPipeName);
        var serverClosed = false;
        var closeServer = function () {
            if (serverClosed) {
                return;
            }
            serverClosed = true;
            process.removeListener('exit', closeServer);
            stdOutServer.close();
            stdErrServer.close();
        };
        // Create the process
        var bootstrapperPath = (uri_1.default.parse(require.toUrl('./stdForkStart.js')).fsPath);
        childProcess = cp.fork(bootstrapperPath, [modulePath].concat(args), {
            silent: true,
            cwd: options.cwd,
            env: newEnv,
            execArgv: options.execArgv
        });
        childProcess.once('error', function (err) {
            closeServer();
            reject(err);
        });
        childProcess.once('exit', function (err) {
            closeServer();
            reject(err);
        });
        // On vscode exit still close server #7758
        process.once('exit', closeServer);
    }
    exports.fork = fork;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[231/*vs/base/node/stream*/], __M([0/*require*/,1/*exports*/,49/*fs*/,2/*vs/base/common/winjs.base*/]), function (require, exports, fs, winjs_base_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Reads totalBytes from the provided file.
     */
    function readExactlyByFile(file, totalBytes) {
        return new winjs_base_1.TPromise(function (complete, error) {
            fs.open(file, 'r', null, function (err, fd) {
                if (err) {
                    return error(err);
                }
                function end(err, resultBuffer, bytesRead) {
                    fs.close(fd, function (closeError) {
                        if (closeError) {
                            return error(closeError);
                        }
                        if (err && err.code === 'EISDIR') {
                            return error(err); // we want to bubble this error up (file is actually a folder)
                        }
                        return complete({ buffer: resultBuffer, bytesRead: bytesRead });
                    });
                }
                var buffer = Buffer.allocUnsafe(totalBytes);
                var offset = 0;
                function readChunk() {
                    fs.read(fd, buffer, offset, totalBytes - offset, null, function (err, bytesRead) {
                        if (err) {
                            return end(err, null, 0);
                        }
                        if (bytesRead === 0) {
                            return end(null, buffer, offset);
                        }
                        offset += bytesRead;
                        if (offset === totalBytes) {
                            return end(null, buffer, offset);
                        }
                        return readChunk();
                    });
                }
                readChunk();
            });
        });
    }
    exports.readExactlyByFile = readExactlyByFile;
    /**
     * Reads a file until a matching string is found.
     *
     * @param file The file to read.
     * @param matchingString The string to search for.
     * @param chunkBytes The number of bytes to read each iteration.
     * @param maximumBytesToRead The maximum number of bytes to read before giving up.
     * @param callback The finished callback.
     */
    function readToMatchingString(file, matchingString, chunkBytes, maximumBytesToRead) {
        return new winjs_base_1.TPromise(function (complete, error) {
            return fs.open(file, 'r', null, function (err, fd) {
                if (err) {
                    return error(err);
                }
                function end(err, result) {
                    fs.close(fd, function (closeError) {
                        if (closeError) {
                            return error(closeError);
                        }
                        if (err && err.code === 'EISDIR') {
                            return error(err); // we want to bubble this error up (file is actually a folder)
                        }
                        return complete(result);
                    });
                }
                var buffer = Buffer.allocUnsafe(maximumBytesToRead);
                var offset = 0;
                function readChunk() {
                    fs.read(fd, buffer, offset, chunkBytes, null, function (err, bytesRead) {
                        if (err) {
                            return end(err, null);
                        }
                        if (bytesRead === 0) {
                            return end(null, null);
                        }
                        offset += bytesRead;
                        var newLineIndex = buffer.indexOf(matchingString);
                        if (newLineIndex >= 0) {
                            return end(null, buffer.toString('utf8').substr(0, newLineIndex));
                        }
                        if (offset >= maximumBytesToRead) {
                            return end(new Error("Could not find " + matchingString + " in first " + maximumBytesToRead + " bytes of " + file), null);
                        }
                        return readChunk();
                    });
                }
                readChunk();
            });
        });
    }
    exports.readToMatchingString = readToMatchingString;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[90/*vs/base/node/encoding*/], __M([0/*require*/,1/*exports*/,231/*vs/base/node/stream*/,240/*iconv-lite*/,2/*vs/base/common/winjs.base*/,10/*vs/base/common/platform*/,50/*child_process*/,239/*stream*/,12/*vs/base/common/async*/]), function (require, exports, stream, iconv, winjs_base_1, platform_1, child_process_1, stream_1, async_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UTF8 = 'utf8';
    exports.UTF8_with_bom = 'utf8bom';
    exports.UTF16be = 'utf16be';
    exports.UTF16le = 'utf16le';
    function toDecodeStream(readable, options) {
        if (!options.minBytesRequiredForDetection) {
            options.minBytesRequiredForDetection = options.guessEncoding ? AUTO_GUESS_BUFFER_MAX_LEN : NO_GUESS_BUFFER_MAX_LEN;
        }
        if (!options.overwriteEncoding) {
            options.overwriteEncoding = function (detected) { return detected || exports.UTF8; };
        }
        return new winjs_base_1.TPromise(function (resolve, reject) {
            readable.pipe(new /** @class */ (function (_super) {
                __extends(class_1, _super);
                function class_1(opts) {
                    var _this = _super.call(this, opts) || this;
                    _this._buffer = [];
                    _this._bytesBuffered = 0;
                    _this.once('finish', function () { return _this._finish(); });
                    return _this;
                }
                class_1.prototype._write = function (chunk, encoding, callback) {
                    if (!Buffer.isBuffer(chunk)) {
                        callback(new Error('data must be a buffer'));
                    }
                    if (this._decodeStream) {
                        // just a forwarder now
                        this._decodeStream.write(chunk, callback);
                        return;
                    }
                    this._buffer.push(chunk);
                    this._bytesBuffered += chunk.length;
                    if (this._decodeStreamConstruction) {
                        // waiting for the decoder to be ready
                        this._decodeStreamConstruction.then(function (_) { return callback(); }, function (err) { return callback(err); });
                    }
                    else if (this._bytesBuffered >= options.minBytesRequiredForDetection) {
                        // buffered enough data, create stream and forward data
                        this._startDecodeStream(callback);
                    }
                    else {
                        // only buffering
                        callback();
                    }
                };
                class_1.prototype._startDecodeStream = function (callback) {
                    var _this = this;
                    this._decodeStreamConstruction = winjs_base_1.TPromise.as(detectEncodingFromBuffer({
                        buffer: Buffer.concat(this._buffer), bytesRead: this._bytesBuffered
                    }, options.guessEncoding)).then(function (detected) {
                        detected.encoding = options.overwriteEncoding(detected.encoding);
                        _this._decodeStream = decodeStream(detected.encoding);
                        for (var _i = 0, _a = _this._buffer; _i < _a.length; _i++) {
                            var buffer = _a[_i];
                            _this._decodeStream.write(buffer);
                        }
                        callback();
                        resolve({ detected: detected, stream: _this._decodeStream });
                    }, function (err) {
                        _this.emit('error', err);
                        callback(err);
                    });
                };
                class_1.prototype._finish = function () {
                    var _this = this;
                    if (this._decodeStream) {
                        // normal finish
                        this._decodeStream.end();
                    }
                    else {
                        // we were still waiting for data...
                        this._startDecodeStream(function () { return _this._decodeStream.end(); });
                    }
                };
                return class_1;
            }(stream_1.Writable)));
        });
    }
    exports.toDecodeStream = toDecodeStream;
    function bomLength(encoding) {
        switch (encoding) {
            case exports.UTF8:
                return 3;
            case exports.UTF16be:
            case exports.UTF16le:
                return 2;
        }
        return 0;
    }
    exports.bomLength = bomLength;
    function decode(buffer, encoding) {
        return iconv.decode(buffer, toNodeEncoding(encoding));
    }
    exports.decode = decode;
    function encode(content, encoding, options) {
        return iconv.encode(content, toNodeEncoding(encoding), options);
    }
    exports.encode = encode;
    function encodingExists(encoding) {
        return iconv.encodingExists(toNodeEncoding(encoding));
    }
    exports.encodingExists = encodingExists;
    function decodeStream(encoding) {
        return iconv.decodeStream(toNodeEncoding(encoding));
    }
    exports.decodeStream = decodeStream;
    function encodeStream(encoding, options) {
        return iconv.encodeStream(toNodeEncoding(encoding), options);
    }
    exports.encodeStream = encodeStream;
    function toNodeEncoding(enc) {
        if (enc === exports.UTF8_with_bom) {
            return exports.UTF8; // iconv does not distinguish UTF 8 with or without BOM, so we need to help it
        }
        return enc;
    }
    function detectEncodingByBOMFromBuffer(buffer, bytesRead) {
        if (!buffer || bytesRead < 2) {
            return null;
        }
        var b0 = buffer.readUInt8(0);
        var b1 = buffer.readUInt8(1);
        // UTF-16 BE
        if (b0 === 0xFE && b1 === 0xFF) {
            return exports.UTF16be;
        }
        // UTF-16 LE
        if (b0 === 0xFF && b1 === 0xFE) {
            return exports.UTF16le;
        }
        if (bytesRead < 3) {
            return null;
        }
        var b2 = buffer.readUInt8(2);
        // UTF-8
        if (b0 === 0xEF && b1 === 0xBB && b2 === 0xBF) {
            return exports.UTF8;
        }
        return null;
    }
    exports.detectEncodingByBOMFromBuffer = detectEncodingByBOMFromBuffer;
    /**
     * Detects the Byte Order Mark in a given file.
     * If no BOM is detected, null will be passed to callback.
     */
    function detectEncodingByBOM(file) {
        return stream.readExactlyByFile(file, 3).then(function (_a) {
            var buffer = _a.buffer, bytesRead = _a.bytesRead;
            return detectEncodingByBOMFromBuffer(buffer, bytesRead);
        });
    }
    exports.detectEncodingByBOM = detectEncodingByBOM;
    var MINIMUM_THRESHOLD = 0.2;
    var IGNORE_ENCODINGS = ['ascii', 'utf-8', 'utf-16', 'utf-32'];
    /**
     * Guesses the encoding from buffer.
     */
    function guessEncodingByBuffer(buffer) {
        return async_1.toWinJsPromise(new Promise(function (resolve_1, reject_1) { require(['jschardet'], resolve_1, reject_1); })).then(function (jschardet) {
            jschardet.Constants.MINIMUM_THRESHOLD = MINIMUM_THRESHOLD;
            var guessed = jschardet.detect(buffer);
            if (!guessed || !guessed.encoding) {
                return null;
            }
            var enc = guessed.encoding.toLowerCase();
            // Ignore encodings that cannot guess correctly
            // (http://chardet.readthedocs.io/en/latest/supported-encodings.html)
            if (0 <= IGNORE_ENCODINGS.indexOf(enc)) {
                return null;
            }
            return toIconvLiteEncoding(guessed.encoding);
        });
    }
    exports.guessEncodingByBuffer = guessEncodingByBuffer;
    var JSCHARDET_TO_ICONV_ENCODINGS = {
        'ibm866': 'cp866',
        'big5': 'cp950'
    };
    function toIconvLiteEncoding(encodingName) {
        var normalizedEncodingName = encodingName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
        var mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];
        return mapped || normalizedEncodingName;
    }
    /**
     * The encodings that are allowed in a settings file don't match the canonical encoding labels specified by WHATWG.
     * See https://encoding.spec.whatwg.org/#names-and-labels
     * Iconv-lite strips all non-alphanumeric characters, but ripgrep doesn't. For backcompat, allow these labels.
     */
    function toCanonicalName(enc) {
        switch (enc) {
            case 'shiftjis':
                return 'shift-jis';
            case 'utf16le':
                return 'utf-16le';
            case 'utf16be':
                return 'utf-16be';
            case 'big5hkscs':
                return 'big5-hkscs';
            case 'eucjp':
                return 'euc-jp';
            case 'euckr':
                return 'euc-kr';
            case 'koi8r':
                return 'koi8-r';
            case 'koi8u':
                return 'koi8-u';
            case 'macroman':
                return 'x-mac-roman';
            case 'utf8bom':
                return 'utf8';
            default:
                var m = enc.match(/windows(\d+)/);
                if (m) {
                    return 'windows-' + m[1];
                }
                return enc;
        }
    }
    exports.toCanonicalName = toCanonicalName;
    var ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512; // number of bytes to look at to decide about a file being binary or not
    var NO_GUESS_BUFFER_MAX_LEN = 512; // when not auto guessing the encoding, small number of bytes are enough
    var AUTO_GUESS_BUFFER_MAX_LEN = 512 * 8; // with auto guessing we want a lot more content to be read for guessing
    function detectEncodingFromBuffer(_a, autoGuessEncoding) {
        var buffer = _a.buffer, bytesRead = _a.bytesRead;
        // Always first check for BOM to find out about encoding
        var encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);
        // Detect 0 bytes to see if file is binary or UTF-16 LE/BE
        // unless we already know that this file has a UTF-16 encoding
        var seemsBinary = false;
        if (encoding !== exports.UTF16be && encoding !== exports.UTF16le) {
            var couldBeUTF16LE = true; // e.g. 0xAA 0x00
            var couldBeUTF16BE = true; // e.g. 0x00 0xAA
            var containsZeroByte = false;
            // This is a simplified guess to detect UTF-16 BE or LE by just checking if
            // the first 512 bytes have the 0-byte at a specific location. For UTF-16 LE
            // this would be the odd byte index and for UTF-16 BE the even one.
            // Note: this can produce false positives (a binary file that uses a 2-byte
            // encoding of the same format as UTF-16) and false negatives (a UTF-16 file
            // that is using 4 bytes to encode a character).
            for (var i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {
                var isEndian = (i % 2 === 1); // assume 2-byte sequences typical for UTF-16
                var isZeroByte = (buffer.readInt8(i) === 0);
                if (isZeroByte) {
                    containsZeroByte = true;
                }
                // UTF-16 LE: expect e.g. 0xAA 0x00
                if (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {
                    couldBeUTF16LE = false;
                }
                // UTF-16 BE: expect e.g. 0x00 0xAA
                if (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {
                    couldBeUTF16BE = false;
                }
                // Return if this is neither UTF16-LE nor UTF16-BE and thus treat as binary
                if (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {
                    break;
                }
            }
            // Handle case of 0-byte included
            if (containsZeroByte) {
                if (couldBeUTF16LE) {
                    encoding = exports.UTF16le;
                }
                else if (couldBeUTF16BE) {
                    encoding = exports.UTF16be;
                }
                else {
                    seemsBinary = true;
                }
            }
        }
        // Auto guess encoding if configured
        if (autoGuessEncoding && !seemsBinary && !encoding) {
            return guessEncodingByBuffer(buffer.slice(0, bytesRead)).then(function (encoding) {
                return {
                    seemsBinary: false,
                    encoding: encoding
                };
            });
        }
        return { seemsBinary: seemsBinary, encoding: encoding };
    }
    exports.detectEncodingFromBuffer = detectEncodingFromBuffer;
    // https://ss64.com/nt/chcp.html
    var windowsTerminalEncodings = {
        '437': 'cp437',
        '850': 'cp850',
        '852': 'cp852',
        '855': 'cp855',
        '857': 'cp857',
        '860': 'cp860',
        '861': 'cp861',
        '863': 'cp863',
        '865': 'cp865',
        '866': 'cp866',
        '869': 'cp869',
        '936': 'cp936',
        '1252': 'cp1252' // West European Latin
    };
    function resolveTerminalEncoding(verbose) {
        var rawEncodingPromise;
        // Support a global environment variable to win over other mechanics
        var cliEncodingEnv = process.env['VSCODE_CLI_ENCODING'];
        if (cliEncodingEnv) {
            if (verbose) {
                console.log("Found VSCODE_CLI_ENCODING variable: " + cliEncodingEnv);
            }
            rawEncodingPromise = winjs_base_1.TPromise.as(cliEncodingEnv);
        }
        // Linux/Mac: use "locale charmap" command
        else if (platform_1.isLinux || platform_1.isMacintosh) {
            rawEncodingPromise = new winjs_base_1.TPromise(function (c) {
                if (verbose) {
                    console.log('Running "locale charmap" to detect terminal encoding...');
                }
                child_process_1.exec('locale charmap', function (err, stdout, stderr) { return c(stdout); });
            });
        }
        // Windows: educated guess
        else {
            rawEncodingPromise = new winjs_base_1.TPromise(function (c) {
                if (verbose) {
                    console.log('Running "chcp" to detect terminal encoding...');
                }
                child_process_1.exec('chcp', function (err, stdout, stderr) {
                    if (stdout) {
                        var windowsTerminalEncodingKeys = Object.keys(windowsTerminalEncodings);
                        for (var i = 0; i < windowsTerminalEncodingKeys.length; i++) {
                            var key = windowsTerminalEncodingKeys[i];
                            if (stdout.indexOf(key) >= 0) {
                                return c(windowsTerminalEncodings[key]);
                            }
                        }
                    }
                    return c(void 0);
                });
            });
        }
        return rawEncodingPromise.then(function (rawEncoding) {
            if (verbose) {
                console.log("Detected raw terminal encoding: " + rawEncoding);
            }
            if (!rawEncoding || rawEncoding.toLowerCase() === 'utf-8' || rawEncoding.toLowerCase() === exports.UTF8) {
                return exports.UTF8;
            }
            var iconvEncoding = toIconvLiteEncoding(rawEncoding);
            if (iconv.encodingExists(iconvEncoding)) {
                return iconvEncoding;
            }
            if (verbose) {
                console.log('Unsupported terminal encoding, falling back to UTF-8.');
            }
            return exports.UTF8;
        });
    }
    exports.resolveTerminalEncoding = resolveTerminalEncoding;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[68/*vs/base/node/extfs*/], __M([0/*require*/,1/*exports*/,49/*fs*/,22/*path*/,12/*vs/base/common/async*/,114/*vs/base/common/normalization*/,10/*vs/base/common/platform*/,8/*vs/base/common/strings*/,44/*vs/base/common/uuid*/,2/*vs/base/common/winjs.base*/,90/*vs/base/node/encoding*/,142/*vs/base/node/flow*/]), function (require, exports, fs, paths, async_1, normalization_1, platform, strings, uuid, winjs_base_1, encoding_1, flow) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var loop = flow.loop;
    function readdirSync(path) {
        // Mac: uses NFD unicode form on disk, but we want NFC
        // See also https://github.com/nodejs/node/issues/2165
        if (platform.isMacintosh) {
            return fs.readdirSync(path).map(function (c) { return normalization_1.normalizeNFC(c); });
        }
        return fs.readdirSync(path);
    }
    exports.readdirSync = readdirSync;
    function readdir(path, callback) {
        // Mac: uses NFD unicode form on disk, but we want NFC
        // See also https://github.com/nodejs/node/issues/2165
        if (platform.isMacintosh) {
            return fs.readdir(path, function (error, children) {
                if (error) {
                    return callback(error, null);
                }
                return callback(null, children.map(function (c) { return normalization_1.normalizeNFC(c); }));
            });
        }
        return fs.readdir(path, callback);
    }
    exports.readdir = readdir;
    function statLink(path, callback) {
        fs.lstat(path, function (error, lstat) {
            if (error || lstat.isSymbolicLink()) {
                fs.stat(path, function (error, stat) {
                    if (error) {
                        return callback(error, null);
                    }
                    callback(null, { stat: stat, isSymbolicLink: lstat && lstat.isSymbolicLink() });
                });
            }
            else {
                callback(null, { stat: lstat, isSymbolicLink: false });
            }
        });
    }
    exports.statLink = statLink;
    function copy(source, target, callback, copiedSources) {
        if (!copiedSources) {
            copiedSources = Object.create(null);
        }
        fs.stat(source, function (error, stat) {
            if (error) {
                return callback(error);
            }
            if (!stat.isDirectory()) {
                return doCopyFile(source, target, stat.mode & 511, callback);
            }
            if (copiedSources[source]) {
                return callback(null); // escape when there are cycles (can happen with symlinks)
            }
            copiedSources[source] = true; // remember as copied
            var proceed = function () {
                readdir(source, function (err, files) {
                    loop(files, function (file, clb) {
                        copy(paths.join(source, file), paths.join(target, file), function (error) { return clb(error, void 0); }, copiedSources);
                    }, callback);
                });
            };
            mkdirp(target, stat.mode & 511).done(proceed, proceed);
        });
    }
    exports.copy = copy;
    function doCopyFile(source, target, mode, callback) {
        var reader = fs.createReadStream(source);
        var writer = fs.createWriteStream(target, { mode: mode });
        var finished = false;
        var finish = function (error) {
            if (!finished) {
                finished = true;
                // in error cases, pass to callback
                if (error) {
                    callback(error);
                }
                // we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104
                else {
                    fs.chmod(target, mode, callback);
                }
            }
        };
        // handle errors properly
        reader.once('error', function (error) { return finish(error); });
        writer.once('error', function (error) { return finish(error); });
        // we are done (underlying fd has been closed)
        writer.once('close', function () { return finish(); });
        // start piping
        reader.pipe(writer);
    }
    function mkdirp(path, mode) {
        var mkdir = function () {
            return async_1.nfcall(fs.mkdir, path, mode).then(null, function (mkdirErr) {
                // ENOENT: a parent folder does not exist yet
                if (mkdirErr.code === 'ENOENT') {
                    return winjs_base_1.TPromise.wrapError(mkdirErr);
                }
                // Any other error: check if folder exists and
                // return normally in that case if its a folder
                return async_1.nfcall(fs.stat, path).then(function (stat) {
                    if (!stat.isDirectory()) {
                        return winjs_base_1.TPromise.wrapError(new Error("'" + path + "' exists and is not a directory."));
                    }
                    return null;
                }, function (statErr) {
                    return winjs_base_1.TPromise.wrapError(mkdirErr); // bubble up original mkdir error
                });
            });
        };
        // stop at root
        if (path === paths.dirname(path)) {
            return winjs_base_1.TPromise.as(true);
        }
        // recursively mkdir
        return mkdir().then(null, function (err) {
            // ENOENT: a parent folder does not exist yet, continue
            // to create the parent folder and then try again.
            if (err.code === 'ENOENT') {
                return mkdirp(paths.dirname(path), mode).then(mkdir);
            }
            // Any other error
            return winjs_base_1.TPromise.wrapError(err);
        });
    }
    exports.mkdirp = mkdirp;
    // Deletes the given path by first moving it out of the workspace. This has two benefits. For one, the operation can return fast because
    // after the rename, the contents are out of the workspace although not yet deleted. The greater benefit however is that this operation
    // will fail in case any file is used by another process. fs.unlink() in node will not bail if a file unlinked is used by another process.
    // However, the consequences are bad as outlined in all the related bugs from https://github.com/joyent/node/issues/7164
    function del(path, tmpFolder, callback, done) {
        fs.exists(path, function (exists) {
            if (!exists) {
                return callback(null);
            }
            fs.stat(path, function (err, stat) {
                if (err || !stat) {
                    return callback(err);
                }
                // Special windows workaround: A file or folder that ends with a "." cannot be moved to another place
                // because it is not a valid file name. In this case, we really have to do the deletion without prior move.
                if (path[path.length - 1] === '.' || strings.endsWith(path, './') || strings.endsWith(path, '.\\')) {
                    return rmRecursive(path, callback);
                }
                var pathInTemp = paths.join(tmpFolder, uuid.generateUuid());
                fs.rename(path, pathInTemp, function (error) {
                    if (error) {
                        return rmRecursive(path, callback); // if rename fails, delete without tmp dir
                    }
                    // Return early since the move succeeded
                    callback(null);
                    // do the heavy deletion outside the callers callback
                    rmRecursive(pathInTemp, function (error) {
                        if (error) {
                            console.error(error);
                        }
                        if (done) {
                            done(error);
                        }
                    });
                });
            });
        });
    }
    exports.del = del;
    function rmRecursive(path, callback) {
        if (path === '\\' || path === '/') {
            return callback(new Error('Will not delete root!'));
        }
        fs.exists(path, function (exists) {
            if (!exists) {
                callback(null);
            }
            else {
                fs.lstat(path, function (err, stat) {
                    if (err || !stat) {
                        callback(err);
                    }
                    else if (!stat.isDirectory() || stat.isSymbolicLink() /* !!! never recurse into links when deleting !!! */) {
                        var mode = stat.mode;
                        if (!(mode & 128)) { // 128 === 0200
                            fs.chmod(path, mode | 128, function (err) {
                                if (err) {
                                    callback(err);
                                }
                                else {
                                    fs.unlink(path, callback);
                                }
                            });
                        }
                        else {
                            fs.unlink(path, callback);
                        }
                    }
                    else {
                        readdir(path, function (err, children) {
                            if (err || !children) {
                                callback(err);
                            }
                            else if (children.length === 0) {
                                fs.rmdir(path, callback);
                            }
                            else {
                                var firstError_1 = null;
                                var childrenLeft_1 = children.length;
                                children.forEach(function (child) {
                                    rmRecursive(paths.join(path, child), function (err) {
                                        childrenLeft_1--;
                                        if (err) {
                                            firstError_1 = firstError_1 || err;
                                        }
                                        if (childrenLeft_1 === 0) {
                                            if (firstError_1) {
                                                callback(firstError_1);
                                            }
                                            else {
                                                fs.rmdir(path, callback);
                                            }
                                        }
                                    });
                                });
                            }
                        });
                    }
                });
            }
        });
    }
    function delSync(path) {
        try {
            var stat = fs.lstatSync(path);
            if (stat.isDirectory() && !stat.isSymbolicLink()) {
                readdirSync(path).forEach(function (child) { return delSync(paths.join(path, child)); });
                fs.rmdirSync(path);
            }
            else {
                fs.unlinkSync(path);
            }
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return; // not found
            }
            throw err;
        }
    }
    exports.delSync = delSync;
    function mv(source, target, callback) {
        if (source === target) {
            return callback(null);
        }
        function updateMtime(err) {
            if (err) {
                return callback(err);
            }
            fs.stat(target, function (error, stat) {
                if (error) {
                    return callback(error);
                }
                if (stat.isDirectory()) {
                    return callback(null);
                }
                fs.open(target, 'a', null, function (err, fd) {
                    if (err) {
                        return callback(err);
                    }
                    fs.futimes(fd, stat.atime, new Date(), function (err) {
                        if (err) {
                            return callback(err);
                        }
                        fs.close(fd, callback);
                    });
                });
            });
        }
        // Try native rename()
        fs.rename(source, target, function (err) {
            if (!err) {
                return updateMtime(null);
            }
            // In two cases we fallback to classic copy and delete:
            //
            // 1.) The EXDEV error indicates that source and target are on different devices
            // In this case, fallback to using a copy() operation as there is no way to
            // rename() between different devices.
            //
            // 2.) The user tries to rename a file/folder that ends with a dot. This is not
            // really possible to move then, at least on UNC devices.
            if (err && source.toLowerCase() !== target.toLowerCase() && (err.code === 'EXDEV') || strings.endsWith(source, '.')) {
                return copy(source, target, function (err) {
                    if (err) {
                        return callback(err);
                    }
                    rmRecursive(source, updateMtime);
                });
            }
            return callback(err);
        });
    }
    exports.mv = mv;
    var canFlush = true;
    function writeFileAndFlush(path, data, options, callback) {
        options = ensureOptions(options);
        if (typeof data === 'string' || Buffer.isBuffer(data)) {
            doWriteFileAndFlush(path, data, options, callback);
        }
        else {
            doWriteFileStreamAndFlush(path, data, options, callback);
        }
    }
    exports.writeFileAndFlush = writeFileAndFlush;
    function doWriteFileStreamAndFlush(path, reader, options, callback) {
        // finish only once
        var finished = false;
        var finish = function (error) {
            if (!finished) {
                finished = true;
                // in error cases we need to manually close streams
                // if the write stream was successfully opened
                if (error) {
                    if (isOpen) {
                        writer.once('close', function () { return callback(error); });
                        writer.close();
                    }
                    else {
                        callback(error);
                    }
                }
                // otherwise just return without error
                else {
                    callback();
                }
            }
        };
        // create writer to target. we set autoClose: false because we want to use the streams
        // file descriptor to call fs.fdatasync to ensure the data is flushed to disk
        var writer = fs.createWriteStream(path, { mode: options.mode, flags: options.flag, autoClose: false });
        // Event: 'open'
        // Purpose: save the fd for later use and start piping
        // Notes: will not be called when there is an error opening the file descriptor!
        var fd;
        var isOpen;
        writer.once('open', function (descriptor) {
            fd = descriptor;
            isOpen = true;
            // if an encoding is provided, we need to pipe the stream through
            // an encoder stream and forward the encoding related options
            if (options.encoding) {
                reader = reader.pipe(encoding_1.encodeStream(options.encoding.charset, { addBOM: options.encoding.addBOM }));
            }
            // start data piping only when we got a successful open. this ensures that we do
            // not consume the stream when an error happens and helps to fix this issue:
            // https://github.com/Microsoft/vscode/issues/42542
            reader.pipe(writer);
        });
        // Event: 'error'
        // Purpose: to return the error to the outside and to close the write stream (does not happen automatically)
        reader.once('error', function (error) { return finish(error); });
        writer.once('error', function (error) { return finish(error); });
        // Event: 'finish'
        // Purpose: use fs.fdatasync to flush the contents to disk
        // Notes: event is called when the writer has finished writing to the underlying resource. we must call writer.close()
        // because we have created the WriteStream with autoClose: false
        writer.once('finish', function () {
            // flush to disk
            if (canFlush && isOpen) {
                fs.fdatasync(fd, function (syncError) {
                    // In some exotic setups it is well possible that node fails to sync
                    // In that case we disable flushing and warn to the console
                    if (syncError) {
                        console.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);
                        canFlush = false;
                    }
                    writer.close();
                });
            }
            else {
                writer.close();
            }
        });
        // Event: 'close'
        // Purpose: signal we are done to the outside
        // Notes: event is called when the writer's filedescriptor is closed
        writer.once('close', function () { return finish(); });
    }
    // Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk
    // We do this in cases where we want to make sure the data is really on disk and
    // not in some cache.
    //
    // See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194
    function doWriteFileAndFlush(path, data, options, callback) {
        if (options.encoding) {
            data = encoding_1.encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });
        }
        if (!canFlush) {
            return fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);
        }
        // Open the file with same flags and mode as fs.writeFile()
        fs.open(path, options.flag, options.mode, function (openError, fd) {
            if (openError) {
                return callback(openError);
            }
            // It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!
            fs.writeFile(fd, data, function (writeError) {
                if (writeError) {
                    return fs.close(fd, function () { return callback(writeError); }); // still need to close the handle on error!
                }
                // Flush contents (not metadata) of the file to disk
                fs.fdatasync(fd, function (syncError) {
                    // In some exotic setups it is well possible that node fails to sync
                    // In that case we disable flushing and warn to the console
                    if (syncError) {
                        console.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);
                        canFlush = false;
                    }
                    return fs.close(fd, function (closeError) { return callback(closeError); });
                });
            });
        });
    }
    function writeFileAndFlushSync(path, data, options) {
        options = ensureOptions(options);
        if (options.encoding) {
            data = encoding_1.encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });
        }
        if (!canFlush) {
            return fs.writeFileSync(path, data, { mode: options.mode, flag: options.flag });
        }
        // Open the file with same flags and mode as fs.writeFile()
        var fd = fs.openSync(path, options.flag, options.mode);
        try {
            // It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!
            fs.writeFileSync(fd, data);
            // Flush contents (not metadata) of the file to disk
            try {
                fs.fdatasyncSync(fd);
            }
            catch (syncError) {
                console.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);
                canFlush = false;
            }
        }
        finally {
            fs.closeSync(fd);
        }
    }
    exports.writeFileAndFlushSync = writeFileAndFlushSync;
    function ensureOptions(options) {
        if (!options) {
            return { mode: 438, flag: 'w' };
        }
        var ensuredOptions = { mode: options.mode, flag: options.flag, encoding: options.encoding };
        if (typeof ensuredOptions.mode !== 'number') {
            ensuredOptions.mode = 438;
        }
        if (typeof ensuredOptions.flag !== 'string') {
            ensuredOptions.flag = 'w';
        }
        return ensuredOptions;
    }
    /**
     * Copied from: https://github.com/Microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83
     *
     * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.
     * On a case insensitive file system, the returned path might differ from the original path by character casing.
     * On a case sensitive file system, the returned path will always be identical to the original path.
     * In case of errors, null is returned. But you cannot use this function to verify that a path exists.
     * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.
     */
    function realcaseSync(path) {
        var dir = paths.dirname(path);
        if (path === dir) { // end recursion
            return path;
        }
        var name = (paths.basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();
        try {
            var entries = readdirSync(dir);
            var found = entries.filter(function (e) { return e.toLowerCase() === name; }); // use a case insensitive search
            if (found.length === 1) {
                // on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition
                var prefix = realcaseSync(dir); // recurse
                if (prefix) {
                    return paths.join(prefix, found[0]);
                }
            }
            else if (found.length > 1) {
                // must be a case sensitive $filesystem
                var ix = found.indexOf(name);
                if (ix >= 0) { // case sensitive
                    var prefix = realcaseSync(dir); // recurse
                    if (prefix) {
                        return paths.join(prefix, found[ix]);
                    }
                }
            }
        }
        catch (error) {
            // silently ignore error
        }
        return null;
    }
    exports.realcaseSync = realcaseSync;
    function realpathSync(path) {
        try {
            return fs.realpathSync(path);
        }
        catch (error) {
            // We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization
            // we now do a similar normalization and then try again if we can access the path with read
            // permissions at least. If that succeeds, we return that path.
            // fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is
            // to not resolve links but to simply see if the path is read accessible or not.
            var normalizedPath = normalizePath(path);
            fs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error
            return normalizedPath;
        }
    }
    exports.realpathSync = realpathSync;
    function realpath(path, callback) {
        return fs.realpath(path, function (error, realpath) {
            if (!error) {
                return callback(null, realpath);
            }
            // We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization
            // we now do a similar normalization and then try again if we can access the path with read
            // permissions at least. If that succeeds, we return that path.
            // fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is
            // to not resolve links but to simply see if the path is read accessible or not.
            var normalizedPath = normalizePath(path);
            return fs.access(normalizedPath, fs.constants.R_OK, function (error) {
                return callback(error, normalizedPath);
            });
        });
    }
    exports.realpath = realpath;
    function normalizePath(path) {
        return strings.rtrim(paths.normalize(path), paths.sep);
    }
    function watch(path, onChange, onError) {
        try {
            var watcher = fs.watch(path);
            watcher.on('change', function (type, raw) {
                var file = null;
                if (raw) { // https://github.com/Microsoft/vscode/issues/38191
                    file = raw.toString();
                    if (platform.isMacintosh) {
                        // Mac: uses NFD unicode form on disk, but we want NFC
                        // See also https://github.com/nodejs/node/issues/2165
                        file = normalization_1.normalizeNFC(file);
                    }
                }
                onChange(type, file);
            });
            watcher.on('error', function (code, signal) { return onError("Failed to watch " + path + " for changes (" + code + ", " + signal + ")"); });
            return watcher;
        }
        catch (error) {
            fs.exists(path, function (exists) {
                if (exists) {
                    onError("Failed to watch " + path + " for changes (" + error.toString() + ")");
                }
            });
        }
        return void 0;
    }
    exports.watch = watch;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[47/*vs/base/node/pfs*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,68/*vs/base/node/extfs*/,22/*path*/,12/*vs/base/common/async*/,49/*fs*/,37/*os*/,10/*vs/base/common/platform*/,3/*vs/base/common/event*/]), function (require, exports, winjs_base_1, extfs, path_1, async_1, fs, os, platform, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function readdir(path) {
        return async_1.nfcall(extfs.readdir, path);
    }
    exports.readdir = readdir;
    function exists(path) {
        return new winjs_base_1.TPromise(function (c) { return fs.exists(path, c); }, function () { });
    }
    exports.exists = exists;
    function chmod(path, mode) {
        return async_1.nfcall(fs.chmod, path, mode);
    }
    exports.chmod = chmod;
    exports.mkdirp = extfs.mkdirp;
    function rimraf(path) {
        return lstat(path).then(function (stat) {
            if (stat.isDirectory() && !stat.isSymbolicLink()) {
                return readdir(path)
                    .then(function (children) { return winjs_base_1.TPromise.join(children.map(function (child) { return rimraf(path_1.join(path, child)); })); })
                    .then(function () { return rmdir(path); });
            }
            else {
                return unlink(path);
            }
        }, function (err) {
            if (err.code === 'ENOENT') {
                return void 0;
            }
            return winjs_base_1.TPromise.wrapError(err);
        });
    }
    exports.rimraf = rimraf;
    function realpath(path) {
        return async_1.nfcall(extfs.realpath, path);
    }
    exports.realpath = realpath;
    function stat(path) {
        return async_1.nfcall(fs.stat, path);
    }
    exports.stat = stat;
    function statLink(path) {
        return async_1.nfcall(extfs.statLink, path);
    }
    exports.statLink = statLink;
    function lstat(path) {
        return async_1.nfcall(fs.lstat, path);
    }
    exports.lstat = lstat;
    function rename(oldPath, newPath) {
        return async_1.nfcall(fs.rename, oldPath, newPath);
    }
    exports.rename = rename;
    function rmdir(path) {
        return async_1.nfcall(fs.rmdir, path);
    }
    exports.rmdir = rmdir;
    function unlink(path) {
        return async_1.nfcall(fs.unlink, path);
    }
    exports.unlink = unlink;
    function symlink(target, path, type) {
        return async_1.nfcall(fs.symlink, target, path, type);
    }
    exports.symlink = symlink;
    function readlink(path) {
        return async_1.nfcall(fs.readlink, path);
    }
    exports.readlink = readlink;
    function truncate(path, len) {
        return async_1.nfcall(fs.truncate, path, len);
    }
    exports.truncate = truncate;
    function readFile(path, encoding) {
        return async_1.nfcall(fs.readFile, path, encoding);
    }
    exports.readFile = readFile;
    // According to node.js docs (https://nodejs.org/docs/v6.5.0/api/fs.html#fs_fs_writefile_file_data_options_callback)
    // it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.
    // Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.
    var writeFilePathQueue = Object.create(null);
    function writeFile(path, data, options) {
        var queueKey = toQueueKey(path);
        return ensureWriteFileQueue(queueKey).queue(function () { return async_1.nfcall(extfs.writeFileAndFlush, path, data, options); });
    }
    exports.writeFile = writeFile;
    function toQueueKey(path) {
        var queueKey = path;
        if (platform.isWindows || platform.isMacintosh) {
            queueKey = queueKey.toLowerCase(); // accomodate for case insensitive file systems
        }
        return queueKey;
    }
    function ensureWriteFileQueue(queueKey) {
        var writeFileQueue = writeFilePathQueue[queueKey];
        if (!writeFileQueue) {
            writeFileQueue = new async_1.Queue();
            writeFilePathQueue[queueKey] = writeFileQueue;
            var onFinish = event_1.once(writeFileQueue.onFinished);
            onFinish(function () {
                delete writeFilePathQueue[queueKey];
                writeFileQueue.dispose();
            });
        }
        return writeFileQueue;
    }
    /**
    * Read a dir and return only subfolders
    */
    function readDirsInDir(dirPath) {
        return readdir(dirPath).then(function (children) {
            return winjs_base_1.TPromise.join(children.map(function (c) { return dirExists(path_1.join(dirPath, c)); })).then(function (exists) {
                return children.filter(function (_, i) { return exists[i]; });
            });
        });
    }
    exports.readDirsInDir = readDirsInDir;
    /**
    * `path` exists and is a directory
    */
    function dirExists(path) {
        return stat(path).then(function (stat) { return stat.isDirectory(); }, function () { return false; });
    }
    exports.dirExists = dirExists;
    /**
    * `path` exists and is a file.
    */
    function fileExists(path) {
        return stat(path).then(function (stat) { return stat.isFile(); }, function () { return false; });
    }
    exports.fileExists = fileExists;
    /**
     * Deletes a path from disk.
     */
    var _tmpDir = null;
    function getTmpDir() {
        if (!_tmpDir) {
            _tmpDir = os.tmpdir();
        }
        return _tmpDir;
    }
    function del(path, tmp) {
        if (tmp === void 0) { tmp = getTmpDir(); }
        return async_1.nfcall(extfs.del, path, tmp);
    }
    exports.del = del;
    function whenDeleted(path) {
        // Complete when wait marker file is deleted
        return new winjs_base_1.TPromise(function (c) {
            var running = false;
            var interval = setInterval(function () {
                if (!running) {
                    running = true;
                    fs.exists(path, function (exists) {
                        running = false;
                        if (!exists) {
                            clearInterval(interval);
                            c(null);
                        }
                    });
                }
            }, 1000);
        });
    }
    exports.whenDeleted = whenDeleted;
    function copy(source, target) {
        return async_1.nfcall(extfs.copy, source, target);
    }
    exports.copy = copy;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[53/*vs/base/parts/ipc/common/ipc*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,9/*vs/base/common/lifecycle*/,3/*vs/base/common/event*/]), function (require, exports, winjs_base_1, lifecycle_1, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var MessageType;
    (function (MessageType) {
        MessageType[MessageType["RequestPromise"] = 0] = "RequestPromise";
        MessageType[MessageType["RequestPromiseCancel"] = 1] = "RequestPromiseCancel";
        MessageType[MessageType["ResponseInitialize"] = 2] = "ResponseInitialize";
        MessageType[MessageType["ResponsePromiseSuccess"] = 3] = "ResponsePromiseSuccess";
        MessageType[MessageType["ResponsePromiseProgress"] = 4] = "ResponsePromiseProgress";
        MessageType[MessageType["ResponsePromiseError"] = 5] = "ResponsePromiseError";
        MessageType[MessageType["ResponsePromiseErrorObj"] = 6] = "ResponsePromiseErrorObj";
        MessageType[MessageType["RequestEventListen"] = 7] = "RequestEventListen";
        MessageType[MessageType["RequestEventDispose"] = 8] = "RequestEventDispose";
        MessageType[MessageType["ResponseEventFire"] = 9] = "ResponseEventFire";
    })(MessageType || (MessageType = {}));
    function isResponse(messageType) {
        return messageType === MessageType.ResponseInitialize
            || messageType === MessageType.ResponsePromiseSuccess
            || messageType === MessageType.ResponsePromiseProgress
            || messageType === MessageType.ResponsePromiseError
            || messageType === MessageType.ResponsePromiseErrorObj
            || messageType === MessageType.ResponseEventFire;
    }
    var State;
    (function (State) {
        State[State["Uninitialized"] = 0] = "Uninitialized";
        State[State["Idle"] = 1] = "Idle";
    })(State || (State = {}));
    // TODO@joao cleanup this mess!
    var ChannelServer = /** @class */ (function () {
        function ChannelServer(protocol) {
            var _this = this;
            this.protocol = protocol;
            this.channels = Object.create(null);
            this.activeRequests = Object.create(null);
            this.protocolListener = this.protocol.onMessage(function (r) { return _this.onMessage(r); });
            this.protocol.send({ type: MessageType.ResponseInitialize });
        }
        ChannelServer.prototype.registerChannel = function (channelName, channel) {
            this.channels[channelName] = channel;
        };
        ChannelServer.prototype.onMessage = function (request) {
            switch (request.type) {
                case MessageType.RequestPromise:
                    this.onPromise(request);
                    break;
                case MessageType.RequestEventListen:
                    this.onEventListen(request);
                    break;
                case MessageType.RequestPromiseCancel:
                case MessageType.RequestEventDispose:
                    this.disposeActiveRequest(request);
                    break;
            }
        };
        ChannelServer.prototype.onPromise = function (request) {
            var _this = this;
            var channel = this.channels[request.channelName];
            var promise;
            try {
                promise = channel.call(request.name, request.arg);
            }
            catch (err) {
                promise = winjs_base_1.TPromise.wrapError(err);
            }
            var id = request.id;
            var requestPromise = promise.then(function (data) {
                _this.protocol.send({ id: id, data: data, type: MessageType.ResponsePromiseSuccess });
                delete _this.activeRequests[request.id];
            }, function (data) {
                if (data instanceof Error) {
                    _this.protocol.send({
                        id: id, data: {
                            message: data.message,
                            name: data.name,
                            stack: data.stack ? (data.stack.split ? data.stack.split('\n') : data.stack) : void 0
                        }, type: MessageType.ResponsePromiseError
                    });
                }
                else {
                    _this.protocol.send({ id: id, data: data, type: MessageType.ResponsePromiseErrorObj });
                }
                delete _this.activeRequests[request.id];
            }, function (data) {
                _this.protocol.send({ id: id, data: data, type: MessageType.ResponsePromiseProgress });
            });
            this.activeRequests[request.id] = lifecycle_1.toDisposable(function () { return requestPromise.cancel(); });
        };
        ChannelServer.prototype.onEventListen = function (request) {
            var _this = this;
            var channel = this.channels[request.channelName];
            var id = request.id;
            var event = channel.listen(request.name, request.arg);
            var disposable = event(function (data) { return _this.protocol.send({ id: id, data: data, type: MessageType.ResponseEventFire }); });
            this.activeRequests[request.id] = disposable;
        };
        ChannelServer.prototype.disposeActiveRequest = function (request) {
            var disposable = this.activeRequests[request.id];
            if (disposable) {
                disposable.dispose();
                delete this.activeRequests[request.id];
            }
        };
        ChannelServer.prototype.dispose = function () {
            var _this = this;
            this.protocolListener.dispose();
            this.protocolListener = null;
            Object.keys(this.activeRequests).forEach(function (id) {
                _this.activeRequests[id].dispose();
            });
            this.activeRequests = null;
        };
        return ChannelServer;
    }());
    exports.ChannelServer = ChannelServer;
    var ChannelClient = /** @class */ (function () {
        function ChannelClient(protocol) {
            var _this = this;
            this.protocol = protocol;
            this.state = State.Uninitialized;
            this.activeRequests = [];
            this.bufferedRequests = [];
            this.handlers = Object.create(null);
            this.lastRequestId = 0;
            this._onDidInitialize = new event_1.Emitter();
            this.onDidInitialize = this._onDidInitialize.event;
            this.protocolListener = this.protocol.onMessage(function (r) { return _this.onMessage(r); });
        }
        ChannelClient.prototype.getChannel = function (channelName) {
            var _this = this;
            var call = function (command, arg) { return _this.requestPromise(channelName, command, arg); };
            var listen = function (event, arg) { return _this.requestEvent(channelName, event, arg); };
            return { call: call, listen: listen };
        };
        ChannelClient.prototype.requestPromise = function (channelName, name, arg) {
            var _this = this;
            var id = this.lastRequestId++;
            var type = MessageType.RequestPromise;
            var request = { raw: { id: id, type: type, channelName: channelName, name: name, arg: arg } };
            var activeRequest = this.state === State.Uninitialized
                ? this.bufferRequest(request)
                : this.doRequest(request);
            var disposable = lifecycle_1.toDisposable(function () { return activeRequest.cancel(); });
            this.activeRequests.push(disposable);
            activeRequest
                .then(null, function (_) { return null; })
                .done(function () { return _this.activeRequests = _this.activeRequests.filter(function (el) { return el !== disposable; }); });
            return activeRequest;
        };
        ChannelClient.prototype.requestEvent = function (channelName, name, arg) {
            var _this = this;
            var id = this.lastRequestId++;
            var type = MessageType.RequestEventListen;
            var request = { raw: { id: id, type: type, channelName: channelName, name: name, arg: arg } };
            var uninitializedPromise = null;
            var emitter = new event_1.Emitter({
                onFirstListenerAdd: function () {
                    uninitializedPromise = _this.whenInitialized();
                    uninitializedPromise.then(function () {
                        uninitializedPromise = null;
                        _this.send(request.raw);
                    });
                },
                onLastListenerRemove: function () {
                    if (uninitializedPromise) {
                        uninitializedPromise.cancel();
                        uninitializedPromise = null;
                    }
                    else {
                        _this.send({ id: id, type: MessageType.RequestEventDispose });
                    }
                }
            });
            this.handlers[id] = function (response) { return emitter.fire(response.data); };
            return emitter.event;
        };
        ChannelClient.prototype.doRequest = function (request) {
            var _this = this;
            var id = request.raw.id;
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this.handlers[id] = function (response) {
                    switch (response.type) {
                        case MessageType.ResponsePromiseSuccess:
                            delete _this.handlers[id];
                            c(response.data);
                            break;
                        case MessageType.ResponsePromiseError:
                            delete _this.handlers[id];
                            var error = new Error(response.data.message);
                            error.stack = response.data.stack;
                            error.name = response.data.name;
                            e(error);
                            break;
                        case MessageType.ResponsePromiseErrorObj:
                            delete _this.handlers[id];
                            e(response.data);
                            break;
                        case MessageType.ResponsePromiseProgress:
                            p(response.data);
                            break;
                    }
                };
                _this.send(request.raw);
            }, function () { return _this.send({ id: id, type: MessageType.RequestPromiseCancel }); });
        };
        ChannelClient.prototype.bufferRequest = function (request) {
            var _this = this;
            var flushedRequest = null;
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this.bufferedRequests.push(request);
                request.flush = function () {
                    request.flush = null;
                    flushedRequest = _this.doRequest(request).then(c, e, p);
                };
            }, function () {
                request.flush = null;
                if (_this.state !== State.Uninitialized) {
                    if (flushedRequest) {
                        flushedRequest.cancel();
                        flushedRequest = null;
                    }
                    return;
                }
                var idx = _this.bufferedRequests.indexOf(request);
                if (idx === -1) {
                    return;
                }
                _this.bufferedRequests.splice(idx, 1);
            });
        };
        ChannelClient.prototype.onMessage = function (response) {
            if (!isResponse(response.type)) {
                return;
            }
            if (this.state === State.Uninitialized && response.type === MessageType.ResponseInitialize) {
                this.state = State.Idle;
                this._onDidInitialize.fire();
                this.bufferedRequests.forEach(function (r) { return r.flush && r.flush(); });
                this.bufferedRequests = null;
                return;
            }
            var handler = this.handlers[response.id];
            if (handler) {
                handler(response);
            }
        };
        ChannelClient.prototype.send = function (raw) {
            try {
                this.protocol.send(raw);
            }
            catch (err) {
                // noop
            }
        };
        ChannelClient.prototype.whenInitialized = function () {
            if (this.state === State.Idle) {
                return winjs_base_1.TPromise.as(null);
            }
            else {
                return event_1.toPromise(this.onDidInitialize);
            }
        };
        ChannelClient.prototype.dispose = function () {
            this.protocolListener.dispose();
            this.protocolListener = null;
            this.activeRequests = lifecycle_1.dispose(this.activeRequests);
        };
        return ChannelClient;
    }());
    exports.ChannelClient = ChannelClient;
    /**
     * An `IPCServer` is both a channel server and a routing channel
     * client.
     *
     * As the owner of a protocol, you should extend both this
     * and the `IPCClient` classes to get IPC implementations
     * for your protocol.
     */
    var IPCServer = /** @class */ (function () {
        function IPCServer(onDidClientConnect) {
            var _this = this;
            this.channels = Object.create(null);
            this.channelClients = Object.create(null);
            this.onClientAdded = new event_1.Emitter();
            onDidClientConnect(function (_a) {
                var protocol = _a.protocol, onDidClientDisconnect = _a.onDidClientDisconnect;
                var onFirstMessage = event_1.once(protocol.onMessage);
                onFirstMessage(function (id) {
                    var channelServer = new ChannelServer(protocol);
                    var channelClient = new ChannelClient(protocol);
                    Object.keys(_this.channels)
                        .forEach(function (name) { return channelServer.registerChannel(name, _this.channels[name]); });
                    _this.channelClients[id] = channelClient;
                    _this.onClientAdded.fire(id);
                    onDidClientDisconnect(function () {
                        channelServer.dispose();
                        channelClient.dispose();
                        delete _this.channelClients[id];
                    });
                });
            });
        }
        IPCServer.prototype.getChannel = function (channelName, router) {
            var _this = this;
            var call = function (command, arg) {
                var channelPromise = router.routeCall(command, arg)
                    .then(function (id) { return _this.getClient(id); })
                    .then(function (client) { return client.getChannel(channelName); });
                return getDelayedChannel(channelPromise)
                    .call(command, arg);
            };
            var listen = function (event, arg) {
                var channelPromise = router.routeEvent(event, arg)
                    .then(function (id) { return _this.getClient(id); })
                    .then(function (client) { return client.getChannel(channelName); });
                return getDelayedChannel(channelPromise)
                    .listen(event, arg);
            };
            return { call: call, listen: listen };
        };
        IPCServer.prototype.registerChannel = function (channelName, channel) {
            this.channels[channelName] = channel;
        };
        IPCServer.prototype.getClient = function (clientId) {
            var _this = this;
            if (!clientId) {
                return winjs_base_1.TPromise.wrapError(new Error('Client id should be provided'));
            }
            var client = this.channelClients[clientId];
            if (client) {
                return winjs_base_1.TPromise.as(client);
            }
            return new winjs_base_1.TPromise(function (c) {
                var onClient = event_1.once(event_1.filterEvent(_this.onClientAdded.event, function (id) { return id === clientId; }));
                onClient(function () { return c(_this.channelClients[clientId]); });
            });
        };
        IPCServer.prototype.dispose = function () {
            this.channels = Object.create(null);
            this.channelClients = Object.create(null);
            this.onClientAdded.dispose();
        };
        return IPCServer;
    }());
    exports.IPCServer = IPCServer;
    /**
     * An `IPCClient` is both a channel client and a channel server.
     *
     * As the owner of a protocol, you should extend both this
     * and the `IPCClient` classes to get IPC implementations
     * for your protocol.
     */
    var IPCClient = /** @class */ (function () {
        function IPCClient(protocol, id) {
            protocol.send(id);
            this.channelClient = new ChannelClient(protocol);
            this.channelServer = new ChannelServer(protocol);
        }
        IPCClient.prototype.getChannel = function (channelName) {
            return this.channelClient.getChannel(channelName);
        };
        IPCClient.prototype.registerChannel = function (channelName, channel) {
            this.channelServer.registerChannel(channelName, channel);
        };
        IPCClient.prototype.dispose = function () {
            this.channelClient.dispose();
            this.channelClient = null;
            this.channelServer.dispose();
            this.channelServer = null;
        };
        return IPCClient;
    }());
    exports.IPCClient = IPCClient;
    function getDelayedChannel(promise) {
        var call = function (command, arg) { return promise.then(function (c) { return c.call(command, arg); }); };
        var listen = function (event, arg) {
            var relay = new event_1.Relay();
            promise.then(function (c) { return relay.input = c.listen(event, arg); });
            return relay.event;
        };
        return { call: call, listen: listen };
    }
    exports.getDelayedChannel = getDelayedChannel;
    function getNextTickChannel(channel) {
        var didTick = false;
        var call = function (command, arg) {
            if (didTick) {
                return channel.call(command, arg);
            }
            return winjs_base_1.TPromise.timeout(0)
                .then(function () { return didTick = true; })
                .then(function () { return channel.call(command, arg); });
        };
        var listen = function (event, arg) {
            if (didTick) {
                return channel.listen(event, arg);
            }
            var relay = new event_1.Relay();
            winjs_base_1.TPromise.timeout(0)
                .then(function () { return didTick = true; })
                .then(function () { return relay.input = channel.listen(event, arg); });
            return relay.event;
        };
        return { call: call, listen: listen };
    }
    exports.getNextTickChannel = getNextTickChannel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[116/*vs/base/parts/ipc/node/ipc.net*/], __M([0/*require*/,1/*exports*/,57/*net*/,2/*vs/base/common/winjs.base*/,3/*vs/base/common/event*/,53/*vs/base/parts/ipc/common/ipc*/,22/*path*/,37/*os*/,44/*vs/base/common/uuid*/,12/*vs/base/common/async*/]), function (require, exports, net_1, winjs_base_1, event_1, ipc_1, path_1, os_1, uuid_1, async_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function generateRandomPipeName() {
        var randomSuffix = uuid_1.generateUuid();
        if (process.platform === 'win32') {
            return "\\\\.\\pipe\\vscode-ipc-" + randomSuffix + "-sock";
        }
        else {
            // Mac/Unix: use socket file
            return path_1.join(os_1.tmpdir(), "vscode-ipc-" + randomSuffix + ".sock");
        }
    }
    exports.generateRandomPipeName = generateRandomPipeName;
    var Protocol = /** @class */ (function () {
        function Protocol(_socket, firstDataChunk) {
            var _this = this;
            this._socket = _socket;
            this._onMessage = new event_1.Emitter();
            this.onMessage = this._onMessage.event;
            this._onClose = new event_1.Emitter();
            this.onClose = this._onClose.event;
            this._writeBuffer = new /** @class */ (function () {
                function class_1() {
                    this._data = [];
                    this._totalLength = 0;
                }
                class_1.prototype.add = function (head, body) {
                    var wasEmpty = this._totalLength === 0;
                    this._data.push(head, body);
                    this._totalLength += head.length + body.length;
                    return wasEmpty;
                };
                class_1.prototype.take = function () {
                    var ret = Buffer.concat(this._data, this._totalLength);
                    this._data.length = 0;
                    this._totalLength = 0;
                    return ret;
                };
                return class_1;
            }());
            this._isDisposed = false;
            this._chunks = [];
            var totalLength = 0;
            var state = {
                readHead: true,
                bodyIsJson: false,
                bodyLen: -1,
            };
            var acceptChunk = function (data) {
                _this._chunks.push(data);
                totalLength += data.length;
                while (totalLength > 0) {
                    if (state.readHead) {
                        // expecting header -> read 5bytes for header
                        // information: `bodyIsJson` and `bodyLen`
                        if (totalLength >= Protocol._headerLen) {
                            var all = Buffer.concat(_this._chunks);
                            state.bodyIsJson = all.readInt8(0) === 1;
                            state.bodyLen = all.readInt32BE(1);
                            state.readHead = false;
                            var rest = all.slice(Protocol._headerLen);
                            totalLength = rest.length;
                            _this._chunks = [rest];
                        }
                        else {
                            break;
                        }
                    }
                    if (!state.readHead) {
                        // expecting body -> read bodyLen-bytes for
                        // the actual message or wait for more data
                        if (totalLength >= state.bodyLen) {
                            var all = Buffer.concat(_this._chunks);
                            var message = all.toString('utf8', 0, state.bodyLen);
                            if (state.bodyIsJson) {
                                message = JSON.parse(message);
                            }
                            // ensure the public getBuffer returns a valid value if invoked from the event listeners
                            var rest = all.slice(state.bodyLen);
                            totalLength = rest.length;
                            _this._chunks = [rest];
                            state.bodyIsJson = false;
                            state.bodyLen = -1;
                            state.readHead = true;
                            _this._onMessage.fire(message);
                            if (_this._isDisposed) {
                                // check if an event listener lead to our disposal
                                break;
                            }
                        }
                        else {
                            break;
                        }
                    }
                }
            };
            var acceptFirstDataChunk = function () {
                if (firstDataChunk && firstDataChunk.length > 0) {
                    var tmp = firstDataChunk;
                    firstDataChunk = null;
                    acceptChunk(tmp);
                }
            };
            // Make sure to always handle the firstDataChunk if no more `data` event comes in
            this._firstChunkTimer = new async_1.TimeoutTimer();
            this._firstChunkTimer.setIfNotSet(function () {
                acceptFirstDataChunk();
            }, 0);
            this._socketDataListener = function (data) {
                acceptFirstDataChunk();
                acceptChunk(data);
            };
            _socket.on('data', this._socketDataListener);
            this._socketEndListener = function () {
                acceptFirstDataChunk();
            };
            _socket.on('end', this._socketEndListener);
            this._socketCloseListener = function () {
                _this._onClose.fire();
            };
            _socket.once('close', this._socketCloseListener);
        }
        Protocol.prototype.dispose = function () {
            this._isDisposed = true;
            this._firstChunkTimer.dispose();
            this._socket.removeListener('data', this._socketDataListener);
            this._socket.removeListener('end', this._socketEndListener);
            this._socket.removeListener('close', this._socketCloseListener);
        };
        Protocol.prototype.end = function () {
            this._socket.end();
        };
        Protocol.prototype.getBuffer = function () {
            return Buffer.concat(this._chunks);
        };
        Protocol.prototype.send = function (message) {
            // [bodyIsJson|bodyLen|message]
            // |^header^^^^^^^^^^^|^data^^]
            var header = Buffer.alloc(Protocol._headerLen);
            // ensure string
            if (typeof message !== 'string') {
                message = JSON.stringify(message);
                header.writeInt8(1, 0, true);
            }
            var data = Buffer.from(message);
            header.writeInt32BE(data.length, 1, true);
            this._writeSoon(header, data);
        };
        Protocol.prototype._writeSoon = function (header, data) {
            var _this = this;
            if (this._writeBuffer.add(header, data)) {
                setImmediate(function () {
                    // return early if socket has been destroyed in the meantime
                    if (_this._socket.destroyed) {
                        return;
                    }
                    // we ignore the returned value from `write` because we would have to cached the data
                    // anyways and nodejs is already doing that for us:
                    // > https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback
                    // > However, the false return value is only advisory and the writable stream will unconditionally
                    // > accept and buffer chunk even if it has not not been allowed to drain.
                    _this._socket.write(_this._writeBuffer.take());
                });
            }
        };
        Protocol._headerLen = 5;
        return Protocol;
    }());
    exports.Protocol = Protocol;
    var Server = /** @class */ (function (_super) {
        __extends(Server, _super);
        function Server(server) {
            var _this = _super.call(this, Server.toClientConnectionEvent(server)) || this;
            _this.server = server;
            return _this;
        }
        Server.toClientConnectionEvent = function (server) {
            var onConnection = event_1.fromNodeEventEmitter(server, 'connection');
            return event_1.mapEvent(onConnection, function (socket) { return ({
                protocol: new Protocol(socket),
                onDidClientDisconnect: event_1.once(event_1.fromNodeEventEmitter(socket, 'close'))
            }); });
        };
        Server.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.server.close();
            this.server = null;
        };
        return Server;
    }(ipc_1.IPCServer));
    exports.Server = Server;
    var Client = /** @class */ (function (_super) {
        __extends(Client, _super);
        function Client(protocol, id) {
            var _this = _super.call(this, protocol, id) || this;
            _this.protocol = protocol;
            return _this;
        }
        Client.fromSocket = function (socket, id) {
            return new Client(new Protocol(socket), id);
        };
        Object.defineProperty(Client.prototype, "onClose", {
            get: function () { return this.protocol.onClose; },
            enumerable: true,
            configurable: true
        });
        Client.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.protocol.end();
        };
        return Client;
    }(ipc_1.IPCClient));
    exports.Client = Client;
    function serve(hook) {
        return new winjs_base_1.TPromise(function (c, e) {
            var server = net_1.createServer();
            server.on('error', e);
            server.listen(hook, function () {
                server.removeListener('error', e);
                c(new Server(server));
            });
        });
    }
    exports.serve = serve;
    function connect(hook, clientId) {
        return new winjs_base_1.TPromise(function (c, e) {
            var socket = net_1.createConnection(hook, function () {
                socket.removeListener('error', e);
                c(Client.fromSocket(socket, clientId));
            });
            socket.once('error', e);
        });
    }
    exports.connect = connect;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[118/*vs/base/parts/quickopen/common/quickOpenScorer*/], __M([0/*require*/,1/*exports*/,75/*vs/base/common/comparers*/,89/*vs/base/common/filters*/,16/*vs/base/common/paths*/,10/*vs/base/common/platform*/,8/*vs/base/common/strings*/]), function (require, exports, comparers_1, filters_1, paths_1, platform_1, strings_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var NO_MATCH = 0;
    var NO_SCORE = [NO_MATCH, []];
    // const DEBUG = false;
    // const DEBUG_MATRIX = false;
    function score(target, query, queryLower, fuzzy) {
        if (!target || !query) {
            return NO_SCORE; // return early if target or query are undefined
        }
        var targetLength = target.length;
        var queryLength = query.length;
        if (targetLength < queryLength) {
            return NO_SCORE; // impossible for query to be contained in target
        }
        // if (DEBUG) {
        // 	console.group(`Target: ${target}, Query: ${query}`);
        // }
        var targetLower = target.toLowerCase();
        // When not searching fuzzy, we require the query to be contained fully
        // in the target string contiguously.
        if (!fuzzy) {
            var indexOfQueryInTarget = targetLower.indexOf(queryLower);
            if (indexOfQueryInTarget === -1) {
                // if (DEBUG) {
                // 	console.log(`Characters not matching consecutively ${queryLower} within ${targetLower}`);
                // }
                return NO_SCORE;
            }
        }
        var res = doScore(query, queryLower, queryLength, target, targetLower, targetLength);
        // if (DEBUG) {
        // 	console.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');
        // 	console.groupEnd();
        // }
        return res;
    }
    exports.score = score;
    function doScore(query, queryLower, queryLength, target, targetLower, targetLength) {
        var scores = [];
        var matches = [];
        //
        // Build Scorer Matrix:
        //
        // The matrix is composed of query q and target t. For each index we score
        // q[i] with t[i] and compare that with the previous score. If the score is
        // equal or larger, we keep the match. In addition to the score, we also keep
        // the length of the consecutive matches to use as boost for the score.
        //
        //      t   a   r   g   e   t
        //  q
        //  u
        //  e
        //  r
        //  y
        //
        for (var queryIndex_1 = 0; queryIndex_1 < queryLength; queryIndex_1++) {
            for (var targetIndex_1 = 0; targetIndex_1 < targetLength; targetIndex_1++) {
                var currentIndex = queryIndex_1 * targetLength + targetIndex_1;
                var leftIndex = currentIndex - 1;
                var diagIndex = (queryIndex_1 - 1) * targetLength + targetIndex_1 - 1;
                var leftScore = targetIndex_1 > 0 ? scores[leftIndex] : 0;
                var diagScore = queryIndex_1 > 0 && targetIndex_1 > 0 ? scores[diagIndex] : 0;
                var matchesSequenceLength = queryIndex_1 > 0 && targetIndex_1 > 0 ? matches[diagIndex] : 0;
                // If we are not matching on the first query character any more, we only produce a
                // score if we had a score previously for the last query index (by looking at the diagScore).
                // This makes sure that the query always matches in sequence on the target. For example
                // given a target of "ede" and a query of "de", we would otherwise produce a wrong high score
                // for query[1] ("e") matching on target[0] ("e") because of the "beginning of word" boost.
                var score_1 = void 0;
                if (!diagScore && queryIndex_1 > 0) {
                    score_1 = 0;
                }
                else {
                    score_1 = computeCharScore(query, queryLower, queryIndex_1, target, targetLower, targetIndex_1, matchesSequenceLength);
                }
                // We have a score and its equal or larger than the left score
                // Match: sequence continues growing from previous diag value
                // Score: increases by diag score value
                if (score_1 && diagScore + score_1 >= leftScore) {
                    matches[currentIndex] = matchesSequenceLength + 1;
                    scores[currentIndex] = diagScore + score_1;
                }
                // We either have no score or the score is lower than the left score
                // Match: reset to 0
                // Score: pick up from left hand side
                else {
                    matches[currentIndex] = NO_MATCH;
                    scores[currentIndex] = leftScore;
                }
            }
        }
        // Restore Positions (starting from bottom right of matrix)
        var positions = [];
        var queryIndex = queryLength - 1;
        var targetIndex = targetLength - 1;
        while (queryIndex >= 0 && targetIndex >= 0) {
            var currentIndex = queryIndex * targetLength + targetIndex;
            var match = matches[currentIndex];
            if (match === NO_MATCH) {
                targetIndex--; // go left
            }
            else {
                positions.push(targetIndex);
                // go up and left
                queryIndex--;
                targetIndex--;
            }
        }
        // Print matrix
        // if (DEBUG_MATRIX) {
        // printMatrix(query, target, matches, scores);
        // }
        return [scores[queryLength * targetLength - 1], positions.reverse()];
    }
    function computeCharScore(query, queryLower, queryIndex, target, targetLower, targetIndex, matchesSequenceLength) {
        var score = 0;
        if (queryLower[queryIndex] !== targetLower[targetIndex]) {
            return score; // no match of characters
        }
        // Character match bonus
        score += 1;
        // if (DEBUG) {
        // 	console.groupCollapsed(`%cCharacter match bonus: +1 (char: ${queryLower[queryIndex]} at index ${targetIndex}, total score: ${score})`, 'font-weight: normal');
        // }
        // Consecutive match bonus
        if (matchesSequenceLength > 0) {
            score += (matchesSequenceLength * 5);
            // if (DEBUG) {
            // 	console.log('Consecutive match bonus: ' + (matchesSequenceLength * 5));
            // }
        }
        // Same case bonus
        if (query[queryIndex] === target[targetIndex]) {
            score += 1;
            // if (DEBUG) {
            // 	console.log('Same case bonus: +1');
            // }
        }
        // Start of word bonus
        if (targetIndex === 0) {
            score += 8;
            // if (DEBUG) {
            // 	console.log('Start of word bonus: +8');
            // }
        }
        else {
            // After separator bonus
            var separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));
            if (separatorBonus) {
                score += separatorBonus;
                // if (DEBUG) {
                // 	console.log('After separtor bonus: +4');
                // }
            }
            // Inside word upper case bonus (camel case)
            else if (filters_1.isUpper(target.charCodeAt(targetIndex))) {
                score += 1;
                // if (DEBUG) {
                // 	console.log('Inside word upper case bonus: +1');
                // }
            }
        }
        // if (DEBUG) {
        // 	console.groupEnd();
        // }
        return score;
    }
    function scoreSeparatorAtPos(charCode) {
        switch (charCode) {
            case 47 /* Slash */:
            case 92 /* Backslash */:
                return 5; // prefer path separators...
            case 95 /* Underline */:
            case 45 /* Dash */:
            case 46 /* Period */:
            case 32 /* Space */:
            case 39 /* SingleQuote */:
            case 34 /* DoubleQuote */:
            case 58 /* Colon */:
                return 4; // ...over other separators
            default:
                return 0;
        }
    }
    var NO_ITEM_SCORE = Object.freeze({ score: 0 });
    var PATH_IDENTITY_SCORE = 1 << 18;
    var LABEL_PREFIX_SCORE = 1 << 17;
    var LABEL_CAMELCASE_SCORE = 1 << 16;
    var LABEL_SCORE_THRESHOLD = 1 << 15;
    /**
     * Helper function to prepare a search value for scoring in quick open by removing unwanted characters.
     */
    function prepareQuery(original) {
        var lowercase;
        var containsPathSeparator;
        var value;
        if (original) {
            value = strings_1.stripWildcards(original).replace(/\s/g, ''); // get rid of all wildcards and whitespace
            if (platform_1.isWindows) {
                value = value.replace(/\//g, paths_1.nativeSep); // Help Windows users to search for paths when using slash
            }
            lowercase = value.toLowerCase();
            containsPathSeparator = value.indexOf(paths_1.nativeSep) >= 0;
        }
        return { original: original, value: value, lowercase: lowercase, containsPathSeparator: containsPathSeparator };
    }
    exports.prepareQuery = prepareQuery;
    function scoreItem(item, query, fuzzy, accessor, cache) {
        if (!item || !query.value) {
            return NO_ITEM_SCORE; // we need an item and query to score on at least
        }
        var label = accessor.getItemLabel(item);
        if (!label) {
            return NO_ITEM_SCORE; // we need a label at least
        }
        var description = accessor.getItemDescription(item);
        var cacheHash;
        if (description) {
            cacheHash = "" + label + description + query.value + fuzzy;
        }
        else {
            cacheHash = "" + label + query.value + fuzzy;
        }
        var cached = cache[cacheHash];
        if (cached) {
            return cached;
        }
        var itemScore = doScoreItem(label, description, accessor.getItemPath(item), query, fuzzy);
        cache[cacheHash] = itemScore;
        return itemScore;
    }
    exports.scoreItem = scoreItem;
    function doScoreItem(label, description, path, query, fuzzy) {
        // 1.) treat identity matches on full path highest
        if (path && platform_1.isLinux ? query.original === path : strings_1.equalsIgnoreCase(query.original, path)) {
            return { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : void 0 };
        }
        // We only consider label matches if the query is not including file path separators
        var preferLabelMatches = !path || !query.containsPathSeparator;
        if (preferLabelMatches) {
            // 2.) treat prefix matches on the label second highest
            var prefixLabelMatch = filters_1.matchesPrefix(query.value, label);
            if (prefixLabelMatch) {
                return { score: LABEL_PREFIX_SCORE, labelMatch: prefixLabelMatch };
            }
            // 3.) treat camelcase matches on the label third highest
            var camelcaseLabelMatch = filters_1.matchesCamelCase(query.value, label);
            if (camelcaseLabelMatch) {
                return { score: LABEL_CAMELCASE_SCORE, labelMatch: camelcaseLabelMatch };
            }
            // 4.) prefer scores on the label if any
            var _a = score(label, query.value, query.lowercase, fuzzy), labelScore = _a[0], labelPositions = _a[1];
            if (labelScore) {
                return { score: labelScore + LABEL_SCORE_THRESHOLD, labelMatch: filters_1.createMatches(labelPositions) };
            }
        }
        // 5.) finally compute description + label scores if we have a description
        if (description) {
            var descriptionPrefix = description;
            if (!!path) {
                descriptionPrefix = "" + description + paths_1.nativeSep; // assume this is a file path
            }
            var descriptionPrefixLength_1 = descriptionPrefix.length;
            var descriptionAndLabel = "" + descriptionPrefix + label;
            var _b = score(descriptionAndLabel, query.value, query.lowercase, fuzzy), labelDescriptionScore = _b[0], labelDescriptionPositions = _b[1];
            if (labelDescriptionScore) {
                var labelDescriptionMatches = filters_1.createMatches(labelDescriptionPositions);
                var labelMatch_1 = [];
                var descriptionMatch_1 = [];
                // We have to split the matches back onto the label and description portions
                labelDescriptionMatches.forEach(function (h) {
                    // Match overlaps label and description part, we need to split it up
                    if (h.start < descriptionPrefixLength_1 && h.end > descriptionPrefixLength_1) {
                        labelMatch_1.push({ start: 0, end: h.end - descriptionPrefixLength_1 });
                        descriptionMatch_1.push({ start: h.start, end: descriptionPrefixLength_1 });
                    }
                    // Match on label part
                    else if (h.start >= descriptionPrefixLength_1) {
                        labelMatch_1.push({ start: h.start - descriptionPrefixLength_1, end: h.end - descriptionPrefixLength_1 });
                    }
                    // Match on description part
                    else {
                        descriptionMatch_1.push(h);
                    }
                });
                return { score: labelDescriptionScore, labelMatch: labelMatch_1, descriptionMatch: descriptionMatch_1 };
            }
        }
        return NO_ITEM_SCORE;
    }
    function compareItemsByScore(itemA, itemB, query, fuzzy, accessor, cache, fallbackComparer) {
        if (fallbackComparer === void 0) { fallbackComparer = fallbackCompare; }
        var itemScoreA = scoreItem(itemA, query, fuzzy, accessor, cache);
        var itemScoreB = scoreItem(itemB, query, fuzzy, accessor, cache);
        var scoreA = itemScoreA.score;
        var scoreB = itemScoreB.score;
        // 1.) prefer identity matches
        if (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {
            if (scoreA !== scoreB) {
                return scoreA === PATH_IDENTITY_SCORE ? -1 : 1;
            }
        }
        // 2.) prefer label prefix matches
        if (scoreA === LABEL_PREFIX_SCORE || scoreB === LABEL_PREFIX_SCORE) {
            if (scoreA !== scoreB) {
                return scoreA === LABEL_PREFIX_SCORE ? -1 : 1;
            }
            var labelA = accessor.getItemLabel(itemA);
            var labelB = accessor.getItemLabel(itemB);
            // prefer shorter names when both match on label prefix
            if (labelA.length !== labelB.length) {
                return labelA.length - labelB.length;
            }
        }
        // 3.) prefer camelcase matches
        if (scoreA === LABEL_CAMELCASE_SCORE || scoreB === LABEL_CAMELCASE_SCORE) {
            if (scoreA !== scoreB) {
                return scoreA === LABEL_CAMELCASE_SCORE ? -1 : 1;
            }
            var labelA = accessor.getItemLabel(itemA);
            var labelB = accessor.getItemLabel(itemB);
            // prefer more compact camel case matches over longer
            var comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);
            if (comparedByMatchLength !== 0) {
                return comparedByMatchLength;
            }
            // prefer shorter names when both match on label camelcase
            if (labelA.length !== labelB.length) {
                return labelA.length - labelB.length;
            }
        }
        // 4.) prefer label scores
        if (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {
            if (scoreB < LABEL_SCORE_THRESHOLD) {
                return -1;
            }
            if (scoreA < LABEL_SCORE_THRESHOLD) {
                return 1;
            }
        }
        // 5.) compare by score
        if (scoreA !== scoreB) {
            return scoreA > scoreB ? -1 : 1;
        }
        // 6.) scores are identical, prefer more compact matches (label and description)
        var itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);
        var itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);
        if (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {
            return itemBMatchDistance > itemAMatchDistance ? -1 : 1;
        }
        // 7.) at this point, scores are identical and match compactness as well
        // for both items so we start to use the fallback compare
        return fallbackComparer(itemA, itemB, query, accessor);
    }
    exports.compareItemsByScore = compareItemsByScore;
    function computeLabelAndDescriptionMatchDistance(item, score, accessor) {
        var hasLabelMatches = (score.labelMatch && score.labelMatch.length);
        var hasDescriptionMatches = (score.descriptionMatch && score.descriptionMatch.length);
        var matchStart = -1;
        var matchEnd = -1;
        // If we have description matches, the start is first of description match
        if (hasDescriptionMatches) {
            matchStart = score.descriptionMatch[0].start;
        }
        // Otherwise, the start is the first label match
        else if (hasLabelMatches) {
            matchStart = score.labelMatch[0].start;
        }
        // If we have label match, the end is the last label match
        // If we had a description match, we add the length of the description
        // as offset to the end to indicate this.
        if (hasLabelMatches) {
            matchEnd = score.labelMatch[score.labelMatch.length - 1].end;
            if (hasDescriptionMatches) {
                var itemDescription = accessor.getItemDescription(item);
                if (itemDescription) {
                    matchEnd += itemDescription.length;
                }
            }
        }
        // If we have just a description match, the end is the last description match
        else if (hasDescriptionMatches) {
            matchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;
        }
        return matchEnd - matchStart;
    }
    function compareByMatchLength(matchesA, matchesB) {
        if ((!matchesA && !matchesB) || (!matchesA.length && !matchesB.length)) {
            return 0; // make sure to not cause bad comparing when matches are not provided
        }
        if (!matchesB || !matchesB.length) {
            return -1;
        }
        if (!matchesA || !matchesA.length) {
            return 1;
        }
        // Compute match length of A (first to last match)
        var matchStartA = matchesA[0].start;
        var matchEndA = matchesA[matchesA.length - 1].end;
        var matchLengthA = matchEndA - matchStartA;
        // Compute match length of B (first to last match)
        var matchStartB = matchesB[0].start;
        var matchEndB = matchesB[matchesB.length - 1].end;
        var matchLengthB = matchEndB - matchStartB;
        // Prefer shorter match length
        return matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;
    }
    function fallbackCompare(itemA, itemB, query, accessor) {
        // check for label + description length and prefer shorter
        var labelA = accessor.getItemLabel(itemA);
        var labelB = accessor.getItemLabel(itemB);
        var descriptionA = accessor.getItemDescription(itemA);
        var descriptionB = accessor.getItemDescription(itemB);
        var labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);
        var labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);
        if (labelDescriptionALength !== labelDescriptionBLength) {
            return labelDescriptionALength - labelDescriptionBLength;
        }
        // check for path length and prefer shorter
        var pathA = accessor.getItemPath(itemA);
        var pathB = accessor.getItemPath(itemB);
        if (pathA && pathB && pathA.length !== pathB.length) {
            return pathA.length - pathB.length;
        }
        // 7.) finally we have equal scores and equal length, we fallback to comparer
        // compare by label
        if (labelA !== labelB) {
            return comparers_1.compareAnything(labelA, labelB, query.value);
        }
        // compare by description
        if (descriptionA && descriptionB && descriptionA !== descriptionB) {
            return comparers_1.compareAnything(descriptionA, descriptionB, query.value);
        }
        // compare by path
        if (pathA && pathB && pathA !== pathB) {
            return comparers_1.compareAnything(pathA, pathB, query.value);
        }
        // equal
        return 0;
    }
    exports.fallbackCompare = fallbackCompare;
});

define(__m[27/*vs/editor/common/core/position*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A position in the editor.
     */
    var Position = /** @class */ (function () {
        function Position(lineNumber, column) {
            this.lineNumber = lineNumber;
            this.column = column;
        }
        /**
         * Test if this position equals other position
         */
        Position.prototype.equals = function (other) {
            return Position.equals(this, other);
        };
        /**
         * Test if position `a` equals position `b`
         */
        Position.equals = function (a, b) {
            if (!a && !b) {
                return true;
            }
            return (!!a &&
                !!b &&
                a.lineNumber === b.lineNumber &&
                a.column === b.column);
        };
        /**
         * Test if this position is before other position.
         * If the two positions are equal, the result will be false.
         */
        Position.prototype.isBefore = function (other) {
            return Position.isBefore(this, other);
        };
        /**
         * Test if position `a` is before position `b`.
         * If the two positions are equal, the result will be false.
         */
        Position.isBefore = function (a, b) {
            if (a.lineNumber < b.lineNumber) {
                return true;
            }
            if (b.lineNumber < a.lineNumber) {
                return false;
            }
            return a.column < b.column;
        };
        /**
         * Test if this position is before other position.
         * If the two positions are equal, the result will be true.
         */
        Position.prototype.isBeforeOrEqual = function (other) {
            return Position.isBeforeOrEqual(this, other);
        };
        /**
         * Test if position `a` is before position `b`.
         * If the two positions are equal, the result will be true.
         */
        Position.isBeforeOrEqual = function (a, b) {
            if (a.lineNumber < b.lineNumber) {
                return true;
            }
            if (b.lineNumber < a.lineNumber) {
                return false;
            }
            return a.column <= b.column;
        };
        /**
         * A function that compares positions, useful for sorting
         */
        Position.compare = function (a, b) {
            var aLineNumber = a.lineNumber | 0;
            var bLineNumber = b.lineNumber | 0;
            if (aLineNumber === bLineNumber) {
                var aColumn = a.column | 0;
                var bColumn = b.column | 0;
                return aColumn - bColumn;
            }
            return aLineNumber - bLineNumber;
        };
        /**
         * Clone this position.
         */
        Position.prototype.clone = function () {
            return new Position(this.lineNumber, this.column);
        };
        /**
         * Convert to a human-readable representation.
         */
        Position.prototype.toString = function () {
            return '(' + this.lineNumber + ',' + this.column + ')';
        };
        // ---
        /**
         * Create a `Position` from an `IPosition`.
         */
        Position.lift = function (pos) {
            return new Position(pos.lineNumber, pos.column);
        };
        /**
         * Test if `obj` is an `IPosition`.
         */
        Position.isIPosition = function (obj) {
            return (obj
                && (typeof obj.lineNumber === 'number')
                && (typeof obj.column === 'number'));
        };
        return Position;
    }());
    exports.Position = Position;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[24/*vs/editor/common/core/range*/], __M([0/*require*/,1/*exports*/,27/*vs/editor/common/core/position*/]), function (require, exports, position_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
     */
    var Range = /** @class */ (function () {
        function Range(startLineNumber, startColumn, endLineNumber, endColumn) {
            if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {
                this.startLineNumber = endLineNumber;
                this.startColumn = endColumn;
                this.endLineNumber = startLineNumber;
                this.endColumn = startColumn;
            }
            else {
                this.startLineNumber = startLineNumber;
                this.startColumn = startColumn;
                this.endLineNumber = endLineNumber;
                this.endColumn = endColumn;
            }
        }
        /**
         * Test if this range is empty.
         */
        Range.prototype.isEmpty = function () {
            return Range.isEmpty(this);
        };
        /**
         * Test if `range` is empty.
         */
        Range.isEmpty = function (range) {
            return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);
        };
        /**
         * Test if position is in this range. If the position is at the edges, will return true.
         */
        Range.prototype.containsPosition = function (position) {
            return Range.containsPosition(this, position);
        };
        /**
         * Test if `position` is in `range`. If the position is at the edges, will return true.
         */
        Range.containsPosition = function (range, position) {
            if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
                return false;
            }
            if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
                return false;
            }
            if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
                return false;
            }
            return true;
        };
        /**
         * Test if range is in this range. If the range is equal to this range, will return true.
         */
        Range.prototype.containsRange = function (range) {
            return Range.containsRange(this, range);
        };
        /**
         * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
         */
        Range.containsRange = function (range, otherRange) {
            if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
                return false;
            }
            if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
                return false;
            }
            if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
                return false;
            }
            if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
                return false;
            }
            return true;
        };
        /**
         * A reunion of the two ranges.
         * The smallest position will be used as the start point, and the largest one as the end point.
         */
        Range.prototype.plusRange = function (range) {
            return Range.plusRange(this, range);
        };
        /**
         * A reunion of the two ranges.
         * The smallest position will be used as the start point, and the largest one as the end point.
         */
        Range.plusRange = function (a, b) {
            var startLineNumber;
            var startColumn;
            var endLineNumber;
            var endColumn;
            if (b.startLineNumber < a.startLineNumber) {
                startLineNumber = b.startLineNumber;
                startColumn = b.startColumn;
            }
            else if (b.startLineNumber === a.startLineNumber) {
                startLineNumber = b.startLineNumber;
                startColumn = Math.min(b.startColumn, a.startColumn);
            }
            else {
                startLineNumber = a.startLineNumber;
                startColumn = a.startColumn;
            }
            if (b.endLineNumber > a.endLineNumber) {
                endLineNumber = b.endLineNumber;
                endColumn = b.endColumn;
            }
            else if (b.endLineNumber === a.endLineNumber) {
                endLineNumber = b.endLineNumber;
                endColumn = Math.max(b.endColumn, a.endColumn);
            }
            else {
                endLineNumber = a.endLineNumber;
                endColumn = a.endColumn;
            }
            return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
        };
        /**
         * A intersection of the two ranges.
         */
        Range.prototype.intersectRanges = function (range) {
            return Range.intersectRanges(this, range);
        };
        /**
         * A intersection of the two ranges.
         */
        Range.intersectRanges = function (a, b) {
            var resultStartLineNumber = a.startLineNumber;
            var resultStartColumn = a.startColumn;
            var resultEndLineNumber = a.endLineNumber;
            var resultEndColumn = a.endColumn;
            var otherStartLineNumber = b.startLineNumber;
            var otherStartColumn = b.startColumn;
            var otherEndLineNumber = b.endLineNumber;
            var otherEndColumn = b.endColumn;
            if (resultStartLineNumber < otherStartLineNumber) {
                resultStartLineNumber = otherStartLineNumber;
                resultStartColumn = otherStartColumn;
            }
            else if (resultStartLineNumber === otherStartLineNumber) {
                resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
            }
            if (resultEndLineNumber > otherEndLineNumber) {
                resultEndLineNumber = otherEndLineNumber;
                resultEndColumn = otherEndColumn;
            }
            else if (resultEndLineNumber === otherEndLineNumber) {
                resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
            }
            // Check if selection is now empty
            if (resultStartLineNumber > resultEndLineNumber) {
                return null;
            }
            if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
                return null;
            }
            return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
        };
        /**
         * Test if this range equals other.
         */
        Range.prototype.equalsRange = function (other) {
            return Range.equalsRange(this, other);
        };
        /**
         * Test if range `a` equals `b`.
         */
        Range.equalsRange = function (a, b) {
            return (!!a &&
                !!b &&
                a.startLineNumber === b.startLineNumber &&
                a.startColumn === b.startColumn &&
                a.endLineNumber === b.endLineNumber &&
                a.endColumn === b.endColumn);
        };
        /**
         * Return the end position (which will be after or equal to the start position)
         */
        Range.prototype.getEndPosition = function () {
            return new position_1.Position(this.endLineNumber, this.endColumn);
        };
        /**
         * Return the start position (which will be before or equal to the end position)
         */
        Range.prototype.getStartPosition = function () {
            return new position_1.Position(this.startLineNumber, this.startColumn);
        };
        /**
         * Transform to a user presentable string representation.
         */
        Range.prototype.toString = function () {
            return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';
        };
        /**
         * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
         */
        Range.prototype.setEndPosition = function (endLineNumber, endColumn) {
            return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        };
        /**
         * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
         */
        Range.prototype.setStartPosition = function (startLineNumber, startColumn) {
            return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        };
        /**
         * Create a new empty range using this range's start position.
         */
        Range.prototype.collapseToStart = function () {
            return Range.collapseToStart(this);
        };
        /**
         * Create a new empty range using this range's start position.
         */
        Range.collapseToStart = function (range) {
            return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
        };
        // ---
        Range.fromPositions = function (start, end) {
            if (end === void 0) { end = start; }
            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        /**
         * Create a `Range` from an `IRange`.
         */
        Range.lift = function (range) {
            if (!range) {
                return null;
            }
            return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        };
        /**
         * Test if `obj` is an `IRange`.
         */
        Range.isIRange = function (obj) {
            return (obj
                && (typeof obj.startLineNumber === 'number')
                && (typeof obj.startColumn === 'number')
                && (typeof obj.endLineNumber === 'number')
                && (typeof obj.endColumn === 'number'));
        };
        /**
         * Test if the two ranges are touching in any way.
         */
        Range.areIntersectingOrTouching = function (a, b) {
            // Check if `a` is before `b`
            if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {
                return false;
            }
            // Check if `b` is before `a`
            if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {
                return false;
            }
            // These ranges must intersect
            return true;
        };
        /**
         * Test if the two ranges are intersecting. If the ranges are touching it returns true.
         */
        Range.areIntersecting = function (a, b) {
            // Check if `a` is before `b`
            if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {
                return false;
            }
            // Check if `b` is before `a`
            if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {
                return false;
            }
            // These ranges must intersect
            return true;
        };
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the startPosition and then on the endPosition
         */
        Range.compareRangesUsingStarts = function (a, b) {
            var aStartLineNumber = a.startLineNumber | 0;
            var bStartLineNumber = b.startLineNumber | 0;
            if (aStartLineNumber === bStartLineNumber) {
                var aStartColumn = a.startColumn | 0;
                var bStartColumn = b.startColumn | 0;
                if (aStartColumn === bStartColumn) {
                    var aEndLineNumber = a.endLineNumber | 0;
                    var bEndLineNumber = b.endLineNumber | 0;
                    if (aEndLineNumber === bEndLineNumber) {
                        var aEndColumn = a.endColumn | 0;
                        var bEndColumn = b.endColumn | 0;
                        return aEndColumn - bEndColumn;
                    }
                    return aEndLineNumber - bEndLineNumber;
                }
                return aStartColumn - bStartColumn;
            }
            return aStartLineNumber - bStartLineNumber;
        };
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the endPosition and then on the startPosition
         */
        Range.compareRangesUsingEnds = function (a, b) {
            if (a.endLineNumber === b.endLineNumber) {
                if (a.endColumn === b.endColumn) {
                    if (a.startLineNumber === b.startLineNumber) {
                        return a.startColumn - b.startColumn;
                    }
                    return a.startLineNumber - b.startLineNumber;
                }
                return a.endColumn - b.endColumn;
            }
            return a.endLineNumber - b.endLineNumber;
        };
        /**
         * Test if the range spans multiple lines.
         */
        Range.spansMultipleLines = function (range) {
            return range.endLineNumber > range.startLineNumber;
        };
        return Range;
    }());
    exports.Range = Range;
});











define(__m[54/*vs/editor/common/core/selection*/], __M([0/*require*/,1/*exports*/,24/*vs/editor/common/core/range*/,27/*vs/editor/common/core/position*/]), function (require, exports, range_1, position_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The direction of a selection.
     */
    var SelectionDirection;
    (function (SelectionDirection) {
        /**
         * The selection starts above where it ends.
         */
        SelectionDirection[SelectionDirection["LTR"] = 0] = "LTR";
        /**
         * The selection starts below where it ends.
         */
        SelectionDirection[SelectionDirection["RTL"] = 1] = "RTL";
    })(SelectionDirection = exports.SelectionDirection || (exports.SelectionDirection = {}));
    /**
     * A selection in the editor.
     * The selection is a range that has an orientation.
     */
    var Selection = /** @class */ (function (_super) {
        __extends(Selection, _super);
        function Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
            var _this = _super.call(this, selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) || this;
            _this.selectionStartLineNumber = selectionStartLineNumber;
            _this.selectionStartColumn = selectionStartColumn;
            _this.positionLineNumber = positionLineNumber;
            _this.positionColumn = positionColumn;
            return _this;
        }
        /**
         * Clone this selection.
         */
        Selection.prototype.clone = function () {
            return new Selection(this.selectionStartLineNumber, this.selectionStartColumn, this.positionLineNumber, this.positionColumn);
        };
        /**
         * Transform to a human-readable representation.
         */
        Selection.prototype.toString = function () {
            return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';
        };
        /**
         * Test if equals other selection.
         */
        Selection.prototype.equalsSelection = function (other) {
            return (Selection.selectionsEqual(this, other));
        };
        /**
         * Test if the two selections are equal.
         */
        Selection.selectionsEqual = function (a, b) {
            return (a.selectionStartLineNumber === b.selectionStartLineNumber &&
                a.selectionStartColumn === b.selectionStartColumn &&
                a.positionLineNumber === b.positionLineNumber &&
                a.positionColumn === b.positionColumn);
        };
        /**
         * Get directions (LTR or RTL).
         */
        Selection.prototype.getDirection = function () {
            if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
                return SelectionDirection.LTR;
            }
            return SelectionDirection.RTL;
        };
        /**
         * Create a new selection with a different `positionLineNumber` and `positionColumn`.
         */
        Selection.prototype.setEndPosition = function (endLineNumber, endColumn) {
            if (this.getDirection() === SelectionDirection.LTR) {
                return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
            }
            return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
        };
        /**
         * Get the position at `positionLineNumber` and `positionColumn`.
         */
        Selection.prototype.getPosition = function () {
            return new position_1.Position(this.positionLineNumber, this.positionColumn);
        };
        /**
         * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
         */
        Selection.prototype.setStartPosition = function (startLineNumber, startColumn) {
            if (this.getDirection() === SelectionDirection.LTR) {
                return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
            }
            return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
        };
        // ----
        /**
         * Create a `Selection` from one or two positions
         */
        Selection.fromPositions = function (start, end) {
            if (end === void 0) { end = start; }
            return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        /**
         * Create a `Selection` from an `ISelection`.
         */
        Selection.liftSelection = function (sel) {
            return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
        };
        /**
         * `a` equals `b`.
         */
        Selection.selectionsArrEqual = function (a, b) {
            if (a && !b || !a && b) {
                return false;
            }
            if (!a && !b) {
                return true;
            }
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0, len = a.length; i < len; i++) {
                if (!this.selectionsEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        };
        /**
         * Test if `obj` is an `ISelection`.
         */
        Selection.isISelection = function (obj) {
            return (obj
                && (typeof obj.selectionStartLineNumber === 'number')
                && (typeof obj.selectionStartColumn === 'number')
                && (typeof obj.positionLineNumber === 'number')
                && (typeof obj.positionColumn === 'number'));
        };
        /**
         * Create with a direction.
         */
        Selection.createWithDirection = function (startLineNumber, startColumn, endLineNumber, endColumn, direction) {
            if (direction === SelectionDirection.LTR) {
                return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
            }
            return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
        };
        return Selection;
    }(range_1.Range));
    exports.Selection = Selection;
});

define(__m[126/*vs/editor/common/core/token*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Token = /** @class */ (function () {
        function Token(offset, type, language) {
            this.offset = offset | 0; // @perf
            this.type = type;
            this.language = language;
        }
        Token.prototype.toString = function () {
            return '(' + this.offset + ', ' + this.type + ')';
        };
        return Token;
    }());
    exports.Token = Token;
    var TokenizationResult = /** @class */ (function () {
        function TokenizationResult(tokens, endState) {
            this.tokens = tokens;
            this.endState = endState;
        }
        return TokenizationResult;
    }());
    exports.TokenizationResult = TokenizationResult;
    var TokenizationResult2 = /** @class */ (function () {
        function TokenizationResult2(tokens, endState) {
            this.tokens = tokens;
            this.endState = endState;
        }
        return TokenizationResult2;
    }());
    exports.TokenizationResult2 = TokenizationResult2;
});

define(__m[56/*vs/editor/common/core/uint*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Uint8Matrix = /** @class */ (function () {
        function Uint8Matrix(rows, cols, defaultValue) {
            var data = new Uint8Array(rows * cols);
            for (var i = 0, len = rows * cols; i < len; i++) {
                data[i] = defaultValue;
            }
            this._data = data;
            this.rows = rows;
            this.cols = cols;
        }
        Uint8Matrix.prototype.get = function (row, col) {
            return this._data[row * this.cols + col];
        };
        Uint8Matrix.prototype.set = function (row, col, value) {
            this._data[row * this.cols + col] = value;
        };
        return Uint8Matrix;
    }());
    exports.Uint8Matrix = Uint8Matrix;
    var Constants;
    (function (Constants) {
        /**
         * MAX SMI (SMall Integer) as defined in v8.
         * one bit is lost for boxing/unboxing flag.
         * one bit is lost for sign flag.
         * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values
         */
        Constants[Constants["MAX_SAFE_SMALL_INTEGER"] = 1073741824] = "MAX_SAFE_SMALL_INTEGER";
        /**
         * MIN SMI (SMall Integer) as defined in v8.
         * one bit is lost for boxing/unboxing flag.
         * one bit is lost for sign flag.
         * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values
         */
        Constants[Constants["MIN_SAFE_SMALL_INTEGER"] = -1073741824] = "MIN_SAFE_SMALL_INTEGER";
        /**
         * Max unsigned integer that fits on 8 bits.
         */
        Constants[Constants["MAX_UINT_8"] = 255] = "MAX_UINT_8";
        /**
         * Max unsigned integer that fits on 16 bits.
         */
        Constants[Constants["MAX_UINT_16"] = 65535] = "MAX_UINT_16";
        /**
         * Max unsigned integer that fits on 32 bits.
         */
        Constants[Constants["MAX_UINT_32"] = 4294967295] = "MAX_UINT_32";
    })(Constants = exports.Constants || (exports.Constants = {}));
    function toUint8(v) {
        if (v < 0) {
            return 0;
        }
        if (v > 255 /* MAX_UINT_8 */) {
            return 255 /* MAX_UINT_8 */;
        }
        return v | 0;
    }
    exports.toUint8 = toUint8;
    function toUint32(v) {
        if (v < 0) {
            return 0;
        }
        if (v > 4294967295 /* MAX_UINT_32 */) {
            return 4294967295 /* MAX_UINT_32 */;
        }
        return v | 0;
    }
    exports.toUint32 = toUint32;
    function toUint32Array(arr) {
        var len = arr.length;
        var r = new Uint32Array(len);
        for (var i = 0; i < len; i++) {
            r[i] = toUint32(arr[i]);
        }
        return r;
    }
    exports.toUint32Array = toUint32Array;
});

define(__m[129/*vs/editor/common/core/characterClassifier*/], __M([0/*require*/,1/*exports*/,56/*vs/editor/common/core/uint*/]), function (require, exports, uint_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A fast character classifier that uses a compact array for ASCII values.
     */
    var CharacterClassifier = /** @class */ (function () {
        function CharacterClassifier(_defaultValue) {
            var defaultValue = uint_1.toUint8(_defaultValue);
            this._defaultValue = defaultValue;
            this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);
            this._map = new Map();
        }
        CharacterClassifier._createAsciiMap = function (defaultValue) {
            var asciiMap = new Uint8Array(256);
            for (var i = 0; i < 256; i++) {
                asciiMap[i] = defaultValue;
            }
            return asciiMap;
        };
        CharacterClassifier.prototype.set = function (charCode, _value) {
            var value = uint_1.toUint8(_value);
            if (charCode >= 0 && charCode < 256) {
                this._asciiMap[charCode] = value;
            }
            else {
                this._map.set(charCode, value);
            }
        };
        CharacterClassifier.prototype.get = function (charCode) {
            if (charCode >= 0 && charCode < 256) {
                return this._asciiMap[charCode];
            }
            else {
                return (this._map.get(charCode) || this._defaultValue);
            }
        };
        return CharacterClassifier;
    }());
    exports.CharacterClassifier = CharacterClassifier;
    var Boolean;
    (function (Boolean) {
        Boolean[Boolean["False"] = 0] = "False";
        Boolean[Boolean["True"] = 1] = "True";
    })(Boolean || (Boolean = {}));
    var CharacterSet = /** @class */ (function () {
        function CharacterSet() {
            this._actual = new CharacterClassifier(0 /* False */);
        }
        CharacterSet.prototype.add = function (charCode) {
            this._actual.set(charCode, 1 /* True */);
        };
        CharacterSet.prototype.has = function (charCode) {
            return (this._actual.get(charCode) === 1 /* True */);
        };
        return CharacterSet;
    }());
    exports.CharacterSet = CharacterSet;
});











define(__m[131/*vs/editor/common/controller/wordCharacterClassifier*/], __M([0/*require*/,1/*exports*/,129/*vs/editor/common/core/characterClassifier*/]), function (require, exports, characterClassifier_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var WordCharacterClass;
    (function (WordCharacterClass) {
        WordCharacterClass[WordCharacterClass["Regular"] = 0] = "Regular";
        WordCharacterClass[WordCharacterClass["Whitespace"] = 1] = "Whitespace";
        WordCharacterClass[WordCharacterClass["WordSeparator"] = 2] = "WordSeparator";
    })(WordCharacterClass = exports.WordCharacterClass || (exports.WordCharacterClass = {}));
    var WordCharacterClassifier = /** @class */ (function (_super) {
        __extends(WordCharacterClassifier, _super);
        function WordCharacterClassifier(wordSeparators) {
            var _this = _super.call(this, 0 /* Regular */) || this;
            for (var i = 0, len = wordSeparators.length; i < len; i++) {
                _this.set(wordSeparators.charCodeAt(i), 2 /* WordSeparator */);
            }
            _this.set(32 /* Space */, 1 /* Whitespace */);
            _this.set(9 /* Tab */, 1 /* Whitespace */);
            return _this;
        }
        return WordCharacterClassifier;
    }(characterClassifier_1.CharacterClassifier));
    exports.WordCharacterClassifier = WordCharacterClassifier;
    function once(computeFn) {
        var cache = {}; // TODO@Alex unbounded cache
        return function (input) {
            if (!cache.hasOwnProperty(input)) {
                cache[input] = computeFn(input);
            }
            return cache[input];
        };
    }
    exports.getMapForWordSeparators = once(function (input) { return new WordCharacterClassifier(input); });
});

define(__m[25/*vs/editor/common/model*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Vertical Lane in the overview ruler of the editor.
     */
    var OverviewRulerLane;
    (function (OverviewRulerLane) {
        OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
        OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
        OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
        OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
    })(OverviewRulerLane = exports.OverviewRulerLane || (exports.OverviewRulerLane = {}));
    /**
     * End of line character preference.
     */
    var EndOfLinePreference;
    (function (EndOfLinePreference) {
        /**
         * Use the end of line character identified in the text buffer.
         */
        EndOfLinePreference[EndOfLinePreference["TextDefined"] = 0] = "TextDefined";
        /**
         * Use line feed (\n) as the end of line character.
         */
        EndOfLinePreference[EndOfLinePreference["LF"] = 1] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        EndOfLinePreference[EndOfLinePreference["CRLF"] = 2] = "CRLF";
    })(EndOfLinePreference = exports.EndOfLinePreference || (exports.EndOfLinePreference = {}));
    /**
     * The default end of line to use when instantiating models.
     */
    var DefaultEndOfLine;
    (function (DefaultEndOfLine) {
        /**
         * Use line feed (\n) as the end of line character.
         */
        DefaultEndOfLine[DefaultEndOfLine["LF"] = 1] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        DefaultEndOfLine[DefaultEndOfLine["CRLF"] = 2] = "CRLF";
    })(DefaultEndOfLine = exports.DefaultEndOfLine || (exports.DefaultEndOfLine = {}));
    /**
     * End of line character preference.
     */
    var EndOfLineSequence;
    (function (EndOfLineSequence) {
        /**
         * Use line feed (\n) as the end of line character.
         */
        EndOfLineSequence[EndOfLineSequence["LF"] = 0] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        EndOfLineSequence[EndOfLineSequence["CRLF"] = 1] = "CRLF";
    })(EndOfLineSequence = exports.EndOfLineSequence || (exports.EndOfLineSequence = {}));
    var TextModelResolvedOptions = /** @class */ (function () {
        /**
         * @internal
         */
        function TextModelResolvedOptions(src) {
            this.tabSize = src.tabSize | 0;
            this.insertSpaces = Boolean(src.insertSpaces);
            this.defaultEOL = src.defaultEOL | 0;
            this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);
        }
        /**
         * @internal
         */
        TextModelResolvedOptions.prototype.equals = function (other) {
            return (this.tabSize === other.tabSize
                && this.insertSpaces === other.insertSpaces
                && this.defaultEOL === other.defaultEOL
                && this.trimAutoWhitespace === other.trimAutoWhitespace);
        };
        /**
         * @internal
         */
        TextModelResolvedOptions.prototype.createChangeEvent = function (newOpts) {
            return {
                tabSize: this.tabSize !== newOpts.tabSize,
                insertSpaces: this.insertSpaces !== newOpts.insertSpaces,
                trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,
            };
        };
        return TextModelResolvedOptions;
    }());
    exports.TextModelResolvedOptions = TextModelResolvedOptions;
    var FindMatch = /** @class */ (function () {
        /**
         * @internal
         */
        function FindMatch(range, matches) {
            this.range = range;
            this.matches = matches;
        }
        return FindMatch;
    }());
    exports.FindMatch = FindMatch;
    /**
     * Describes the behavior of decorations when typing/editing near their edges.
     * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
     */
    var TrackedRangeStickiness;
    (function (TrackedRangeStickiness) {
        TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
    })(TrackedRangeStickiness = exports.TrackedRangeStickiness || (exports.TrackedRangeStickiness = {}));
    /**
     * @internal
     */
    var ApplyEditsResult = /** @class */ (function () {
        function ApplyEditsResult(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {
            this.reverseEdits = reverseEdits;
            this.changes = changes;
            this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;
        }
        return ApplyEditsResult;
    }());
    exports.ApplyEditsResult = ApplyEditsResult;
});

define(__m[136/*vs/editor/common/model/editStack*/], __M([0/*require*/,1/*exports*/,14/*vs/base/common/errors*/,25/*vs/editor/common/model*/]), function (require, exports, errors_1, model_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var EditStackElement = /** @class */ (function () {
        function EditStackElement(beforeVersionId, beforeCursorState) {
            this.beforeVersionId = beforeVersionId;
            this.beforeCursorState = beforeCursorState;
            this.afterCursorState = null;
            this.afterVersionId = -1;
            this.editOperations = [];
        }
        EditStackElement.prototype.undo = function (model) {
            // Apply all operations in reverse order
            for (var i = this.editOperations.length - 1; i >= 0; i--) {
                this.editOperations[i] = {
                    operations: model.applyEdits(this.editOperations[i].operations)
                };
            }
        };
        EditStackElement.prototype.redo = function (model) {
            // Apply all operations
            for (var i = 0; i < this.editOperations.length; i++) {
                this.editOperations[i] = {
                    operations: model.applyEdits(this.editOperations[i].operations)
                };
            }
        };
        return EditStackElement;
    }());
    function getModelEOL(model) {
        var eol = model.getEOL();
        if (eol === '\n') {
            return model_1.EndOfLineSequence.LF;
        }
        else {
            return model_1.EndOfLineSequence.CRLF;
        }
    }
    var EOLStackElement = /** @class */ (function () {
        function EOLStackElement(beforeVersionId, setEOL) {
            this.beforeVersionId = beforeVersionId;
            this.beforeCursorState = null;
            this.afterCursorState = null;
            this.afterVersionId = -1;
            this.eol = setEOL;
        }
        EOLStackElement.prototype.undo = function (model) {
            var redoEOL = getModelEOL(model);
            model.setEOL(this.eol);
            this.eol = redoEOL;
        };
        EOLStackElement.prototype.redo = function (model) {
            var undoEOL = getModelEOL(model);
            model.setEOL(this.eol);
            this.eol = undoEOL;
        };
        return EOLStackElement;
    }());
    var EditStack = /** @class */ (function () {
        function EditStack(model) {
            this.model = model;
            this.currentOpenStackElement = null;
            this.past = [];
            this.future = [];
        }
        EditStack.prototype.pushStackElement = function () {
            if (this.currentOpenStackElement !== null) {
                this.past.push(this.currentOpenStackElement);
                this.currentOpenStackElement = null;
            }
        };
        EditStack.prototype.clear = function () {
            this.currentOpenStackElement = null;
            this.past = [];
            this.future = [];
        };
        EditStack.prototype.pushEOL = function (eol) {
            // No support for parallel universes :(
            this.future = [];
            if (this.currentOpenStackElement) {
                this.pushStackElement();
            }
            var prevEOL = getModelEOL(this.model);
            var stackElement = new EOLStackElement(this.model.getAlternativeVersionId(), prevEOL);
            this.model.setEOL(eol);
            stackElement.afterVersionId = this.model.getVersionId();
            this.currentOpenStackElement = stackElement;
            this.pushStackElement();
        };
        EditStack.prototype.pushEditOperation = function (beforeCursorState, editOperations, cursorStateComputer) {
            // No support for parallel universes :(
            this.future = [];
            var stackElement = null;
            if (this.currentOpenStackElement) {
                if (this.currentOpenStackElement instanceof EditStackElement) {
                    stackElement = this.currentOpenStackElement;
                }
                else {
                    this.pushStackElement();
                }
            }
            if (!this.currentOpenStackElement) {
                stackElement = new EditStackElement(this.model.getAlternativeVersionId(), beforeCursorState);
                this.currentOpenStackElement = stackElement;
            }
            var inverseEditOperation = {
                operations: this.model.applyEdits(editOperations)
            };
            stackElement.editOperations.push(inverseEditOperation);
            stackElement.afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperation.operations);
            stackElement.afterVersionId = this.model.getVersionId();
            return stackElement.afterCursorState;
        };
        EditStack._computeCursorState = function (cursorStateComputer, inverseEditOperations) {
            try {
                return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
                return null;
            }
        };
        EditStack.prototype.undo = function () {
            this.pushStackElement();
            if (this.past.length > 0) {
                var pastStackElement = this.past.pop();
                try {
                    pastStackElement.undo(this.model);
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                    this.clear();
                    return null;
                }
                this.future.push(pastStackElement);
                return {
                    selections: pastStackElement.beforeCursorState,
                    recordedVersionId: pastStackElement.beforeVersionId
                };
            }
            return null;
        };
        EditStack.prototype.canUndo = function () {
            return (this.past.length > 0);
        };
        EditStack.prototype.redo = function () {
            if (this.future.length > 0) {
                var futureStackElement = this.future.pop();
                try {
                    futureStackElement.redo(this.model);
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                    this.clear();
                    return null;
                }
                this.past.push(futureStackElement);
                return {
                    selections: futureStackElement.afterCursorState,
                    recordedVersionId: futureStackElement.afterVersionId
                };
            }
            return null;
        };
        EditStack.prototype.canRedo = function () {
            return (this.future.length > 0);
        };
        return EditStack;
    }());
    exports.EditStack = EditStack;
});

define(__m[137/*vs/editor/common/model/indentationGuesser*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Compute the diff in spaces between two line's indentation.
     */
    function spacesDiff(a, aLength, b, bLength) {
        // This can go both ways (e.g.):
        //  - a: "\t"
        //  - b: "\t    "
        //  => This should count 1 tab and 4 spaces
        var i;
        for (i = 0; i < aLength && i < bLength; i++) {
            var aCharCode = a.charCodeAt(i);
            var bCharCode = b.charCodeAt(i);
            if (aCharCode !== bCharCode) {
                break;
            }
        }
        var aSpacesCnt = 0, aTabsCount = 0;
        for (var j = i; j < aLength; j++) {
            var aCharCode = a.charCodeAt(j);
            if (aCharCode === 32 /* Space */) {
                aSpacesCnt++;
            }
            else {
                aTabsCount++;
            }
        }
        var bSpacesCnt = 0, bTabsCount = 0;
        for (var j = i; j < bLength; j++) {
            var bCharCode = b.charCodeAt(j);
            if (bCharCode === 32 /* Space */) {
                bSpacesCnt++;
            }
            else {
                bTabsCount++;
            }
        }
        if (aSpacesCnt > 0 && aTabsCount > 0) {
            return 0;
        }
        if (bSpacesCnt > 0 && bTabsCount > 0) {
            return 0;
        }
        var tabsDiff = Math.abs(aTabsCount - bTabsCount);
        var spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);
        if (tabsDiff === 0) {
            return spacesDiff;
        }
        if (spacesDiff % tabsDiff === 0) {
            return spacesDiff / tabsDiff;
        }
        return 0;
    }
    function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {
        // Look at most at the first 10k lines
        var linesCount = Math.min(source.getLineCount(), 10000);
        var linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation
        var linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation
        var previousLineText = ''; // content of latest line that contained non-whitespace chars
        var previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char
        var ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8]; // limit guesses for `tabSize` to 2, 4, 6 or 8.
        var MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(2,4,6,8) = 8
        var spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores
        for (var lineNumber = 1; lineNumber <= linesCount; lineNumber++) {
            var currentLineLength = source.getLineLength(lineNumber);
            var currentLineText = source.getLineContent(lineNumber);
            // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.
            // checking charCode on chunks directly is cheaper.
            var useCurrentLineText = (currentLineLength <= 65536);
            var currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars
            var currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char
            var currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation
            var currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation
            for (var j = 0, lenJ = currentLineLength; j < lenJ; j++) {
                var charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));
                if (charCode === 9 /* Tab */) {
                    currentLineTabsCount++;
                }
                else if (charCode === 32 /* Space */) {
                    currentLineSpacesCount++;
                }
                else {
                    // Hit non whitespace character on this line
                    currentLineHasContent = true;
                    currentLineIndentation = j;
                    break;
                }
            }
            // Ignore empty or only whitespace lines
            if (!currentLineHasContent) {
                continue;
            }
            if (currentLineTabsCount > 0) {
                linesIndentedWithTabsCount++;
            }
            else if (currentLineSpacesCount > 1) {
                linesIndentedWithSpacesCount++;
            }
            var currentSpacesDiff = spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation);
            if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {
                spacesDiffCount[currentSpacesDiff]++;
            }
            previousLineText = currentLineText;
            previousLineIndentation = currentLineIndentation;
        }
        var insertSpaces = defaultInsertSpaces;
        if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {
            insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);
        }
        var tabSize = defaultTabSize;
        var tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);
        // console.log("score threshold: " + tabSizeScore);
        ALLOWED_TAB_SIZE_GUESSES.forEach(function (possibleTabSize) {
            var possibleTabSizeScore = spacesDiffCount[possibleTabSize];
            if (possibleTabSizeScore > tabSizeScore) {
                tabSizeScore = possibleTabSizeScore;
                tabSize = possibleTabSize;
            }
        });
        // console.log('--------------------------');
        // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);
        // console.log('spacesDiffCount: ' + spacesDiffCount);
        // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);
        return {
            insertSpaces: insertSpaces,
            tabSize: tabSize
        };
    }
    exports.guessIndentation = guessIndentation;
});

define(__m[139/*vs/editor/common/model/intervalTree*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    //
    // The red-black tree is based on the "Introduction to Algorithms" by Cormen, Leiserson and Rivest.
    //
    var ClassName;
    (function (ClassName) {
        ClassName["EditorHintDecoration"] = "squiggly-hint";
        ClassName["EditorInfoDecoration"] = "squiggly-info";
        ClassName["EditorWarningDecoration"] = "squiggly-warning";
        ClassName["EditorErrorDecoration"] = "squiggly-error";
        ClassName["EditorUnnecessaryDecoration"] = "squiggly-unnecessary";
        ClassName["EditorUnnecessaryInlineDecoration"] = "squiggly-inline-unnecessary";
    })(ClassName = exports.ClassName || (exports.ClassName = {}));
    /**
     * Describes the behavior of decorations when typing/editing near their edges.
     * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
     */
    var TrackedRangeStickiness;
    (function (TrackedRangeStickiness) {
        TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
    })(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
    var NodeColor;
    (function (NodeColor) {
        NodeColor[NodeColor["Black"] = 0] = "Black";
        NodeColor[NodeColor["Red"] = 1] = "Red";
    })(NodeColor = exports.NodeColor || (exports.NodeColor = {}));
    var Constants;
    (function (Constants) {
        Constants[Constants["ColorMask"] = 1] = "ColorMask";
        Constants[Constants["ColorMaskInverse"] = 254] = "ColorMaskInverse";
        Constants[Constants["ColorOffset"] = 0] = "ColorOffset";
        Constants[Constants["IsVisitedMask"] = 2] = "IsVisitedMask";
        Constants[Constants["IsVisitedMaskInverse"] = 253] = "IsVisitedMaskInverse";
        Constants[Constants["IsVisitedOffset"] = 1] = "IsVisitedOffset";
        Constants[Constants["IsForValidationMask"] = 4] = "IsForValidationMask";
        Constants[Constants["IsForValidationMaskInverse"] = 251] = "IsForValidationMaskInverse";
        Constants[Constants["IsForValidationOffset"] = 2] = "IsForValidationOffset";
        Constants[Constants["IsInOverviewRulerMask"] = 8] = "IsInOverviewRulerMask";
        Constants[Constants["IsInOverviewRulerMaskInverse"] = 247] = "IsInOverviewRulerMaskInverse";
        Constants[Constants["IsInOverviewRulerOffset"] = 3] = "IsInOverviewRulerOffset";
        Constants[Constants["StickinessMask"] = 48] = "StickinessMask";
        Constants[Constants["StickinessMaskInverse"] = 207] = "StickinessMaskInverse";
        Constants[Constants["StickinessOffset"] = 4] = "StickinessOffset";
        /**
         * Due to how deletion works (in order to avoid always walking the right subtree of the deleted node),
         * the deltas for nodes can grow and shrink dramatically. It has been observed, in practice, that unless
         * the deltas are corrected, integer overflow will occur.
         *
         * The integer overflow occurs when 53 bits are used in the numbers, but we will try to avoid it as
         * a node's delta gets below a negative 30 bits number.
         *
         * MIN SMI (SMall Integer) as defined in v8.
         * one bit is lost for boxing/unboxing flag.
         * one bit is lost for sign flag.
         * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values
         */
        Constants[Constants["MIN_SAFE_DELTA"] = -1073741824] = "MIN_SAFE_DELTA";
        /**
         * MAX SMI (SMall Integer) as defined in v8.
         * one bit is lost for boxing/unboxing flag.
         * one bit is lost for sign flag.
         * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values
         */
        Constants[Constants["MAX_SAFE_DELTA"] = 1073741824] = "MAX_SAFE_DELTA";
    })(Constants || (Constants = {}));
    function getNodeColor(node) {
        return ((node.metadata & 1 /* ColorMask */) >>> 0 /* ColorOffset */);
    }
    exports.getNodeColor = getNodeColor;
    function setNodeColor(node, color) {
        node.metadata = ((node.metadata & 254 /* ColorMaskInverse */) | (color << 0 /* ColorOffset */));
    }
    function getNodeIsVisited(node) {
        return ((node.metadata & 2 /* IsVisitedMask */) >>> 1 /* IsVisitedOffset */) === 1;
    }
    function setNodeIsVisited(node, value) {
        node.metadata = ((node.metadata & 253 /* IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* IsVisitedOffset */));
    }
    function getNodeIsForValidation(node) {
        return ((node.metadata & 4 /* IsForValidationMask */) >>> 2 /* IsForValidationOffset */) === 1;
    }
    function setNodeIsForValidation(node, value) {
        node.metadata = ((node.metadata & 251 /* IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* IsForValidationOffset */));
    }
    function getNodeIsInOverviewRuler(node) {
        return ((node.metadata & 8 /* IsInOverviewRulerMask */) >>> 3 /* IsInOverviewRulerOffset */) === 1;
    }
    exports.getNodeIsInOverviewRuler = getNodeIsInOverviewRuler;
    function setNodeIsInOverviewRuler(node, value) {
        node.metadata = ((node.metadata & 247 /* IsInOverviewRulerMaskInverse */) | ((value ? 1 : 0) << 3 /* IsInOverviewRulerOffset */));
    }
    function getNodeStickiness(node) {
        return ((node.metadata & 48 /* StickinessMask */) >>> 4 /* StickinessOffset */);
    }
    function _setNodeStickiness(node, stickiness) {
        node.metadata = ((node.metadata & 207 /* StickinessMaskInverse */) | (stickiness << 4 /* StickinessOffset */));
    }
    function setNodeStickiness(node, stickiness) {
        _setNodeStickiness(node, stickiness);
    }
    exports.setNodeStickiness = setNodeStickiness;
    var IntervalNode = /** @class */ (function () {
        function IntervalNode(id, start, end) {
            this.metadata = 0;
            this.parent = null;
            this.left = null;
            this.right = null;
            setNodeColor(this, 1 /* Red */);
            this.start = start;
            this.end = end;
            // FORCE_OVERFLOWING_TEST: this.delta = start;
            this.delta = 0;
            this.maxEnd = end;
            this.id = id;
            this.ownerId = 0;
            this.options = null;
            setNodeIsForValidation(this, false);
            _setNodeStickiness(this, 1 /* NeverGrowsWhenTypingAtEdges */);
            setNodeIsInOverviewRuler(this, false);
            this.cachedVersionId = 0;
            this.cachedAbsoluteStart = start;
            this.cachedAbsoluteEnd = end;
            this.range = null;
            setNodeIsVisited(this, false);
        }
        IntervalNode.prototype.reset = function (versionId, start, end, range) {
            this.start = start;
            this.end = end;
            this.maxEnd = end;
            this.cachedVersionId = versionId;
            this.cachedAbsoluteStart = start;
            this.cachedAbsoluteEnd = end;
            this.range = range;
        };
        IntervalNode.prototype.setOptions = function (options) {
            this.options = options;
            var className = this.options.className;
            setNodeIsForValidation(this, (className === "squiggly-error" /* EditorErrorDecoration */
                || className === "squiggly-warning" /* EditorWarningDecoration */
                || className === "squiggly-info" /* EditorInfoDecoration */));
            _setNodeStickiness(this, this.options.stickiness);
            setNodeIsInOverviewRuler(this, this.options.overviewRuler.color ? true : false);
        };
        IntervalNode.prototype.setCachedOffsets = function (absoluteStart, absoluteEnd, cachedVersionId) {
            if (this.cachedVersionId !== cachedVersionId) {
                this.range = null;
            }
            this.cachedVersionId = cachedVersionId;
            this.cachedAbsoluteStart = absoluteStart;
            this.cachedAbsoluteEnd = absoluteEnd;
        };
        IntervalNode.prototype.detach = function () {
            this.parent = null;
            this.left = null;
            this.right = null;
        };
        return IntervalNode;
    }());
    exports.IntervalNode = IntervalNode;
    exports.SENTINEL = new IntervalNode(null, 0, 0);
    exports.SENTINEL.parent = exports.SENTINEL;
    exports.SENTINEL.left = exports.SENTINEL;
    exports.SENTINEL.right = exports.SENTINEL;
    setNodeColor(exports.SENTINEL, 0 /* Black */);
    var IntervalTree = /** @class */ (function () {
        function IntervalTree() {
            this.root = exports.SENTINEL;
            this.requestNormalizeDelta = false;
        }
        IntervalTree.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {
            if (this.root === exports.SENTINEL) {
                return [];
            }
            return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);
        };
        IntervalTree.prototype.search = function (filterOwnerId, filterOutValidation, cachedVersionId) {
            if (this.root === exports.SENTINEL) {
                return [];
            }
            return search(this, filterOwnerId, filterOutValidation, cachedVersionId);
        };
        /**
         * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
         */
        IntervalTree.prototype.collectNodesFromOwner = function (ownerId) {
            return collectNodesFromOwner(this, ownerId);
        };
        /**
         * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
         */
        IntervalTree.prototype.collectNodesPostOrder = function () {
            return collectNodesPostOrder(this);
        };
        IntervalTree.prototype.insert = function (node) {
            rbTreeInsert(this, node);
            this._normalizeDeltaIfNecessary();
        };
        IntervalTree.prototype.delete = function (node) {
            rbTreeDelete(this, node);
            this._normalizeDeltaIfNecessary();
        };
        IntervalTree.prototype.resolveNode = function (node, cachedVersionId) {
            var initialNode = node;
            var delta = 0;
            while (node !== this.root) {
                if (node === node.parent.right) {
                    delta += node.parent.delta;
                }
                node = node.parent;
            }
            var nodeStart = initialNode.start + delta;
            var nodeEnd = initialNode.end + delta;
            initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
        };
        IntervalTree.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {
            // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.
            // (1) collect all nodes that are intersecting this edit as nodes of interest
            var nodesOfInterest = searchForEditing(this, offset, offset + length);
            // (2) remove all nodes that are intersecting this edit
            for (var i = 0, len = nodesOfInterest.length; i < len; i++) {
                var node = nodesOfInterest[i];
                rbTreeDelete(this, node);
            }
            this._normalizeDeltaIfNecessary();
            // (3) edit all tree nodes except the nodes of interest
            noOverlapReplace(this, offset, offset + length, textLength);
            this._normalizeDeltaIfNecessary();
            // (4) edit the nodes of interest and insert them back in the tree
            for (var i = 0, len = nodesOfInterest.length; i < len; i++) {
                var node = nodesOfInterest[i];
                node.start = node.cachedAbsoluteStart;
                node.end = node.cachedAbsoluteEnd;
                nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);
                node.maxEnd = node.end;
                rbTreeInsert(this, node);
            }
            this._normalizeDeltaIfNecessary();
        };
        IntervalTree.prototype.getAllInOrder = function () {
            return search(this, 0, false, 0);
        };
        IntervalTree.prototype._normalizeDeltaIfNecessary = function () {
            if (!this.requestNormalizeDelta) {
                return;
            }
            this.requestNormalizeDelta = false;
            normalizeDelta(this);
        };
        return IntervalTree;
    }());
    exports.IntervalTree = IntervalTree;
    //#region Delta Normalization
    function normalizeDelta(T) {
        var node = T.root;
        var delta = 0;
        while (node !== exports.SENTINEL) {
            if (node.left !== exports.SENTINEL && !getNodeIsVisited(node.left)) {
                // go left
                node = node.left;
                continue;
            }
            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {
                // go right
                delta += node.delta;
                node = node.right;
                continue;
            }
            // handle current node
            node.start = delta + node.start;
            node.end = delta + node.end;
            node.delta = 0;
            recomputeMaxEnd(node);
            setNodeIsVisited(node, true);
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            if (node === node.parent.right) {
                delta -= node.parent.delta;
            }
            node = node.parent;
        }
        setNodeIsVisited(T.root, false);
    }
    //#endregion
    //#region Editing
    var MarkerMoveSemantics;
    (function (MarkerMoveSemantics) {
        MarkerMoveSemantics[MarkerMoveSemantics["MarkerDefined"] = 0] = "MarkerDefined";
        MarkerMoveSemantics[MarkerMoveSemantics["ForceMove"] = 1] = "ForceMove";
        MarkerMoveSemantics[MarkerMoveSemantics["ForceStay"] = 2] = "ForceStay";
    })(MarkerMoveSemantics || (MarkerMoveSemantics = {}));
    function adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {
        if (markerOffset < checkOffset) {
            return true;
        }
        if (markerOffset > checkOffset) {
            return false;
        }
        if (moveSemantics === 1 /* ForceMove */) {
            return false;
        }
        if (moveSemantics === 2 /* ForceStay */) {
            return true;
        }
        return markerStickToPreviousCharacter;
    }
    /**
     * This is a lot more complicated than strictly necessary to maintain the same behaviour
     * as when decorations were implemented using two markers.
     */
    function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {
        var nodeStickiness = getNodeStickiness(node);
        var startStickToPreviousCharacter = (nodeStickiness === 0 /* AlwaysGrowsWhenTypingAtEdges */
            || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);
        var endStickToPreviousCharacter = (nodeStickiness === 1 /* NeverGrowsWhenTypingAtEdges */
            || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);
        var deletingCnt = (end - start);
        var insertingCnt = textLength;
        var commonLength = Math.min(deletingCnt, insertingCnt);
        var nodeStart = node.start;
        var startDone = false;
        var nodeEnd = node.end;
        var endDone = false;
        {
            var moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */);
            if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {
                startDone = true;
            }
            if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {
                endDone = true;
            }
        }
        if (commonLength > 0 && !forceMoveMarkers) {
            var moveSemantics = (deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */);
            if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {
                startDone = true;
            }
            if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {
                endDone = true;
            }
        }
        {
            var moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */;
            if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {
                node.start = start + insertingCnt;
                startDone = true;
            }
            if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {
                node.end = start + insertingCnt;
                endDone = true;
            }
        }
        // Finish
        var deltaColumn = (insertingCnt - deletingCnt);
        if (!startDone) {
            node.start = Math.max(0, nodeStart + deltaColumn);
            startDone = true;
        }
        if (!endDone) {
            node.end = Math.max(0, nodeEnd + deltaColumn);
            endDone = true;
        }
        if (node.start > node.end) {
            node.end = node.start;
        }
    }
    exports.nodeAcceptEdit = nodeAcceptEdit;
    function searchForEditing(T, start, end) {
        // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree
        // Now, it is known that two intervals A and B overlap only when both
        // A.low <= B.high and A.high >= B.low. When searching the trees for
        // nodes overlapping with a given interval, you can immediately skip:
        //  a) all nodes to the right of nodes whose low value is past the end of the given interval.
        //  b) all nodes that have their maximum 'high' value below the start of the given interval.
        var node = T.root;
        var delta = 0;
        var nodeMaxEnd = 0;
        var nodeStart = 0;
        var nodeEnd = 0;
        var result = [];
        var resultLen = 0;
        while (node !== exports.SENTINEL) {
            if (getNodeIsVisited(node)) {
                // going up from this node
                setNodeIsVisited(node.left, false);
                setNodeIsVisited(node.right, false);
                if (node === node.parent.right) {
                    delta -= node.parent.delta;
                }
                node = node.parent;
                continue;
            }
            if (!getNodeIsVisited(node.left)) {
                // first time seeing this node
                nodeMaxEnd = delta + node.maxEnd;
                if (nodeMaxEnd < start) {
                    // cover case b) from above
                    // there is no need to search this node or its children
                    setNodeIsVisited(node, true);
                    continue;
                }
                if (node.left !== exports.SENTINEL) {
                    // go left
                    node = node.left;
                    continue;
                }
            }
            // handle current node
            nodeStart = delta + node.start;
            if (nodeStart > end) {
                // cover case a) from above
                // there is no need to search this node or its right subtree
                setNodeIsVisited(node, true);
                continue;
            }
            nodeEnd = delta + node.end;
            if (nodeEnd >= start) {
                node.setCachedOffsets(nodeStart, nodeEnd, 0);
                result[resultLen++] = node;
            }
            setNodeIsVisited(node, true);
            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {
                // go right
                delta += node.delta;
                node = node.right;
                continue;
            }
        }
        setNodeIsVisited(T.root, false);
        return result;
    }
    function noOverlapReplace(T, start, end, textLength) {
        // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree
        // Now, it is known that two intervals A and B overlap only when both
        // A.low <= B.high and A.high >= B.low. When searching the trees for
        // nodes overlapping with a given interval, you can immediately skip:
        //  a) all nodes to the right of nodes whose low value is past the end of the given interval.
        //  b) all nodes that have their maximum 'high' value below the start of the given interval.
        var node = T.root;
        var delta = 0;
        var nodeMaxEnd = 0;
        var nodeStart = 0;
        var editDelta = (textLength - (end - start));
        while (node !== exports.SENTINEL) {
            if (getNodeIsVisited(node)) {
                // going up from this node
                setNodeIsVisited(node.left, false);
                setNodeIsVisited(node.right, false);
                if (node === node.parent.right) {
                    delta -= node.parent.delta;
                }
                recomputeMaxEnd(node);
                node = node.parent;
                continue;
            }
            if (!getNodeIsVisited(node.left)) {
                // first time seeing this node
                nodeMaxEnd = delta + node.maxEnd;
                if (nodeMaxEnd < start) {
                    // cover case b) from above
                    // there is no need to search this node or its children
                    setNodeIsVisited(node, true);
                    continue;
                }
                if (node.left !== exports.SENTINEL) {
                    // go left
                    node = node.left;
                    continue;
                }
            }
            // handle current node
            nodeStart = delta + node.start;
            if (nodeStart > end) {
                node.start += editDelta;
                node.end += editDelta;
                node.delta += editDelta;
                if (node.delta < -1073741824 /* MIN_SAFE_DELTA */ || node.delta > 1073741824 /* MAX_SAFE_DELTA */) {
                    T.requestNormalizeDelta = true;
                }
                // cover case a) from above
                // there is no need to search this node or its right subtree
                setNodeIsVisited(node, true);
                continue;
            }
            setNodeIsVisited(node, true);
            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {
                // go right
                delta += node.delta;
                node = node.right;
                continue;
            }
        }
        setNodeIsVisited(T.root, false);
    }
    //#endregion
    //#region Searching
    function collectNodesFromOwner(T, ownerId) {
        var node = T.root;
        var result = [];
        var resultLen = 0;
        while (node !== exports.SENTINEL) {
            if (getNodeIsVisited(node)) {
                // going up from this node
                setNodeIsVisited(node.left, false);
                setNodeIsVisited(node.right, false);
                node = node.parent;
                continue;
            }
            if (node.left !== exports.SENTINEL && !getNodeIsVisited(node.left)) {
                // go left
                node = node.left;
                continue;
            }
            // handle current node
            if (node.ownerId === ownerId) {
                result[resultLen++] = node;
            }
            setNodeIsVisited(node, true);
            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {
                // go right
                node = node.right;
                continue;
            }
        }
        setNodeIsVisited(T.root, false);
        return result;
    }
    function collectNodesPostOrder(T) {
        var node = T.root;
        var result = [];
        var resultLen = 0;
        while (node !== exports.SENTINEL) {
            if (getNodeIsVisited(node)) {
                // going up from this node
                setNodeIsVisited(node.left, false);
                setNodeIsVisited(node.right, false);
                node = node.parent;
                continue;
            }
            if (node.left !== exports.SENTINEL && !getNodeIsVisited(node.left)) {
                // go left
                node = node.left;
                continue;
            }
            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {
                // go right
                node = node.right;
                continue;
            }
            // handle current node
            result[resultLen++] = node;
            setNodeIsVisited(node, true);
        }
        setNodeIsVisited(T.root, false);
        return result;
    }
    function search(T, filterOwnerId, filterOutValidation, cachedVersionId) {
        var node = T.root;
        var delta = 0;
        var nodeStart = 0;
        var nodeEnd = 0;
        var result = [];
        var resultLen = 0;
        while (node !== exports.SENTINEL) {
            if (getNodeIsVisited(node)) {
                // going up from this node
                setNodeIsVisited(node.left, false);
                setNodeIsVisited(node.right, false);
                if (node === node.parent.right) {
                    delta -= node.parent.delta;
                }
                node = node.parent;
                continue;
            }
            if (node.left !== exports.SENTINEL && !getNodeIsVisited(node.left)) {
                // go left
                node = node.left;
                continue;
            }
            // handle current node
            nodeStart = delta + node.start;
            nodeEnd = delta + node.end;
            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
            var include = true;
            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {
                include = false;
            }
            if (filterOutValidation && getNodeIsForValidation(node)) {
                include = false;
            }
            if (include) {
                result[resultLen++] = node;
            }
            setNodeIsVisited(node, true);
            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {
                // go right
                delta += node.delta;
                node = node.right;
                continue;
            }
        }
        setNodeIsVisited(T.root, false);
        return result;
    }
    function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {
        // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree
        // Now, it is known that two intervals A and B overlap only when both
        // A.low <= B.high and A.high >= B.low. When searching the trees for
        // nodes overlapping with a given interval, you can immediately skip:
        //  a) all nodes to the right of nodes whose low value is past the end of the given interval.
        //  b) all nodes that have their maximum 'high' value below the start of the given interval.
        var node = T.root;
        var delta = 0;
        var nodeMaxEnd = 0;
        var nodeStart = 0;
        var nodeEnd = 0;
        var result = [];
        var resultLen = 0;
        while (node !== exports.SENTINEL) {
            if (getNodeIsVisited(node)) {
                // going up from this node
                setNodeIsVisited(node.left, false);
                setNodeIsVisited(node.right, false);
                if (node === node.parent.right) {
                    delta -= node.parent.delta;
                }
                node = node.parent;
                continue;
            }
            if (!getNodeIsVisited(node.left)) {
                // first time seeing this node
                nodeMaxEnd = delta + node.maxEnd;
                if (nodeMaxEnd < intervalStart) {
                    // cover case b) from above
                    // there is no need to search this node or its children
                    setNodeIsVisited(node, true);
                    continue;
                }
                if (node.left !== exports.SENTINEL) {
                    // go left
                    node = node.left;
                    continue;
                }
            }
            // handle current node
            nodeStart = delta + node.start;
            if (nodeStart > intervalEnd) {
                // cover case a) from above
                // there is no need to search this node or its right subtree
                setNodeIsVisited(node, true);
                continue;
            }
            nodeEnd = delta + node.end;
            if (nodeEnd >= intervalStart) {
                // There is overlap
                node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
                var include = true;
                if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {
                    include = false;
                }
                if (filterOutValidation && getNodeIsForValidation(node)) {
                    include = false;
                }
                if (include) {
                    result[resultLen++] = node;
                }
            }
            setNodeIsVisited(node, true);
            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {
                // go right
                delta += node.delta;
                node = node.right;
                continue;
            }
        }
        setNodeIsVisited(T.root, false);
        return result;
    }
    //#endregion
    //#region Insertion
    function rbTreeInsert(T, newNode) {
        if (T.root === exports.SENTINEL) {
            newNode.parent = exports.SENTINEL;
            newNode.left = exports.SENTINEL;
            newNode.right = exports.SENTINEL;
            setNodeColor(newNode, 0 /* Black */);
            T.root = newNode;
            return T.root;
        }
        treeInsert(T, newNode);
        recomputeMaxEndWalkToRoot(newNode.parent);
        // repair tree
        var x = newNode;
        while (x !== T.root && getNodeColor(x.parent) === 1 /* Red */) {
            if (x.parent === x.parent.parent.left) {
                var y = x.parent.parent.right;
                if (getNodeColor(y) === 1 /* Red */) {
                    setNodeColor(x.parent, 0 /* Black */);
                    setNodeColor(y, 0 /* Black */);
                    setNodeColor(x.parent.parent, 1 /* Red */);
                    x = x.parent.parent;
                }
                else {
                    if (x === x.parent.right) {
                        x = x.parent;
                        leftRotate(T, x);
                    }
                    setNodeColor(x.parent, 0 /* Black */);
                    setNodeColor(x.parent.parent, 1 /* Red */);
                    rightRotate(T, x.parent.parent);
                }
            }
            else {
                var y = x.parent.parent.left;
                if (getNodeColor(y) === 1 /* Red */) {
                    setNodeColor(x.parent, 0 /* Black */);
                    setNodeColor(y, 0 /* Black */);
                    setNodeColor(x.parent.parent, 1 /* Red */);
                    x = x.parent.parent;
                }
                else {
                    if (x === x.parent.left) {
                        x = x.parent;
                        rightRotate(T, x);
                    }
                    setNodeColor(x.parent, 0 /* Black */);
                    setNodeColor(x.parent.parent, 1 /* Red */);
                    leftRotate(T, x.parent.parent);
                }
            }
        }
        setNodeColor(T.root, 0 /* Black */);
        return newNode;
    }
    function treeInsert(T, z) {
        var delta = 0;
        var x = T.root;
        var zAbsoluteStart = z.start;
        var zAbsoluteEnd = z.end;
        while (true) {
            var cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);
            if (cmp < 0) {
                // this node should be inserted to the left
                // => it is not affected by the node's delta
                if (x.left === exports.SENTINEL) {
                    z.start -= delta;
                    z.end -= delta;
                    z.maxEnd -= delta;
                    x.left = z;
                    break;
                }
                else {
                    x = x.left;
                }
            }
            else {
                // this node should be inserted to the right
                // => it is not affected by the node's delta
                if (x.right === exports.SENTINEL) {
                    z.start -= (delta + x.delta);
                    z.end -= (delta + x.delta);
                    z.maxEnd -= (delta + x.delta);
                    x.right = z;
                    break;
                }
                else {
                    delta += x.delta;
                    x = x.right;
                }
            }
        }
        z.parent = x;
        z.left = exports.SENTINEL;
        z.right = exports.SENTINEL;
        setNodeColor(z, 1 /* Red */);
    }
    //#endregion
    //#region Deletion
    function rbTreeDelete(T, z) {
        var x;
        var y;
        // RB-DELETE except we don't swap z and y in case c)
        // i.e. we always delete what's pointed at by z.
        if (z.left === exports.SENTINEL) {
            x = z.right;
            y = z;
            // x's delta is no longer influenced by z's delta
            x.delta += z.delta;
            if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {
                T.requestNormalizeDelta = true;
            }
            x.start += z.delta;
            x.end += z.delta;
        }
        else if (z.right === exports.SENTINEL) {
            x = z.left;
            y = z;
        }
        else {
            y = leftest(z.right);
            x = y.right;
            // y's delta is no longer influenced by z's delta,
            // but we don't want to walk the entire right-hand-side subtree of x.
            // we therefore maintain z's delta in y, and adjust only x
            x.start += y.delta;
            x.end += y.delta;
            x.delta += y.delta;
            if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {
                T.requestNormalizeDelta = true;
            }
            y.start += z.delta;
            y.end += z.delta;
            y.delta = z.delta;
            if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {
                T.requestNormalizeDelta = true;
            }
        }
        if (y === T.root) {
            T.root = x;
            setNodeColor(x, 0 /* Black */);
            z.detach();
            resetSentinel();
            recomputeMaxEnd(x);
            T.root.parent = exports.SENTINEL;
            return;
        }
        var yWasRed = (getNodeColor(y) === 1 /* Red */);
        if (y === y.parent.left) {
            y.parent.left = x;
        }
        else {
            y.parent.right = x;
        }
        if (y === z) {
            x.parent = y.parent;
        }
        else {
            if (y.parent === z) {
                x.parent = y;
            }
            else {
                x.parent = y.parent;
            }
            y.left = z.left;
            y.right = z.right;
            y.parent = z.parent;
            setNodeColor(y, getNodeColor(z));
            if (z === T.root) {
                T.root = y;
            }
            else {
                if (z === z.parent.left) {
                    z.parent.left = y;
                }
                else {
                    z.parent.right = y;
                }
            }
            if (y.left !== exports.SENTINEL) {
                y.left.parent = y;
            }
            if (y.right !== exports.SENTINEL) {
                y.right.parent = y;
            }
        }
        z.detach();
        if (yWasRed) {
            recomputeMaxEndWalkToRoot(x.parent);
            if (y !== z) {
                recomputeMaxEndWalkToRoot(y);
                recomputeMaxEndWalkToRoot(y.parent);
            }
            resetSentinel();
            return;
        }
        recomputeMaxEndWalkToRoot(x);
        recomputeMaxEndWalkToRoot(x.parent);
        if (y !== z) {
            recomputeMaxEndWalkToRoot(y);
            recomputeMaxEndWalkToRoot(y.parent);
        }
        // RB-DELETE-FIXUP
        var w;
        while (x !== T.root && getNodeColor(x) === 0 /* Black */) {
            if (x === x.parent.left) {
                w = x.parent.right;
                if (getNodeColor(w) === 1 /* Red */) {
                    setNodeColor(w, 0 /* Black */);
                    setNodeColor(x.parent, 1 /* Red */);
                    leftRotate(T, x.parent);
                    w = x.parent.right;
                }
                if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {
                    setNodeColor(w, 1 /* Red */);
                    x = x.parent;
                }
                else {
                    if (getNodeColor(w.right) === 0 /* Black */) {
                        setNodeColor(w.left, 0 /* Black */);
                        setNodeColor(w, 1 /* Red */);
                        rightRotate(T, w);
                        w = x.parent.right;
                    }
                    setNodeColor(w, getNodeColor(x.parent));
                    setNodeColor(x.parent, 0 /* Black */);
                    setNodeColor(w.right, 0 /* Black */);
                    leftRotate(T, x.parent);
                    x = T.root;
                }
            }
            else {
                w = x.parent.left;
                if (getNodeColor(w) === 1 /* Red */) {
                    setNodeColor(w, 0 /* Black */);
                    setNodeColor(x.parent, 1 /* Red */);
                    rightRotate(T, x.parent);
                    w = x.parent.left;
                }
                if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {
                    setNodeColor(w, 1 /* Red */);
                    x = x.parent;
                }
                else {
                    if (getNodeColor(w.left) === 0 /* Black */) {
                        setNodeColor(w.right, 0 /* Black */);
                        setNodeColor(w, 1 /* Red */);
                        leftRotate(T, w);
                        w = x.parent.left;
                    }
                    setNodeColor(w, getNodeColor(x.parent));
                    setNodeColor(x.parent, 0 /* Black */);
                    setNodeColor(w.left, 0 /* Black */);
                    rightRotate(T, x.parent);
                    x = T.root;
                }
            }
        }
        setNodeColor(x, 0 /* Black */);
        resetSentinel();
    }
    function leftest(node) {
        while (node.left !== exports.SENTINEL) {
            node = node.left;
        }
        return node;
    }
    function resetSentinel() {
        exports.SENTINEL.parent = exports.SENTINEL;
        exports.SENTINEL.delta = 0; // optional
        exports.SENTINEL.start = 0; // optional
        exports.SENTINEL.end = 0; // optional
    }
    //#endregion
    //#region Rotations
    function leftRotate(T, x) {
        var y = x.right; // set y.
        y.delta += x.delta; // y's delta is no longer influenced by x's delta
        if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {
            T.requestNormalizeDelta = true;
        }
        y.start += x.delta;
        y.end += x.delta;
        x.right = y.left; // turn y's left subtree into x's right subtree.
        if (y.left !== exports.SENTINEL) {
            y.left.parent = x;
        }
        y.parent = x.parent; // link x's parent to y.
        if (x.parent === exports.SENTINEL) {
            T.root = y;
        }
        else if (x === x.parent.left) {
            x.parent.left = y;
        }
        else {
            x.parent.right = y;
        }
        y.left = x; // put x on y's left.
        x.parent = y;
        recomputeMaxEnd(x);
        recomputeMaxEnd(y);
    }
    function rightRotate(T, y) {
        var x = y.left;
        y.delta -= x.delta;
        if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {
            T.requestNormalizeDelta = true;
        }
        y.start -= x.delta;
        y.end -= x.delta;
        y.left = x.right;
        if (x.right !== exports.SENTINEL) {
            x.right.parent = y;
        }
        x.parent = y.parent;
        if (y.parent === exports.SENTINEL) {
            T.root = x;
        }
        else if (y === y.parent.right) {
            y.parent.right = x;
        }
        else {
            y.parent.left = x;
        }
        x.right = y;
        y.parent = x;
        recomputeMaxEnd(y);
        recomputeMaxEnd(x);
    }
    //#endregion
    //#region max end computation
    function computeMaxEnd(node) {
        var maxEnd = node.end;
        if (node.left !== exports.SENTINEL) {
            var leftMaxEnd = node.left.maxEnd;
            if (leftMaxEnd > maxEnd) {
                maxEnd = leftMaxEnd;
            }
        }
        if (node.right !== exports.SENTINEL) {
            var rightMaxEnd = node.right.maxEnd + node.delta;
            if (rightMaxEnd > maxEnd) {
                maxEnd = rightMaxEnd;
            }
        }
        return maxEnd;
    }
    function recomputeMaxEnd(node) {
        node.maxEnd = computeMaxEnd(node);
    }
    exports.recomputeMaxEnd = recomputeMaxEnd;
    function recomputeMaxEndWalkToRoot(node) {
        while (node !== exports.SENTINEL) {
            var maxEnd = computeMaxEnd(node);
            if (node.maxEnd === maxEnd) {
                // no need to go further
                return;
            }
            node.maxEnd = maxEnd;
            node = node.parent;
        }
    }
    //#endregion
    //#region utils
    function intervalCompare(aStart, aEnd, bStart, bEnd) {
        if (aStart === bStart) {
            return aEnd - bEnd;
        }
        return aStart - bStart;
    }
    exports.intervalCompare = intervalCompare;
});
//#endregion

define(__m[140/*vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TreeNode = /** @class */ (function () {
        function TreeNode(piece, color) {
            this.piece = piece;
            this.color = color;
            this.size_left = 0;
            this.lf_left = 0;
            this.parent = null;
            this.left = null;
            this.right = null;
        }
        TreeNode.prototype.next = function () {
            if (this.right !== exports.SENTINEL) {
                return leftest(this.right);
            }
            var node = this;
            while (node.parent !== exports.SENTINEL) {
                if (node.parent.left === node) {
                    break;
                }
                node = node.parent;
            }
            if (node.parent === exports.SENTINEL) {
                return exports.SENTINEL;
            }
            else {
                return node.parent;
            }
        };
        TreeNode.prototype.prev = function () {
            if (this.left !== exports.SENTINEL) {
                return righttest(this.left);
            }
            var node = this;
            while (node.parent !== exports.SENTINEL) {
                if (node.parent.right === node) {
                    break;
                }
                node = node.parent;
            }
            if (node.parent === exports.SENTINEL) {
                return exports.SENTINEL;
            }
            else {
                return node.parent;
            }
        };
        TreeNode.prototype.detach = function () {
            this.parent = null;
            this.left = null;
            this.right = null;
        };
        return TreeNode;
    }());
    exports.TreeNode = TreeNode;
    var NodeColor;
    (function (NodeColor) {
        NodeColor[NodeColor["Black"] = 0] = "Black";
        NodeColor[NodeColor["Red"] = 1] = "Red";
    })(NodeColor = exports.NodeColor || (exports.NodeColor = {}));
    exports.SENTINEL = new TreeNode(null, 0 /* Black */);
    exports.SENTINEL.parent = exports.SENTINEL;
    exports.SENTINEL.left = exports.SENTINEL;
    exports.SENTINEL.right = exports.SENTINEL;
    exports.SENTINEL.color = 0 /* Black */;
    function leftest(node) {
        while (node.left !== exports.SENTINEL) {
            node = node.left;
        }
        return node;
    }
    exports.leftest = leftest;
    function righttest(node) {
        while (node.right !== exports.SENTINEL) {
            node = node.right;
        }
        return node;
    }
    exports.righttest = righttest;
    function calculateSize(node) {
        if (node === exports.SENTINEL) {
            return 0;
        }
        return node.size_left + node.piece.length + calculateSize(node.right);
    }
    exports.calculateSize = calculateSize;
    function calculateLF(node) {
        if (node === exports.SENTINEL) {
            return 0;
        }
        return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);
    }
    exports.calculateLF = calculateLF;
    function resetSentinel() {
        exports.SENTINEL.parent = exports.SENTINEL;
    }
    exports.resetSentinel = resetSentinel;
    function leftRotate(tree, x) {
        var y = x.right;
        // fix size_left
        y.size_left += x.size_left + (x.piece ? x.piece.length : 0);
        y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
        x.right = y.left;
        if (y.left !== exports.SENTINEL) {
            y.left.parent = x;
        }
        y.parent = x.parent;
        if (x.parent === exports.SENTINEL) {
            tree.root = y;
        }
        else if (x.parent.left === x) {
            x.parent.left = y;
        }
        else {
            x.parent.right = y;
        }
        y.left = x;
        x.parent = y;
    }
    exports.leftRotate = leftRotate;
    function rightRotate(tree, y) {
        var x = y.left;
        y.left = x.right;
        if (x.right !== exports.SENTINEL) {
            x.right.parent = y;
        }
        x.parent = y.parent;
        // fix size_left
        y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);
        y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
        if (y.parent === exports.SENTINEL) {
            tree.root = x;
        }
        else if (y === y.parent.right) {
            y.parent.right = x;
        }
        else {
            y.parent.left = x;
        }
        x.right = y;
        y.parent = x;
    }
    exports.rightRotate = rightRotate;
    function rbDelete(tree, z) {
        var x;
        var y;
        if (z.left === exports.SENTINEL) {
            y = z;
            x = y.right;
        }
        else if (z.right === exports.SENTINEL) {
            y = z;
            x = y.left;
        }
        else {
            y = leftest(z.right);
            x = y.right;
        }
        if (y === tree.root) {
            tree.root = x;
            // if x is null, we are removing the only node
            x.color = 0 /* Black */;
            z.detach();
            resetSentinel();
            tree.root.parent = exports.SENTINEL;
            return;
        }
        var yWasRed = (y.color === 1 /* Red */);
        if (y === y.parent.left) {
            y.parent.left = x;
        }
        else {
            y.parent.right = x;
        }
        if (y === z) {
            x.parent = y.parent;
            recomputeTreeMetadata(tree, x);
        }
        else {
            if (y.parent === z) {
                x.parent = y;
            }
            else {
                x.parent = y.parent;
            }
            // as we make changes to x's hierarchy, update size_left of subtree first
            recomputeTreeMetadata(tree, x);
            y.left = z.left;
            y.right = z.right;
            y.parent = z.parent;
            y.color = z.color;
            if (z === tree.root) {
                tree.root = y;
            }
            else {
                if (z === z.parent.left) {
                    z.parent.left = y;
                }
                else {
                    z.parent.right = y;
                }
            }
            if (y.left !== exports.SENTINEL) {
                y.left.parent = y;
            }
            if (y.right !== exports.SENTINEL) {
                y.right.parent = y;
            }
            // update metadata
            // we replace z with y, so in this sub tree, the length change is z.item.length
            y.size_left = z.size_left;
            y.lf_left = z.lf_left;
            recomputeTreeMetadata(tree, y);
        }
        z.detach();
        if (x.parent.left === x) {
            var newSizeLeft = calculateSize(x);
            var newLFLeft = calculateLF(x);
            if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {
                var delta = newSizeLeft - x.parent.size_left;
                var lf_delta = newLFLeft - x.parent.lf_left;
                x.parent.size_left = newSizeLeft;
                x.parent.lf_left = newLFLeft;
                updateTreeMetadata(tree, x.parent, delta, lf_delta);
            }
        }
        recomputeTreeMetadata(tree, x.parent);
        if (yWasRed) {
            resetSentinel();
            return;
        }
        // RB-DELETE-FIXUP
        var w;
        while (x !== tree.root && x.color === 0 /* Black */) {
            if (x === x.parent.left) {
                w = x.parent.right;
                if (w.color === 1 /* Red */) {
                    w.color = 0 /* Black */;
                    x.parent.color = 1 /* Red */;
                    leftRotate(tree, x.parent);
                    w = x.parent.right;
                }
                if (w.left.color === 0 /* Black */ && w.right.color === 0 /* Black */) {
                    w.color = 1 /* Red */;
                    x = x.parent;
                }
                else {
                    if (w.right.color === 0 /* Black */) {
                        w.left.color = 0 /* Black */;
                        w.color = 1 /* Red */;
                        rightRotate(tree, w);
                        w = x.parent.right;
                    }
                    w.color = x.parent.color;
                    x.parent.color = 0 /* Black */;
                    w.right.color = 0 /* Black */;
                    leftRotate(tree, x.parent);
                    x = tree.root;
                }
            }
            else {
                w = x.parent.left;
                if (w.color === 1 /* Red */) {
                    w.color = 0 /* Black */;
                    x.parent.color = 1 /* Red */;
                    rightRotate(tree, x.parent);
                    w = x.parent.left;
                }
                if (w.left.color === 0 /* Black */ && w.right.color === 0 /* Black */) {
                    w.color = 1 /* Red */;
                    x = x.parent;
                }
                else {
                    if (w.left.color === 0 /* Black */) {
                        w.right.color = 0 /* Black */;
                        w.color = 1 /* Red */;
                        leftRotate(tree, w);
                        w = x.parent.left;
                    }
                    w.color = x.parent.color;
                    x.parent.color = 0 /* Black */;
                    w.left.color = 0 /* Black */;
                    rightRotate(tree, x.parent);
                    x = tree.root;
                }
            }
        }
        x.color = 0 /* Black */;
        resetSentinel();
    }
    exports.rbDelete = rbDelete;
    function fixInsert(tree, x) {
        recomputeTreeMetadata(tree, x);
        while (x !== tree.root && x.parent.color === 1 /* Red */) {
            if (x.parent === x.parent.parent.left) {
                var y = x.parent.parent.right;
                if (y.color === 1 /* Red */) {
                    x.parent.color = 0 /* Black */;
                    y.color = 0 /* Black */;
                    x.parent.parent.color = 1 /* Red */;
                    x = x.parent.parent;
                }
                else {
                    if (x === x.parent.right) {
                        x = x.parent;
                        leftRotate(tree, x);
                    }
                    x.parent.color = 0 /* Black */;
                    x.parent.parent.color = 1 /* Red */;
                    rightRotate(tree, x.parent.parent);
                }
            }
            else {
                var y = x.parent.parent.left;
                if (y.color === 1 /* Red */) {
                    x.parent.color = 0 /* Black */;
                    y.color = 0 /* Black */;
                    x.parent.parent.color = 1 /* Red */;
                    x = x.parent.parent;
                }
                else {
                    if (x === x.parent.left) {
                        x = x.parent;
                        rightRotate(tree, x);
                    }
                    x.parent.color = 0 /* Black */;
                    x.parent.parent.color = 1 /* Red */;
                    leftRotate(tree, x.parent.parent);
                }
            }
        }
        tree.root.color = 0 /* Black */;
    }
    exports.fixInsert = fixInsert;
    function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {
        // node length change or line feed count change
        while (x !== tree.root && x !== exports.SENTINEL) {
            if (x.parent.left === x) {
                x.parent.size_left += delta;
                x.parent.lf_left += lineFeedCntDelta;
            }
            x = x.parent;
        }
    }
    exports.updateTreeMetadata = updateTreeMetadata;
    function recomputeTreeMetadata(tree, x) {
        var delta = 0;
        var lf_delta = 0;
        if (x === tree.root) {
            return;
        }
        if (delta === 0) {
            // go upwards till the node whose left subtree is changed.
            while (x !== tree.root && x === x.parent.right) {
                x = x.parent;
            }
            if (x === tree.root) {
                // well, it means we add a node to the end (inorder)
                return;
            }
            // x is the node whose right subtree is changed.
            x = x.parent;
            delta = calculateSize(x.left) - x.size_left;
            lf_delta = calculateLF(x.left) - x.lf_left;
            x.size_left += delta;
            x.lf_left += lf_delta;
        }
        // go upwards till root. O(logN)
        while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {
            if (x.parent.left === x) {
                x.parent.size_left += delta;
                x.parent.lf_left += lf_delta;
            }
            x = x.parent;
        }
    }
    exports.recomputeTreeMetadata = recomputeTreeMetadata;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[141/*vs/editor/common/model/textModelEvents*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @internal
     */
    var RawContentChangedType;
    (function (RawContentChangedType) {
        RawContentChangedType[RawContentChangedType["Flush"] = 1] = "Flush";
        RawContentChangedType[RawContentChangedType["LineChanged"] = 2] = "LineChanged";
        RawContentChangedType[RawContentChangedType["LinesDeleted"] = 3] = "LinesDeleted";
        RawContentChangedType[RawContentChangedType["LinesInserted"] = 4] = "LinesInserted";
        RawContentChangedType[RawContentChangedType["EOLChanged"] = 5] = "EOLChanged";
    })(RawContentChangedType = exports.RawContentChangedType || (exports.RawContentChangedType = {}));
    /**
     * An event describing that a model has been reset to a new value.
     * @internal
     */
    var ModelRawFlush = /** @class */ (function () {
        function ModelRawFlush() {
            this.changeType = 1 /* Flush */;
        }
        return ModelRawFlush;
    }());
    exports.ModelRawFlush = ModelRawFlush;
    /**
     * An event describing that a line has changed in a model.
     * @internal
     */
    var ModelRawLineChanged = /** @class */ (function () {
        function ModelRawLineChanged(lineNumber, detail) {
            this.changeType = 2 /* LineChanged */;
            this.lineNumber = lineNumber;
            this.detail = detail;
        }
        return ModelRawLineChanged;
    }());
    exports.ModelRawLineChanged = ModelRawLineChanged;
    /**
     * An event describing that line(s) have been deleted in a model.
     * @internal
     */
    var ModelRawLinesDeleted = /** @class */ (function () {
        function ModelRawLinesDeleted(fromLineNumber, toLineNumber) {
            this.changeType = 3 /* LinesDeleted */;
            this.fromLineNumber = fromLineNumber;
            this.toLineNumber = toLineNumber;
        }
        return ModelRawLinesDeleted;
    }());
    exports.ModelRawLinesDeleted = ModelRawLinesDeleted;
    /**
     * An event describing that line(s) have been inserted in a model.
     * @internal
     */
    var ModelRawLinesInserted = /** @class */ (function () {
        function ModelRawLinesInserted(fromLineNumber, toLineNumber, detail) {
            this.changeType = 4 /* LinesInserted */;
            this.fromLineNumber = fromLineNumber;
            this.toLineNumber = toLineNumber;
            this.detail = detail;
        }
        return ModelRawLinesInserted;
    }());
    exports.ModelRawLinesInserted = ModelRawLinesInserted;
    /**
     * An event describing that a model has had its EOL changed.
     * @internal
     */
    var ModelRawEOLChanged = /** @class */ (function () {
        function ModelRawEOLChanged() {
            this.changeType = 5 /* EOLChanged */;
        }
        return ModelRawEOLChanged;
    }());
    exports.ModelRawEOLChanged = ModelRawEOLChanged;
    /**
     * An event describing a change in the text of a model.
     * @internal
     */
    var ModelRawContentChangedEvent = /** @class */ (function () {
        function ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing) {
            this.changes = changes;
            this.versionId = versionId;
            this.isUndoing = isUndoing;
            this.isRedoing = isRedoing;
        }
        ModelRawContentChangedEvent.prototype.containsEvent = function (type) {
            for (var i = 0, len = this.changes.length; i < len; i++) {
                var change = this.changes[i];
                if (change.changeType === type) {
                    return true;
                }
            }
            return false;
        };
        ModelRawContentChangedEvent.merge = function (a, b) {
            var changes = [].concat(a.changes).concat(b.changes);
            var versionId = b.versionId;
            var isUndoing = (a.isUndoing || b.isUndoing);
            var isRedoing = (a.isRedoing || b.isRedoing);
            return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);
        };
        return ModelRawContentChangedEvent;
    }());
    exports.ModelRawContentChangedEvent = ModelRawContentChangedEvent;
    /**
     * @internal
     */
    var InternalModelContentChangeEvent = /** @class */ (function () {
        function InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent) {
            this.rawContentChangedEvent = rawContentChangedEvent;
            this.contentChangedEvent = contentChangedEvent;
        }
        InternalModelContentChangeEvent.prototype.merge = function (other) {
            var rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);
            var contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);
            return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);
        };
        InternalModelContentChangeEvent._mergeChangeEvents = function (a, b) {
            var changes = [].concat(a.changes).concat(b.changes);
            var eol = b.eol;
            var versionId = b.versionId;
            var isUndoing = (a.isUndoing || b.isUndoing);
            var isRedoing = (a.isRedoing || b.isRedoing);
            var isFlush = (a.isFlush || b.isFlush);
            return {
                changes: changes,
                eol: eol,
                versionId: versionId,
                isUndoing: isUndoing,
                isRedoing: isRedoing,
                isFlush: isFlush
            };
        };
        return InternalModelContentChangeEvent;
    }());
    exports.InternalModelContentChangeEvent = InternalModelContentChangeEvent;
});

define(__m[59/*vs/editor/common/model/textModelSearch*/], __M([0/*require*/,1/*exports*/,8/*vs/base/common/strings*/,27/*vs/editor/common/core/position*/,24/*vs/editor/common/core/range*/,25/*vs/editor/common/model*/,131/*vs/editor/common/controller/wordCharacterClassifier*/]), function (require, exports, strings, position_1, range_1, model_1, wordCharacterClassifier_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var LIMIT_FIND_COUNT = 999;
    var SearchParams = /** @class */ (function () {
        function SearchParams(searchString, isRegex, matchCase, wordSeparators) {
            this.searchString = searchString;
            this.isRegex = isRegex;
            this.matchCase = matchCase;
            this.wordSeparators = wordSeparators;
        }
        SearchParams._isMultilineRegexSource = function (searchString) {
            if (!searchString || searchString.length === 0) {
                return false;
            }
            for (var i = 0, len = searchString.length; i < len; i++) {
                var chCode = searchString.charCodeAt(i);
                if (chCode === 92 /* Backslash */) {
                    // move to next char
                    i++;
                    if (i >= len) {
                        // string ends with a \
                        break;
                    }
                    var nextChCode = searchString.charCodeAt(i);
                    if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */) {
                        return true;
                    }
                }
            }
            return false;
        };
        SearchParams.prototype.parseSearchRequest = function () {
            if (this.searchString === '') {
                return null;
            }
            // Try to create a RegExp out of the params
            var multiline;
            if (this.isRegex) {
                multiline = SearchParams._isMultilineRegexSource(this.searchString);
            }
            else {
                multiline = (this.searchString.indexOf('\n') >= 0);
            }
            var regex = null;
            try {
                regex = strings.createRegExp(this.searchString, this.isRegex, {
                    matchCase: this.matchCase,
                    wholeWord: false,
                    multiline: multiline,
                    global: true
                });
            }
            catch (err) {
                return null;
            }
            if (!regex) {
                return null;
            }
            var canUseSimpleSearch = (!this.isRegex && !multiline);
            if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {
                // casing might make a difference
                canUseSimpleSearch = this.matchCase;
            }
            return new SearchData(regex, this.wordSeparators ? wordCharacterClassifier_1.getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);
        };
        return SearchParams;
    }());
    exports.SearchParams = SearchParams;
    var SearchData = /** @class */ (function () {
        function SearchData(regex, wordSeparators, simpleSearch) {
            this.regex = regex;
            this.wordSeparators = wordSeparators;
            this.simpleSearch = simpleSearch;
        }
        return SearchData;
    }());
    exports.SearchData = SearchData;
    function createFindMatch(range, rawMatches, captureMatches) {
        if (!captureMatches) {
            return new model_1.FindMatch(range, null);
        }
        var matches = [];
        for (var i = 0, len = rawMatches.length; i < len; i++) {
            matches[i] = rawMatches[i];
        }
        return new model_1.FindMatch(range, matches);
    }
    exports.createFindMatch = createFindMatch;
    var LineFeedCounter = /** @class */ (function () {
        function LineFeedCounter(text) {
            var lineFeedsOffsets = [];
            var lineFeedsOffsetsLen = 0;
            for (var i = 0, textLen = text.length; i < textLen; i++) {
                if (text.charCodeAt(i) === 10 /* LineFeed */) {
                    lineFeedsOffsets[lineFeedsOffsetsLen++] = i;
                }
            }
            this._lineFeedsOffsets = lineFeedsOffsets;
        }
        LineFeedCounter.prototype.findLineFeedCountBeforeOffset = function (offset) {
            var lineFeedsOffsets = this._lineFeedsOffsets;
            var min = 0;
            var max = lineFeedsOffsets.length - 1;
            if (max === -1) {
                // no line feeds
                return 0;
            }
            if (offset <= lineFeedsOffsets[0]) {
                // before first line feed
                return 0;
            }
            while (min < max) {
                var mid = min + ((max - min) / 2 >> 0);
                if (lineFeedsOffsets[mid] >= offset) {
                    max = mid - 1;
                }
                else {
                    if (lineFeedsOffsets[mid + 1] >= offset) {
                        // bingo!
                        min = mid;
                        max = mid;
                    }
                    else {
                        min = mid + 1;
                    }
                }
            }
            return min + 1;
        };
        return LineFeedCounter;
    }());
    var TextModelSearch = /** @class */ (function () {
        function TextModelSearch() {
        }
        TextModelSearch.findMatches = function (model, searchParams, searchRange, captureMatches, limitResultCount) {
            var searchData = searchParams.parseSearchRequest();
            if (!searchData) {
                return [];
            }
            if (searchData.regex.multiline) {
                return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);
            }
            return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);
        };
        /**
         * Multiline search always executes on the lines concatenated with \n.
         * We must therefore compensate for the count of \n in case the model is CRLF
         */
        TextModelSearch._getMultilineMatchRange = function (model, deltaOffset, text, lfCounter, matchIndex, match0) {
            var startOffset;
            var lineFeedCountBeforeMatch = 0;
            if (model.getEOL() === '\r\n') {
                lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);
                startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \r as there were \n */;
            }
            else {
                startOffset = deltaOffset + matchIndex;
            }
            var endOffset;
            if (model.getEOL() === '\r\n') {
                var lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);
                var lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;
                endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \r as there were \n */;
            }
            else {
                endOffset = startOffset + match0.length;
            }
            var startPosition = model.getPositionAt(startOffset);
            var endPosition = model.getPositionAt(endOffset);
            return new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
        };
        TextModelSearch._doFindMatchesMultiline = function (model, searchRange, searcher, captureMatches, limitResultCount) {
            var deltaOffset = model.getOffsetAt(searchRange.getStartPosition());
            // We always execute multiline search over the lines joined with \n
            // This makes it that \n will match the EOL for both CRLF and LF models
            // We compensate for offset errors in `_getMultilineMatchRange`
            var text = model.getValueInRange(searchRange, model_1.EndOfLinePreference.LF);
            var lfCounter = (model.getEOL() === '\r\n' ? new LineFeedCounter(text) : null);
            var result = [];
            var counter = 0;
            var m;
            searcher.reset(0);
            while ((m = searcher.next(text))) {
                result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);
                if (counter >= limitResultCount) {
                    return result;
                }
            }
            return result;
        };
        TextModelSearch._doFindMatchesLineByLine = function (model, searchRange, searchData, captureMatches, limitResultCount) {
            var result = [];
            var resultLen = 0;
            // Early case for a search range that starts & stops on the same line number
            if (searchRange.startLineNumber === searchRange.endLineNumber) {
                var text_1 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);
                resultLen = this._findMatchesInLine(searchData, text_1, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
                return result;
            }
            // Collect results from first line
            var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);
            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
            // Collect results from middle lines
            for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {
                resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);
            }
            // Collect results from last line
            if (resultLen < limitResultCount) {
                var text_2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);
                resultLen = this._findMatchesInLine(searchData, text_2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);
            }
            return result;
        };
        TextModelSearch._findMatchesInLine = function (searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
            var wordSeparators = searchData.wordSeparators;
            if (!captureMatches && searchData.simpleSearch) {
                var searchString = searchData.simpleSearch;
                var searchStringLen = searchString.length;
                var textLength = text.length;
                var lastMatchIndex = -searchStringLen;
                while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
                    if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {
                        result[resultLen++] = new model_1.FindMatch(new range_1.Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
                        if (resultLen >= limitResultCount) {
                            return resultLen;
                        }
                    }
                }
                return resultLen;
            }
            var searcher = new Searcher(searchData.wordSeparators, searchData.regex);
            var m;
            // Reset regex to search from the beginning
            searcher.reset(0);
            do {
                m = searcher.next(text);
                if (m) {
                    result[resultLen++] = createFindMatch(new range_1.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
                    if (resultLen >= limitResultCount) {
                        return resultLen;
                    }
                }
            } while (m);
            return resultLen;
        };
        TextModelSearch.findNextMatch = function (model, searchParams, searchStart, captureMatches) {
            var searchData = searchParams.parseSearchRequest();
            if (!searchData) {
                return null;
            }
            var searcher = new Searcher(searchData.wordSeparators, searchData.regex);
            if (searchData.regex.multiline) {
                return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);
            }
            return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);
        };
        TextModelSearch._doFindNextMatchMultiline = function (model, searchStart, searcher, captureMatches) {
            var searchTextStart = new position_1.Position(searchStart.lineNumber, 1);
            var deltaOffset = model.getOffsetAt(searchTextStart);
            var lineCount = model.getLineCount();
            // We always execute multiline search over the lines joined with \n
            // This makes it that \n will match the EOL for both CRLF and LF models
            // We compensate for offset errors in `_getMultilineMatchRange`
            var text = model.getValueInRange(new range_1.Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), model_1.EndOfLinePreference.LF);
            var lfCounter = (model.getEOL() === '\r\n' ? new LineFeedCounter(text) : null);
            searcher.reset(searchStart.column - 1);
            var m = searcher.next(text);
            if (m) {
                return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);
            }
            if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {
                // Try again from the top
                return this._doFindNextMatchMultiline(model, new position_1.Position(1, 1), searcher, captureMatches);
            }
            return null;
        };
        TextModelSearch._doFindNextMatchLineByLine = function (model, searchStart, searcher, captureMatches) {
            var lineCount = model.getLineCount();
            var startLineNumber = searchStart.lineNumber;
            // Look in first line
            var text = model.getLineContent(startLineNumber);
            var r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);
            if (r) {
                return r;
            }
            for (var i = 1; i <= lineCount; i++) {
                var lineIndex = (startLineNumber + i - 1) % lineCount;
                var text_3 = model.getLineContent(lineIndex + 1);
                var r_1 = this._findFirstMatchInLine(searcher, text_3, lineIndex + 1, 1, captureMatches);
                if (r_1) {
                    return r_1;
                }
            }
            return null;
        };
        TextModelSearch._findFirstMatchInLine = function (searcher, text, lineNumber, fromColumn, captureMatches) {
            // Set regex to search from column
            searcher.reset(fromColumn - 1);
            var m = searcher.next(text);
            if (m) {
                return createFindMatch(new range_1.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
            }
            return null;
        };
        TextModelSearch.findPreviousMatch = function (model, searchParams, searchStart, captureMatches) {
            var searchData = searchParams.parseSearchRequest();
            if (!searchData) {
                return null;
            }
            var searcher = new Searcher(searchData.wordSeparators, searchData.regex);
            if (searchData.regex.multiline) {
                return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);
            }
            return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);
        };
        TextModelSearch._doFindPreviousMatchMultiline = function (model, searchStart, searcher, captureMatches) {
            var matches = this._doFindMatchesMultiline(model, new range_1.Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);
            if (matches.length > 0) {
                return matches[matches.length - 1];
            }
            var lineCount = model.getLineCount();
            if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {
                // Try again with all content
                return this._doFindPreviousMatchMultiline(model, new position_1.Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);
            }
            return null;
        };
        TextModelSearch._doFindPreviousMatchLineByLine = function (model, searchStart, searcher, captureMatches) {
            var lineCount = model.getLineCount();
            var startLineNumber = searchStart.lineNumber;
            // Look in first line
            var text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);
            var r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);
            if (r) {
                return r;
            }
            for (var i = 1; i <= lineCount; i++) {
                var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;
                var text_4 = model.getLineContent(lineIndex + 1);
                var r_2 = this._findLastMatchInLine(searcher, text_4, lineIndex + 1, captureMatches);
                if (r_2) {
                    return r_2;
                }
            }
            return null;
        };
        TextModelSearch._findLastMatchInLine = function (searcher, text, lineNumber, captureMatches) {
            var bestResult = null;
            var m;
            searcher.reset(0);
            while ((m = searcher.next(text))) {
                bestResult = createFindMatch(new range_1.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
            }
            return bestResult;
        };
        return TextModelSearch;
    }());
    exports.TextModelSearch = TextModelSearch;
    function leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
        if (matchStartIndex === 0) {
            // Match starts at start of string
            return true;
        }
        var charBefore = text.charCodeAt(matchStartIndex - 1);
        if (wordSeparators.get(charBefore) !== 0 /* Regular */) {
            // The character before the match is a word separator
            return true;
        }
        if (charBefore === 13 /* CarriageReturn */ || charBefore === 10 /* LineFeed */) {
            // The character before the match is line break or carriage return.
            return true;
        }
        if (matchLength > 0) {
            var firstCharInMatch = text.charCodeAt(matchStartIndex);
            if (wordSeparators.get(firstCharInMatch) !== 0 /* Regular */) {
                // The first character inside the match is a word separator
                return true;
            }
        }
        return false;
    }
    function rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
        if (matchStartIndex + matchLength === textLength) {
            // Match ends at end of string
            return true;
        }
        var charAfter = text.charCodeAt(matchStartIndex + matchLength);
        if (wordSeparators.get(charAfter) !== 0 /* Regular */) {
            // The character after the match is a word separator
            return true;
        }
        if (charAfter === 13 /* CarriageReturn */ || charAfter === 10 /* LineFeed */) {
            // The character after the match is line break or carriage return.
            return true;
        }
        if (matchLength > 0) {
            var lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
            if (wordSeparators.get(lastCharInMatch) !== 0 /* Regular */) {
                // The last character in the match is a word separator
                return true;
            }
        }
        return false;
    }
    function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {
        return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)
            && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));
    }
    exports.isValidMatch = isValidMatch;
    var Searcher = /** @class */ (function () {
        function Searcher(wordSeparators, searchRegex) {
            this._wordSeparators = wordSeparators;
            this._searchRegex = searchRegex;
            this._prevMatchStartIndex = -1;
            this._prevMatchLength = 0;
        }
        Searcher.prototype.reset = function (lastIndex) {
            this._searchRegex.lastIndex = lastIndex;
            this._prevMatchStartIndex = -1;
            this._prevMatchLength = 0;
        };
        Searcher.prototype.next = function (text) {
            var textLength = text.length;
            var m;
            do {
                if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
                    // Reached the end of the line
                    return null;
                }
                m = this._searchRegex.exec(text);
                if (!m) {
                    return null;
                }
                var matchStartIndex = m.index;
                var matchLength = m[0].length;
                if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
                    // Exit early if the regex matches the same range twice
                    return null;
                }
                this._prevMatchStartIndex = matchStartIndex;
                this._prevMatchLength = matchLength;
                if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
                    return m;
                }
            } while (m);
            return null;
        };
        return Searcher;
    }());
    exports.Searcher = Searcher;
});

define(__m[60/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase*/], __M([0/*require*/,1/*exports*/,27/*vs/editor/common/core/position*/,24/*vs/editor/common/core/range*/,140/*vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase*/,59/*vs/editor/common/model/textModelSearch*/,25/*vs/editor/common/model*/]), function (require, exports, position_1, range_1, rbTreeBase_1, textModelSearch_1, model_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // const lfRegex = new RegExp(/\r\n|\r|\n/g);
    exports.AverageBufferSize = 65535;
    function createUintArray(arr) {
        var r;
        if (arr[arr.length - 1] < 65536) {
            r = new Uint16Array(arr.length);
        }
        else {
            r = new Uint32Array(arr.length);
        }
        r.set(arr, 0);
        return r;
    }
    exports.createUintArray = createUintArray;
    var LineStarts = /** @class */ (function () {
        function LineStarts(lineStarts, cr, lf, crlf, isBasicASCII) {
            this.lineStarts = lineStarts;
            this.cr = cr;
            this.lf = lf;
            this.crlf = crlf;
            this.isBasicASCII = isBasicASCII;
        }
        return LineStarts;
    }());
    exports.LineStarts = LineStarts;
    function createLineStartsFast(str, readonly) {
        if (readonly === void 0) { readonly = true; }
        var r = [0], rLength = 1;
        for (var i = 0, len = str.length; i < len; i++) {
            var chr = str.charCodeAt(i);
            if (chr === 13 /* CarriageReturn */) {
                if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {
                    // \r\n... case
                    r[rLength++] = i + 2;
                    i++; // skip \n
                }
                else {
                    // \r... case
                    r[rLength++] = i + 1;
                }
            }
            else if (chr === 10 /* LineFeed */) {
                r[rLength++] = i + 1;
            }
        }
        if (readonly) {
            return createUintArray(r);
        }
        else {
            return r;
        }
    }
    exports.createLineStartsFast = createLineStartsFast;
    function createLineStarts(r, str) {
        r.length = 0;
        r[0] = 0;
        var rLength = 1;
        var cr = 0, lf = 0, crlf = 0;
        var isBasicASCII = true;
        for (var i = 0, len = str.length; i < len; i++) {
            var chr = str.charCodeAt(i);
            if (chr === 13 /* CarriageReturn */) {
                if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {
                    // \r\n... case
                    crlf++;
                    r[rLength++] = i + 2;
                    i++; // skip \n
                }
                else {
                    cr++;
                    // \r... case
                    r[rLength++] = i + 1;
                }
            }
            else if (chr === 10 /* LineFeed */) {
                lf++;
                r[rLength++] = i + 1;
            }
            else {
                if (isBasicASCII) {
                    if (chr !== 9 /* Tab */ && (chr < 32 || chr > 126)) {
                        isBasicASCII = false;
                    }
                }
            }
        }
        var result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);
        r.length = 0;
        return result;
    }
    exports.createLineStarts = createLineStarts;
    var Piece = /** @class */ (function () {
        function Piece(bufferIndex, start, end, lineFeedCnt, length) {
            this.bufferIndex = bufferIndex;
            this.start = start;
            this.end = end;
            this.lineFeedCnt = lineFeedCnt;
            this.length = length;
        }
        return Piece;
    }());
    exports.Piece = Piece;
    var StringBuffer = /** @class */ (function () {
        function StringBuffer(buffer, lineStarts) {
            this.buffer = buffer;
            this.lineStarts = lineStarts;
        }
        return StringBuffer;
    }());
    exports.StringBuffer = StringBuffer;
    /**
     * Readonly snapshot for piece tree.
     * In a real multiple thread environment, to make snapshot reading always work correctly, we need to
     * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.
     * 2. TreeNode/Buffers normalization should not happen during snapshot reading.
     */
    var PieceTreeSnapshot = /** @class */ (function () {
        function PieceTreeSnapshot(tree, BOM) {
            var _this = this;
            this._pieces = [];
            this._tree = tree;
            this._BOM = BOM;
            this._index = 0;
            if (tree.root !== rbTreeBase_1.SENTINEL) {
                tree.iterate(tree.root, function (node) {
                    if (node !== rbTreeBase_1.SENTINEL) {
                        _this._pieces.push(node.piece);
                    }
                    return true;
                });
            }
        }
        PieceTreeSnapshot.prototype.read = function () {
            if (this._pieces.length === 0) {
                if (this._index === 0) {
                    this._index++;
                    return this._BOM;
                }
                else {
                    return null;
                }
            }
            if (this._index > this._pieces.length - 1) {
                return null;
            }
            if (this._index === 0) {
                return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);
            }
            return this._tree.getPieceContent(this._pieces[this._index++]);
        };
        return PieceTreeSnapshot;
    }());
    var PieceTreeSearchCache = /** @class */ (function () {
        function PieceTreeSearchCache(limit) {
            this._limit = limit;
            this._cache = [];
        }
        PieceTreeSearchCache.prototype.get = function (offset) {
            for (var i = this._cache.length - 1; i >= 0; i--) {
                var nodePos = this._cache[i];
                if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {
                    return nodePos;
                }
            }
            return null;
        };
        PieceTreeSearchCache.prototype.get2 = function (lineNumber) {
            for (var i = this._cache.length - 1; i >= 0; i--) {
                var nodePos = this._cache[i];
                if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {
                    return nodePos;
                }
            }
            return null;
        };
        PieceTreeSearchCache.prototype.set = function (nodePosition) {
            if (this._cache.length >= this._limit) {
                this._cache.shift();
            }
            this._cache.push(nodePosition);
        };
        PieceTreeSearchCache.prototype.valdiate = function (offset) {
            var hasInvalidVal = false;
            for (var i = 0; i < this._cache.length; i++) {
                var nodePos = this._cache[i];
                if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {
                    this._cache[i] = null;
                    hasInvalidVal = true;
                    continue;
                }
            }
            if (hasInvalidVal) {
                var newArr = [];
                for (var i = 0; i < this._cache.length; i++) {
                    if (this._cache[i] !== null) {
                        newArr.push(this._cache[i]);
                    }
                }
                this._cache = newArr;
            }
        };
        return PieceTreeSearchCache;
    }());
    var PieceTreeBase = /** @class */ (function () {
        function PieceTreeBase(chunks, eol, eolNormalized) {
            this.create(chunks, eol, eolNormalized);
        }
        PieceTreeBase.prototype.create = function (chunks, eol, eolNormalized) {
            this._buffers = [
                new StringBuffer('', [0])
            ];
            this._lastChangeBufferPos = { line: 0, column: 0 };
            this.root = rbTreeBase_1.SENTINEL;
            this._lineCnt = 1;
            this._length = 0;
            this._EOL = eol;
            this._EOLLength = eol.length;
            this._EOLNormalized = eolNormalized;
            var lastNode = null;
            for (var i = 0, len = chunks.length; i < len; i++) {
                if (chunks[i].buffer.length > 0) {
                    if (!chunks[i].lineStarts) {
                        chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);
                    }
                    var piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);
                    this._buffers.push(chunks[i]);
                    lastNode = this.rbInsertRight(lastNode, piece);
                }
            }
            this._searchCache = new PieceTreeSearchCache(1);
            this._lastVisitedLine = { lineNumber: 0, value: null };
            this.computeBufferMetadata();
        };
        PieceTreeBase.prototype.normalizeEOL = function (eol) {
            var _this = this;
            var averageBufferSize = exports.AverageBufferSize;
            var min = averageBufferSize - Math.floor(averageBufferSize / 3);
            var max = min * 2;
            var tempChunk = '';
            var tempChunkLen = 0;
            var chunks = [];
            this.iterate(this.root, function (node) {
                var str = _this.getNodeContent(node);
                var len = str.length;
                if (tempChunkLen <= min || tempChunkLen + len < max) {
                    tempChunk += str;
                    tempChunkLen += len;
                    return true;
                }
                // flush anyways
                var text = tempChunk.replace(/\r\n|\r|\n/g, eol);
                chunks.push(new StringBuffer(text, createLineStartsFast(text)));
                tempChunk = str;
                tempChunkLen = len;
                return true;
            });
            if (tempChunkLen > 0) {
                var text = tempChunk.replace(/\r\n|\r|\n/g, eol);
                chunks.push(new StringBuffer(text, createLineStartsFast(text)));
            }
            this.create(chunks, eol, true);
        };
        // #region Buffer API
        PieceTreeBase.prototype.getEOL = function () {
            return this._EOL;
        };
        PieceTreeBase.prototype.setEOL = function (newEOL) {
            this._EOL = newEOL;
            this._EOLLength = this._EOL.length;
            this.normalizeEOL(newEOL);
        };
        PieceTreeBase.prototype.createSnapshot = function (BOM) {
            return new PieceTreeSnapshot(this, BOM);
        };
        PieceTreeBase.prototype.equal = function (other) {
            var _this = this;
            if (this.getLength() !== other.getLength()) {
                return false;
            }
            if (this.getLineCount() !== other.getLineCount()) {
                return false;
            }
            var offset = 0;
            var ret = this.iterate(this.root, function (node) {
                if (node === rbTreeBase_1.SENTINEL) {
                    return true;
                }
                var str = _this.getNodeContent(node);
                var len = str.length;
                var startPosition = other.nodeAt(offset);
                var endPosition = other.nodeAt(offset + len);
                var val = other.getValueInRange2(startPosition, endPosition);
                return str === val;
            });
            return ret;
        };
        PieceTreeBase.prototype.getOffsetAt = function (lineNumber, column) {
            var leftLen = 0; // inorder
            var x = this.root;
            while (x !== rbTreeBase_1.SENTINEL) {
                if (x.left !== rbTreeBase_1.SENTINEL && x.lf_left + 1 >= lineNumber) {
                    x = x.left;
                }
                else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {
                    leftLen += x.size_left;
                    // lineNumber >= 2
                    var accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                    return leftLen += accumualtedValInCurrentIndex + column - 1;
                }
                else {
                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;
                    leftLen += x.size_left + x.piece.length;
                    x = x.right;
                }
            }
            return leftLen;
        };
        PieceTreeBase.prototype.getPositionAt = function (offset) {
            offset = Math.floor(offset);
            offset = Math.max(0, offset);
            var x = this.root;
            var lfCnt = 0;
            var originalOffset = offset;
            while (x !== rbTreeBase_1.SENTINEL) {
                if (x.size_left !== 0 && x.size_left >= offset) {
                    x = x.left;
                }
                else if (x.size_left + x.piece.length >= offset) {
                    var out = this.getIndexOf(x, offset - x.size_left);
                    lfCnt += x.lf_left + out.index;
                    if (out.index === 0) {
                        var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
                        var column = originalOffset - lineStartOffset;
                        return new position_1.Position(lfCnt + 1, column + 1);
                    }
                    return new position_1.Position(lfCnt + 1, out.remainder + 1);
                }
                else {
                    offset -= x.size_left + x.piece.length;
                    lfCnt += x.lf_left + x.piece.lineFeedCnt;
                    if (x.right === rbTreeBase_1.SENTINEL) {
                        // last node
                        var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
                        var column = originalOffset - offset - lineStartOffset;
                        return new position_1.Position(lfCnt + 1, column + 1);
                    }
                    else {
                        x = x.right;
                    }
                }
            }
            return new position_1.Position(1, 1);
        };
        PieceTreeBase.prototype.getValueInRange = function (range, eol) {
            if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {
                return '';
            }
            var startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);
            var endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);
            var value = this.getValueInRange2(startPosition, endPosition);
            if (eol) {
                if (eol !== this._EOL || !this._EOLNormalized) {
                    return value.replace(/\r\n|\r|\n/g, eol);
                }
                if (eol === this.getEOL() && this._EOLNormalized) {
                    if (eol === '\r\n') {
                    }
                    return value;
                }
                return value.replace(/\r\n|\r|\n/g, eol);
            }
            return value;
        };
        PieceTreeBase.prototype.getValueInRange2 = function (startPosition, endPosition) {
            if (startPosition.node === endPosition.node) {
                var node = startPosition.node;
                var buffer_1 = this._buffers[node.piece.bufferIndex].buffer;
                var startOffset_1 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
                return buffer_1.substring(startOffset_1 + startPosition.remainder, startOffset_1 + endPosition.remainder);
            }
            var x = startPosition.node;
            var buffer = this._buffers[x.piece.bufferIndex].buffer;
            var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
            var ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);
            x = x.next();
            while (x !== rbTreeBase_1.SENTINEL) {
                var buffer_2 = this._buffers[x.piece.bufferIndex].buffer;
                var startOffset_2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                if (x === endPosition.node) {
                    ret += buffer_2.substring(startOffset_2, startOffset_2 + endPosition.remainder);
                    break;
                }
                else {
                    ret += buffer_2.substr(startOffset_2, x.piece.length);
                }
                x = x.next();
            }
            return ret;
        };
        PieceTreeBase.prototype.getLinesContent = function () {
            return this.getContentOfSubTree(this.root).split(/\r\n|\r|\n/);
        };
        PieceTreeBase.prototype.getLength = function () {
            return this._length;
        };
        PieceTreeBase.prototype.getLineCount = function () {
            return this._lineCnt;
        };
        PieceTreeBase.prototype.getLineContent = function (lineNumber) {
            if (this._lastVisitedLine.lineNumber === lineNumber) {
                return this._lastVisitedLine.value;
            }
            this._lastVisitedLine.lineNumber = lineNumber;
            if (lineNumber === this._lineCnt) {
                this._lastVisitedLine.value = this.getLineRawContent(lineNumber);
            }
            else if (this._EOLNormalized) {
                this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);
            }
            else {
                this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\r\n|\r|\n)$/, '');
            }
            return this._lastVisitedLine.value;
        };
        PieceTreeBase.prototype.getLineCharCode = function (lineNumber, index) {
            var nodePos = this.nodeAt2(lineNumber, index + 1);
            if (nodePos.remainder === nodePos.node.piece.length) {
                // the char we want to fetch is at the head of next node.
                var matchingNode = nodePos.node.next();
                if (!matchingNode) {
                    return 0;
                }
                var buffer = this._buffers[matchingNode.piece.bufferIndex];
                var startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);
                return buffer.buffer.charCodeAt(startOffset);
            }
            else {
                var buffer = this._buffers[nodePos.node.piece.bufferIndex];
                var startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);
                var targetOffset = startOffset + nodePos.remainder;
                return buffer.buffer.charCodeAt(targetOffset);
            }
        };
        PieceTreeBase.prototype.getLineLength = function (lineNumber) {
            if (lineNumber === this.getLineCount()) {
                var startOffset = this.getOffsetAt(lineNumber, 1);
                return this.getLength() - startOffset;
            }
            return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;
        };
        PieceTreeBase.prototype.findMatchesInNode = function (node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {
            var buffer = this._buffers[node.piece.bufferIndex];
            var startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
            var start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);
            var end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);
            var m;
            // Reset regex to search from the beginning
            searcher.reset(start);
            var ret = { line: 0, column: 0 };
            do {
                m = searcher.next(buffer.buffer);
                if (m) {
                    if (m.index >= end) {
                        return resultLen;
                    }
                    this.positionInBuffer(node, m.index - startOffsetInBuffer, ret);
                    var lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);
                    var retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;
                    var retEndColumn = retStartColumn + m[0].length;
                    result[resultLen++] = textModelSearch_1.createFindMatch(new range_1.Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);
                    if (m.index + m[0].length >= end) {
                        return resultLen;
                    }
                    if (resultLen >= limitResultCount) {
                        return resultLen;
                    }
                }
            } while (m);
            return resultLen;
        };
        PieceTreeBase.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {
            var result = [];
            var resultLen = 0;
            var searcher = new textModelSearch_1.Searcher(searchData.wordSeparators, searchData.regex);
            var startPostion = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);
            if (startPostion === null) {
                return [];
            }
            var endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);
            if (endPosition === null) {
                return [];
            }
            var start = this.positionInBuffer(startPostion.node, startPostion.remainder);
            var end = this.positionInBuffer(endPosition.node, endPosition.remainder);
            if (startPostion.node === endPosition.node) {
                this.findMatchesInNode(startPostion.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
                return result;
            }
            var startLineNumber = searchRange.startLineNumber;
            var currentNode = startPostion.node;
            while (currentNode !== endPosition.node) {
                var lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);
                if (lineBreakCnt >= 1) {
                    // last line break position
                    var lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;
                    var startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);
                    var nextLineStartOffset = lineStarts[start.line + lineBreakCnt];
                    var startColumn_1 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
                    resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn_1, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);
                    if (resultLen >= limitResultCount) {
                        return result;
                    }
                    startLineNumber += lineBreakCnt;
                }
                var startColumn_2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
                // search for the remaining content
                if (startLineNumber === searchRange.endLineNumber) {
                    var text = this.getLineContent(startLineNumber).substring(startColumn_2, searchRange.endColumn - 1);
                    resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);
                    return result;
                }
                resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn_2), startLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);
                if (resultLen >= limitResultCount) {
                    return result;
                }
                startLineNumber++;
                startPostion = this.nodeAt2(startLineNumber, 1);
                currentNode = startPostion.node;
                start = this.positionInBuffer(startPostion.node, startPostion.remainder);
            }
            if (startLineNumber === searchRange.endLineNumber) {
                var startColumn_3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
                var text = this.getLineContent(startLineNumber).substring(startColumn_3, searchRange.endColumn - 1);
                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_3, resultLen, result, captureMatches, limitResultCount);
                return result;
            }
            var startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
            resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
            return result;
        };
        PieceTreeBase.prototype._findMatchesInLine = function (searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
            var wordSeparators = searchData.wordSeparators;
            if (!captureMatches && searchData.simpleSearch) {
                var searchString = searchData.simpleSearch;
                var searchStringLen = searchString.length;
                var textLength = text.length;
                var lastMatchIndex = -searchStringLen;
                while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
                    if (!wordSeparators || textModelSearch_1.isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {
                        result[resultLen++] = new model_1.FindMatch(new range_1.Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
                        if (resultLen >= limitResultCount) {
                            return resultLen;
                        }
                    }
                }
                return resultLen;
            }
            var m;
            // Reset regex to search from the beginning
            searcher.reset(0);
            do {
                m = searcher.next(text);
                if (m) {
                    result[resultLen++] = textModelSearch_1.createFindMatch(new range_1.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
                    if (resultLen >= limitResultCount) {
                        return resultLen;
                    }
                }
            } while (m);
            return resultLen;
        };
        // #endregion
        // #region Piece Table
        PieceTreeBase.prototype.insert = function (offset, value, eolNormalized) {
            if (eolNormalized === void 0) { eolNormalized = false; }
            this._EOLNormalized = this._EOLNormalized && eolNormalized;
            this._lastVisitedLine.lineNumber = 0;
            this._lastVisitedLine.value = null;
            if (this.root !== rbTreeBase_1.SENTINEL) {
                var _a = this.nodeAt(offset), node = _a.node, remainder = _a.remainder, nodeStartOffset = _a.nodeStartOffset;
                var piece = node.piece;
                var bufferIndex = piece.bufferIndex;
                var insertPosInBuffer = this.positionInBuffer(node, remainder);
                if (node.piece.bufferIndex === 0 &&
                    piece.end.line === this._lastChangeBufferPos.line &&
                    piece.end.column === this._lastChangeBufferPos.column &&
                    (nodeStartOffset + piece.length === offset) &&
                    value.length < exports.AverageBufferSize) {
                    // changed buffer
                    this.appendToNode(node, value);
                    this.computeBufferMetadata();
                    return;
                }
                if (nodeStartOffset === offset) {
                    this.insertContentToNodeLeft(value, node);
                    this._searchCache.valdiate(offset);
                }
                else if (nodeStartOffset + node.piece.length > offset) {
                    // we are inserting into the middle of a node.
                    var nodesToDel = [];
                    var newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));
                    if (this.shouldCheckCRLF() && this.endWithCR(value)) {
                        var headOfRight = this.nodeCharCodeAt(node, remainder);
                        if (headOfRight === 10 /** \n */) {
                            var newStart = { line: newRightPiece.start.line + 1, column: 0 };
                            newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);
                            value += '\n';
                        }
                    }
                    // reuse node for content before insertion point.
                    if (this.shouldCheckCRLF() && this.startWithLF(value)) {
                        var tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);
                        if (tailOfLeft === 13 /** \r */) {
                            var previousPos = this.positionInBuffer(node, remainder - 1);
                            this.deleteNodeTail(node, previousPos);
                            value = '\r' + value;
                            if (node.piece.length === 0) {
                                nodesToDel.push(node);
                            }
                        }
                        else {
                            this.deleteNodeTail(node, insertPosInBuffer);
                        }
                    }
                    else {
                        this.deleteNodeTail(node, insertPosInBuffer);
                    }
                    var newPieces = this.createNewPieces(value);
                    if (newRightPiece.length > 0) {
                        this.rbInsertRight(node, newRightPiece);
                    }
                    var tmpNode = node;
                    for (var k = 0; k < newPieces.length; k++) {
                        tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
                    }
                    this.deleteNodes(nodesToDel);
                }
                else {
                    this.insertContentToNodeRight(value, node);
                }
            }
            else {
                // insert new node
                var pieces = this.createNewPieces(value);
                var node = this.rbInsertLeft(null, pieces[0]);
                for (var k = 1; k < pieces.length; k++) {
                    node = this.rbInsertRight(node, pieces[k]);
                }
            }
            // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.
            this.computeBufferMetadata();
        };
        PieceTreeBase.prototype.delete = function (offset, cnt) {
            this._lastVisitedLine.lineNumber = 0;
            this._lastVisitedLine.value = null;
            if (cnt <= 0 || this.root === rbTreeBase_1.SENTINEL) {
                return;
            }
            var startPosition = this.nodeAt(offset);
            var endPosition = this.nodeAt(offset + cnt);
            var startNode = startPosition.node;
            var endNode = endPosition.node;
            if (startNode === endNode) {
                var startSplitPosInBuffer_1 = this.positionInBuffer(startNode, startPosition.remainder);
                var endSplitPosInBuffer_1 = this.positionInBuffer(startNode, endPosition.remainder);
                if (startPosition.nodeStartOffset === offset) {
                    if (cnt === startNode.piece.length) { // delete node
                        var next = startNode.next();
                        rbTreeBase_1.rbDelete(this, startNode);
                        this.validateCRLFWithPrevNode(next);
                        this.computeBufferMetadata();
                        return;
                    }
                    this.deleteNodeHead(startNode, endSplitPosInBuffer_1);
                    this._searchCache.valdiate(offset);
                    this.validateCRLFWithPrevNode(startNode);
                    this.computeBufferMetadata();
                    return;
                }
                if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {
                    this.deleteNodeTail(startNode, startSplitPosInBuffer_1);
                    this.validateCRLFWithNextNode(startNode);
                    this.computeBufferMetadata();
                    return;
                }
                // delete content in the middle, this node will be splitted to nodes
                this.shrinkNode(startNode, startSplitPosInBuffer_1, endSplitPosInBuffer_1);
                this.computeBufferMetadata();
                return;
            }
            var nodesToDel = [];
            var startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);
            this.deleteNodeTail(startNode, startSplitPosInBuffer);
            this._searchCache.valdiate(offset);
            if (startNode.piece.length === 0) {
                nodesToDel.push(startNode);
            }
            // update last touched node
            var endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);
            this.deleteNodeHead(endNode, endSplitPosInBuffer);
            if (endNode.piece.length === 0) {
                nodesToDel.push(endNode);
            }
            // delete nodes in between
            var secondNode = startNode.next();
            for (var node = secondNode; node !== rbTreeBase_1.SENTINEL && node !== endNode; node = node.next()) {
                nodesToDel.push(node);
            }
            var prev = startNode.piece.length === 0 ? startNode.prev() : startNode;
            this.deleteNodes(nodesToDel);
            this.validateCRLFWithNextNode(prev);
            this.computeBufferMetadata();
        };
        PieceTreeBase.prototype.insertContentToNodeLeft = function (value, node) {
            // we are inserting content to the beginning of node
            var nodesToDel = [];
            if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {
                // move `\n` to new node.
                var piece = node.piece;
                var newStart = { line: piece.start.line + 1, column: 0 };
                var nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);
                node.piece = nPiece;
                value += '\n';
                rbTreeBase_1.updateTreeMetadata(this, node, -1, -1);
                if (node.piece.length === 0) {
                    nodesToDel.push(node);
                }
            }
            var newPieces = this.createNewPieces(value);
            var newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);
            for (var k = newPieces.length - 2; k >= 0; k--) {
                newNode = this.rbInsertLeft(newNode, newPieces[k]);
            }
            this.validateCRLFWithPrevNode(newNode);
            this.deleteNodes(nodesToDel);
        };
        PieceTreeBase.prototype.insertContentToNodeRight = function (value, node) {
            // we are inserting to the right of this node.
            if (this.adjustCarriageReturnFromNext(value, node)) {
                // move \n to the new node.
                value += '\n';
            }
            var newPieces = this.createNewPieces(value);
            var newNode = this.rbInsertRight(node, newPieces[0]);
            var tmpNode = newNode;
            for (var k = 1; k < newPieces.length; k++) {
                tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
            }
            this.validateCRLFWithPrevNode(newNode);
        };
        PieceTreeBase.prototype.positionInBuffer = function (node, remainder, ret) {
            var piece = node.piece;
            var bufferIndex = node.piece.bufferIndex;
            var lineStarts = this._buffers[bufferIndex].lineStarts;
            var startOffset = lineStarts[piece.start.line] + piece.start.column;
            var offset = startOffset + remainder;
            // binary search offset between startOffset and endOffset
            var low = piece.start.line;
            var high = piece.end.line;
            var mid;
            var midStop;
            var midStart;
            while (low <= high) {
                mid = low + ((high - low) / 2) | 0;
                midStart = lineStarts[mid];
                if (mid === high) {
                    break;
                }
                midStop = lineStarts[mid + 1];
                if (offset < midStart) {
                    high = mid - 1;
                }
                else if (offset >= midStop) {
                    low = mid + 1;
                }
                else {
                    break;
                }
            }
            if (ret) {
                ret.line = mid;
                ret.column = offset - midStart;
                return null;
            }
            return {
                line: mid,
                column: offset - midStart
            };
        };
        PieceTreeBase.prototype.getLineFeedCnt = function (bufferIndex, start, end) {
            // we don't need to worry about start: abc\r|\n, or abc|\r, or abc|\n, or abc|\r\n doesn't change the fact that, there is one line break after start.
            // now let's take care of end: abc\r|\n, if end is in between \r and \n, we need to add line feed count by 1
            if (end.column === 0) {
                return end.line - start.line;
            }
            var lineStarts = this._buffers[bufferIndex].lineStarts;
            if (end.line === lineStarts.length - 1) { // it means, there is no \n after end, otherwise, there will be one more lineStart.
                return end.line - start.line;
            }
            var nextLineStartOffset = lineStarts[end.line + 1];
            var endOffset = lineStarts[end.line] + end.column;
            if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \n
                return end.line - start.line;
            }
            // endOffset + 1 === nextLineStartOffset
            // character at endOffset is \n, so we check the character before first
            // if character at endOffset is \r, end.column is 0 and we can't get here.
            var previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.
            var buffer = this._buffers[bufferIndex].buffer;
            if (buffer.charCodeAt(previousCharOffset) === 13) {
                return end.line - start.line + 1;
            }
            else {
                return end.line - start.line;
            }
        };
        PieceTreeBase.prototype.offsetInBuffer = function (bufferIndex, cursor) {
            var lineStarts = this._buffers[bufferIndex].lineStarts;
            return lineStarts[cursor.line] + cursor.column;
        };
        PieceTreeBase.prototype.deleteNodes = function (nodes) {
            for (var i = 0; i < nodes.length; i++) {
                rbTreeBase_1.rbDelete(this, nodes[i]);
            }
        };
        PieceTreeBase.prototype.createNewPieces = function (text) {
            if (text.length > exports.AverageBufferSize) {
                // the content is large, operations like substring, charCode becomes slow
                // so here we split it into smaller chunks, just like what we did for CR/LF normalization
                var newPieces = [];
                while (text.length > exports.AverageBufferSize) {
                    var lastChar = text.charCodeAt(exports.AverageBufferSize - 1);
                    var splitText = void 0;
                    if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xd800 && lastChar <= 0xdbff)) {
                        // last character is \r or a high surrogate => keep it back
                        splitText = text.substring(0, exports.AverageBufferSize - 1);
                        text = text.substring(exports.AverageBufferSize - 1);
                    }
                    else {
                        splitText = text.substring(0, exports.AverageBufferSize);
                        text = text.substring(exports.AverageBufferSize);
                    }
                    var lineStarts_1 = createLineStartsFast(splitText);
                    newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts_1.length - 1, column: splitText.length - lineStarts_1[lineStarts_1.length - 1] }, lineStarts_1.length - 1, splitText.length));
                    this._buffers.push(new StringBuffer(splitText, lineStarts_1));
                }
                var lineStarts_2 = createLineStartsFast(text);
                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts_2.length - 1, column: text.length - lineStarts_2[lineStarts_2.length - 1] }, lineStarts_2.length - 1, text.length));
                this._buffers.push(new StringBuffer(text, lineStarts_2));
                return newPieces;
            }
            var startOffset = this._buffers[0].buffer.length;
            var lineStarts = createLineStartsFast(text, false);
            var start = this._lastChangeBufferPos;
            if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset
                && startOffset !== 0
                && this.startWithLF(text)
                && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one
            ) {
                this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };
                start = this._lastChangeBufferPos;
                for (var i = 0; i < lineStarts.length; i++) {
                    lineStarts[i] += startOffset + 1;
                }
                this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
                this._buffers[0].buffer += '_' + text;
                startOffset += 1;
            }
            else {
                if (startOffset !== 0) {
                    for (var i = 0; i < lineStarts.length; i++) {
                        lineStarts[i] += startOffset;
                    }
                }
                this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
                this._buffers[0].buffer += text;
            }
            var endOffset = this._buffers[0].buffer.length;
            var endIndex = this._buffers[0].lineStarts.length - 1;
            var endColumn = endOffset - this._buffers[0].lineStarts[endIndex];
            var endPos = { line: endIndex, column: endColumn };
            var newPiece = new Piece(0, /** todo */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);
            this._lastChangeBufferPos = endPos;
            return [newPiece];
        };
        PieceTreeBase.prototype.getLinesRawContent = function () {
            return this.getContentOfSubTree(this.root);
        };
        PieceTreeBase.prototype.getLineRawContent = function (lineNumber, endOffset) {
            if (endOffset === void 0) { endOffset = 0; }
            var x = this.root;
            var ret = '';
            var cache = this._searchCache.get2(lineNumber);
            if (cache) {
                x = cache.node;
                var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);
                var buffer = this._buffers[x.piece.bufferIndex].buffer;
                var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {
                    ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);
                }
                else {
                    var accumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);
                    return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);
                }
            }
            else {
                var nodeStartOffset = 0;
                var originalLineNumber = lineNumber;
                while (x !== rbTreeBase_1.SENTINEL) {
                    if (x.left !== rbTreeBase_1.SENTINEL && x.lf_left >= lineNumber - 1) {
                        x = x.left;
                    }
                    else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
                        var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                        var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
                        var buffer = this._buffers[x.piece.bufferIndex].buffer;
                        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                        nodeStartOffset += x.size_left;
                        this._searchCache.set({
                            node: x,
                            nodeStartOffset: nodeStartOffset,
                            nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)
                        });
                        return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);
                    }
                    else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
                        var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                        var buffer = this._buffers[x.piece.bufferIndex].buffer;
                        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                        ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);
                        break;
                    }
                    else {
                        lineNumber -= x.lf_left + x.piece.lineFeedCnt;
                        nodeStartOffset += x.size_left + x.piece.length;
                        x = x.right;
                    }
                }
            }
            // search in order, to find the node contains end column
            x = x.next();
            while (x !== rbTreeBase_1.SENTINEL) {
                var buffer = this._buffers[x.piece.bufferIndex].buffer;
                if (x.piece.lineFeedCnt > 0) {
                    var accumualtedValue = this.getAccumulatedValue(x, 0);
                    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                    ret += buffer.substring(startOffset, startOffset + accumualtedValue - endOffset);
                    return ret;
                }
                else {
                    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                    ret += buffer.substr(startOffset, x.piece.length);
                }
                x = x.next();
            }
            return ret;
        };
        PieceTreeBase.prototype.computeBufferMetadata = function () {
            var x = this.root;
            var lfCnt = 1;
            var len = 0;
            while (x !== rbTreeBase_1.SENTINEL) {
                lfCnt += x.lf_left + x.piece.lineFeedCnt;
                len += x.size_left + x.piece.length;
                x = x.right;
            }
            this._lineCnt = lfCnt;
            this._length = len;
            this._searchCache.valdiate(this._length);
        };
        // #region node operations
        PieceTreeBase.prototype.getIndexOf = function (node, accumulatedValue) {
            var piece = node.piece;
            var pos = this.positionInBuffer(node, accumulatedValue);
            var lineCnt = pos.line - piece.start.line;
            if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {
                // we are checking the end of this node, so a CRLF check is necessary.
                var realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);
                if (realLineCnt !== lineCnt) {
                    // aha yes, CRLF
                    return { index: realLineCnt, remainder: 0 };
                }
            }
            return { index: lineCnt, remainder: pos.column };
        };
        PieceTreeBase.prototype.getAccumulatedValue = function (node, index) {
            if (index < 0) {
                return 0;
            }
            var piece = node.piece;
            var lineStarts = this._buffers[piece.bufferIndex].lineStarts;
            var expectedLineStartIndex = piece.start.line + index + 1;
            if (expectedLineStartIndex > piece.end.line) {
                return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;
            }
            else {
                return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;
            }
        };
        PieceTreeBase.prototype.deleteNodeTail = function (node, pos) {
            var piece = node.piece;
            var originalLFCnt = piece.lineFeedCnt;
            var originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
            var newEnd = pos;
            var newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);
            var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
            var lf_delta = newLineFeedCnt - originalLFCnt;
            var size_delta = newEndOffset - originalEndOffset;
            var newLength = piece.length + size_delta;
            node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
            rbTreeBase_1.updateTreeMetadata(this, node, size_delta, lf_delta);
        };
        PieceTreeBase.prototype.deleteNodeHead = function (node, pos) {
            var piece = node.piece;
            var originalLFCnt = piece.lineFeedCnt;
            var originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
            var newStart = pos;
            var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
            var newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);
            var lf_delta = newLineFeedCnt - originalLFCnt;
            var size_delta = originalStartOffset - newStartOffset;
            var newLength = piece.length + size_delta;
            node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
            rbTreeBase_1.updateTreeMetadata(this, node, size_delta, lf_delta);
        };
        PieceTreeBase.prototype.shrinkNode = function (node, start, end) {
            var piece = node.piece;
            var originalStartPos = piece.start;
            var originalEndPos = piece.end;
            // old piece, originalStartPos, start
            var oldLength = piece.length;
            var oldLFCnt = piece.lineFeedCnt;
            var newEnd = start;
            var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
            var newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);
            node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
            rbTreeBase_1.updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);
            // new right piece, end, originalEndPos
            var newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));
            var newNode = this.rbInsertRight(node, newPiece);
            this.validateCRLFWithPrevNode(newNode);
        };
        PieceTreeBase.prototype.appendToNode = function (node, value) {
            if (this.adjustCarriageReturnFromNext(value, node)) {
                value += '\n';
            }
            var hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);
            var startOffset = this._buffers[0].buffer.length;
            this._buffers[0].buffer += value;
            var lineStarts = createLineStartsFast(value, false);
            for (var i = 0; i < lineStarts.length; i++) {
                lineStarts[i] += startOffset;
            }
            if (hitCRLF) {
                var prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
                this._buffers[0].lineStarts.pop();
                // _lastChangeBufferPos is already wrong
                this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };
            }
            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
            var endIndex = this._buffers[0].lineStarts.length - 1;
            var endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];
            var newEnd = { line: endIndex, column: endColumn };
            var newLength = node.piece.length + value.length;
            var oldLineFeedCnt = node.piece.lineFeedCnt;
            var newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);
            var lf_delta = newLineFeedCnt - oldLineFeedCnt;
            node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);
            this._lastChangeBufferPos = newEnd;
            rbTreeBase_1.updateTreeMetadata(this, node, value.length, lf_delta);
        };
        PieceTreeBase.prototype.nodeAt = function (offset) {
            var x = this.root;
            var cache = this._searchCache.get(offset);
            if (cache) {
                return {
                    node: cache.node,
                    nodeStartOffset: cache.nodeStartOffset,
                    remainder: offset - cache.nodeStartOffset
                };
            }
            var nodeStartOffset = 0;
            while (x !== rbTreeBase_1.SENTINEL) {
                if (x.size_left > offset) {
                    x = x.left;
                }
                else if (x.size_left + x.piece.length >= offset) {
                    nodeStartOffset += x.size_left;
                    var ret = {
                        node: x,
                        remainder: offset - x.size_left,
                        nodeStartOffset: nodeStartOffset
                    };
                    this._searchCache.set(ret);
                    return ret;
                }
                else {
                    offset -= x.size_left + x.piece.length;
                    nodeStartOffset += x.size_left + x.piece.length;
                    x = x.right;
                }
            }
            return null;
        };
        PieceTreeBase.prototype.nodeAt2 = function (lineNumber, column) {
            var x = this.root;
            var nodeStartOffset = 0;
            while (x !== rbTreeBase_1.SENTINEL) {
                if (x.left !== rbTreeBase_1.SENTINEL && x.lf_left >= lineNumber - 1) {
                    x = x.left;
                }
                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
                    var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                    var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
                    nodeStartOffset += x.size_left;
                    return {
                        node: x,
                        remainder: Math.min(prevAccumualtedValue + column - 1, accumualtedValue),
                        nodeStartOffset: nodeStartOffset
                    };
                }
                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
                    var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                    if (prevAccumualtedValue + column - 1 <= x.piece.length) {
                        return {
                            node: x,
                            remainder: prevAccumualtedValue + column - 1,
                            nodeStartOffset: nodeStartOffset
                        };
                    }
                    else {
                        column -= x.piece.length - prevAccumualtedValue;
                        break;
                    }
                }
                else {
                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;
                    nodeStartOffset += x.size_left + x.piece.length;
                    x = x.right;
                }
            }
            // search in order, to find the node contains position.column
            x = x.next();
            while (x !== rbTreeBase_1.SENTINEL) {
                if (x.piece.lineFeedCnt > 0) {
                    var accumualtedValue = this.getAccumulatedValue(x, 0);
                    var nodeStartOffset_1 = this.offsetOfNode(x);
                    return {
                        node: x,
                        remainder: Math.min(column - 1, accumualtedValue),
                        nodeStartOffset: nodeStartOffset_1
                    };
                }
                else {
                    if (x.piece.length >= column - 1) {
                        var nodeStartOffset_2 = this.offsetOfNode(x);
                        return {
                            node: x,
                            remainder: column - 1,
                            nodeStartOffset: nodeStartOffset_2
                        };
                    }
                    else {
                        column -= x.piece.length;
                    }
                }
                x = x.next();
            }
            return null;
        };
        PieceTreeBase.prototype.nodeCharCodeAt = function (node, offset) {
            if (node.piece.lineFeedCnt < 1) {
                return -1;
            }
            var buffer = this._buffers[node.piece.bufferIndex];
            var newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;
            return buffer.buffer.charCodeAt(newOffset);
        };
        PieceTreeBase.prototype.offsetOfNode = function (node) {
            if (!node) {
                return 0;
            }
            var pos = node.size_left;
            while (node !== this.root) {
                if (node.parent.right === node) {
                    pos += node.parent.size_left + node.parent.piece.length;
                }
                node = node.parent;
            }
            return pos;
        };
        // #endregion
        // #region CRLF
        PieceTreeBase.prototype.shouldCheckCRLF = function () {
            return !(this._EOLNormalized && this._EOL === '\n');
        };
        PieceTreeBase.prototype.startWithLF = function (val) {
            if (typeof val === 'string') {
                return val.charCodeAt(0) === 10;
            }
            if (val === rbTreeBase_1.SENTINEL || val.piece.lineFeedCnt === 0) {
                return false;
            }
            var piece = val.piece;
            var lineStarts = this._buffers[piece.bufferIndex].lineStarts;
            var line = piece.start.line;
            var startOffset = lineStarts[line] + piece.start.column;
            if (line === lineStarts.length - 1) {
                // last line, so there is no line feed at the end of this line
                return false;
            }
            var nextLineOffset = lineStarts[line + 1];
            if (nextLineOffset > startOffset + 1) {
                return false;
            }
            return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;
        };
        PieceTreeBase.prototype.endWithCR = function (val) {
            if (typeof val === 'string') {
                return val.charCodeAt(val.length - 1) === 13;
            }
            if (val === rbTreeBase_1.SENTINEL || val.piece.lineFeedCnt === 0) {
                return false;
            }
            return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;
        };
        PieceTreeBase.prototype.validateCRLFWithPrevNode = function (nextNode) {
            if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {
                var node = nextNode.prev();
                if (this.endWithCR(node)) {
                    this.fixCRLF(node, nextNode);
                }
            }
        };
        PieceTreeBase.prototype.validateCRLFWithNextNode = function (node) {
            if (this.shouldCheckCRLF() && this.endWithCR(node)) {
                var nextNode = node.next();
                if (this.startWithLF(nextNode)) {
                    this.fixCRLF(node, nextNode);
                }
            }
        };
        PieceTreeBase.prototype.fixCRLF = function (prev, next) {
            var nodesToDel = [];
            // update node
            var lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;
            var newEnd;
            if (prev.piece.end.column === 0) {
                // it means, last line ends with \r, not \r\n
                newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };
            }
            else {
                // \r\n
                newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };
            }
            var prevNewLength = prev.piece.length - 1;
            var prevNewLFCnt = prev.piece.lineFeedCnt - 1;
            prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);
            rbTreeBase_1.updateTreeMetadata(this, prev, -1, -1);
            if (prev.piece.length === 0) {
                nodesToDel.push(prev);
            }
            // update nextNode
            var newStart = { line: next.piece.start.line + 1, column: 0 };
            var newLength = next.piece.length - 1;
            var newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);
            next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);
            rbTreeBase_1.updateTreeMetadata(this, next, -1, -1);
            if (next.piece.length === 0) {
                nodesToDel.push(next);
            }
            // create new piece which contains \r\n
            var pieces = this.createNewPieces('\r\n');
            this.rbInsertRight(prev, pieces[0]);
            // delete empty nodes
            for (var i = 0; i < nodesToDel.length; i++) {
                rbTreeBase_1.rbDelete(this, nodesToDel[i]);
            }
        };
        PieceTreeBase.prototype.adjustCarriageReturnFromNext = function (value, node) {
            if (this.shouldCheckCRLF() && this.endWithCR(value)) {
                var nextNode = node.next();
                if (this.startWithLF(nextNode)) {
                    // move `\n` forward
                    value += '\n';
                    if (nextNode.piece.length === 1) {
                        rbTreeBase_1.rbDelete(this, nextNode);
                    }
                    else {
                        var piece = nextNode.piece;
                        var newStart = { line: piece.start.line + 1, column: 0 };
                        var newLength = piece.length - 1;
                        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
                        nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
                        rbTreeBase_1.updateTreeMetadata(this, nextNode, -1, -1);
                    }
                    return true;
                }
            }
            return false;
        };
        // #endregion
        // #endregion
        // #region Tree operations
        PieceTreeBase.prototype.iterate = function (node, callback) {
            if (node === rbTreeBase_1.SENTINEL) {
                return callback(rbTreeBase_1.SENTINEL);
            }
            var leftRet = this.iterate(node.left, callback);
            if (!leftRet) {
                return leftRet;
            }
            return callback(node) && this.iterate(node.right, callback);
        };
        PieceTreeBase.prototype.getNodeContent = function (node) {
            if (node === rbTreeBase_1.SENTINEL) {
                return '';
            }
            var buffer = this._buffers[node.piece.bufferIndex];
            var currentContent;
            var piece = node.piece;
            var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
            var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
            currentContent = buffer.buffer.substring(startOffset, endOffset);
            return currentContent;
        };
        PieceTreeBase.prototype.getPieceContent = function (piece) {
            var buffer = this._buffers[piece.bufferIndex];
            var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
            var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
            var currentContent = buffer.buffer.substring(startOffset, endOffset);
            return currentContent;
        };
        /**
         *      node              node
         *     /  \              /  \
         *    a   b    <----   a    b
         *                         /
         *                        z
         */
        PieceTreeBase.prototype.rbInsertRight = function (node, p) {
            var z = new rbTreeBase_1.TreeNode(p, 1 /* Red */);
            z.left = rbTreeBase_1.SENTINEL;
            z.right = rbTreeBase_1.SENTINEL;
            z.parent = rbTreeBase_1.SENTINEL;
            z.size_left = 0;
            z.lf_left = 0;
            var x = this.root;
            if (x === rbTreeBase_1.SENTINEL) {
                this.root = z;
                z.color = 0 /* Black */;
            }
            else if (node.right === rbTreeBase_1.SENTINEL) {
                node.right = z;
                z.parent = node;
            }
            else {
                var nextNode = rbTreeBase_1.leftest(node.right);
                nextNode.left = z;
                z.parent = nextNode;
            }
            rbTreeBase_1.fixInsert(this, z);
            return z;
        };
        /**
         *      node              node
         *     /  \              /  \
         *    a   b     ---->   a    b
         *                       \
         *                        z
         */
        PieceTreeBase.prototype.rbInsertLeft = function (node, p) {
            var z = new rbTreeBase_1.TreeNode(p, 1 /* Red */);
            z.left = rbTreeBase_1.SENTINEL;
            z.right = rbTreeBase_1.SENTINEL;
            z.parent = rbTreeBase_1.SENTINEL;
            z.size_left = 0;
            z.lf_left = 0;
            var x = this.root;
            if (x === rbTreeBase_1.SENTINEL) {
                this.root = z;
                z.color = 0 /* Black */;
            }
            else if (node.left === rbTreeBase_1.SENTINEL) {
                node.left = z;
                z.parent = node;
            }
            else {
                var prevNode = rbTreeBase_1.righttest(node.left); // a
                prevNode.right = z;
                z.parent = prevNode;
            }
            rbTreeBase_1.fixInsert(this, z);
            return z;
        };
        PieceTreeBase.prototype.getContentOfSubTree = function (node) {
            var _this = this;
            var str = '';
            this.iterate(node, function (node) {
                str += _this.getNodeContent(node);
                return true;
            });
            return str;
        };
        return PieceTreeBase;
    }());
    exports.PieceTreeBase = PieceTreeBase;
});

define(__m[149/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer*/], __M([0/*require*/,1/*exports*/,24/*vs/editor/common/core/range*/,8/*vs/base/common/strings*/,60/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase*/,25/*vs/editor/common/model*/]), function (require, exports, range_1, strings, pieceTreeBase_1, model_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var PieceTreeTextBuffer = /** @class */ (function () {
        function PieceTreeTextBuffer(chunks, BOM, eol, containsRTL, isBasicASCII, eolNormalized) {
            this._BOM = BOM;
            this._mightContainNonBasicASCII = !isBasicASCII;
            this._mightContainRTL = containsRTL;
            this._pieceTree = new pieceTreeBase_1.PieceTreeBase(chunks, eol, eolNormalized);
        }
        // #region TextBuffer
        PieceTreeTextBuffer.prototype.equals = function (other) {
            if (!(other instanceof PieceTreeTextBuffer)) {
                return false;
            }
            if (this._BOM !== other._BOM) {
                return false;
            }
            if (this.getEOL() !== other.getEOL()) {
                return false;
            }
            return this._pieceTree.equal(other._pieceTree);
        };
        PieceTreeTextBuffer.prototype.mightContainRTL = function () {
            return this._mightContainRTL;
        };
        PieceTreeTextBuffer.prototype.mightContainNonBasicASCII = function () {
            return this._mightContainNonBasicASCII;
        };
        PieceTreeTextBuffer.prototype.getBOM = function () {
            return this._BOM;
        };
        PieceTreeTextBuffer.prototype.getEOL = function () {
            return this._pieceTree.getEOL();
        };
        PieceTreeTextBuffer.prototype.createSnapshot = function (preserveBOM) {
            return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');
        };
        PieceTreeTextBuffer.prototype.getOffsetAt = function (lineNumber, column) {
            return this._pieceTree.getOffsetAt(lineNumber, column);
        };
        PieceTreeTextBuffer.prototype.getPositionAt = function (offset) {
            return this._pieceTree.getPositionAt(offset);
        };
        PieceTreeTextBuffer.prototype.getRangeAt = function (start, length) {
            var end = start + length;
            var startPosition = this.getPositionAt(start);
            var endPosition = this.getPositionAt(end);
            return new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
        };
        PieceTreeTextBuffer.prototype.getValueInRange = function (range, eol) {
            if (eol === void 0) { eol = model_1.EndOfLinePreference.TextDefined; }
            if (range.isEmpty()) {
                return '';
            }
            var lineEnding = this._getEndOfLine(eol);
            return this._pieceTree.getValueInRange(range, lineEnding);
        };
        PieceTreeTextBuffer.prototype.getValueLengthInRange = function (range, eol) {
            if (eol === void 0) { eol = model_1.EndOfLinePreference.TextDefined; }
            if (range.isEmpty()) {
                return 0;
            }
            if (range.startLineNumber === range.endLineNumber) {
                return (range.endColumn - range.startColumn);
            }
            var startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);
            var endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);
            return endOffset - startOffset;
        };
        PieceTreeTextBuffer.prototype.getLength = function () {
            return this._pieceTree.getLength();
        };
        PieceTreeTextBuffer.prototype.getLineCount = function () {
            return this._pieceTree.getLineCount();
        };
        PieceTreeTextBuffer.prototype.getLinesContent = function () {
            return this._pieceTree.getLinesContent();
        };
        PieceTreeTextBuffer.prototype.getLineContent = function (lineNumber) {
            return this._pieceTree.getLineContent(lineNumber);
        };
        PieceTreeTextBuffer.prototype.getLineCharCode = function (lineNumber, index) {
            return this._pieceTree.getLineCharCode(lineNumber, index);
        };
        PieceTreeTextBuffer.prototype.getLineLength = function (lineNumber) {
            return this._pieceTree.getLineLength(lineNumber);
        };
        PieceTreeTextBuffer.prototype.getLineMinColumn = function (lineNumber) {
            return 1;
        };
        PieceTreeTextBuffer.prototype.getLineMaxColumn = function (lineNumber) {
            return this.getLineLength(lineNumber) + 1;
        };
        PieceTreeTextBuffer.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
            var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));
            if (result === -1) {
                return 0;
            }
            return result + 1;
        };
        PieceTreeTextBuffer.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
            var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));
            if (result === -1) {
                return 0;
            }
            return result + 2;
        };
        PieceTreeTextBuffer.prototype._getEndOfLine = function (eol) {
            switch (eol) {
                case model_1.EndOfLinePreference.LF:
                    return '\n';
                case model_1.EndOfLinePreference.CRLF:
                    return '\r\n';
                case model_1.EndOfLinePreference.TextDefined:
                    return this.getEOL();
            }
            throw new Error('Unknown EOL preference');
        };
        PieceTreeTextBuffer.prototype.setEOL = function (newEOL) {
            this._pieceTree.setEOL(newEOL);
        };
        PieceTreeTextBuffer.prototype.applyEdits = function (rawOperations, recordTrimAutoWhitespace) {
            var mightContainRTL = this._mightContainRTL;
            var mightContainNonBasicASCII = this._mightContainNonBasicASCII;
            var canReduceOperations = true;
            var operations = [];
            for (var i = 0; i < rawOperations.length; i++) {
                var op = rawOperations[i];
                if (canReduceOperations && op._isTracked) {
                    canReduceOperations = false;
                }
                var validatedRange = op.range;
                if (!mightContainRTL && op.text) {
                    // check if the new inserted text contains RTL
                    mightContainRTL = strings.containsRTL(op.text);
                }
                if (!mightContainNonBasicASCII && op.text) {
                    mightContainNonBasicASCII = !strings.isBasicASCII(op.text);
                }
                operations[i] = {
                    sortIndex: i,
                    identifier: op.identifier,
                    range: validatedRange,
                    rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),
                    rangeLength: this.getValueLengthInRange(validatedRange),
                    lines: op.text ? op.text.split(/\r\n|\r|\n/) : null,
                    forceMoveMarkers: op.forceMoveMarkers,
                    isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false
                };
            }
            // Sort operations ascending
            operations.sort(PieceTreeTextBuffer._sortOpsAscending);
            var hasTouchingRanges = false;
            for (var i = 0, count = operations.length - 1; i < count; i++) {
                var rangeEnd = operations[i].range.getEndPosition();
                var nextRangeStart = operations[i + 1].range.getStartPosition();
                if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {
                    if (nextRangeStart.isBefore(rangeEnd)) {
                        // overlapping ranges
                        throw new Error('Overlapping ranges are not allowed!');
                    }
                    hasTouchingRanges = true;
                }
            }
            if (canReduceOperations) {
                operations = this._reduceOperations(operations);
            }
            // Delta encode operations
            var reverseRanges = PieceTreeTextBuffer._getInverseEditRanges(operations);
            var newTrimAutoWhitespaceCandidates = [];
            for (var i = 0; i < operations.length; i++) {
                var op = operations[i];
                var reverseRange = reverseRanges[i];
                if (recordTrimAutoWhitespace && op.isAutoWhitespaceEdit && op.range.isEmpty()) {
                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit
                    for (var lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {
                        var currentLineContent = '';
                        if (lineNumber === reverseRange.startLineNumber) {
                            currentLineContent = this.getLineContent(op.range.startLineNumber);
                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {
                                continue;
                            }
                        }
                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });
                    }
                }
            }
            var reverseOperations = [];
            for (var i = 0; i < operations.length; i++) {
                var op = operations[i];
                var reverseRange = reverseRanges[i];
                reverseOperations[i] = {
                    sortIndex: op.sortIndex,
                    identifier: op.identifier,
                    range: reverseRange,
                    text: this.getValueInRange(op.range),
                    forceMoveMarkers: op.forceMoveMarkers
                };
            }
            // Can only sort reverse operations when the order is not significant
            if (!hasTouchingRanges) {
                reverseOperations.sort(function (a, b) { return a.sortIndex - b.sortIndex; });
            }
            this._mightContainRTL = mightContainRTL;
            this._mightContainNonBasicASCII = mightContainNonBasicASCII;
            var contentChanges = this._doApplyEdits(operations);
            var trimAutoWhitespaceLineNumbers = null;
            if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {
                // sort line numbers auto whitespace removal candidates for next edit descending
                newTrimAutoWhitespaceCandidates.sort(function (a, b) { return b.lineNumber - a.lineNumber; });
                trimAutoWhitespaceLineNumbers = [];
                for (var i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {
                    var lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;
                    if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {
                        // Do not have the same line number twice
                        continue;
                    }
                    var prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;
                    var lineContent = this.getLineContent(lineNumber);
                    if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {
                        continue;
                    }
                    trimAutoWhitespaceLineNumbers.push(lineNumber);
                }
            }
            return new model_1.ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);
        };
        /**
         * Transform operations such that they represent the same logic edit,
         * but that they also do not cause OOM crashes.
         */
        PieceTreeTextBuffer.prototype._reduceOperations = function (operations) {
            if (operations.length < 1000) {
                // We know from empirical testing that a thousand edits work fine regardless of their shape.
                return operations;
            }
            // At one point, due to how events are emitted and how each operation is handled,
            // some operations can trigger a high ammount of temporary string allocations,
            // that will immediately get edited again.
            // e.g. a formatter inserting ridiculous ammounts of \n on a model with a single line
            // Therefore, the strategy is to collapse all the operations into a huge single edit operation
            return [this._toSingleEditOperation(operations)];
        };
        PieceTreeTextBuffer.prototype._toSingleEditOperation = function (operations) {
            var forceMoveMarkers = false, firstEditRange = operations[0].range, lastEditRange = operations[operations.length - 1].range, entireEditRange = new range_1.Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn), lastEndLineNumber = firstEditRange.startLineNumber, lastEndColumn = firstEditRange.startColumn, result = [];
            for (var i = 0, len = operations.length; i < len; i++) {
                var operation = operations[i], range = operation.range;
                forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;
                // (1) -- Push old text
                for (var lineNumber = lastEndLineNumber; lineNumber < range.startLineNumber; lineNumber++) {
                    if (lineNumber === lastEndLineNumber) {
                        result.push(this.getLineContent(lineNumber).substring(lastEndColumn - 1));
                    }
                    else {
                        result.push('\n');
                        result.push(this.getLineContent(lineNumber));
                    }
                }
                if (range.startLineNumber === lastEndLineNumber) {
                    result.push(this.getLineContent(range.startLineNumber).substring(lastEndColumn - 1, range.startColumn - 1));
                }
                else {
                    result.push('\n');
                    result.push(this.getLineContent(range.startLineNumber).substring(0, range.startColumn - 1));
                }
                // (2) -- Push new text
                if (operation.lines) {
                    for (var j = 0, lenJ = operation.lines.length; j < lenJ; j++) {
                        if (j !== 0) {
                            result.push('\n');
                        }
                        result.push(operation.lines[j]);
                    }
                }
                lastEndLineNumber = operation.range.endLineNumber;
                lastEndColumn = operation.range.endColumn;
            }
            return {
                sortIndex: 0,
                identifier: operations[0].identifier,
                range: entireEditRange,
                rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),
                rangeLength: this.getValueLengthInRange(entireEditRange, model_1.EndOfLinePreference.TextDefined),
                lines: result.join('').split('\n'),
                forceMoveMarkers: forceMoveMarkers,
                isAutoWhitespaceEdit: false
            };
        };
        PieceTreeTextBuffer.prototype._doApplyEdits = function (operations) {
            operations.sort(PieceTreeTextBuffer._sortOpsDescending);
            var contentChanges = [];
            // operations are from bottom to top
            for (var i = 0; i < operations.length; i++) {
                var op = operations[i];
                var startLineNumber = op.range.startLineNumber;
                var startColumn = op.range.startColumn;
                var endLineNumber = op.range.endLineNumber;
                var endColumn = op.range.endColumn;
                if (startLineNumber === endLineNumber && startColumn === endColumn && (!op.lines || op.lines.length === 0)) {
                    // no-op
                    continue;
                }
                var deletingLinesCnt = endLineNumber - startLineNumber;
                var insertingLinesCnt = (op.lines ? op.lines.length - 1 : 0);
                var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
                var text = (op.lines ? op.lines.join(this.getEOL()) : '');
                if (text) {
                    // replacement
                    this._pieceTree.delete(op.rangeOffset, op.rangeLength);
                    this._pieceTree.insert(op.rangeOffset, text, true);
                }
                else {
                    // deletion
                    this._pieceTree.delete(op.rangeOffset, op.rangeLength);
                }
                if (editingLinesCnt < insertingLinesCnt) {
                    var newLinesContent = [];
                    for (var j = editingLinesCnt + 1; j <= insertingLinesCnt; j++) {
                        newLinesContent.push(op.lines[j]);
                    }
                    newLinesContent[newLinesContent.length - 1] = this.getLineContent(startLineNumber + insertingLinesCnt - 1);
                }
                var contentChangeRange = new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);
                contentChanges.push({
                    range: contentChangeRange,
                    rangeLength: op.rangeLength,
                    text: text,
                    rangeOffset: op.rangeOffset,
                    forceMoveMarkers: op.forceMoveMarkers
                });
            }
            return contentChanges;
        };
        PieceTreeTextBuffer.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {
            return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
        };
        // #endregion
        // #region helper
        // testing purpose.
        PieceTreeTextBuffer.prototype.getPieceTree = function () {
            return this._pieceTree;
        };
        /**
         * Assumes `operations` are validated and sorted ascending
         */
        PieceTreeTextBuffer._getInverseEditRanges = function (operations) {
            var result = [];
            var prevOpEndLineNumber;
            var prevOpEndColumn;
            var prevOp = null;
            for (var i = 0, len = operations.length; i < len; i++) {
                var op = operations[i];
                var startLineNumber = void 0;
                var startColumn = void 0;
                if (prevOp) {
                    if (prevOp.range.endLineNumber === op.range.startLineNumber) {
                        startLineNumber = prevOpEndLineNumber;
                        startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);
                    }
                    else {
                        startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);
                        startColumn = op.range.startColumn;
                    }
                }
                else {
                    startLineNumber = op.range.startLineNumber;
                    startColumn = op.range.startColumn;
                }
                var resultRange = void 0;
                if (op.lines && op.lines.length > 0) {
                    // the operation inserts something
                    var lineCount = op.lines.length;
                    var firstLine = op.lines[0];
                    var lastLine = op.lines[lineCount - 1];
                    if (lineCount === 1) {
                        // single line insert
                        resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLine.length);
                    }
                    else {
                        // multi line insert
                        resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLine.length + 1);
                    }
                }
                else {
                    // There is nothing to insert
                    resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber, startColumn);
                }
                prevOpEndLineNumber = resultRange.endLineNumber;
                prevOpEndColumn = resultRange.endColumn;
                result.push(resultRange);
                prevOp = op;
            }
            return result;
        };
        PieceTreeTextBuffer._sortOpsAscending = function (a, b) {
            var r = range_1.Range.compareRangesUsingEnds(a.range, b.range);
            if (r === 0) {
                return a.sortIndex - b.sortIndex;
            }
            return r;
        };
        PieceTreeTextBuffer._sortOpsDescending = function (a, b) {
            var r = range_1.Range.compareRangesUsingEnds(a.range, b.range);
            if (r === 0) {
                return b.sortIndex - a.sortIndex;
            }
            return -r;
        };
        return PieceTreeTextBuffer;
    }());
    exports.PieceTreeTextBuffer = PieceTreeTextBuffer;
});

define(__m[153/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder*/], __M([0/*require*/,1/*exports*/,8/*vs/base/common/strings*/,25/*vs/editor/common/model*/,149/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer*/,60/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase*/]), function (require, exports, strings, model_1, pieceTreeTextBuffer_1, pieceTreeBase_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var PieceTreeTextBufferFactory = /** @class */ (function () {
        function PieceTreeTextBufferFactory(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _isBasicASCII, _normalizeEOL) {
            this._chunks = _chunks;
            this._bom = _bom;
            this._cr = _cr;
            this._lf = _lf;
            this._crlf = _crlf;
            this._containsRTL = _containsRTL;
            this._isBasicASCII = _isBasicASCII;
            this._normalizeEOL = _normalizeEOL;
        }
        PieceTreeTextBufferFactory.prototype._getEOL = function (defaultEOL) {
            var totalEOLCount = this._cr + this._lf + this._crlf;
            var totalCRCount = this._cr + this._crlf;
            if (totalEOLCount === 0) {
                // This is an empty file or a file with precisely one line
                return (defaultEOL === model_1.DefaultEndOfLine.LF ? '\n' : '\r\n');
            }
            if (totalCRCount > totalEOLCount / 2) {
                // More than half of the file contains \r\n ending lines
                return '\r\n';
            }
            // At least one line more ends in \n
            return '\n';
        };
        PieceTreeTextBufferFactory.prototype.create = function (defaultEOL) {
            var eol = this._getEOL(defaultEOL);
            var chunks = this._chunks;
            if (this._normalizeEOL &&
                ((eol === '\r\n' && (this._cr > 0 || this._lf > 0))
                    || (eol === '\n' && (this._cr > 0 || this._crlf > 0)))) {
                // Normalize pieces
                for (var i = 0, len = chunks.length; i < len; i++) {
                    var str = chunks[i].buffer.replace(/\r\n|\r|\n/g, eol);
                    var newLineStart = pieceTreeBase_1.createLineStartsFast(str);
                    chunks[i] = new pieceTreeBase_1.StringBuffer(str, newLineStart);
                }
            }
            return new pieceTreeTextBuffer_1.PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._isBasicASCII, this._normalizeEOL);
        };
        PieceTreeTextBufferFactory.prototype.getFirstLineText = function (lengthLimit) {
            return this._chunks[0].buffer.substr(0, 100).split(/\r\n|\r|\n/)[0];
        };
        return PieceTreeTextBufferFactory;
    }());
    exports.PieceTreeTextBufferFactory = PieceTreeTextBufferFactory;
    var PieceTreeTextBufferBuilder = /** @class */ (function () {
        function PieceTreeTextBufferBuilder() {
            this.chunks = [];
            this.BOM = '';
            this._hasPreviousChar = false;
            this._previousChar = 0;
            this._tmpLineStarts = [];
            this.cr = 0;
            this.lf = 0;
            this.crlf = 0;
            this.containsRTL = false;
            this.isBasicASCII = true;
        }
        PieceTreeTextBufferBuilder.prototype.acceptChunk = function (chunk) {
            if (chunk.length === 0) {
                return;
            }
            if (this.chunks.length === 0) {
                if (strings.startsWithUTF8BOM(chunk)) {
                    this.BOM = strings.UTF8_BOM_CHARACTER;
                    chunk = chunk.substr(1);
                }
            }
            var lastChar = chunk.charCodeAt(chunk.length - 1);
            if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xd800 && lastChar <= 0xdbff)) {
                // last character is \r or a high surrogate => keep it back
                this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);
                this._hasPreviousChar = true;
                this._previousChar = lastChar;
            }
            else {
                this._acceptChunk1(chunk, false);
                this._hasPreviousChar = false;
                this._previousChar = lastChar;
            }
        };
        PieceTreeTextBufferBuilder.prototype._acceptChunk1 = function (chunk, allowEmptyStrings) {
            if (!allowEmptyStrings && chunk.length === 0) {
                // Nothing to do
                return;
            }
            if (this._hasPreviousChar) {
                this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);
            }
            else {
                this._acceptChunk2(chunk);
            }
        };
        PieceTreeTextBufferBuilder.prototype._acceptChunk2 = function (chunk) {
            var lineStarts = pieceTreeBase_1.createLineStarts(this._tmpLineStarts, chunk);
            this.chunks.push(new pieceTreeBase_1.StringBuffer(chunk, lineStarts.lineStarts));
            this.cr += lineStarts.cr;
            this.lf += lineStarts.lf;
            this.crlf += lineStarts.crlf;
            if (this.isBasicASCII) {
                this.isBasicASCII = lineStarts.isBasicASCII;
            }
            if (!this.isBasicASCII && !this.containsRTL) {
                // No need to check if is basic ASCII
                this.containsRTL = strings.containsRTL(chunk);
            }
        };
        PieceTreeTextBufferBuilder.prototype.finish = function (normalizeEOL) {
            if (normalizeEOL === void 0) { normalizeEOL = true; }
            this._finish();
            return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.isBasicASCII, normalizeEOL);
        };
        PieceTreeTextBufferBuilder.prototype._finish = function () {
            if (this.chunks.length === 0) {
                this._acceptChunk1('', true);
            }
            if (this._hasPreviousChar) {
                this._hasPreviousChar = false;
                // recreate last chunk
                var lastChunk = this.chunks[this.chunks.length - 1];
                lastChunk.buffer += String.fromCharCode(this._previousChar);
                var newLineStarts = pieceTreeBase_1.createLineStartsFast(lastChunk.buffer);
                lastChunk.lineStarts = newLineStarts;
                if (this._previousChar === 13 /* CarriageReturn */) {
                    this.cr++;
                }
            }
        };
        return PieceTreeTextBufferBuilder;
    }());
    exports.PieceTreeTextBufferBuilder = PieceTreeTextBufferBuilder;
});

define(__m[41/*vs/editor/common/model/wordHelper*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // {{SQL CARBON EDIT}}
    exports.USUAL_WORD_SEPARATORS = '`~!#$%^&*()-=+[{]}\\|;:\'",.<>/?';
    /**
     * Create a word definition regular expression based on default word separators.
     * Optionally provide allowed separators that should be included in words.
     *
     * The default would look like this:
     * /(-?\d*\.\d\w*)|([^\`\~\!\@\#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
     */
    function createWordRegExp(allowInWords) {
        if (allowInWords === void 0) { allowInWords = ''; }
        var source = '(-?\\d*\\.\\d\\w*)|([^';
        for (var i = 0; i < exports.USUAL_WORD_SEPARATORS.length; i++) {
            if (allowInWords.indexOf(exports.USUAL_WORD_SEPARATORS[i]) >= 0) {
                continue;
            }
            source += '\\' + exports.USUAL_WORD_SEPARATORS[i];
        }
        source += '\\s]+)';
        return new RegExp(source, 'g');
    }
    // catches numbers (including floating numbers) in the first group, and alphanum in the second
    exports.DEFAULT_WORD_REGEXP = createWordRegExp();
    function ensureValidWordDefinition(wordDefinition) {
        var result = exports.DEFAULT_WORD_REGEXP;
        if (wordDefinition && (wordDefinition instanceof RegExp)) {
            if (!wordDefinition.global) {
                var flags = 'g';
                if (wordDefinition.ignoreCase) {
                    flags += 'i';
                }
                if (wordDefinition.multiline) {
                    flags += 'm';
                }
                result = new RegExp(wordDefinition.source, flags);
            }
            else {
                result = wordDefinition;
            }
        }
        result.lastIndex = 0;
        return result;
    }
    exports.ensureValidWordDefinition = ensureValidWordDefinition;
    function getWordAtPosFast(column, wordDefinition, text, textOffset) {
        // find whitespace enclosed text around column and match from there
        var pos = column - 1 - textOffset;
        var start = text.lastIndexOf(' ', pos - 1) + 1;
        var end = text.indexOf(' ', pos);
        if (end === -1) {
            end = text.length;
        }
        wordDefinition.lastIndex = start;
        var match;
        while (match = wordDefinition.exec(text)) {
            if (match.index <= pos && wordDefinition.lastIndex >= pos) {
                return {
                    word: match[0],
                    startColumn: textOffset + 1 + match.index,
                    endColumn: textOffset + 1 + wordDefinition.lastIndex
                };
            }
        }
        return null;
    }
    function getWordAtPosSlow(column, wordDefinition, text, textOffset) {
        // matches all words starting at the beginning
        // of the input until it finds a match that encloses
        // the desired column. slow but correct
        var pos = column - 1 - textOffset;
        wordDefinition.lastIndex = 0;
        var match;
        while (match = wordDefinition.exec(text)) {
            if (match.index > pos) {
                // |nW -> matched only after the pos
                return null;
            }
            else if (wordDefinition.lastIndex >= pos) {
                // W|W -> match encloses pos
                return {
                    word: match[0],
                    startColumn: textOffset + 1 + match.index,
                    endColumn: textOffset + 1 + wordDefinition.lastIndex
                };
            }
        }
        return null;
    }
    function getWordAtText(column, wordDefinition, text, textOffset) {
        // if `words` can contain whitespace character we have to use the slow variant
        // otherwise we use the fast variant of finding a word
        wordDefinition.lastIndex = 0;
        var match = wordDefinition.exec(text);
        if (!match) {
            return null;
        }
        // todo@joh the `match` could already be the (first) word
        var ret = match[0].indexOf(' ') >= 0
            // did match a word which contains a space character -> use slow word find
            ? getWordAtPosSlow(column, wordDefinition, text, textOffset)
            // sane word definition -> use fast word find
            : getWordAtPosFast(column, wordDefinition, text, textOffset);
        // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp
        // in an undefined state and to not confuse other users of the wordDefinition
        // we reset the lastIndex
        wordDefinition.lastIndex = 0;
        return ret;
    }
    exports.getWordAtText = getWordAtText;
});

define(__m[35/*vs/editor/common/modes/languageConfiguration*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Describes what to do with the indentation when pressing Enter.
     */
    var IndentAction;
    (function (IndentAction) {
        /**
         * Insert new line and copy the previous line's indentation.
         */
        IndentAction[IndentAction["None"] = 0] = "None";
        /**
         * Insert new line and indent once (relative to the previous line's indentation).
         */
        IndentAction[IndentAction["Indent"] = 1] = "Indent";
        /**
         * Insert two new lines:
         *  - the first one indented which will hold the cursor
         *  - the second one at the same indentation level
         */
        IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
        /**
         * Insert new line and outdent once (relative to the previous line's indentation).
         */
        IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
    })(IndentAction = exports.IndentAction || (exports.IndentAction = {}));
    /**
     * @internal
     */
    var StandardAutoClosingPairConditional = /** @class */ (function () {
        function StandardAutoClosingPairConditional(source) {
            this.open = source.open;
            this.close = source.close;
            // initially allowed in all tokens
            this._standardTokenMask = 0;
            if (Array.isArray(source.notIn)) {
                for (var i = 0, len = source.notIn.length; i < len; i++) {
                    var notIn = source.notIn[i];
                    switch (notIn) {
                        case 'string':
                            this._standardTokenMask |= 2 /* String */;
                            break;
                        case 'comment':
                            this._standardTokenMask |= 1 /* Comment */;
                            break;
                        case 'regex':
                            this._standardTokenMask |= 4 /* RegEx */;
                            break;
                    }
                }
            }
        }
        StandardAutoClosingPairConditional.prototype.isOK = function (standardToken) {
            return (this._standardTokenMask & standardToken) === 0;
        };
        return StandardAutoClosingPairConditional;
    }());
    exports.StandardAutoClosingPairConditional = StandardAutoClosingPairConditional;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[66/*vs/editor/common/modes/languageSelector*/], __M([0/*require*/,1/*exports*/,33/*vs/base/common/glob*/]), function (require, exports, glob_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized) {
        if (Array.isArray(selector)) {
            // array -> take max individual value
            var ret = 0;
            for (var _i = 0, selector_1 = selector; _i < selector_1.length; _i++) {
                var filter = selector_1[_i];
                var value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized);
                if (value === 10) {
                    return value; // already at the highest
                }
                if (value > ret) {
                    ret = value;
                }
            }
            return ret;
        }
        else if (typeof selector === 'string') {
            if (!candidateIsSynchronized) {
                return 0;
            }
            // short-hand notion, desugars to
            // 'fooLang' -> { language: 'fooLang'}
            // '*' -> { language: '*' }
            if (selector === '*') {
                return 5;
            }
            else if (selector === candidateLanguage) {
                return 10;
            }
            else {
                return 0;
            }
        }
        else if (selector) {
            // filter -> select accordingly, use defaults for scheme
            var language = selector.language, pattern = selector.pattern, scheme = selector.scheme, hasAccessToAllModels = selector.hasAccessToAllModels;
            if (!candidateIsSynchronized && !hasAccessToAllModels) {
                return 0;
            }
            var ret = 0;
            if (scheme) {
                if (scheme === candidateUri.scheme) {
                    ret = 10;
                }
                else if (scheme === '*') {
                    ret = 5;
                }
                else {
                    return 0;
                }
            }
            if (language) {
                if (language === candidateLanguage) {
                    ret = 10;
                }
                else if (language === '*') {
                    ret = Math.max(ret, 5);
                }
                else {
                    return 0;
                }
            }
            if (pattern) {
                if (pattern === candidateUri.fsPath || glob_1.match(pattern, candidateUri.fsPath)) {
                    ret = 10;
                }
                else {
                    return 0;
                }
            }
            return ret;
        }
        else {
            return 0;
        }
    }
    exports.score = score;
});

define(__m[46/*vs/editor/common/modes/supports*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function createScopedLineTokens(context, offset) {
        var tokenCount = context.getCount();
        var tokenIndex = context.findTokenIndexAtOffset(offset);
        var desiredLanguageId = context.getLanguageId(tokenIndex);
        var lastTokenIndex = tokenIndex;
        while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {
            lastTokenIndex++;
        }
        var firstTokenIndex = tokenIndex;
        while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {
            firstTokenIndex--;
        }
        return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));
    }
    exports.createScopedLineTokens = createScopedLineTokens;
    var ScopedLineTokens = /** @class */ (function () {
        function ScopedLineTokens(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {
            this._actual = actual;
            this.languageId = languageId;
            this._firstTokenIndex = firstTokenIndex;
            this._lastTokenIndex = lastTokenIndex;
            this.firstCharOffset = firstCharOffset;
            this._lastCharOffset = lastCharOffset;
        }
        ScopedLineTokens.prototype.getLineContent = function () {
            var actualLineContent = this._actual.getLineContent();
            return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);
        };
        ScopedLineTokens.prototype.getTokenCount = function () {
            return this._lastTokenIndex - this._firstTokenIndex;
        };
        ScopedLineTokens.prototype.findTokenIndexAtOffset = function (offset) {
            return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;
        };
        ScopedLineTokens.prototype.getStandardTokenType = function (tokenIndex) {
            return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);
        };
        return ScopedLineTokens;
    }());
    exports.ScopedLineTokens = ScopedLineTokens;
    var IgnoreBracketsInTokens;
    (function (IgnoreBracketsInTokens) {
        IgnoreBracketsInTokens[IgnoreBracketsInTokens["value"] = 7] = "value";
    })(IgnoreBracketsInTokens || (IgnoreBracketsInTokens = {}));
    function ignoreBracketsInToken(standardTokenType) {
        return (standardTokenType & 7 /* value */) !== 0;
    }
    exports.ignoreBracketsInToken = ignoreBracketsInToken;
});

define(__m[175/*vs/editor/common/modes/supports/characterPair*/], __M([0/*require*/,1/*exports*/,35/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var CharacterPairSupport = /** @class */ (function () {
        function CharacterPairSupport(config) {
            if (config.autoClosingPairs) {
                this._autoClosingPairs = config.autoClosingPairs.map(function (el) { return new languageConfiguration_1.StandardAutoClosingPairConditional(el); });
            }
            else if (config.brackets) {
                this._autoClosingPairs = config.brackets.map(function (b) { return new languageConfiguration_1.StandardAutoClosingPairConditional({ open: b[0], close: b[1] }); });
            }
            else {
                this._autoClosingPairs = [];
            }
            this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;
        }
        CharacterPairSupport.prototype.getAutoClosingPairs = function () {
            return this._autoClosingPairs;
        };
        CharacterPairSupport.prototype.shouldAutoClosePair = function (character, context, column) {
            // Always complete on empty line
            if (context.getTokenCount() === 0) {
                return true;
            }
            var tokenIndex = context.findTokenIndexAtOffset(column - 2);
            var standardTokenType = context.getStandardTokenType(tokenIndex);
            for (var i = 0; i < this._autoClosingPairs.length; ++i) {
                var autoClosingPair = this._autoClosingPairs[i];
                if (autoClosingPair.open === character) {
                    return autoClosingPair.isOK(standardTokenType);
                }
            }
            return false;
        };
        CharacterPairSupport.prototype.getSurroundingPairs = function () {
            return this._surroundingPairs;
        };
        return CharacterPairSupport;
    }());
    exports.CharacterPairSupport = CharacterPairSupport;
});

define(__m[176/*vs/editor/common/modes/supports/indentRules*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var IndentConsts;
    (function (IndentConsts) {
        IndentConsts[IndentConsts["INCREASE_MASK"] = 1] = "INCREASE_MASK";
        IndentConsts[IndentConsts["DECREASE_MASK"] = 2] = "DECREASE_MASK";
        IndentConsts[IndentConsts["INDENT_NEXTLINE_MASK"] = 4] = "INDENT_NEXTLINE_MASK";
        IndentConsts[IndentConsts["UNINDENT_MASK"] = 8] = "UNINDENT_MASK";
    })(IndentConsts = exports.IndentConsts || (exports.IndentConsts = {}));
    var IndentRulesSupport = /** @class */ (function () {
        function IndentRulesSupport(indentationRules) {
            this._indentationRules = indentationRules;
        }
        IndentRulesSupport.prototype.shouldIncrease = function (text) {
            if (this._indentationRules) {
                if (this._indentationRules.increaseIndentPattern && this._indentationRules.increaseIndentPattern.test(text)) {
                    return true;
                }
                // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {
                // 	return true;
                // }
            }
            return false;
        };
        IndentRulesSupport.prototype.shouldDecrease = function (text) {
            if (this._indentationRules && this._indentationRules.decreaseIndentPattern && this._indentationRules.decreaseIndentPattern.test(text)) {
                return true;
            }
            return false;
        };
        IndentRulesSupport.prototype.shouldIndentNextLine = function (text) {
            if (this._indentationRules && this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {
                return true;
            }
            return false;
        };
        IndentRulesSupport.prototype.shouldIgnore = function (text) {
            // the text matches `unIndentedLinePattern`
            if (this._indentationRules && this._indentationRules.unIndentedLinePattern && this._indentationRules.unIndentedLinePattern.test(text)) {
                return true;
            }
            return false;
        };
        IndentRulesSupport.prototype.getIndentMetadata = function (text) {
            var ret = 0;
            if (this.shouldIncrease(text)) {
                ret += 1 /* INCREASE_MASK */;
            }
            if (this.shouldDecrease(text)) {
                ret += 2 /* DECREASE_MASK */;
            }
            if (this.shouldIndentNextLine(text)) {
                ret += 4 /* INDENT_NEXTLINE_MASK */;
            }
            if (this.shouldIgnore(text)) {
                ret += 8 /* UNINDENT_MASK */;
            }
            return ret;
        };
        return IndentRulesSupport;
    }());
    exports.IndentRulesSupport = IndentRulesSupport;
});

define(__m[195/*vs/editor/common/modes/supports/onEnter*/], __M([0/*require*/,1/*exports*/,14/*vs/base/common/errors*/,8/*vs/base/common/strings*/,35/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, errors_1, strings, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var OnEnterSupport = /** @class */ (function () {
        function OnEnterSupport(opts) {
            opts = opts || {};
            opts.brackets = opts.brackets || [
                ['(', ')'],
                ['{', '}'],
                ['[', ']']
            ];
            this._brackets = opts.brackets.map(function (bracket) {
                return {
                    open: bracket[0],
                    openRegExp: OnEnterSupport._createOpenBracketRegExp(bracket[0]),
                    close: bracket[1],
                    closeRegExp: OnEnterSupport._createCloseBracketRegExp(bracket[1]),
                };
            });
            this._regExpRules = opts.regExpRules || [];
        }
        OnEnterSupport.prototype.onEnter = function (oneLineAboveText, beforeEnterText, afterEnterText) {
            // (1): `regExpRules`
            for (var i = 0, len = this._regExpRules.length; i < len; i++) {
                var rule = this._regExpRules[i];
                if (rule.beforeText.test(beforeEnterText)) {
                    if (rule.afterText) {
                        if (rule.afterText.test(afterEnterText)) {
                            return rule.action;
                        }
                    }
                    else {
                        return rule.action;
                    }
                }
            }
            // (2): Special indent-outdent
            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {
                for (var i = 0, len = this._brackets.length; i < len; i++) {
                    var bracket = this._brackets[i];
                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {
                        return { indentAction: languageConfiguration_1.IndentAction.IndentOutdent };
                    }
                }
            }
            // (4): Open bracket based logic
            if (beforeEnterText.length > 0) {
                for (var i = 0, len = this._brackets.length; i < len; i++) {
                    var bracket = this._brackets[i];
                    if (bracket.openRegExp.test(beforeEnterText)) {
                        return { indentAction: languageConfiguration_1.IndentAction.Indent };
                    }
                }
            }
            return null;
        };
        OnEnterSupport._createOpenBracketRegExp = function (bracket) {
            var str = strings.escapeRegExpCharacters(bracket);
            if (!/\B/.test(str.charAt(0))) {
                str = '\\b' + str;
            }
            str += '\\s*$';
            return OnEnterSupport._safeRegExp(str);
        };
        OnEnterSupport._createCloseBracketRegExp = function (bracket) {
            var str = strings.escapeRegExpCharacters(bracket);
            if (!/\B/.test(str.charAt(str.length - 1))) {
                str = str + '\\b';
            }
            str = '^\\s*' + str;
            return OnEnterSupport._safeRegExp(str);
        };
        OnEnterSupport._safeRegExp = function (def) {
            try {
                return new RegExp(def);
            }
            catch (err) {
                errors_1.onUnexpectedError(err);
                return null;
            }
        };
        return OnEnterSupport;
    }());
    exports.OnEnterSupport = OnEnterSupport;
});

define(__m[45/*vs/editor/common/modes/supports/richEditBrackets*/], __M([0/*require*/,1/*exports*/,8/*vs/base/common/strings*/,24/*vs/editor/common/core/range*/]), function (require, exports, strings, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RichEditBracket = /** @class */ (function () {
        function RichEditBracket(languageIdentifier, open, close, forwardRegex, reversedRegex) {
            this.languageIdentifier = languageIdentifier;
            this.open = open;
            this.close = close;
            this.forwardRegex = forwardRegex;
            this.reversedRegex = reversedRegex;
        }
        return RichEditBracket;
    }());
    exports.RichEditBracket = RichEditBracket;
    var RichEditBrackets = /** @class */ (function () {
        function RichEditBrackets(languageIdentifier, brackets) {
            var _this = this;
            this.brackets = brackets.map(function (b) {
                return new RichEditBracket(languageIdentifier, b[0], b[1], getRegexForBracketPair({ open: b[0], close: b[1] }), getReversedRegexForBracketPair({ open: b[0], close: b[1] }));
            });
            this.forwardRegex = getRegexForBrackets(this.brackets);
            this.reversedRegex = getReversedRegexForBrackets(this.brackets);
            this.textIsBracket = {};
            this.textIsOpenBracket = {};
            var maxBracketLength = 0;
            this.brackets.forEach(function (b) {
                _this.textIsBracket[b.open.toLowerCase()] = b;
                _this.textIsBracket[b.close.toLowerCase()] = b;
                _this.textIsOpenBracket[b.open.toLowerCase()] = true;
                _this.textIsOpenBracket[b.close.toLowerCase()] = false;
                maxBracketLength = Math.max(maxBracketLength, b.open.length);
                maxBracketLength = Math.max(maxBracketLength, b.close.length);
            });
            this.maxBracketLength = maxBracketLength;
        }
        return RichEditBrackets;
    }());
    exports.RichEditBrackets = RichEditBrackets;
    function once(keyFn, computeFn) {
        var cache = {};
        return function (input) {
            var key = keyFn(input);
            if (!cache.hasOwnProperty(key)) {
                cache[key] = computeFn(input);
            }
            return cache[key];
        };
    }
    var getRegexForBracketPair = once(function (input) { return input.open + ";" + input.close; }, function (input) {
        return createBracketOrRegExp([input.open, input.close]);
    });
    var getReversedRegexForBracketPair = once(function (input) { return input.open + ";" + input.close; }, function (input) {
        return createBracketOrRegExp([toReversedString(input.open), toReversedString(input.close)]);
    });
    var getRegexForBrackets = once(function (input) { return input.map(function (b) { return b.open + ";" + b.close; }).join(';'); }, function (input) {
        var pieces = [];
        input.forEach(function (b) {
            pieces.push(b.open);
            pieces.push(b.close);
        });
        return createBracketOrRegExp(pieces);
    });
    var getReversedRegexForBrackets = once(function (input) { return input.map(function (b) { return b.open + ";" + b.close; }).join(';'); }, function (input) {
        var pieces = [];
        input.forEach(function (b) {
            pieces.push(toReversedString(b.open));
            pieces.push(toReversedString(b.close));
        });
        return createBracketOrRegExp(pieces);
    });
    function prepareBracketForRegExp(str) {
        // This bracket pair uses letters like e.g. "begin" - "end"
        var insertWordBoundaries = (/^[\w]+$/.test(str));
        str = strings.escapeRegExpCharacters(str);
        return (insertWordBoundaries ? "\\b" + str + "\\b" : str);
    }
    function createBracketOrRegExp(pieces) {
        var regexStr = "(" + pieces.map(prepareBracketForRegExp).join(')|(') + ")";
        return strings.createRegExp(regexStr, true);
    }
    var toReversedString = (function () {
        function reverse(str) {
            var reversedStr = '';
            for (var i = str.length - 1; i >= 0; i--) {
                reversedStr += str.charAt(i);
            }
            return reversedStr;
        }
        var lastInput = null;
        var lastOutput = null;
        return function toReversedString(str) {
            if (lastInput !== str) {
                lastInput = str;
                lastOutput = reverse(lastInput);
            }
            return lastOutput;
        };
    })();
    var BracketsUtils = /** @class */ (function () {
        function BracketsUtils() {
        }
        BracketsUtils._findPrevBracketInText = function (reversedBracketRegex, lineNumber, reversedText, offset) {
            var m = reversedText.match(reversedBracketRegex);
            if (!m) {
                return null;
            }
            var matchOffset = reversedText.length - m.index;
            var matchLength = m[0].length;
            var absoluteMatchOffset = offset + matchOffset;
            return new range_1.Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);
        };
        BracketsUtils.findPrevBracketInToken = function (reversedBracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {
            // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)
            var reversedLineText = toReversedString(lineText);
            var reversedTokenText = reversedLineText.substring(lineText.length - currentTokenEnd, lineText.length - currentTokenStart);
            return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedTokenText, currentTokenStart);
        };
        BracketsUtils.findNextBracketInText = function (bracketRegex, lineNumber, text, offset) {
            var m = text.match(bracketRegex);
            if (!m) {
                return null;
            }
            var matchOffset = m.index;
            var matchLength = m[0].length;
            if (matchLength === 0) {
                return null;
            }
            var absoluteMatchOffset = offset + matchOffset;
            return new range_1.Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);
        };
        BracketsUtils.findNextBracketInToken = function (bracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {
            var currentTokenText = lineText.substring(currentTokenStart, currentTokenEnd);
            return this.findNextBracketInText(bracketRegex, lineNumber, currentTokenText, currentTokenStart);
        };
        return BracketsUtils;
    }());
    exports.BracketsUtils = BracketsUtils;
});

define(__m[219/*vs/editor/common/modes/supports/electricCharacter*/], __M([0/*require*/,1/*exports*/,46/*vs/editor/common/modes/supports*/,45/*vs/editor/common/modes/supports/richEditBrackets*/,35/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, supports_1, richEditBrackets_1, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var BracketElectricCharacterSupport = /** @class */ (function () {
        function BracketElectricCharacterSupport(richEditBrackets, autoClosePairs, contribution) {
            contribution = contribution || {};
            this._richEditBrackets = richEditBrackets;
            this._complexAutoClosePairs = autoClosePairs.filter(function (pair) { return pair.open.length > 1 && !!pair.close; }).map(function (el) { return new languageConfiguration_1.StandardAutoClosingPairConditional(el); });
            if (contribution.docComment) {
                // IDocComment is legacy, only partially supported
                this._complexAutoClosePairs.push(new languageConfiguration_1.StandardAutoClosingPairConditional({ open: contribution.docComment.open, close: contribution.docComment.close }));
            }
        }
        BracketElectricCharacterSupport.prototype.getElectricCharacters = function () {
            var result = [];
            if (this._richEditBrackets) {
                for (var i = 0, len = this._richEditBrackets.brackets.length; i < len; i++) {
                    var bracketPair = this._richEditBrackets.brackets[i];
                    var lastChar = bracketPair.close.charAt(bracketPair.close.length - 1);
                    result.push(lastChar);
                }
            }
            // auto close
            for (var _i = 0, _a = this._complexAutoClosePairs; _i < _a.length; _i++) {
                var pair = _a[_i];
                result.push(pair.open.charAt(pair.open.length - 1));
            }
            // Filter duplicate entries
            result = result.filter(function (item, pos, array) {
                return array.indexOf(item) === pos;
            });
            return result;
        };
        BracketElectricCharacterSupport.prototype.onElectricCharacter = function (character, context, column) {
            return (this._onElectricAutoClose(character, context, column) ||
                this._onElectricAutoIndent(character, context, column));
        };
        BracketElectricCharacterSupport.prototype._onElectricAutoIndent = function (character, context, column) {
            if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {
                return null;
            }
            var tokenIndex = context.findTokenIndexAtOffset(column - 1);
            if (supports_1.ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {
                return null;
            }
            var reversedBracketRegex = this._richEditBrackets.reversedRegex;
            var text = context.getLineContent().substring(0, column - 1) + character;
            var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, 1, text, 0, text.length);
            if (!r) {
                return null;
            }
            var bracketText = text.substring(r.startColumn - 1, r.endColumn - 1);
            bracketText = bracketText.toLowerCase();
            var isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];
            if (isOpen) {
                return null;
            }
            var textBeforeBracket = text.substring(0, r.startColumn - 1);
            if (!/^\s*$/.test(textBeforeBracket)) {
                // There is other text on the line before the bracket
                return null;
            }
            return {
                matchOpenBracket: bracketText
            };
        };
        BracketElectricCharacterSupport.prototype._onElectricAutoClose = function (character, context, column) {
            if (!this._complexAutoClosePairs.length) {
                return null;
            }
            var line = context.getLineContent();
            for (var i = 0, len = this._complexAutoClosePairs.length; i < len; i++) {
                var pair = this._complexAutoClosePairs[i];
                // See if the right electric character was pressed
                if (character !== pair.open.charAt(pair.open.length - 1)) {
                    continue;
                }
                // check if the full open bracket matches
                var actual = line.substring(line.length - pair.open.length + 1) + character;
                if (actual !== pair.open) {
                    continue;
                }
                var lastTokenIndex = context.findTokenIndexAtOffset(column - 1);
                var lastTokenStandardType = context.getStandardTokenType(lastTokenIndex);
                // If we're in a scope listed in 'notIn', do nothing
                if (!pair.isOK(lastTokenStandardType)) {
                    continue;
                }
                // If this line already contains the closing tag, do nothing.
                if (line.indexOf(pair.close, column - 1) >= 0) {
                    continue;
                }
                return { appendText: pair.close };
            }
            return null;
        };
        return BracketElectricCharacterSupport;
    }());
    exports.BracketElectricCharacterSupport = BracketElectricCharacterSupport;
});

define(__m[73/*vs/editor/common/modes/languageConfigurationRegistry*/], __M([0/*require*/,1/*exports*/,175/*vs/editor/common/modes/supports/characterPair*/,219/*vs/editor/common/modes/supports/electricCharacter*/,195/*vs/editor/common/modes/supports/onEnter*/,176/*vs/editor/common/modes/supports/indentRules*/,45/*vs/editor/common/modes/supports/richEditBrackets*/,3/*vs/base/common/event*/,14/*vs/base/common/errors*/,8/*vs/base/common/strings*/,9/*vs/base/common/lifecycle*/,41/*vs/editor/common/model/wordHelper*/,46/*vs/editor/common/modes/supports*/,24/*vs/editor/common/core/range*/,35/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, characterPair_1, electricCharacter_1, onEnter_1, indentRules_1, richEditBrackets_1, event_1, errors_1, strings, lifecycle_1, wordHelper_1, supports_1, range_1, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RichEditSupport = /** @class */ (function () {
        function RichEditSupport(languageIdentifier, previous, rawConf) {
            this._languageIdentifier = languageIdentifier;
            this._brackets = null;
            this._electricCharacter = null;
            var prev = null;
            if (previous) {
                prev = previous._conf;
            }
            this._conf = RichEditSupport._mergeConf(prev, rawConf);
            this.onEnter = RichEditSupport._handleOnEnter(this._conf);
            this.comments = RichEditSupport._handleComments(this._conf);
            this.characterPair = new characterPair_1.CharacterPairSupport(this._conf);
            this.wordDefinition = this._conf.wordPattern || wordHelper_1.DEFAULT_WORD_REGEXP;
            this.indentationRules = this._conf.indentationRules;
            if (this._conf.indentationRules) {
                this.indentRulesSupport = new indentRules_1.IndentRulesSupport(this._conf.indentationRules);
            }
            this.foldingRules = this._conf.folding || {};
        }
        Object.defineProperty(RichEditSupport.prototype, "brackets", {
            get: function () {
                if (!this._brackets && this._conf.brackets) {
                    this._brackets = new richEditBrackets_1.RichEditBrackets(this._languageIdentifier, this._conf.brackets);
                }
                return this._brackets;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RichEditSupport.prototype, "electricCharacter", {
            get: function () {
                if (!this._electricCharacter) {
                    var autoClosingPairs = [];
                    if (this._conf.autoClosingPairs) {
                        autoClosingPairs = this._conf.autoClosingPairs;
                    }
                    else if (this._conf.brackets) {
                        autoClosingPairs = this._conf.brackets.map(function (b) {
                            return { open: b[0], close: b[1] };
                        });
                    }
                    this._electricCharacter = new electricCharacter_1.BracketElectricCharacterSupport(this.brackets, autoClosingPairs, this._conf.__electricCharacterSupport);
                }
                return this._electricCharacter;
            },
            enumerable: true,
            configurable: true
        });
        RichEditSupport._mergeConf = function (prev, current) {
            return {
                comments: (prev ? current.comments || prev.comments : current.comments),
                brackets: (prev ? current.brackets || prev.brackets : current.brackets),
                wordPattern: (prev ? current.wordPattern || prev.wordPattern : current.wordPattern),
                indentationRules: (prev ? current.indentationRules || prev.indentationRules : current.indentationRules),
                onEnterRules: (prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules),
                autoClosingPairs: (prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs),
                surroundingPairs: (prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs),
                folding: (prev ? current.folding || prev.folding : current.folding),
                __electricCharacterSupport: (prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport),
            };
        };
        RichEditSupport._handleOnEnter = function (conf) {
            // on enter
            var onEnter = {};
            var empty = true;
            if (conf.brackets) {
                empty = false;
                onEnter.brackets = conf.brackets;
            }
            if (conf.indentationRules) {
                empty = false;
            }
            if (conf.onEnterRules) {
                empty = false;
                onEnter.regExpRules = conf.onEnterRules;
            }
            if (!empty) {
                return new onEnter_1.OnEnterSupport(onEnter);
            }
            return null;
        };
        RichEditSupport._handleComments = function (conf) {
            var commentRule = conf.comments;
            if (!commentRule) {
                return null;
            }
            // comment configuration
            var comments = {};
            if (commentRule.lineComment) {
                comments.lineCommentToken = commentRule.lineComment;
            }
            if (commentRule.blockComment) {
                var _a = commentRule.blockComment, blockStart = _a[0], blockEnd = _a[1];
                comments.blockCommentStartToken = blockStart;
                comments.blockCommentEndToken = blockEnd;
            }
            return comments;
        };
        return RichEditSupport;
    }());
    exports.RichEditSupport = RichEditSupport;
    var LanguageConfigurationChangeEvent = /** @class */ (function () {
        function LanguageConfigurationChangeEvent() {
        }
        return LanguageConfigurationChangeEvent;
    }());
    exports.LanguageConfigurationChangeEvent = LanguageConfigurationChangeEvent;
    var LanguageConfigurationRegistryImpl = /** @class */ (function () {
        function LanguageConfigurationRegistryImpl() {
            this._onDidChange = new event_1.Emitter();
            this.onDidChange = this._onDidChange.event;
            this._entries = [];
        }
        LanguageConfigurationRegistryImpl.prototype.register = function (languageIdentifier, configuration) {
            var _this = this;
            var previous = this._getRichEditSupport(languageIdentifier.id);
            var current = new RichEditSupport(languageIdentifier, previous, configuration);
            this._entries[languageIdentifier.id] = current;
            this._onDidChange.fire({ languageIdentifier: languageIdentifier });
            return lifecycle_1.toDisposable(function () {
                if (_this._entries[languageIdentifier.id] === current) {
                    _this._entries[languageIdentifier.id] = previous;
                    _this._onDidChange.fire({ languageIdentifier: languageIdentifier });
                }
            });
        };
        LanguageConfigurationRegistryImpl.prototype._getRichEditSupport = function (languageId) {
            return this._entries[languageId] || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getIndentationRules = function (languageId) {
            var value = this._entries[languageId];
            if (!value) {
                return null;
            }
            return value.indentationRules || null;
        };
        // begin electricCharacter
        LanguageConfigurationRegistryImpl.prototype._getElectricCharacterSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.electricCharacter || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getElectricCharacters = function (languageId) {
            var electricCharacterSupport = this._getElectricCharacterSupport(languageId);
            if (!electricCharacterSupport) {
                return [];
            }
            return electricCharacterSupport.getElectricCharacters();
        };
        /**
         * Should return opening bracket type to match indentation with
         */
        LanguageConfigurationRegistryImpl.prototype.onElectricCharacter = function (character, context, column) {
            var scopedLineTokens = supports_1.createScopedLineTokens(context, column - 1);
            var electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);
            if (!electricCharacterSupport) {
                return null;
            }
            return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);
        };
        // end electricCharacter
        LanguageConfigurationRegistryImpl.prototype.getComments = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.comments || null;
        };
        // begin characterPair
        LanguageConfigurationRegistryImpl.prototype._getCharacterPairSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.characterPair || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getAutoClosingPairs = function (languageId) {
            var characterPairSupport = this._getCharacterPairSupport(languageId);
            if (!characterPairSupport) {
                return [];
            }
            return characterPairSupport.getAutoClosingPairs();
        };
        LanguageConfigurationRegistryImpl.prototype.getSurroundingPairs = function (languageId) {
            var characterPairSupport = this._getCharacterPairSupport(languageId);
            if (!characterPairSupport) {
                return [];
            }
            return characterPairSupport.getSurroundingPairs();
        };
        LanguageConfigurationRegistryImpl.prototype.shouldAutoClosePair = function (character, context, column) {
            var scopedLineTokens = supports_1.createScopedLineTokens(context, column - 1);
            var characterPairSupport = this._getCharacterPairSupport(scopedLineTokens.languageId);
            if (!characterPairSupport) {
                return false;
            }
            return characterPairSupport.shouldAutoClosePair(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);
        };
        // end characterPair
        LanguageConfigurationRegistryImpl.prototype.getWordDefinition = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return wordHelper_1.ensureValidWordDefinition(null);
            }
            return wordHelper_1.ensureValidWordDefinition(value.wordDefinition || null);
        };
        LanguageConfigurationRegistryImpl.prototype.getFoldingRules = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return {};
            }
            return value.foldingRules;
        };
        // begin Indent Rules
        LanguageConfigurationRegistryImpl.prototype.getIndentRulesSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.indentRulesSupport || null;
        };
        /**
         * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.
         * Result:
         * -1: run into the boundary of embedded languages
         * 0: every line above are invalid
         * else: nearest preceding line of the same language
         */
        LanguageConfigurationRegistryImpl.prototype.getPrecedingValidLine = function (model, lineNumber, indentRulesSupport) {
            var languageID = model.getLanguageIdAtPosition(lineNumber, 0);
            if (lineNumber > 1) {
                var lastLineNumber = lineNumber - 1;
                var resultLineNumber = -1;
                for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {
                    if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {
                        return resultLineNumber;
                    }
                    var text = model.getLineContent(lastLineNumber);
                    if (indentRulesSupport.shouldIgnore(text) || /^\s+$/.test(text) || text === '') {
                        resultLineNumber = lastLineNumber;
                        continue;
                    }
                    return lastLineNumber;
                }
            }
            return -1;
        };
        /**
         * Get inherited indentation from above lines.
         * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.
         * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.
         * 3. If this line doesn't match any indent rules
         *   a. check whether the line above it matches indentNextLinePattern
         *   b. If not, the indent level of this line is the result
         *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).
         * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`
         *
         * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.
         */
        LanguageConfigurationRegistryImpl.prototype.getInheritIndentForLine = function (model, lineNumber, honorIntentialIndent) {
            if (honorIntentialIndent === void 0) { honorIntentialIndent = true; }
            var indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);
            if (!indentRulesSupport) {
                return null;
            }
            if (lineNumber <= 1) {
                return {
                    indentation: '',
                    action: null
                };
            }
            var precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);
            if (precedingUnIgnoredLine < 0) {
                return null;
            }
            else if (precedingUnIgnoredLine < 1) {
                return {
                    indentation: '',
                    action: null
                };
            }
            var precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);
            if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {
                return {
                    indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),
                    action: languageConfiguration_1.IndentAction.Indent,
                    line: precedingUnIgnoredLine
                };
            }
            else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {
                return {
                    indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),
                    action: null,
                    line: precedingUnIgnoredLine
                };
            }
            else {
                // precedingUnIgnoredLine can not be ignored.
                // it doesn't increase indent of following lines
                // it doesn't increase just next line
                // so current line is not affect by precedingUnIgnoredLine
                // and then we should get a correct inheritted indentation from above lines
                if (precedingUnIgnoredLine === 1) {
                    return {
                        indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),
                        action: null,
                        line: precedingUnIgnoredLine
                    };
                }
                var previousLine = precedingUnIgnoredLine - 1;
                var previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));
                if (!(previousLineIndentMetadata & (1 /* INCREASE_MASK */ | 2 /* DECREASE_MASK */)) &&
                    (previousLineIndentMetadata & 4 /* INDENT_NEXTLINE_MASK */)) {
                    var stopLine = 0;
                    for (var i = previousLine - 1; i > 0; i--) {
                        if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {
                            continue;
                        }
                        stopLine = i;
                        break;
                    }
                    return {
                        indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),
                        action: null,
                        line: stopLine + 1
                    };
                }
                if (honorIntentialIndent) {
                    return {
                        indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),
                        action: null,
                        line: precedingUnIgnoredLine
                    };
                }
                else {
                    // search from precedingUnIgnoredLine until we find one whose indent is not temporary
                    for (var i = precedingUnIgnoredLine; i > 0; i--) {
                        var lineContent = model.getLineContent(i);
                        if (indentRulesSupport.shouldIncrease(lineContent)) {
                            return {
                                indentation: strings.getLeadingWhitespace(lineContent),
                                action: languageConfiguration_1.IndentAction.Indent,
                                line: i
                            };
                        }
                        else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {
                            var stopLine = 0;
                            for (var j = i - 1; j > 0; j--) {
                                if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {
                                    continue;
                                }
                                stopLine = j;
                                break;
                            }
                            return {
                                indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),
                                action: null,
                                line: stopLine + 1
                            };
                        }
                        else if (indentRulesSupport.shouldDecrease(lineContent)) {
                            return {
                                indentation: strings.getLeadingWhitespace(lineContent),
                                action: null,
                                line: i
                            };
                        }
                    }
                    return {
                        indentation: strings.getLeadingWhitespace(model.getLineContent(1)),
                        action: null,
                        line: 1
                    };
                }
            }
        };
        LanguageConfigurationRegistryImpl.prototype.getGoodIndentForLine = function (virtualModel, languageId, lineNumber, indentConverter) {
            var indentRulesSupport = this.getIndentRulesSupport(languageId);
            if (!indentRulesSupport) {
                return null;
            }
            var indent = this.getInheritIndentForLine(virtualModel, lineNumber);
            var lineContent = virtualModel.getLineContent(lineNumber);
            if (indent) {
                var inheritLine = indent.line;
                if (inheritLine !== undefined) {
                    var onEnterSupport = this._getOnEnterSupport(languageId);
                    var enterResult = null;
                    try {
                        enterResult = onEnterSupport.onEnter('', virtualModel.getLineContent(inheritLine), '');
                    }
                    catch (e) {
                        errors_1.onUnexpectedError(e);
                    }
                    if (enterResult) {
                        var indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));
                        if (enterResult.removeText) {
                            indentation = indentation.substring(0, indentation.length - enterResult.removeText);
                        }
                        if ((enterResult.indentAction === languageConfiguration_1.IndentAction.Indent) ||
                            (enterResult.indentAction === languageConfiguration_1.IndentAction.IndentOutdent)) {
                            indentation = indentConverter.shiftIndent(indentation);
                        }
                        else if (enterResult.indentAction === languageConfiguration_1.IndentAction.Outdent) {
                            indentation = indentConverter.unshiftIndent(indentation);
                        }
                        if (indentRulesSupport.shouldDecrease(lineContent)) {
                            indentation = indentConverter.unshiftIndent(indentation);
                        }
                        if (enterResult.appendText) {
                            indentation += enterResult.appendText;
                        }
                        return strings.getLeadingWhitespace(indentation);
                    }
                }
                if (indentRulesSupport.shouldDecrease(lineContent)) {
                    if (indent.action === languageConfiguration_1.IndentAction.Indent) {
                        return indent.indentation;
                    }
                    else {
                        return indentConverter.unshiftIndent(indent.indentation);
                    }
                }
                else {
                    if (indent.action === languageConfiguration_1.IndentAction.Indent) {
                        return indentConverter.shiftIndent(indent.indentation);
                    }
                    else {
                        return indent.indentation;
                    }
                }
            }
            return null;
        };
        LanguageConfigurationRegistryImpl.prototype.getIndentForEnter = function (model, range, indentConverter, autoIndent) {
            model.forceTokenization(range.startLineNumber);
            var lineTokens = model.getLineTokens(range.startLineNumber);
            var beforeEnterText;
            var afterEnterText;
            var scopedLineTokens = supports_1.createScopedLineTokens(lineTokens, range.startColumn - 1);
            var scopedLineText = scopedLineTokens.getLineContent();
            var embeddedLanguage = false;
            if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {
                // we are in the embeded language content
                embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line
                beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            else {
                beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);
            }
            if (range.isEmpty()) {
                afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            else {
                var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);
                afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            var indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);
            if (!indentRulesSupport) {
                return null;
            }
            var beforeEnterResult = beforeEnterText;
            var beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);
            if (!autoIndent && !embeddedLanguage) {
                var beforeEnterIndentAction = this.getInheritIndentForLine(model, range.startLineNumber);
                if (indentRulesSupport.shouldDecrease(beforeEnterText)) {
                    if (beforeEnterIndentAction) {
                        beforeEnterIndent = beforeEnterIndentAction.indentation;
                        if (beforeEnterIndentAction.action !== languageConfiguration_1.IndentAction.Indent) {
                            beforeEnterIndent = indentConverter.unshiftIndent(beforeEnterIndent);
                        }
                    }
                }
                beforeEnterResult = beforeEnterIndent + strings.ltrim(strings.ltrim(beforeEnterText, ' '), '\t');
            }
            var virtualModel = {
                getLineTokens: function (lineNumber) {
                    return model.getLineTokens(lineNumber);
                },
                getLanguageIdentifier: function () {
                    return model.getLanguageIdentifier();
                },
                getLanguageIdAtPosition: function (lineNumber, column) {
                    return model.getLanguageIdAtPosition(lineNumber, column);
                },
                getLineContent: function (lineNumber) {
                    if (lineNumber === range.startLineNumber) {
                        return beforeEnterResult;
                    }
                    else {
                        return model.getLineContent(lineNumber);
                    }
                }
            };
            var currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());
            var afterEnterAction = this.getInheritIndentForLine(virtualModel, range.startLineNumber + 1);
            if (!afterEnterAction) {
                var beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;
                return {
                    beforeEnter: beforeEnter,
                    afterEnter: beforeEnter
                };
            }
            var afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;
            if (afterEnterAction.action === languageConfiguration_1.IndentAction.Indent) {
                afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);
            }
            if (indentRulesSupport.shouldDecrease(afterEnterText)) {
                afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);
            }
            return {
                beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,
                afterEnter: afterEnterIndent
            };
        };
        /**
         * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of
         * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.
         */
        LanguageConfigurationRegistryImpl.prototype.getIndentActionForType = function (model, range, ch, indentConverter) {
            var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);
            var indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);
            if (!indentRulesSupport) {
                return null;
            }
            var scopedLineText = scopedLineTokens.getLineContent();
            var beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
            var afterTypeText;
            // selection support
            if (range.isEmpty()) {
                afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            else {
                var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);
                afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted
            // Users might change the indentation by purpose and we should honor that instead of readjusting.
            if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {
                // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.
                // 1. Get inherited indent action
                var r = this.getInheritIndentForLine(model, range.startLineNumber, false);
                if (!r) {
                    return null;
                }
                var indentation = r.indentation;
                if (r.action !== languageConfiguration_1.IndentAction.Indent) {
                    indentation = indentConverter.unshiftIndent(indentation);
                }
                return indentation;
            }
            return null;
        };
        LanguageConfigurationRegistryImpl.prototype.getIndentMetadata = function (model, lineNumber) {
            var indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);
            if (!indentRulesSupport) {
                return null;
            }
            if (lineNumber < 1 || lineNumber > model.getLineCount()) {
                return null;
            }
            return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));
        };
        // end Indent Rules
        // begin onEnter
        LanguageConfigurationRegistryImpl.prototype._getOnEnterSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.onEnter || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getRawEnterActionAtPosition = function (model, lineNumber, column) {
            var r = this.getEnterAction(model, new range_1.Range(lineNumber, column, lineNumber, column));
            return r ? r.enterAction : null;
        };
        LanguageConfigurationRegistryImpl.prototype.getEnterAction = function (model, range) {
            var indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);
            var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);
            var onEnterSupport = this._getOnEnterSupport(scopedLineTokens.languageId);
            if (!onEnterSupport) {
                return null;
            }
            var scopedLineText = scopedLineTokens.getLineContent();
            var beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
            var afterEnterText;
            // selection support
            if (range.isEmpty()) {
                afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            else {
                var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);
                afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            var lineNumber = range.startLineNumber;
            var oneLineAboveText = '';
            if (lineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {
                // This is not the first line and the entire line belongs to this mode
                var oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, lineNumber - 1);
                if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {
                    // The line above ends with text belonging to the same mode
                    oneLineAboveText = oneLineAboveScopedLineTokens.getLineContent();
                }
            }
            var enterResult = null;
            try {
                enterResult = onEnterSupport.onEnter(oneLineAboveText, beforeEnterText, afterEnterText);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
            if (!enterResult) {
                return null;
            }
            else {
                // Here we add `\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.
                if (!enterResult.appendText) {
                    if ((enterResult.indentAction === languageConfiguration_1.IndentAction.Indent) ||
                        (enterResult.indentAction === languageConfiguration_1.IndentAction.IndentOutdent)) {
                        enterResult.appendText = '\t';
                    }
                    else {
                        enterResult.appendText = '';
                    }
                }
            }
            if (enterResult.removeText) {
                indentation = indentation.substring(0, indentation.length - enterResult.removeText);
            }
            return {
                enterAction: enterResult,
                indentation: indentation,
            };
        };
        LanguageConfigurationRegistryImpl.prototype.getIndentationAtPosition = function (model, lineNumber, column) {
            var lineText = model.getLineContent(lineNumber);
            var indentation = strings.getLeadingWhitespace(lineText);
            if (indentation.length > column - 1) {
                indentation = indentation.substring(0, column - 1);
            }
            return indentation;
        };
        LanguageConfigurationRegistryImpl.prototype.getScopedLineTokens = function (model, lineNumber, columnNumber) {
            model.forceTokenization(lineNumber);
            var lineTokens = model.getLineTokens(lineNumber);
            var column = isNaN(columnNumber) ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1;
            var scopedLineTokens = supports_1.createScopedLineTokens(lineTokens, column);
            return scopedLineTokens;
        };
        // end onEnter
        LanguageConfigurationRegistryImpl.prototype.getBracketsSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.brackets || null;
        };
        return LanguageConfigurationRegistryImpl;
    }());
    exports.LanguageConfigurationRegistryImpl = LanguageConfigurationRegistryImpl;
    exports.LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();
});

define(__m[235/*vs/editor/common/modes/tokenizationRegistry*/], __M([0/*require*/,1/*exports*/,9/*vs/base/common/lifecycle*/,3/*vs/base/common/event*/]), function (require, exports, lifecycle_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TokenizationRegistryImpl = /** @class */ (function () {
        function TokenizationRegistryImpl() {
            this._onDidChange = new event_1.Emitter();
            this.onDidChange = this._onDidChange.event;
            this._map = Object.create(null);
            this._colorMap = null;
        }
        TokenizationRegistryImpl.prototype.fire = function (languages) {
            this._onDidChange.fire({
                changedLanguages: languages,
                changedColorMap: false
            });
        };
        TokenizationRegistryImpl.prototype.register = function (language, support) {
            var _this = this;
            this._map[language] = support;
            this.fire([language]);
            return lifecycle_1.toDisposable(function () {
                if (_this._map[language] !== support) {
                    return;
                }
                delete _this._map[language];
                _this.fire([language]);
            });
        };
        TokenizationRegistryImpl.prototype.get = function (language) {
            return (this._map[language] || null);
        };
        TokenizationRegistryImpl.prototype.setColorMap = function (colorMap) {
            this._colorMap = colorMap;
            this._onDidChange.fire({
                changedLanguages: Object.keys(this._map),
                changedColorMap: true
            });
        };
        TokenizationRegistryImpl.prototype.getColorMap = function () {
            return this._colorMap;
        };
        TokenizationRegistryImpl.prototype.getDefaultBackground = function () {
            return this._colorMap[2 /* DefaultBackground */];
        };
        return TokenizationRegistryImpl;
    }());
    exports.TokenizationRegistryImpl = TokenizationRegistryImpl;
});

define(__m[86/*vs/editor/common/viewModel/prefixSumComputer*/], __M([0/*require*/,1/*exports*/,56/*vs/editor/common/core/uint*/]), function (require, exports, uint_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var PrefixSumIndexOfResult = /** @class */ (function () {
        function PrefixSumIndexOfResult(index, remainder) {
            this.index = index;
            this.remainder = remainder;
        }
        return PrefixSumIndexOfResult;
    }());
    exports.PrefixSumIndexOfResult = PrefixSumIndexOfResult;
    var PrefixSumComputer = /** @class */ (function () {
        function PrefixSumComputer(values) {
            this.values = values;
            this.prefixSum = new Uint32Array(values.length);
            this.prefixSumValidIndex = new Int32Array(1);
            this.prefixSumValidIndex[0] = -1;
        }
        PrefixSumComputer.prototype.getCount = function () {
            return this.values.length;
        };
        PrefixSumComputer.prototype.insertValues = function (insertIndex, insertValues) {
            insertIndex = uint_1.toUint32(insertIndex);
            var oldValues = this.values;
            var oldPrefixSum = this.prefixSum;
            var insertValuesLen = insertValues.length;
            if (insertValuesLen === 0) {
                return false;
            }
            this.values = new Uint32Array(oldValues.length + insertValuesLen);
            this.values.set(oldValues.subarray(0, insertIndex), 0);
            this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
            this.values.set(insertValues, insertIndex);
            if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
                this.prefixSumValidIndex[0] = insertIndex - 1;
            }
            this.prefixSum = new Uint32Array(this.values.length);
            if (this.prefixSumValidIndex[0] >= 0) {
                this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
            }
            return true;
        };
        PrefixSumComputer.prototype.changeValue = function (index, value) {
            index = uint_1.toUint32(index);
            value = uint_1.toUint32(value);
            if (this.values[index] === value) {
                return false;
            }
            this.values[index] = value;
            if (index - 1 < this.prefixSumValidIndex[0]) {
                this.prefixSumValidIndex[0] = index - 1;
            }
            return true;
        };
        PrefixSumComputer.prototype.removeValues = function (startIndex, cnt) {
            startIndex = uint_1.toUint32(startIndex);
            cnt = uint_1.toUint32(cnt);
            var oldValues = this.values;
            var oldPrefixSum = this.prefixSum;
            if (startIndex >= oldValues.length) {
                return false;
            }
            var maxCnt = oldValues.length - startIndex;
            if (cnt >= maxCnt) {
                cnt = maxCnt;
            }
            if (cnt === 0) {
                return false;
            }
            this.values = new Uint32Array(oldValues.length - cnt);
            this.values.set(oldValues.subarray(0, startIndex), 0);
            this.values.set(oldValues.subarray(startIndex + cnt), startIndex);
            this.prefixSum = new Uint32Array(this.values.length);
            if (startIndex - 1 < this.prefixSumValidIndex[0]) {
                this.prefixSumValidIndex[0] = startIndex - 1;
            }
            if (this.prefixSumValidIndex[0] >= 0) {
                this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
            }
            return true;
        };
        PrefixSumComputer.prototype.getTotalValue = function () {
            if (this.values.length === 0) {
                return 0;
            }
            return this._getAccumulatedValue(this.values.length - 1);
        };
        PrefixSumComputer.prototype.getAccumulatedValue = function (index) {
            if (index < 0) {
                return 0;
            }
            index = uint_1.toUint32(index);
            return this._getAccumulatedValue(index);
        };
        PrefixSumComputer.prototype._getAccumulatedValue = function (index) {
            if (index <= this.prefixSumValidIndex[0]) {
                return this.prefixSum[index];
            }
            var startIndex = this.prefixSumValidIndex[0] + 1;
            if (startIndex === 0) {
                this.prefixSum[0] = this.values[0];
                startIndex++;
            }
            if (index >= this.values.length) {
                index = this.values.length - 1;
            }
            for (var i = startIndex; i <= index; i++) {
                this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
            }
            this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
            return this.prefixSum[index];
        };
        PrefixSumComputer.prototype.getIndexOf = function (accumulatedValue) {
            accumulatedValue = Math.floor(accumulatedValue); //@perf
            // Compute all sums (to get a fully valid prefixSum)
            this.getTotalValue();
            var low = 0;
            var high = this.values.length - 1;
            var mid;
            var midStop;
            var midStart;
            while (low <= high) {
                mid = low + ((high - low) / 2) | 0;
                midStop = this.prefixSum[mid];
                midStart = midStop - this.values[mid];
                if (accumulatedValue < midStart) {
                    high = mid - 1;
                }
                else if (accumulatedValue >= midStop) {
                    low = mid + 1;
                }
                else {
                    break;
                }
            }
            return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);
        };
        return PrefixSumComputer;
    }());
    exports.PrefixSumComputer = PrefixSumComputer;
    var PrefixSumComputerWithCache = /** @class */ (function () {
        function PrefixSumComputerWithCache(values) {
            this._cacheAccumulatedValueStart = 0;
            this._cache = null;
            this._actual = new PrefixSumComputer(values);
            this._bustCache();
        }
        PrefixSumComputerWithCache.prototype._bustCache = function () {
            this._cacheAccumulatedValueStart = 0;
            this._cache = null;
        };
        PrefixSumComputerWithCache.prototype.insertValues = function (insertIndex, insertValues) {
            if (this._actual.insertValues(insertIndex, insertValues)) {
                this._bustCache();
            }
        };
        PrefixSumComputerWithCache.prototype.changeValue = function (index, value) {
            if (this._actual.changeValue(index, value)) {
                this._bustCache();
            }
        };
        PrefixSumComputerWithCache.prototype.removeValues = function (startIndex, cnt) {
            if (this._actual.removeValues(startIndex, cnt)) {
                this._bustCache();
            }
        };
        PrefixSumComputerWithCache.prototype.getTotalValue = function () {
            return this._actual.getTotalValue();
        };
        PrefixSumComputerWithCache.prototype.getAccumulatedValue = function (index) {
            return this._actual.getAccumulatedValue(index);
        };
        PrefixSumComputerWithCache.prototype.getIndexOf = function (accumulatedValue) {
            accumulatedValue = Math.floor(accumulatedValue); //@perf
            if (this._cache !== null) {
                var cacheIndex = accumulatedValue - this._cacheAccumulatedValueStart;
                if (cacheIndex >= 0 && cacheIndex < this._cache.length) {
                    // Cache hit!
                    return this._cache[cacheIndex];
                }
            }
            // Cache miss!
            return this._actual.getIndexOf(accumulatedValue);
        };
        /**
         * Gives a hint that a lot of requests are about to come in for these accumulated values.
         */
        PrefixSumComputerWithCache.prototype.warmUpCache = function (accumulatedValueStart, accumulatedValueEnd) {
            var newCache = [];
            for (var accumulatedValue = accumulatedValueStart; accumulatedValue <= accumulatedValueEnd; accumulatedValue++) {
                newCache[accumulatedValue - accumulatedValueStart] = this.getIndexOf(accumulatedValue);
            }
            this._cache = newCache;
            this._cacheAccumulatedValueStart = accumulatedValueStart;
        };
        return PrefixSumComputerWithCache;
    }());
    exports.PrefixSumComputerWithCache = PrefixSumComputerWithCache;
});

define(__m[87/*vs/editor/common/model/mirrorTextModel*/], __M([0/*require*/,1/*exports*/,86/*vs/editor/common/viewModel/prefixSumComputer*/,27/*vs/editor/common/core/position*/]), function (require, exports, prefixSumComputer_1, position_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var MirrorTextModel = /** @class */ (function () {
        function MirrorTextModel(uri, lines, eol, versionId) {
            this._uri = uri;
            this._lines = lines;
            this._eol = eol;
            this._versionId = versionId;
        }
        MirrorTextModel.prototype.dispose = function () {
            this._lines.length = 0;
        };
        Object.defineProperty(MirrorTextModel.prototype, "version", {
            get: function () {
                return this._versionId;
            },
            enumerable: true,
            configurable: true
        });
        MirrorTextModel.prototype.getText = function () {
            return this._lines.join(this._eol);
        };
        MirrorTextModel.prototype.onEvents = function (e) {
            if (e.eol && e.eol !== this._eol) {
                this._eol = e.eol;
                this._lineStarts = null;
            }
            // Update my lines
            var changes = e.changes;
            for (var i = 0, len = changes.length; i < len; i++) {
                var change = changes[i];
                this._acceptDeleteRange(change.range);
                this._acceptInsertText(new position_1.Position(change.range.startLineNumber, change.range.startColumn), change.text);
            }
            this._versionId = e.versionId;
        };
        MirrorTextModel.prototype._ensureLineStarts = function () {
            if (!this._lineStarts) {
                var eolLength = this._eol.length;
                var linesLength = this._lines.length;
                var lineStartValues = new Uint32Array(linesLength);
                for (var i = 0; i < linesLength; i++) {
                    lineStartValues[i] = this._lines[i].length + eolLength;
                }
                this._lineStarts = new prefixSumComputer_1.PrefixSumComputer(lineStartValues);
            }
        };
        /**
         * All changes to a line's text go through this method
         */
        MirrorTextModel.prototype._setLineText = function (lineIndex, newValue) {
            this._lines[lineIndex] = newValue;
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
            }
        };
        MirrorTextModel.prototype._acceptDeleteRange = function (range) {
            if (range.startLineNumber === range.endLineNumber) {
                if (range.startColumn === range.endColumn) {
                    // Nothing to delete
                    return;
                }
                // Delete text on the affected line
                this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                    + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
                return;
            }
            // Take remaining text on last line and append it to remaining text on first line
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
            // Delete middle lines
            this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
            }
        };
        MirrorTextModel.prototype._acceptInsertText = function (position, insertText) {
            if (insertText.length === 0) {
                // Nothing to insert
                return;
            }
            var insertLines = insertText.split(/\r\n|\r|\n/);
            if (insertLines.length === 1) {
                // Inserting text on one line
                this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                    + insertLines[0]
                    + this._lines[position.lineNumber - 1].substring(position.column - 1));
                return;
            }
            // Append overflowing text from first line to the end of text to insert
            insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
            // Delete overflowing text from first line and insert text on first line
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                + insertLines[0]);
            // Insert new lines & store lengths
            var newLengths = new Uint32Array(insertLines.length - 1);
            for (var i = 1; i < insertLines.length; i++) {
                this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
                newLengths[i - 1] = insertLines[i].length + this._eol.length;
            }
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.insertValues(position.lineNumber, newLengths);
            }
        };
        return MirrorTextModel;
    }());
    exports.MirrorTextModel = MirrorTextModel;
});

define(__m[88/*vs/nls!sql/workbench/api/node/extHostModelView*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("sql/workbench/api/node/extHostModelView", data); });
define(__m[91/*vs/nls!sql/workbench/api/node/extHostModelViewDialog*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("sql/workbench/api/node/extHostModelViewDialog", data); });
define(__m[92/*vs/nls!sql/workbench/api/node/extHostModelViewTree*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("sql/workbench/api/node/extHostModelViewTree", data); });
define(__m[93/*vs/nls!sql/workbench/api/node/extHostNotebook*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("sql/workbench/api/node/extHostNotebook", data); });
define(__m[94/*vs/nls!vs/base/common/errorMessage*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/base/common/errorMessage", data); });
define(__m[80/*vs/base/common/errorMessage*/], __M([0/*require*/,1/*exports*/,94/*vs/nls!vs/base/common/errorMessage*/,18/*vs/base/common/types*/,13/*vs/base/common/arrays*/]), function (require, exports, nls, types, arrays) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function exceptionToErrorMessage(exception, verbose) {
        if (exception.message) {
            if (verbose && (exception.stack || exception.stacktrace)) {
                return nls.localize(0, null, detectSystemErrorMessage(exception), exception.stack || exception.stacktrace);
            }
            return detectSystemErrorMessage(exception);
        }
        return nls.localize(1, null);
    }
    function detectSystemErrorMessage(exception) {
        // See https://nodejs.org/api/errors.html#errors_class_system_error
        if (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {
            return nls.localize(2, null, exception.message);
        }
        return exception.message;
    }
    /**
     * Tries to generate a human readable error message out of the error. If the verbose parameter
     * is set to true, the error message will include stacktrace details if provided.
     *
     * @returns A string containing the error message.
     */
    function toErrorMessage(error, verbose) {
        if (error === void 0) { error = null; }
        if (verbose === void 0) { verbose = false; }
        if (!error) {
            return nls.localize(3, null);
        }
        if (Array.isArray(error)) {
            var errors = arrays.coalesce(error);
            var msg = toErrorMessage(errors[0], verbose);
            if (errors.length > 1) {
                return nls.localize(4, null, msg, errors.length);
            }
            return msg;
        }
        if (types.isString(error)) {
            return error;
        }
        if (error.detail) {
            var detail = error.detail;
            if (detail.error) {
                return exceptionToErrorMessage(detail.error, verbose);
            }
            if (detail.exception) {
                return exceptionToErrorMessage(detail.exception, verbose);
            }
        }
        if (error.stack) {
            return exceptionToErrorMessage(error, verbose);
        }
        if (error.message) {
            return error.message;
        }
        return nls.localize(5, null);
    }
    exports.toErrorMessage = toErrorMessage;
});

define(__m[96/*vs/nls!vs/base/common/severity*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/base/common/severity", data); });
define(__m[34/*vs/base/common/severity*/], __M([0/*require*/,1/*exports*/,96/*vs/nls!vs/base/common/severity*/,8/*vs/base/common/strings*/]), function (require, exports, nls, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Severity;
    (function (Severity) {
        Severity[Severity["Ignore"] = 0] = "Ignore";
        Severity[Severity["Info"] = 1] = "Info";
        Severity[Severity["Warning"] = 2] = "Warning";
        Severity[Severity["Error"] = 3] = "Error";
    })(Severity || (Severity = {}));
    (function (Severity) {
        var _error = 'error';
        var _warning = 'warning';
        var _warn = 'warn';
        var _info = 'info';
        var _displayStrings = Object.create(null);
        _displayStrings[Severity.Error] = nls.localize(0, null);
        _displayStrings[Severity.Warning] = nls.localize(1, null);
        _displayStrings[Severity.Info] = nls.localize(2, null);
        /**
         * Parses 'error', 'warning', 'warn', 'info' in call casings
         * and falls back to ignore.
         */
        function fromValue(value) {
            if (!value) {
                return Severity.Ignore;
            }
            if (strings.equalsIgnoreCase(_error, value)) {
                return Severity.Error;
            }
            if (strings.equalsIgnoreCase(_warning, value) || strings.equalsIgnoreCase(_warn, value)) {
                return Severity.Warning;
            }
            if (strings.equalsIgnoreCase(_info, value)) {
                return Severity.Info;
            }
            return Severity.Ignore;
        }
        Severity.fromValue = fromValue;
    })(Severity || (Severity = {}));
    exports.default = Severity;
});

define(__m[98/*vs/nls!vs/base/node/processes*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/base/node/processes", data); });










define(__m[99/*vs/base/node/processes*/], __M([0/*require*/,1/*exports*/,22/*path*/,50/*child_process*/,155/*vs/base/node/stdFork*/,98/*vs/nls!vs/base/node/processes*/,2/*vs/base/common/winjs.base*/,18/*vs/base/common/types*/,4/*vs/base/common/uri*/,20/*vs/base/common/objects*/,16/*vs/base/common/paths*/,10/*vs/base/common/platform*/,127/*vs/base/node/decoder*/,160/*vs/base/common/processes*/]), function (require, exports, path, cp, stdFork_1, nls, winjs_base_1, Types, uri_1, Objects, TPath, Platform, decoder_1, processes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Source = processes_1.Source;
    exports.TerminateResponseCode = processes_1.TerminateResponseCode;
    function getWindowsCode(status) {
        switch (status) {
            case 0:
                return processes_1.TerminateResponseCode.Success;
            case 1:
                return processes_1.TerminateResponseCode.AccessDenied;
            case 128:
                return processes_1.TerminateResponseCode.ProcessNotFound;
            default:
                return processes_1.TerminateResponseCode.Unknown;
        }
    }
    function terminateProcess(process, cwd) {
        if (Platform.isWindows) {
            try {
                var options = {
                    stdio: ['pipe', 'pipe', 'ignore']
                };
                if (cwd) {
                    options.cwd = cwd;
                }
                cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
            }
            catch (err) {
                return { success: false, error: err, code: err.status ? getWindowsCode(err.status) : processes_1.TerminateResponseCode.Unknown };
            }
        }
        else if (Platform.isLinux || Platform.isMacintosh) {
            try {
                var cmd = uri_1.default.parse(require.toUrl('vs/base/node/terminateProcess.sh')).fsPath;
                var result = cp.spawnSync(cmd, [process.pid.toString()]);
                if (result.error) {
                    return { success: false, error: result.error };
                }
            }
            catch (err) {
                return { success: false, error: err };
            }
        }
        else {
            process.kill('SIGKILL');
        }
        return { success: true };
    }
    exports.terminateProcess = terminateProcess;
    function getWindowsShell() {
        return process.env['comspec'] || 'cmd.exe';
    }
    exports.getWindowsShell = getWindowsShell;
    var AbstractProcess = /** @class */ (function () {
        function AbstractProcess(arg1, arg2, arg3, arg4) {
            var _this = this;
            if (arg4) {
                this.cmd = arg1;
                this.args = arg2;
                this.shell = arg3;
                this.options = arg4;
            }
            else if (arg3 && arg2) {
                this.module = arg1;
                this.args = arg2;
                this.shell = false;
                this.options = arg3;
            }
            else {
                var executable = arg1;
                this.cmd = executable.command;
                this.shell = executable.isShellCommand;
                this.args = executable.args.slice(0);
                this.options = executable.options || {};
            }
            this.childProcess = null;
            this.terminateRequested = false;
            if (this.options.env) {
                var newEnv_1 = Object.create(null);
                Object.keys(process.env).forEach(function (key) {
                    newEnv_1[key] = process.env[key];
                });
                Object.keys(this.options.env).forEach(function (key) {
                    newEnv_1[key] = _this.options.env[key];
                });
                this.options.env = newEnv_1;
            }
        }
        AbstractProcess.prototype.getSanitizedCommand = function () {
            var result = this.cmd.toLowerCase();
            var index = result.lastIndexOf(path.sep);
            if (index !== -1) {
                result = result.substring(index + 1);
            }
            if (AbstractProcess.WellKnowCommands[result]) {
                return result;
            }
            return 'other';
        };
        AbstractProcess.prototype.start = function (pp) {
            var _this = this;
            if (Platform.isWindows && ((this.options && this.options.cwd && TPath.isUNC(this.options.cwd)) || !this.options && !this.options.cwd && TPath.isUNC(process.cwd()))) {
                return winjs_base_1.TPromise.wrapError(new Error(nls.localize(0, null)));
            }
            return this.useExec().then(function (useExec) {
                var cc;
                var ee;
                var result = new winjs_base_1.TPromise(function (c, e) {
                    cc = c;
                    ee = e;
                });
                if (useExec) {
                    var cmd = _this.cmd;
                    if (_this.args) {
                        cmd = cmd + ' ' + _this.args.join(' ');
                    }
                    _this.childProcess = cp.exec(cmd, _this.options, function (error, stdout, stderr) {
                        _this.childProcess = null;
                        var err = error;
                        // This is tricky since executing a command shell reports error back in case the executed command return an
                        // error or the command didn't exist at all. So we can't blindly treat an error as a failed command. So we
                        // always parse the output and report success unless the job got killed.
                        if (err && err.killed) {
                            ee({ killed: _this.terminateRequested, stdout: stdout.toString(), stderr: stderr.toString() });
                        }
                        else {
                            _this.handleExec(cc, pp, error, stdout, stderr);
                        }
                    });
                }
                else {
                    var childProcess = null;
                    var closeHandler_1 = function (data) {
                        _this.childProcess = null;
                        _this.childProcessPromise = null;
                        _this.handleClose(data, cc, pp, ee);
                        var result = {
                            terminated: _this.terminateRequested
                        };
                        if (Types.isNumber(data)) {
                            result.cmdCode = data;
                        }
                        cc(result);
                    };
                    if (_this.shell && Platform.isWindows) {
                        var options = Objects.deepClone(_this.options);
                        options.windowsVerbatimArguments = true;
                        options.detached = false;
                        var quotedCommand = false;
                        var quotedArg_1 = false;
                        var commandLine_1 = [];
                        var quoted_1 = _this.ensureQuotes(_this.cmd);
                        commandLine_1.push(quoted_1.value);
                        quotedCommand = quoted_1.quoted;
                        if (_this.args) {
                            _this.args.forEach(function (elem) {
                                quoted_1 = _this.ensureQuotes(elem);
                                commandLine_1.push(quoted_1.value);
                                quotedArg_1 = quotedArg_1 && quoted_1.quoted;
                            });
                        }
                        var args = [
                            '/s',
                            '/c',
                        ];
                        if (quotedCommand) {
                            if (quotedArg_1) {
                                args.push('"' + commandLine_1.join(' ') + '"');
                            }
                            else if (commandLine_1.length > 1) {
                                args.push('"' + commandLine_1[0] + '"' + ' ' + commandLine_1.slice(1).join(' '));
                            }
                            else {
                                args.push('"' + commandLine_1[0] + '"');
                            }
                        }
                        else {
                            args.push(commandLine_1.join(' '));
                        }
                        childProcess = cp.spawn(getWindowsShell(), args, options);
                    }
                    else {
                        if (_this.cmd) {
                            childProcess = cp.spawn(_this.cmd, _this.args, _this.options);
                        }
                        else if (_this.module) {
                            _this.childProcessPromise = new winjs_base_1.TPromise(function (c, e) {
                                stdFork_1.fork(_this.module, _this.args, _this.options, function (error, childProcess) {
                                    if (error) {
                                        e(error);
                                        ee({ terminated: _this.terminateRequested, error: error });
                                        return;
                                    }
                                    _this.childProcess = childProcess;
                                    if (_this.pidResolve) {
                                        _this.pidResolve(Types.isNumber(childProcess.pid) ? childProcess.pid : -1);
                                        _this.pidResolve = undefined;
                                    }
                                    _this.childProcess.on('close', closeHandler_1);
                                    _this.handleSpawn(childProcess, cc, pp, ee, false);
                                    c(childProcess);
                                });
                            });
                        }
                    }
                    if (childProcess) {
                        _this.childProcess = childProcess;
                        _this.childProcessPromise = winjs_base_1.TPromise.as(childProcess);
                        if (_this.pidResolve) {
                            _this.pidResolve(Types.isNumber(childProcess.pid) ? childProcess.pid : -1);
                            _this.pidResolve = undefined;
                        }
                        childProcess.on('error', function (error) {
                            _this.childProcess = null;
                            ee({ terminated: _this.terminateRequested, error: error });
                        });
                        if (childProcess.pid) {
                            _this.childProcess.on('close', closeHandler_1);
                            _this.handleSpawn(childProcess, cc, pp, ee, true);
                        }
                    }
                }
                return result;
            });
        };
        AbstractProcess.prototype.handleClose = function (data, cc, pp, ee) {
            // Default is to do nothing.
        };
        AbstractProcess.prototype.ensureQuotes = function (value) {
            if (AbstractProcess.regexp.test(value)) {
                return {
                    value: '"' + value + '"',
                    quoted: true
                };
            }
            else {
                return {
                    value: value,
                    quoted: value.length > 0 && value[0] === '"' && value[value.length - 1] === '"'
                };
            }
        };
        Object.defineProperty(AbstractProcess.prototype, "pid", {
            get: function () {
                var _this = this;
                if (this.childProcessPromise) {
                    return this.childProcessPromise.then(function (childProcess) { return childProcess.pid; }, function (err) { return -1; });
                }
                else {
                    return new winjs_base_1.TPromise(function (resolve) {
                        _this.pidResolve = resolve;
                    });
                }
            },
            enumerable: true,
            configurable: true
        });
        AbstractProcess.prototype.terminate = function () {
            var _this = this;
            if (!this.childProcessPromise) {
                return winjs_base_1.TPromise.as({ success: true });
            }
            return this.childProcessPromise.then(function (childProcess) {
                _this.terminateRequested = true;
                var result = terminateProcess(childProcess, _this.options.cwd);
                if (result.success) {
                    _this.childProcess = null;
                }
                return result;
            }, function (err) {
                return { success: true };
            });
        };
        AbstractProcess.prototype.useExec = function () {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e) {
                if (!_this.shell || !Platform.isWindows) {
                    c(false);
                }
                var cmdShell = cp.spawn(getWindowsShell(), ['/s', '/c']);
                cmdShell.on('error', function (error) {
                    c(true);
                });
                cmdShell.on('exit', function (data) {
                    c(false);
                });
            });
        };
        AbstractProcess.WellKnowCommands = {
            'ant': true,
            'cmake': true,
            'eslint': true,
            'gradle': true,
            'grunt': true,
            'gulp': true,
            'jake': true,
            'jenkins': true,
            'jshint': true,
            'make': true,
            'maven': true,
            'msbuild': true,
            'msc': true,
            'nmake': true,
            'npm': true,
            'rake': true,
            'tsc': true,
            'xbuild': true
        };
        AbstractProcess.regexp = /^[^"].* .*[^"]/;
        return AbstractProcess;
    }());
    exports.AbstractProcess = AbstractProcess;
    var LineProcess = /** @class */ (function (_super) {
        __extends(LineProcess, _super);
        function LineProcess(arg1, arg2, arg3, arg4) {
            return _super.call(this, arg1, arg2, arg3, arg4) || this;
        }
        LineProcess.prototype.handleExec = function (cc, pp, error, stdout, stderr) {
            [stdout, stderr].forEach(function (buffer, index) {
                var lineDecoder = new decoder_1.LineDecoder();
                var lines = lineDecoder.write(buffer);
                lines.forEach(function (line) {
                    pp({ line: line, source: index === 0 ? processes_1.Source.stdout : processes_1.Source.stderr });
                });
                var line = lineDecoder.end();
                if (line) {
                    pp({ line: line, source: index === 0 ? processes_1.Source.stdout : processes_1.Source.stderr });
                }
            });
            cc({ terminated: this.terminateRequested, error: error });
        };
        LineProcess.prototype.handleSpawn = function (childProcess, cc, pp, ee, sync) {
            var _this = this;
            this.stdoutLineDecoder = new decoder_1.LineDecoder();
            this.stderrLineDecoder = new decoder_1.LineDecoder();
            childProcess.stdout.on('data', function (data) {
                var lines = _this.stdoutLineDecoder.write(data);
                lines.forEach(function (line) { return pp({ line: line, source: processes_1.Source.stdout }); });
            });
            childProcess.stderr.on('data', function (data) {
                var lines = _this.stderrLineDecoder.write(data);
                lines.forEach(function (line) { return pp({ line: line, source: processes_1.Source.stderr }); });
            });
        };
        LineProcess.prototype.handleClose = function (data, cc, pp, ee) {
            [this.stdoutLineDecoder.end(), this.stderrLineDecoder.end()].forEach(function (line, index) {
                if (line) {
                    pp({ line: line, source: index === 0 ? processes_1.Source.stdout : processes_1.Source.stderr });
                }
            });
        };
        return LineProcess;
    }(AbstractProcess));
    exports.LineProcess = LineProcess;
    // Wrapper around process.send() that will queue any messages if the internal node.js
    // queue is filled with messages and only continue sending messages when the internal
    // queue is free again to consume messages.
    // On Windows we always wait for the send() method to return before sending the next message
    // to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)
    function createQueuedSender(childProcess) {
        var msgQueue = [];
        var useQueue = false;
        var send = function (msg) {
            if (useQueue) {
                msgQueue.push(msg); // add to the queue if the process cannot handle more messages
                return;
            }
            var result = childProcess.send(msg, function (error) {
                if (error) {
                    console.error(error); // unlikely to happen, best we can do is log this error
                }
                useQueue = false; // we are good again to send directly without queue
                // now send all the messages that we have in our queue and did not send yet
                if (msgQueue.length > 0) {
                    var msgQueueCopy = msgQueue.slice(0);
                    msgQueue = [];
                    msgQueueCopy.forEach(function (entry) { return send(entry); });
                }
            });
            if (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {
                useQueue = true;
            }
        };
        return { send: send };
    }
    exports.createQueuedSender = createQueuedSender;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[100/*vs/base/parts/ipc/node/ipc.cp*/], __M([0/*require*/,1/*exports*/,50/*child_process*/,9/*vs/base/common/lifecycle*/,2/*vs/base/common/winjs.base*/,12/*vs/base/common/async*/,20/*vs/base/common/objects*/,3/*vs/base/common/event*/,99/*vs/base/node/processes*/,53/*vs/base/parts/ipc/common/ipc*/,125/*vs/base/node/console*/]), function (require, exports, child_process_1, lifecycle_1, winjs_base_1, async_1, objects_1, event_1, processes_1, ipc_1, console_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Server = /** @class */ (function (_super) {
        __extends(Server, _super);
        function Server() {
            var _this = _super.call(this, {
                send: function (r) { try {
                    process.send(r);
                }
                catch (e) { /* not much to do */ } },
                onMessage: event_1.fromNodeEventEmitter(process, 'message', function (msg) { return msg; })
            }) || this;
            process.once('disconnect', function () { return _this.dispose(); });
            return _this;
        }
        return Server;
    }(ipc_1.ChannelServer));
    exports.Server = Server;
    var Client = /** @class */ (function () {
        function Client(modulePath, options) {
            this.modulePath = modulePath;
            this.options = options;
            this._onDidProcessExit = new event_1.Emitter();
            this.onDidProcessExit = this._onDidProcessExit.event;
            var timeout = options && options.timeout ? options.timeout : 60000;
            this.disposeDelayer = new async_1.Delayer(timeout);
            this.activeRequests = [];
            this.child = null;
            this._client = null;
            this.channels = Object.create(null);
        }
        Client.prototype.getChannel = function (channelName) {
            var _this = this;
            var call = function (command, arg) { return _this.requestPromise(channelName, command, arg); };
            var listen = function (event, arg) { return _this.requestEvent(channelName, event, arg); };
            return { call: call, listen: listen };
        };
        Client.prototype.requestPromise = function (channelName, name, arg) {
            var _this = this;
            if (!this.disposeDelayer) {
                return winjs_base_1.TPromise.wrapError(new Error('disposed'));
            }
            this.disposeDelayer.cancel();
            var channel = this.channels[channelName] || (this.channels[channelName] = this.client.getChannel(channelName));
            var request = channel.call(name, arg);
            // Progress doesn't propagate across 'then', we need to create a promise wrapper
            var result = new winjs_base_1.TPromise(function (c, e, p) {
                request.then(c, e, p).done(function () {
                    if (!_this.activeRequests) {
                        return;
                    }
                    _this.activeRequests.splice(_this.activeRequests.indexOf(disposable), 1);
                    if (_this.activeRequests.length === 0) {
                        _this.disposeDelayer.trigger(function () { return _this.disposeClient(); });
                    }
                });
            }, function () { return request.cancel(); });
            var disposable = lifecycle_1.toDisposable(function () { return result.cancel(); });
            this.activeRequests.push(disposable);
            return result;
        };
        Client.prototype.requestEvent = function (channelName, name, arg) {
            var _this = this;
            if (!this.disposeDelayer) {
                return event_1.Event.None;
            }
            this.disposeDelayer.cancel();
            var listener;
            var emitter = new event_1.Emitter({
                onFirstListenerAdd: function () {
                    var channel = _this.channels[channelName] || (_this.channels[channelName] = _this.client.getChannel(channelName));
                    var event = channel.listen(name, arg);
                    listener = event(emitter.fire, emitter);
                    _this.activeRequests.push(listener);
                },
                onLastListenerRemove: function () {
                    if (!_this.activeRequests) {
                        return;
                    }
                    _this.activeRequests.splice(_this.activeRequests.indexOf(listener), 1);
                    listener.dispose();
                    if (_this.activeRequests.length === 0) {
                        _this.disposeDelayer.trigger(function () { return _this.disposeClient(); });
                    }
                }
            });
            return emitter.event;
        };
        Object.defineProperty(Client.prototype, "client", {
            get: function () {
                var _this = this;
                if (!this._client) {
                    var args = this.options && this.options.args ? this.options.args : [];
                    var forkOpts = Object.create(null);
                    forkOpts.env = objects_1.assign(objects_1.deepClone(process.env), { 'VSCODE_PARENT_PID': String(process.pid) });
                    if (this.options && this.options.env) {
                        forkOpts.env = objects_1.assign(forkOpts.env, this.options.env);
                    }
                    if (this.options && this.options.freshExecArgv) {
                        forkOpts.execArgv = [];
                    }
                    if (this.options && typeof this.options.debug === 'number') {
                        forkOpts.execArgv = ['--nolazy', '--inspect=' + this.options.debug];
                    }
                    if (this.options && typeof this.options.debugBrk === 'number') {
                        forkOpts.execArgv = ['--nolazy', '--inspect-brk=' + this.options.debugBrk];
                    }
                    this.child = child_process_1.fork(this.modulePath, args, forkOpts);
                    var onMessageEmitter_1 = new event_1.Emitter();
                    var onRawMessage = event_1.fromNodeEventEmitter(this.child, 'message', function (msg) { return msg; });
                    onRawMessage(function (msg) {
                        // Handle remote console logs specially
                        if (console_1.isRemoteConsoleLog(msg)) {
                            console_1.log(msg, "IPC Library: " + _this.options.serverName);
                            return null;
                        }
                        // Anything else goes to the outside
                        onMessageEmitter_1.fire(msg);
                    });
                    var sender_1 = this.options.useQueue ? processes_1.createQueuedSender(this.child) : this.child;
                    var send = function (r) { return _this.child && _this.child.connected && sender_1.send(r); };
                    var onMessage = onMessageEmitter_1.event;
                    var protocol = { send: send, onMessage: onMessage };
                    this._client = new ipc_1.ChannelClient(protocol);
                    var onExit_1 = function () { return _this.disposeClient(); };
                    process.once('exit', onExit_1);
                    this.child.on('error', function (err) { return console.warn('IPC "' + _this.options.serverName + '" errored with ' + err); });
                    this.child.on('exit', function (code, signal) {
                        process.removeListener('exit', onExit_1);
                        if (_this.activeRequests) {
                            _this.activeRequests = lifecycle_1.dispose(_this.activeRequests);
                        }
                        if (code !== 0 && signal !== 'SIGTERM') {
                            console.warn('IPC "' + _this.options.serverName + '" crashed with exit code ' + code + ' and signal ' + signal);
                            _this.disposeDelayer.cancel();
                            _this.disposeClient();
                        }
                        _this._onDidProcessExit.fire({ code: code, signal: signal });
                    });
                }
                return this._client;
            },
            enumerable: true,
            configurable: true
        });
        Client.prototype.disposeClient = function () {
            if (this._client) {
                this.child.kill();
                this.child = null;
                this._client = null;
                this.channels = Object.create(null);
            }
        };
        Client.prototype.dispose = function () {
            this._onDidProcessExit.dispose();
            this.disposeDelayer.cancel();
            this.disposeDelayer = null;
            this.disposeClient();
            this.activeRequests = null;
        };
        return Client;
    }());
    exports.Client = Client;
});

define(__m[101/*vs/nls!vs/editor/common/config/editorOptions*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/editor/common/config/editorOptions", data); });
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
define(__m[83/*vs/editor/common/config/editorOptions*/], __M([0/*require*/,1/*exports*/,101/*vs/nls!vs/editor/common/config/editorOptions*/,10/*vs/base/common/platform*/,121/*vs/base/common/scrollable*/,41/*vs/editor/common/model/wordHelper*/,13/*vs/base/common/arrays*/,20/*vs/base/common/objects*/]), function (require, exports, nls, platform, scrollable_1, wordHelper_1, arrays, objects) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RenderMinimap;
    (function (RenderMinimap) {
        RenderMinimap[RenderMinimap["None"] = 0] = "None";
        RenderMinimap[RenderMinimap["Small"] = 1] = "Small";
        RenderMinimap[RenderMinimap["Large"] = 2] = "Large";
        RenderMinimap[RenderMinimap["SmallBlocks"] = 3] = "SmallBlocks";
        RenderMinimap[RenderMinimap["LargeBlocks"] = 4] = "LargeBlocks";
    })(RenderMinimap = exports.RenderMinimap || (exports.RenderMinimap = {}));
    /**
     * Describes how to indent wrapped lines.
     */
    var WrappingIndent;
    (function (WrappingIndent) {
        /**
         * No indentation => wrapped lines begin at column 1.
         */
        WrappingIndent[WrappingIndent["None"] = 0] = "None";
        /**
         * Same => wrapped lines get the same indentation as the parent.
         */
        WrappingIndent[WrappingIndent["Same"] = 1] = "Same";
        /**
         * Indent => wrapped lines get +1 indentation toward the parent.
         */
        WrappingIndent[WrappingIndent["Indent"] = 2] = "Indent";
        /**
         * DeepIndent => wrapped lines get +2 indentation toward the parent.
         */
        WrappingIndent[WrappingIndent["DeepIndent"] = 3] = "DeepIndent";
    })(WrappingIndent = exports.WrappingIndent || (exports.WrappingIndent = {}));
    /**
     * The kind of animation in which the editor's cursor should be rendered.
     */
    var TextEditorCursorBlinkingStyle;
    (function (TextEditorCursorBlinkingStyle) {
        /**
         * Hidden
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Hidden"] = 0] = "Hidden";
        /**
         * Blinking
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Blink"] = 1] = "Blink";
        /**
         * Blinking with smooth fading
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Smooth"] = 2] = "Smooth";
        /**
         * Blinking with prolonged filled state and smooth fading
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Phase"] = 3] = "Phase";
        /**
         * Expand collapse animation on the y axis
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Expand"] = 4] = "Expand";
        /**
         * No-Blinking
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Solid"] = 5] = "Solid";
    })(TextEditorCursorBlinkingStyle = exports.TextEditorCursorBlinkingStyle || (exports.TextEditorCursorBlinkingStyle = {}));
    /**
     * @internal
     */
    function blinkingStyleToString(blinkingStyle) {
        if (blinkingStyle === TextEditorCursorBlinkingStyle.Blink) {
            return 'blink';
        }
        else if (blinkingStyle === TextEditorCursorBlinkingStyle.Expand) {
            return 'expand';
        }
        else if (blinkingStyle === TextEditorCursorBlinkingStyle.Phase) {
            return 'phase';
        }
        else if (blinkingStyle === TextEditorCursorBlinkingStyle.Smooth) {
            return 'smooth';
        }
        else if (blinkingStyle === TextEditorCursorBlinkingStyle.Solid) {
            return 'solid';
        }
        else {
            throw new Error('blinkingStyleToString: Unknown blinkingStyle');
        }
    }
    exports.blinkingStyleToString = blinkingStyleToString;
    /**
     * The style in which the editor's cursor should be rendered.
     */
    var TextEditorCursorStyle;
    (function (TextEditorCursorStyle) {
        /**
         * As a vertical line (sitting between two characters).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
        /**
         * As a block (sitting on top of a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
        /**
         * As a horizontal line (sitting under a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
        /**
         * As a thin vertical line (sitting between two characters).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["LineThin"] = 4] = "LineThin";
        /**
         * As an outlined block (sitting on top of a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["BlockOutline"] = 5] = "BlockOutline";
        /**
         * As a thin horizontal line (sitting under a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
    })(TextEditorCursorStyle = exports.TextEditorCursorStyle || (exports.TextEditorCursorStyle = {}));
    /**
     * @internal
     */
    function cursorStyleToString(cursorStyle) {
        if (cursorStyle === TextEditorCursorStyle.Line) {
            return 'line';
        }
        else if (cursorStyle === TextEditorCursorStyle.Block) {
            return 'block';
        }
        else if (cursorStyle === TextEditorCursorStyle.Underline) {
            return 'underline';
        }
        else if (cursorStyle === TextEditorCursorStyle.LineThin) {
            return 'line-thin';
        }
        else if (cursorStyle === TextEditorCursorStyle.BlockOutline) {
            return 'block-outline';
        }
        else if (cursorStyle === TextEditorCursorStyle.UnderlineThin) {
            return 'underline-thin';
        }
        else {
            throw new Error('cursorStyleToString: Unknown cursorStyle');
        }
    }
    exports.cursorStyleToString = cursorStyleToString;
    function _cursorStyleFromString(cursorStyle, defaultValue) {
        if (typeof cursorStyle !== 'string') {
            return defaultValue;
        }
        if (cursorStyle === 'line') {
            return TextEditorCursorStyle.Line;
        }
        else if (cursorStyle === 'block') {
            return TextEditorCursorStyle.Block;
        }
        else if (cursorStyle === 'underline') {
            return TextEditorCursorStyle.Underline;
        }
        else if (cursorStyle === 'line-thin') {
            return TextEditorCursorStyle.LineThin;
        }
        else if (cursorStyle === 'block-outline') {
            return TextEditorCursorStyle.BlockOutline;
        }
        else if (cursorStyle === 'underline-thin') {
            return TextEditorCursorStyle.UnderlineThin;
        }
        return TextEditorCursorStyle.Line;
    }
    var RenderLineNumbersType;
    (function (RenderLineNumbersType) {
        RenderLineNumbersType[RenderLineNumbersType["Off"] = 0] = "Off";
        RenderLineNumbersType[RenderLineNumbersType["On"] = 1] = "On";
        RenderLineNumbersType[RenderLineNumbersType["Relative"] = 2] = "Relative";
        RenderLineNumbersType[RenderLineNumbersType["Interval"] = 3] = "Interval";
        RenderLineNumbersType[RenderLineNumbersType["Custom"] = 4] = "Custom";
    })(RenderLineNumbersType = exports.RenderLineNumbersType || (exports.RenderLineNumbersType = {}));
    /**
     * Internal configuration options (transformed or computed) for the editor.
     */
    var InternalEditorOptions = /** @class */ (function () {
        /**
         * @internal
         */
        function InternalEditorOptions(source) {
            this.canUseLayerHinting = source.canUseLayerHinting;
            this.pixelRatio = source.pixelRatio;
            this.editorClassName = source.editorClassName;
            this.lineHeight = source.lineHeight | 0;
            this.readOnly = source.readOnly;
            this.accessibilitySupport = source.accessibilitySupport;
            this.multiCursorModifier = source.multiCursorModifier;
            this.multiCursorMergeOverlapping = source.multiCursorMergeOverlapping;
            this.wordSeparators = source.wordSeparators;
            this.autoClosingBrackets = source.autoClosingBrackets;
            this.autoIndent = source.autoIndent;
            this.useTabStops = source.useTabStops;
            this.tabFocusMode = source.tabFocusMode;
            this.dragAndDrop = source.dragAndDrop;
            this.emptySelectionClipboard = source.emptySelectionClipboard;
            this.layoutInfo = source.layoutInfo;
            this.fontInfo = source.fontInfo;
            this.viewInfo = source.viewInfo;
            this.wrappingInfo = source.wrappingInfo;
            this.contribInfo = source.contribInfo;
            this.showUnused = source.showUnused;
        }
        /**
         * @internal
         */
        InternalEditorOptions.prototype.equals = function (other) {
            return (this.canUseLayerHinting === other.canUseLayerHinting
                && this.pixelRatio === other.pixelRatio
                && this.editorClassName === other.editorClassName
                && this.lineHeight === other.lineHeight
                && this.readOnly === other.readOnly
                && this.accessibilitySupport === other.accessibilitySupport
                && this.multiCursorModifier === other.multiCursorModifier
                && this.multiCursorMergeOverlapping === other.multiCursorMergeOverlapping
                && this.wordSeparators === other.wordSeparators
                && this.autoClosingBrackets === other.autoClosingBrackets
                && this.autoIndent === other.autoIndent
                && this.useTabStops === other.useTabStops
                && this.tabFocusMode === other.tabFocusMode
                && this.dragAndDrop === other.dragAndDrop
                && this.showUnused === other.showUnused
                && this.emptySelectionClipboard === other.emptySelectionClipboard
                && InternalEditorOptions._equalsLayoutInfo(this.layoutInfo, other.layoutInfo)
                && this.fontInfo.equals(other.fontInfo)
                && InternalEditorOptions._equalsViewOptions(this.viewInfo, other.viewInfo)
                && InternalEditorOptions._equalsWrappingInfo(this.wrappingInfo, other.wrappingInfo)
                && InternalEditorOptions._equalsContribOptions(this.contribInfo, other.contribInfo));
        };
        /**
         * @internal
         */
        InternalEditorOptions.prototype.createChangeEvent = function (newOpts) {
            return {
                canUseLayerHinting: (this.canUseLayerHinting !== newOpts.canUseLayerHinting),
                pixelRatio: (this.pixelRatio !== newOpts.pixelRatio),
                editorClassName: (this.editorClassName !== newOpts.editorClassName),
                lineHeight: (this.lineHeight !== newOpts.lineHeight),
                readOnly: (this.readOnly !== newOpts.readOnly),
                accessibilitySupport: (this.accessibilitySupport !== newOpts.accessibilitySupport),
                multiCursorModifier: (this.multiCursorModifier !== newOpts.multiCursorModifier),
                multiCursorMergeOverlapping: (this.multiCursorMergeOverlapping !== newOpts.multiCursorMergeOverlapping),
                wordSeparators: (this.wordSeparators !== newOpts.wordSeparators),
                autoClosingBrackets: (this.autoClosingBrackets !== newOpts.autoClosingBrackets),
                autoIndent: (this.autoIndent !== newOpts.autoIndent),
                useTabStops: (this.useTabStops !== newOpts.useTabStops),
                tabFocusMode: (this.tabFocusMode !== newOpts.tabFocusMode),
                dragAndDrop: (this.dragAndDrop !== newOpts.dragAndDrop),
                emptySelectionClipboard: (this.emptySelectionClipboard !== newOpts.emptySelectionClipboard),
                layoutInfo: (!InternalEditorOptions._equalsLayoutInfo(this.layoutInfo, newOpts.layoutInfo)),
                fontInfo: (!this.fontInfo.equals(newOpts.fontInfo)),
                viewInfo: (!InternalEditorOptions._equalsViewOptions(this.viewInfo, newOpts.viewInfo)),
                wrappingInfo: (!InternalEditorOptions._equalsWrappingInfo(this.wrappingInfo, newOpts.wrappingInfo)),
                contribInfo: (!InternalEditorOptions._equalsContribOptions(this.contribInfo, newOpts.contribInfo))
            };
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsLayoutInfo = function (a, b) {
            return (a.width === b.width
                && a.height === b.height
                && a.glyphMarginLeft === b.glyphMarginLeft
                && a.glyphMarginWidth === b.glyphMarginWidth
                && a.glyphMarginHeight === b.glyphMarginHeight
                && a.lineNumbersLeft === b.lineNumbersLeft
                && a.lineNumbersWidth === b.lineNumbersWidth
                && a.lineNumbersHeight === b.lineNumbersHeight
                && a.decorationsLeft === b.decorationsLeft
                && a.decorationsWidth === b.decorationsWidth
                && a.decorationsHeight === b.decorationsHeight
                && a.contentLeft === b.contentLeft
                && a.contentWidth === b.contentWidth
                && a.contentHeight === b.contentHeight
                && a.renderMinimap === b.renderMinimap
                && a.minimapLeft === b.minimapLeft
                && a.minimapWidth === b.minimapWidth
                && a.viewportColumn === b.viewportColumn
                && a.verticalScrollbarWidth === b.verticalScrollbarWidth
                && a.horizontalScrollbarHeight === b.horizontalScrollbarHeight
                && this._equalsOverviewRuler(a.overviewRuler, b.overviewRuler));
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsOverviewRuler = function (a, b) {
            return (a.width === b.width
                && a.height === b.height
                && a.top === b.top
                && a.right === b.right);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsViewOptions = function (a, b) {
            return (a.extraEditorClassName === b.extraEditorClassName
                && a.disableMonospaceOptimizations === b.disableMonospaceOptimizations
                && arrays.equals(a.rulers, b.rulers)
                && a.ariaLabel === b.ariaLabel
                && a.renderLineNumbers === b.renderLineNumbers
                && a.renderCustomLineNumbers === b.renderCustomLineNumbers
                && a.selectOnLineNumbers === b.selectOnLineNumbers
                && a.glyphMargin === b.glyphMargin
                && a.revealHorizontalRightPadding === b.revealHorizontalRightPadding
                && a.roundedSelection === b.roundedSelection
                && a.overviewRulerLanes === b.overviewRulerLanes
                && a.overviewRulerBorder === b.overviewRulerBorder
                && a.cursorBlinking === b.cursorBlinking
                && a.mouseWheelZoom === b.mouseWheelZoom
                && a.cursorStyle === b.cursorStyle
                && a.cursorWidth === b.cursorWidth
                && a.hideCursorInOverviewRuler === b.hideCursorInOverviewRuler
                && a.scrollBeyondLastLine === b.scrollBeyondLastLine
                && a.scrollBeyondLastColumn === b.scrollBeyondLastColumn
                && a.smoothScrolling === b.smoothScrolling
                && a.stopRenderingLineAfter === b.stopRenderingLineAfter
                && a.renderWhitespace === b.renderWhitespace
                && a.renderControlCharacters === b.renderControlCharacters
                && a.fontLigatures === b.fontLigatures
                && a.renderIndentGuides === b.renderIndentGuides
                && a.highlightActiveIndentGuide === b.highlightActiveIndentGuide
                && a.renderLineHighlight === b.renderLineHighlight
                && this._equalsScrollbarOptions(a.scrollbar, b.scrollbar)
                && this._equalsMinimapOptions(a.minimap, b.minimap)
                && a.fixedOverflowWidgets === b.fixedOverflowWidgets);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsScrollbarOptions = function (a, b) {
            return (a.arrowSize === b.arrowSize
                && a.vertical === b.vertical
                && a.horizontal === b.horizontal
                && a.useShadows === b.useShadows
                && a.verticalHasArrows === b.verticalHasArrows
                && a.horizontalHasArrows === b.horizontalHasArrows
                && a.handleMouseWheel === b.handleMouseWheel
                && a.horizontalScrollbarSize === b.horizontalScrollbarSize
                && a.horizontalSliderSize === b.horizontalSliderSize
                && a.verticalScrollbarSize === b.verticalScrollbarSize
                && a.verticalSliderSize === b.verticalSliderSize
                && a.mouseWheelScrollSensitivity === b.mouseWheelScrollSensitivity);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsMinimapOptions = function (a, b) {
            return (a.enabled === b.enabled
                && a.side === b.side
                && a.showSlider === b.showSlider
                && a.renderCharacters === b.renderCharacters
                && a.maxColumn === b.maxColumn);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalFindOptions = function (a, b) {
            return (a.seedSearchStringFromSelection === b.seedSearchStringFromSelection
                && a.autoFindInSelection === b.autoFindInSelection
                && a.globalFindClipboard === b.globalFindClipboard);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsHoverOptions = function (a, b) {
            return (a.enabled === b.enabled
                && a.delay === b.delay
                && a.sticky === b.sticky);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsSuggestOptions = function (a, b) {
            if (a === b) {
                return true;
            }
            else if (!a || !b) {
                return false;
            }
            else {
                return a.filterGraceful === b.filterGraceful
                    && a.snippets === b.snippets
                    && a.snippetsPreventQuickSuggestions === b.snippetsPreventQuickSuggestions;
            }
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsWrappingInfo = function (a, b) {
            return (a.inDiffEditor === b.inDiffEditor
                && a.isDominatedByLongLines === b.isDominatedByLongLines
                && a.isWordWrapMinified === b.isWordWrapMinified
                && a.isViewportWrapping === b.isViewportWrapping
                && a.wrappingColumn === b.wrappingColumn
                && a.wrappingIndent === b.wrappingIndent
                && a.wordWrapBreakBeforeCharacters === b.wordWrapBreakBeforeCharacters
                && a.wordWrapBreakAfterCharacters === b.wordWrapBreakAfterCharacters
                && a.wordWrapBreakObtrusiveCharacters === b.wordWrapBreakObtrusiveCharacters);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsContribOptions = function (a, b) {
            return (a.selectionClipboard === b.selectionClipboard
                && this._equalsHoverOptions(a.hover, b.hover)
                && a.links === b.links
                && a.contextmenu === b.contextmenu
                && InternalEditorOptions._equalsQuickSuggestions(a.quickSuggestions, b.quickSuggestions)
                && a.quickSuggestionsDelay === b.quickSuggestionsDelay
                && a.parameterHints === b.parameterHints
                && a.iconsInSuggestions === b.iconsInSuggestions
                && a.formatOnType === b.formatOnType
                && a.formatOnPaste === b.formatOnPaste
                && a.suggestOnTriggerCharacters === b.suggestOnTriggerCharacters
                && a.acceptSuggestionOnEnter === b.acceptSuggestionOnEnter
                && a.acceptSuggestionOnCommitCharacter === b.acceptSuggestionOnCommitCharacter
                && a.wordBasedSuggestions === b.wordBasedSuggestions
                && a.suggestSelection === b.suggestSelection
                && a.suggestFontSize === b.suggestFontSize
                && a.suggestLineHeight === b.suggestLineHeight
                && this._equalsSuggestOptions(a.suggest, b.suggest)
                && a.selectionHighlight === b.selectionHighlight
                && a.occurrencesHighlight === b.occurrencesHighlight
                && a.codeLens === b.codeLens
                && a.folding === b.folding
                && a.foldingStrategy === b.foldingStrategy
                && a.showFoldingControls === b.showFoldingControls
                && a.matchBrackets === b.matchBrackets
                && this._equalFindOptions(a.find, b.find)
                && a.colorDecorators === b.colorDecorators
                && objects.equals(a.codeActionsOnSave, b.codeActionsOnSave)
                && a.codeActionsOnSaveTimeout === b.codeActionsOnSaveTimeout
                && a.lightbulbEnabled === b.lightbulbEnabled);
        };
        InternalEditorOptions._equalsQuickSuggestions = function (a, b) {
            if (typeof a === 'boolean') {
                if (typeof b !== 'boolean') {
                    return false;
                }
                return a === b;
            }
            if (typeof b === 'boolean') {
                return false;
            }
            return (a.comments === b.comments
                && a.other === b.other
                && a.strings === b.strings);
        };
        return InternalEditorOptions;
    }());
    exports.InternalEditorOptions = InternalEditorOptions;
    function _boolean(value, defaultValue) {
        if (typeof value === 'undefined') {
            return defaultValue;
        }
        if (value === 'false') {
            // treat the string 'false' as false
            return false;
        }
        return Boolean(value);
    }
    function _booleanMap(value, defaultValue) {
        if (!value) {
            return defaultValue;
        }
        var out = Object.create(null);
        for (var _i = 0, _a = Object.keys(value); _i < _a.length; _i++) {
            var k = _a[_i];
            var v = value[k];
            if (typeof v === 'boolean') {
                out[k] = v;
            }
        }
        return out;
    }
    function _string(value, defaultValue) {
        if (typeof value !== 'string') {
            return defaultValue;
        }
        return value;
    }
    function _stringSet(value, defaultValue, allowedValues) {
        if (typeof value !== 'string') {
            return defaultValue;
        }
        if (allowedValues.indexOf(value) === -1) {
            return defaultValue;
        }
        return value;
    }
    function _clampedInt(value, defaultValue, minimum, maximum) {
        var r;
        if (typeof value === 'undefined') {
            r = defaultValue;
        }
        else {
            r = parseInt(value, 10);
            if (isNaN(r)) {
                r = defaultValue;
            }
        }
        r = Math.max(minimum, r);
        r = Math.min(maximum, r);
        return r | 0;
    }
    function _float(value, defaultValue) {
        var r = parseFloat(value);
        if (isNaN(r)) {
            r = defaultValue;
        }
        return r;
    }
    function _wrappingIndentFromString(wrappingIndent, defaultValue) {
        if (typeof wrappingIndent !== 'string') {
            return defaultValue;
        }
        if (wrappingIndent === 'same') {
            return WrappingIndent.Same;
        }
        else if (wrappingIndent === 'indent') {
            return WrappingIndent.Indent;
        }
        else if (wrappingIndent === 'deepIndent') {
            return WrappingIndent.DeepIndent;
        }
        else {
            return WrappingIndent.None;
        }
    }
    function _cursorBlinkingStyleFromString(cursorBlinkingStyle, defaultValue) {
        if (typeof cursorBlinkingStyle !== 'string') {
            return defaultValue;
        }
        switch (cursorBlinkingStyle) {
            case 'blink':
                return TextEditorCursorBlinkingStyle.Blink;
            case 'smooth':
                return TextEditorCursorBlinkingStyle.Smooth;
            case 'phase':
                return TextEditorCursorBlinkingStyle.Phase;
            case 'expand':
                return TextEditorCursorBlinkingStyle.Expand;
            case 'visible': // maintain compatibility
            case 'solid':
                return TextEditorCursorBlinkingStyle.Solid;
        }
        return TextEditorCursorBlinkingStyle.Blink;
    }
    function _scrollbarVisibilityFromString(visibility, defaultValue) {
        if (typeof visibility !== 'string') {
            return defaultValue;
        }
        switch (visibility) {
            case 'hidden':
                return scrollable_1.ScrollbarVisibility.Hidden;
            case 'visible':
                return scrollable_1.ScrollbarVisibility.Visible;
            default:
                return scrollable_1.ScrollbarVisibility.Auto;
        }
    }
    /**
     * @internal
     */
    var EditorOptionsValidator = /** @class */ (function () {
        function EditorOptionsValidator() {
        }
        /**
         * Validate raw editor options.
         * i.e. since they can be defined by the user, they might be invalid.
         */
        EditorOptionsValidator.validate = function (opts, defaults) {
            var wordWrap = opts.wordWrap;
            {
                // Compatibility with old true or false values
                if (wordWrap === true) {
                    wordWrap = 'on';
                }
                else if (wordWrap === false) {
                    wordWrap = 'off';
                }
                wordWrap = _stringSet(wordWrap, defaults.wordWrap, ['off', 'on', 'wordWrapColumn', 'bounded']);
            }
            var viewInfo = this._sanitizeViewInfo(opts, defaults.viewInfo);
            var contribInfo = this._sanitizeContribInfo(opts, defaults.contribInfo);
            var configuredMulticursorModifier;
            if (typeof opts.multiCursorModifier === 'string') {
                if (opts.multiCursorModifier === 'ctrlCmd') {
                    configuredMulticursorModifier = platform.isMacintosh ? 'metaKey' : 'ctrlKey';
                }
                else {
                    configuredMulticursorModifier = 'altKey';
                }
            }
            var multiCursorModifier = _stringSet(configuredMulticursorModifier, defaults.multiCursorModifier, ['altKey', 'metaKey', 'ctrlKey']);
            return {
                inDiffEditor: _boolean(opts.inDiffEditor, defaults.inDiffEditor),
                wordSeparators: _string(opts.wordSeparators, defaults.wordSeparators),
                lineNumbersMinChars: _clampedInt(opts.lineNumbersMinChars, defaults.lineNumbersMinChars, 1, 10),
                lineDecorationsWidth: (typeof opts.lineDecorationsWidth === 'undefined' ? defaults.lineDecorationsWidth : opts.lineDecorationsWidth),
                readOnly: _boolean(opts.readOnly, defaults.readOnly),
                mouseStyle: _stringSet(opts.mouseStyle, defaults.mouseStyle, ['text', 'default', 'copy']),
                disableLayerHinting: _boolean(opts.disableLayerHinting, defaults.disableLayerHinting),
                automaticLayout: _boolean(opts.automaticLayout, defaults.automaticLayout),
                wordWrap: wordWrap,
                wordWrapColumn: _clampedInt(opts.wordWrapColumn, defaults.wordWrapColumn, 1, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
                wordWrapMinified: _boolean(opts.wordWrapMinified, defaults.wordWrapMinified),
                wrappingIndent: _wrappingIndentFromString(opts.wrappingIndent, defaults.wrappingIndent),
                wordWrapBreakBeforeCharacters: _string(opts.wordWrapBreakBeforeCharacters, defaults.wordWrapBreakBeforeCharacters),
                wordWrapBreakAfterCharacters: _string(opts.wordWrapBreakAfterCharacters, defaults.wordWrapBreakAfterCharacters),
                wordWrapBreakObtrusiveCharacters: _string(opts.wordWrapBreakObtrusiveCharacters, defaults.wordWrapBreakObtrusiveCharacters),
                autoClosingBrackets: _boolean(opts.autoClosingBrackets, defaults.autoClosingBrackets),
                autoIndent: _boolean(opts.autoIndent, defaults.autoIndent),
                dragAndDrop: _boolean(opts.dragAndDrop, defaults.dragAndDrop),
                emptySelectionClipboard: _boolean(opts.emptySelectionClipboard, defaults.emptySelectionClipboard),
                useTabStops: _boolean(opts.useTabStops, defaults.useTabStops),
                multiCursorModifier: multiCursorModifier,
                multiCursorMergeOverlapping: _boolean(opts.multiCursorMergeOverlapping, defaults.multiCursorMergeOverlapping),
                accessibilitySupport: _stringSet(opts.accessibilitySupport, defaults.accessibilitySupport, ['auto', 'on', 'off']),
                showUnused: _boolean(opts.showUnused, defaults.showUnused),
                viewInfo: viewInfo,
                contribInfo: contribInfo,
            };
        };
        EditorOptionsValidator._sanitizeScrollbarOpts = function (opts, defaults, mouseWheelScrollSensitivity) {
            if (typeof opts !== 'object') {
                return defaults;
            }
            var horizontalScrollbarSize = _clampedInt(opts.horizontalScrollbarSize, defaults.horizontalScrollbarSize, 0, 1000);
            var verticalScrollbarSize = _clampedInt(opts.verticalScrollbarSize, defaults.verticalScrollbarSize, 0, 1000);
            return {
                vertical: _scrollbarVisibilityFromString(opts.vertical, defaults.vertical),
                horizontal: _scrollbarVisibilityFromString(opts.horizontal, defaults.horizontal),
                arrowSize: _clampedInt(opts.arrowSize, defaults.arrowSize, 0, 1000),
                useShadows: _boolean(opts.useShadows, defaults.useShadows),
                verticalHasArrows: _boolean(opts.verticalHasArrows, defaults.verticalHasArrows),
                horizontalHasArrows: _boolean(opts.horizontalHasArrows, defaults.horizontalHasArrows),
                horizontalScrollbarSize: horizontalScrollbarSize,
                horizontalSliderSize: _clampedInt(opts.horizontalSliderSize, horizontalScrollbarSize, 0, 1000),
                verticalScrollbarSize: verticalScrollbarSize,
                verticalSliderSize: _clampedInt(opts.verticalSliderSize, verticalScrollbarSize, 0, 1000),
                handleMouseWheel: _boolean(opts.handleMouseWheel, defaults.handleMouseWheel),
                mouseWheelScrollSensitivity: mouseWheelScrollSensitivity
            };
        };
        EditorOptionsValidator._sanitizeMinimapOpts = function (opts, defaults) {
            if (typeof opts !== 'object') {
                return defaults;
            }
            return {
                enabled: _boolean(opts.enabled, defaults.enabled),
                side: _stringSet(opts.side, defaults.side, ['right', 'left']),
                showSlider: _stringSet(opts.showSlider, defaults.showSlider, ['always', 'mouseover']),
                renderCharacters: _boolean(opts.renderCharacters, defaults.renderCharacters),
                maxColumn: _clampedInt(opts.maxColumn, defaults.maxColumn, 1, 10000),
            };
        };
        EditorOptionsValidator._santizeFindOpts = function (opts, defaults) {
            if (typeof opts !== 'object') {
                return defaults;
            }
            return {
                seedSearchStringFromSelection: _boolean(opts.seedSearchStringFromSelection, defaults.seedSearchStringFromSelection),
                autoFindInSelection: _boolean(opts.autoFindInSelection, defaults.autoFindInSelection),
                globalFindClipboard: _boolean(opts.globalFindClipboard, defaults.globalFindClipboard)
            };
        };
        EditorOptionsValidator._santizeHoverOpts = function (_opts, defaults) {
            var opts;
            if (typeof _opts === 'boolean') {
                opts = {
                    enabled: _opts
                };
            }
            else if (typeof _opts === 'object') {
                opts = _opts;
            }
            else {
                return defaults;
            }
            return {
                enabled: _boolean(opts.enabled, defaults.enabled),
                delay: _clampedInt(opts.delay, defaults.delay, 0, 10000),
                sticky: _boolean(opts.sticky, defaults.sticky)
            };
        };
        EditorOptionsValidator._sanitizeSuggestOpts = function (opts, defaults) {
            var suggestOpts = opts.suggest || {};
            return {
                filterGraceful: _boolean(suggestOpts.filterGraceful, defaults.filterGraceful),
                snippets: _stringSet(opts.snippetSuggestions, defaults.snippets, ['top', 'bottom', 'inline', 'none']),
                snippetsPreventQuickSuggestions: _boolean(suggestOpts.snippetsPreventQuickSuggestions, defaults.filterGraceful),
            };
        };
        EditorOptionsValidator._sanitizeViewInfo = function (opts, defaults) {
            var rulers = [];
            if (Array.isArray(opts.rulers)) {
                for (var i = 0, len = opts.rulers.length; i < len; i++) {
                    rulers.push(_clampedInt(opts.rulers[i], 0, 0, 10000));
                }
                rulers.sort();
            }
            var renderLineNumbers = defaults.renderLineNumbers;
            var renderCustomLineNumbers = defaults.renderCustomLineNumbers;
            if (typeof opts.lineNumbers !== 'undefined') {
                var lineNumbers = opts.lineNumbers;
                // Compatibility with old true or false values
                if (lineNumbers === true) {
                    lineNumbers = 'on';
                }
                else if (lineNumbers === false) {
                    lineNumbers = 'off';
                }
                if (typeof lineNumbers === 'function') {
                    renderLineNumbers = 4 /* Custom */;
                    renderCustomLineNumbers = lineNumbers;
                }
                else if (lineNumbers === 'interval') {
                    renderLineNumbers = 3 /* Interval */;
                }
                else if (lineNumbers === 'relative') {
                    renderLineNumbers = 2 /* Relative */;
                }
                else if (lineNumbers === 'on') {
                    renderLineNumbers = 1 /* On */;
                }
                else {
                    renderLineNumbers = 0 /* Off */;
                }
            }
            var fontLigatures = _boolean(opts.fontLigatures, defaults.fontLigatures);
            var disableMonospaceOptimizations = _boolean(opts.disableMonospaceOptimizations, defaults.disableMonospaceOptimizations) || fontLigatures;
            var renderWhitespace = opts.renderWhitespace;
            {
                // Compatibility with old true or false values
                if (renderWhitespace === true) {
                    renderWhitespace = 'boundary';
                }
                else if (renderWhitespace === false) {
                    renderWhitespace = 'none';
                }
                renderWhitespace = _stringSet(opts.renderWhitespace, defaults.renderWhitespace, ['none', 'boundary', 'all']);
            }
            var renderLineHighlight = opts.renderLineHighlight;
            {
                // Compatibility with old true or false values
                if (renderLineHighlight === true) {
                    renderLineHighlight = 'line';
                }
                else if (renderLineHighlight === false) {
                    renderLineHighlight = 'none';
                }
                renderLineHighlight = _stringSet(opts.renderLineHighlight, defaults.renderLineHighlight, ['none', 'gutter', 'line', 'all']);
            }
            var mouseWheelScrollSensitivity = _float(opts.mouseWheelScrollSensitivity, defaults.scrollbar.mouseWheelScrollSensitivity);
            if (mouseWheelScrollSensitivity === 0) {
                // Disallow 0, as it would prevent/block scrolling
                mouseWheelScrollSensitivity = 1;
            }
            var scrollbar = this._sanitizeScrollbarOpts(opts.scrollbar, defaults.scrollbar, mouseWheelScrollSensitivity);
            var minimap = this._sanitizeMinimapOpts(opts.minimap, defaults.minimap);
            return {
                extraEditorClassName: _string(opts.extraEditorClassName, defaults.extraEditorClassName),
                disableMonospaceOptimizations: disableMonospaceOptimizations,
                rulers: rulers,
                ariaLabel: _string(opts.ariaLabel, defaults.ariaLabel),
                renderLineNumbers: renderLineNumbers,
                renderCustomLineNumbers: renderCustomLineNumbers,
                selectOnLineNumbers: _boolean(opts.selectOnLineNumbers, defaults.selectOnLineNumbers),
                glyphMargin: _boolean(opts.glyphMargin, defaults.glyphMargin),
                revealHorizontalRightPadding: _clampedInt(opts.revealHorizontalRightPadding, defaults.revealHorizontalRightPadding, 0, 1000),
                roundedSelection: _boolean(opts.roundedSelection, defaults.roundedSelection),
                overviewRulerLanes: _clampedInt(opts.overviewRulerLanes, defaults.overviewRulerLanes, 0, 3),
                overviewRulerBorder: _boolean(opts.overviewRulerBorder, defaults.overviewRulerBorder),
                cursorBlinking: _cursorBlinkingStyleFromString(opts.cursorBlinking, defaults.cursorBlinking),
                mouseWheelZoom: _boolean(opts.mouseWheelZoom, defaults.mouseWheelZoom),
                cursorStyle: _cursorStyleFromString(opts.cursorStyle, defaults.cursorStyle),
                cursorWidth: _clampedInt(opts.cursorWidth, defaults.cursorWidth, 0, Number.MAX_VALUE),
                hideCursorInOverviewRuler: _boolean(opts.hideCursorInOverviewRuler, defaults.hideCursorInOverviewRuler),
                scrollBeyondLastLine: _boolean(opts.scrollBeyondLastLine, defaults.scrollBeyondLastLine),
                scrollBeyondLastColumn: _clampedInt(opts.scrollBeyondLastColumn, defaults.scrollBeyondLastColumn, 0, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
                smoothScrolling: _boolean(opts.smoothScrolling, defaults.smoothScrolling),
                stopRenderingLineAfter: _clampedInt(opts.stopRenderingLineAfter, defaults.stopRenderingLineAfter, -1, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
                renderWhitespace: renderWhitespace,
                renderControlCharacters: _boolean(opts.renderControlCharacters, defaults.renderControlCharacters),
                fontLigatures: fontLigatures,
                renderIndentGuides: _boolean(opts.renderIndentGuides, defaults.renderIndentGuides),
                highlightActiveIndentGuide: _boolean(opts.highlightActiveIndentGuide, defaults.highlightActiveIndentGuide),
                renderLineHighlight: renderLineHighlight,
                scrollbar: scrollbar,
                minimap: minimap,
                fixedOverflowWidgets: _boolean(opts.fixedOverflowWidgets, defaults.fixedOverflowWidgets),
            };
        };
        EditorOptionsValidator._sanitizeContribInfo = function (opts, defaults) {
            var quickSuggestions;
            if (typeof opts.quickSuggestions === 'object') {
                quickSuggestions = __assign({ other: true }, opts.quickSuggestions);
            }
            else {
                quickSuggestions = _boolean(opts.quickSuggestions, defaults.quickSuggestions);
            }
            // Compatibility support for acceptSuggestionOnEnter
            if (typeof opts.acceptSuggestionOnEnter === 'boolean') {
                opts.acceptSuggestionOnEnter = opts.acceptSuggestionOnEnter ? 'on' : 'off';
            }
            var find = this._santizeFindOpts(opts.find, defaults.find);
            return {
                selectionClipboard: _boolean(opts.selectionClipboard, defaults.selectionClipboard),
                hover: this._santizeHoverOpts(opts.hover, defaults.hover),
                links: _boolean(opts.links, defaults.links),
                contextmenu: _boolean(opts.contextmenu, defaults.contextmenu),
                quickSuggestions: quickSuggestions,
                quickSuggestionsDelay: _clampedInt(opts.quickSuggestionsDelay, defaults.quickSuggestionsDelay, -1073741824 /* MIN_SAFE_SMALL_INTEGER */, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
                parameterHints: _boolean(opts.parameterHints, defaults.parameterHints),
                iconsInSuggestions: _boolean(opts.iconsInSuggestions, defaults.iconsInSuggestions),
                formatOnType: _boolean(opts.formatOnType, defaults.formatOnType),
                formatOnPaste: _boolean(opts.formatOnPaste, defaults.formatOnPaste),
                suggestOnTriggerCharacters: _boolean(opts.suggestOnTriggerCharacters, defaults.suggestOnTriggerCharacters),
                acceptSuggestionOnEnter: _stringSet(opts.acceptSuggestionOnEnter, defaults.acceptSuggestionOnEnter, ['on', 'smart', 'off']),
                acceptSuggestionOnCommitCharacter: _boolean(opts.acceptSuggestionOnCommitCharacter, defaults.acceptSuggestionOnCommitCharacter),
                wordBasedSuggestions: _boolean(opts.wordBasedSuggestions, defaults.wordBasedSuggestions),
                suggestSelection: _stringSet(opts.suggestSelection, defaults.suggestSelection, ['first', 'recentlyUsed', 'recentlyUsedByPrefix']),
                suggestFontSize: _clampedInt(opts.suggestFontSize, defaults.suggestFontSize, 0, 1000),
                suggestLineHeight: _clampedInt(opts.suggestLineHeight, defaults.suggestLineHeight, 0, 1000),
                suggest: this._sanitizeSuggestOpts(opts, defaults.suggest),
                selectionHighlight: _boolean(opts.selectionHighlight, defaults.selectionHighlight),
                occurrencesHighlight: _boolean(opts.occurrencesHighlight, defaults.occurrencesHighlight),
                codeLens: _boolean(opts.codeLens, defaults.codeLens),
                folding: _boolean(opts.folding, defaults.folding),
                foldingStrategy: _stringSet(opts.foldingStrategy, defaults.foldingStrategy, ['auto', 'indentation']),
                showFoldingControls: _stringSet(opts.showFoldingControls, defaults.showFoldingControls, ['always', 'mouseover']),
                matchBrackets: _boolean(opts.matchBrackets, defaults.matchBrackets),
                find: find,
                colorDecorators: _boolean(opts.colorDecorators, defaults.colorDecorators),
                lightbulbEnabled: _boolean(opts.lightbulb ? opts.lightbulb.enabled : false, defaults.lightbulbEnabled),
                codeActionsOnSave: _booleanMap(opts.codeActionsOnSave, {}),
                codeActionsOnSaveTimeout: _clampedInt(opts.codeActionsOnSaveTimeout, defaults.codeActionsOnSaveTimeout, 1, 10000)
            };
        };
        return EditorOptionsValidator;
    }());
    exports.EditorOptionsValidator = EditorOptionsValidator;
    /**
     * @internal
     */
    var InternalEditorOptionsFactory = /** @class */ (function () {
        function InternalEditorOptionsFactory() {
        }
        InternalEditorOptionsFactory._tweakValidatedOptions = function (opts, accessibilitySupport) {
            var accessibilityIsOn = (accessibilitySupport === 2 /* Enabled */);
            var accessibilityIsOff = (accessibilitySupport === 1 /* Disabled */);
            return {
                inDiffEditor: opts.inDiffEditor,
                wordSeparators: opts.wordSeparators,
                lineNumbersMinChars: opts.lineNumbersMinChars,
                lineDecorationsWidth: opts.lineDecorationsWidth,
                readOnly: opts.readOnly,
                mouseStyle: opts.mouseStyle,
                disableLayerHinting: opts.disableLayerHinting,
                automaticLayout: opts.automaticLayout,
                wordWrap: opts.wordWrap,
                wordWrapColumn: opts.wordWrapColumn,
                wordWrapMinified: opts.wordWrapMinified,
                wrappingIndent: opts.wrappingIndent,
                wordWrapBreakBeforeCharacters: opts.wordWrapBreakBeforeCharacters,
                wordWrapBreakAfterCharacters: opts.wordWrapBreakAfterCharacters,
                wordWrapBreakObtrusiveCharacters: opts.wordWrapBreakObtrusiveCharacters,
                autoClosingBrackets: opts.autoClosingBrackets,
                autoIndent: opts.autoIndent,
                dragAndDrop: opts.dragAndDrop,
                emptySelectionClipboard: opts.emptySelectionClipboard,
                useTabStops: opts.useTabStops,
                multiCursorModifier: opts.multiCursorModifier,
                multiCursorMergeOverlapping: opts.multiCursorMergeOverlapping,
                accessibilitySupport: opts.accessibilitySupport,
                showUnused: opts.showUnused,
                viewInfo: {
                    extraEditorClassName: opts.viewInfo.extraEditorClassName,
                    disableMonospaceOptimizations: opts.viewInfo.disableMonospaceOptimizations,
                    rulers: opts.viewInfo.rulers,
                    ariaLabel: (accessibilityIsOff ? nls.localize(0, null) : opts.viewInfo.ariaLabel),
                    renderLineNumbers: opts.viewInfo.renderLineNumbers,
                    renderCustomLineNumbers: opts.viewInfo.renderCustomLineNumbers,
                    selectOnLineNumbers: opts.viewInfo.selectOnLineNumbers,
                    glyphMargin: opts.viewInfo.glyphMargin,
                    revealHorizontalRightPadding: opts.viewInfo.revealHorizontalRightPadding,
                    roundedSelection: (accessibilityIsOn ? false : opts.viewInfo.roundedSelection),
                    overviewRulerLanes: opts.viewInfo.overviewRulerLanes,
                    overviewRulerBorder: opts.viewInfo.overviewRulerBorder,
                    cursorBlinking: opts.viewInfo.cursorBlinking,
                    mouseWheelZoom: opts.viewInfo.mouseWheelZoom,
                    cursorStyle: opts.viewInfo.cursorStyle,
                    cursorWidth: opts.viewInfo.cursorWidth,
                    hideCursorInOverviewRuler: opts.viewInfo.hideCursorInOverviewRuler,
                    scrollBeyondLastLine: opts.viewInfo.scrollBeyondLastLine,
                    scrollBeyondLastColumn: opts.viewInfo.scrollBeyondLastColumn,
                    smoothScrolling: opts.viewInfo.smoothScrolling,
                    stopRenderingLineAfter: opts.viewInfo.stopRenderingLineAfter,
                    renderWhitespace: (accessibilityIsOn ? 'none' : opts.viewInfo.renderWhitespace),
                    renderControlCharacters: (accessibilityIsOn ? false : opts.viewInfo.renderControlCharacters),
                    fontLigatures: (accessibilityIsOn ? false : opts.viewInfo.fontLigatures),
                    renderIndentGuides: (accessibilityIsOn ? false : opts.viewInfo.renderIndentGuides),
                    highlightActiveIndentGuide: opts.viewInfo.highlightActiveIndentGuide,
                    renderLineHighlight: opts.viewInfo.renderLineHighlight,
                    scrollbar: opts.viewInfo.scrollbar,
                    minimap: {
                        enabled: (accessibilityIsOn ? false : opts.viewInfo.minimap.enabled),
                        side: opts.viewInfo.minimap.side,
                        renderCharacters: opts.viewInfo.minimap.renderCharacters,
                        showSlider: opts.viewInfo.minimap.showSlider,
                        maxColumn: opts.viewInfo.minimap.maxColumn
                    },
                    fixedOverflowWidgets: opts.viewInfo.fixedOverflowWidgets
                },
                contribInfo: {
                    selectionClipboard: opts.contribInfo.selectionClipboard,
                    hover: opts.contribInfo.hover,
                    links: (accessibilityIsOn ? false : opts.contribInfo.links),
                    contextmenu: opts.contribInfo.contextmenu,
                    quickSuggestions: opts.contribInfo.quickSuggestions,
                    quickSuggestionsDelay: opts.contribInfo.quickSuggestionsDelay,
                    parameterHints: opts.contribInfo.parameterHints,
                    iconsInSuggestions: opts.contribInfo.iconsInSuggestions,
                    formatOnType: opts.contribInfo.formatOnType,
                    formatOnPaste: opts.contribInfo.formatOnPaste,
                    suggestOnTriggerCharacters: opts.contribInfo.suggestOnTriggerCharacters,
                    acceptSuggestionOnEnter: opts.contribInfo.acceptSuggestionOnEnter,
                    acceptSuggestionOnCommitCharacter: opts.contribInfo.acceptSuggestionOnCommitCharacter,
                    wordBasedSuggestions: opts.contribInfo.wordBasedSuggestions,
                    suggestSelection: opts.contribInfo.suggestSelection,
                    suggestFontSize: opts.contribInfo.suggestFontSize,
                    suggestLineHeight: opts.contribInfo.suggestLineHeight,
                    suggest: opts.contribInfo.suggest,
                    selectionHighlight: (accessibilityIsOn ? false : opts.contribInfo.selectionHighlight),
                    occurrencesHighlight: (accessibilityIsOn ? false : opts.contribInfo.occurrencesHighlight),
                    codeLens: (accessibilityIsOn ? false : opts.contribInfo.codeLens),
                    folding: (accessibilityIsOn ? false : opts.contribInfo.folding),
                    foldingStrategy: opts.contribInfo.foldingStrategy,
                    showFoldingControls: opts.contribInfo.showFoldingControls,
                    matchBrackets: (accessibilityIsOn ? false : opts.contribInfo.matchBrackets),
                    find: opts.contribInfo.find,
                    colorDecorators: opts.contribInfo.colorDecorators,
                    lightbulbEnabled: opts.contribInfo.lightbulbEnabled,
                    codeActionsOnSave: opts.contribInfo.codeActionsOnSave,
                    codeActionsOnSaveTimeout: opts.contribInfo.codeActionsOnSaveTimeout
                }
            };
        };
        InternalEditorOptionsFactory.createInternalEditorOptions = function (env, _opts) {
            var accessibilitySupport;
            if (_opts.accessibilitySupport === 'auto') {
                // The editor reads the `accessibilitySupport` from the environment
                accessibilitySupport = env.accessibilitySupport;
            }
            else if (_opts.accessibilitySupport === 'on') {
                accessibilitySupport = 2 /* Enabled */;
            }
            else {
                accessibilitySupport = 1 /* Disabled */;
            }
            // Disable some non critical features to get as best performance as possible
            // See https://github.com/Microsoft/vscode/issues/26730
            var opts = this._tweakValidatedOptions(_opts, accessibilitySupport);
            var lineDecorationsWidth;
            if (typeof opts.lineDecorationsWidth === 'string' && /^\d+(\.\d+)?ch$/.test(opts.lineDecorationsWidth)) {
                var multiple = parseFloat(opts.lineDecorationsWidth.substr(0, opts.lineDecorationsWidth.length - 2));
                lineDecorationsWidth = multiple * env.fontInfo.typicalHalfwidthCharacterWidth;
            }
            else {
                lineDecorationsWidth = _clampedInt(opts.lineDecorationsWidth, 0, 0, 1000);
            }
            if (opts.contribInfo.folding) {
                lineDecorationsWidth += 16;
            }
            var layoutInfo = EditorLayoutProvider.compute({
                outerWidth: env.outerWidth,
                outerHeight: env.outerHeight,
                showGlyphMargin: opts.viewInfo.glyphMargin,
                lineHeight: env.fontInfo.lineHeight,
                showLineNumbers: (opts.viewInfo.renderLineNumbers !== 0 /* Off */),
                lineNumbersMinChars: opts.lineNumbersMinChars,
                lineNumbersDigitCount: env.lineNumbersDigitCount,
                lineDecorationsWidth: lineDecorationsWidth,
                typicalHalfwidthCharacterWidth: env.fontInfo.typicalHalfwidthCharacterWidth,
                maxDigitWidth: env.fontInfo.maxDigitWidth,
                verticalScrollbarWidth: opts.viewInfo.scrollbar.verticalScrollbarSize,
                horizontalScrollbarHeight: opts.viewInfo.scrollbar.horizontalScrollbarSize,
                scrollbarArrowSize: opts.viewInfo.scrollbar.arrowSize,
                verticalScrollbarHasArrows: opts.viewInfo.scrollbar.verticalHasArrows,
                minimap: opts.viewInfo.minimap.enabled,
                minimapSide: opts.viewInfo.minimap.side,
                minimapRenderCharacters: opts.viewInfo.minimap.renderCharacters,
                minimapMaxColumn: opts.viewInfo.minimap.maxColumn,
                pixelRatio: env.pixelRatio
            });
            var bareWrappingInfo = null;
            {
                var wordWrap = opts.wordWrap;
                var wordWrapColumn = opts.wordWrapColumn;
                var wordWrapMinified = opts.wordWrapMinified;
                if (accessibilitySupport === 2 /* Enabled */) {
                    // See https://github.com/Microsoft/vscode/issues/27766
                    // Never enable wrapping when a screen reader is attached
                    // because arrow down etc. will not move the cursor in the way
                    // a screen reader expects.
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: false,
                        wrappingColumn: -1
                    };
                }
                else if (wordWrapMinified && env.isDominatedByLongLines) {
                    // Force viewport width wrapping if model is dominated by long lines
                    bareWrappingInfo = {
                        isWordWrapMinified: true,
                        isViewportWrapping: true,
                        wrappingColumn: Math.max(1, layoutInfo.viewportColumn)
                    };
                }
                else if (wordWrap === 'on') {
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: true,
                        wrappingColumn: Math.max(1, layoutInfo.viewportColumn)
                    };
                }
                else if (wordWrap === 'bounded') {
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: true,
                        wrappingColumn: Math.min(Math.max(1, layoutInfo.viewportColumn), wordWrapColumn)
                    };
                }
                else if (wordWrap === 'wordWrapColumn') {
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: false,
                        wrappingColumn: wordWrapColumn
                    };
                }
                else {
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: false,
                        wrappingColumn: -1
                    };
                }
            }
            var wrappingInfo = {
                inDiffEditor: opts.inDiffEditor,
                isDominatedByLongLines: env.isDominatedByLongLines,
                isWordWrapMinified: bareWrappingInfo.isWordWrapMinified,
                isViewportWrapping: bareWrappingInfo.isViewportWrapping,
                wrappingColumn: bareWrappingInfo.wrappingColumn,
                wrappingIndent: opts.wrappingIndent,
                wordWrapBreakBeforeCharacters: opts.wordWrapBreakBeforeCharacters,
                wordWrapBreakAfterCharacters: opts.wordWrapBreakAfterCharacters,
                wordWrapBreakObtrusiveCharacters: opts.wordWrapBreakObtrusiveCharacters,
            };
            var className = 'monaco-editor';
            if (opts.viewInfo.extraEditorClassName) {
                className += ' ' + opts.viewInfo.extraEditorClassName;
            }
            if (env.extraEditorClassName) {
                className += ' ' + env.extraEditorClassName;
            }
            if (opts.viewInfo.fontLigatures) {
                className += ' enable-ligatures';
            }
            if (opts.mouseStyle === 'default') {
                className += ' mouse-default';
            }
            else if (opts.mouseStyle === 'copy') {
                className += ' mouse-copy';
            }
            return new InternalEditorOptions({
                canUseLayerHinting: opts.disableLayerHinting ? false : true,
                pixelRatio: env.pixelRatio,
                editorClassName: className,
                lineHeight: env.fontInfo.lineHeight,
                readOnly: opts.readOnly,
                accessibilitySupport: accessibilitySupport,
                multiCursorModifier: opts.multiCursorModifier,
                multiCursorMergeOverlapping: opts.multiCursorMergeOverlapping,
                wordSeparators: opts.wordSeparators,
                autoClosingBrackets: opts.autoClosingBrackets,
                autoIndent: opts.autoIndent,
                useTabStops: opts.useTabStops,
                tabFocusMode: opts.readOnly ? true : env.tabFocusMode,
                dragAndDrop: opts.dragAndDrop,
                emptySelectionClipboard: opts.emptySelectionClipboard && env.emptySelectionClipboard,
                layoutInfo: layoutInfo,
                fontInfo: env.fontInfo,
                viewInfo: opts.viewInfo,
                wrappingInfo: wrappingInfo,
                contribInfo: opts.contribInfo,
                showUnused: opts.showUnused,
            });
        };
        return InternalEditorOptionsFactory;
    }());
    exports.InternalEditorOptionsFactory = InternalEditorOptionsFactory;
    /**
     * @internal
     */
    var EditorLayoutProvider = /** @class */ (function () {
        function EditorLayoutProvider() {
        }
        EditorLayoutProvider.compute = function (_opts) {
            var outerWidth = _opts.outerWidth | 0;
            var outerHeight = _opts.outerHeight | 0;
            var showGlyphMargin = _opts.showGlyphMargin;
            var lineHeight = _opts.lineHeight | 0;
            var showLineNumbers = _opts.showLineNumbers;
            var lineNumbersMinChars = _opts.lineNumbersMinChars | 0;
            var lineNumbersDigitCount = _opts.lineNumbersDigitCount | 0;
            var lineDecorationsWidth = _opts.lineDecorationsWidth | 0;
            var typicalHalfwidthCharacterWidth = _opts.typicalHalfwidthCharacterWidth;
            var maxDigitWidth = _opts.maxDigitWidth;
            var verticalScrollbarWidth = _opts.verticalScrollbarWidth | 0;
            var verticalScrollbarHasArrows = _opts.verticalScrollbarHasArrows;
            var scrollbarArrowSize = _opts.scrollbarArrowSize | 0;
            var horizontalScrollbarHeight = _opts.horizontalScrollbarHeight | 0;
            var minimap = _opts.minimap;
            var minimapSide = _opts.minimapSide;
            var minimapRenderCharacters = _opts.minimapRenderCharacters;
            var minimapMaxColumn = _opts.minimapMaxColumn | 0;
            var pixelRatio = _opts.pixelRatio;
            var lineNumbersWidth = 0;
            if (showLineNumbers) {
                var digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);
                lineNumbersWidth = Math.round(digitCount * maxDigitWidth);
            }
            var glyphMarginWidth = 0;
            if (showGlyphMargin) {
                glyphMarginWidth = lineHeight;
            }
            var glyphMarginLeft = 0;
            var lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;
            var decorationsLeft = lineNumbersLeft + lineNumbersWidth;
            var contentLeft = decorationsLeft + lineDecorationsWidth;
            var remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;
            var renderMinimap;
            var minimapLeft;
            var minimapWidth;
            var contentWidth;
            if (!minimap) {
                minimapLeft = 0;
                minimapWidth = 0;
                renderMinimap = RenderMinimap.None;
                contentWidth = remainingWidth;
            }
            else {
                var minimapCharWidth = void 0;
                if (pixelRatio >= 2) {
                    renderMinimap = minimapRenderCharacters ? RenderMinimap.Large : RenderMinimap.LargeBlocks;
                    minimapCharWidth = 2 / pixelRatio;
                }
                else {
                    renderMinimap = minimapRenderCharacters ? RenderMinimap.Small : RenderMinimap.SmallBlocks;
                    minimapCharWidth = 1 / pixelRatio;
                }
                // Given:
                // (leaving 2px for the cursor to have space after the last character)
                // viewportColumn = (contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth
                // minimapWidth = viewportColumn * minimapCharWidth
                // contentWidth = remainingWidth - minimapWidth
                // What are good values for contentWidth and minimapWidth ?
                // minimapWidth = ((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth) * minimapCharWidth
                // typicalHalfwidthCharacterWidth * minimapWidth = (contentWidth - verticalScrollbarWidth - 2) * minimapCharWidth
                // typicalHalfwidthCharacterWidth * minimapWidth = (remainingWidth - minimapWidth - verticalScrollbarWidth - 2) * minimapCharWidth
                // (typicalHalfwidthCharacterWidth + minimapCharWidth) * minimapWidth = (remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth
                // minimapWidth = ((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)
                minimapWidth = Math.max(0, Math.floor(((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)));
                var minimapColumns = minimapWidth / minimapCharWidth;
                if (minimapColumns > minimapMaxColumn) {
                    minimapWidth = Math.floor(minimapMaxColumn * minimapCharWidth);
                }
                contentWidth = remainingWidth - minimapWidth;
                if (minimapSide === 'left') {
                    minimapLeft = 0;
                    glyphMarginLeft += minimapWidth;
                    lineNumbersLeft += minimapWidth;
                    decorationsLeft += minimapWidth;
                    contentLeft += minimapWidth;
                }
                else {
                    minimapLeft = outerWidth - minimapWidth - verticalScrollbarWidth;
                }
            }
            // (leaving 2px for the cursor to have space after the last character)
            var viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));
            var verticalArrowSize = (verticalScrollbarHasArrows ? scrollbarArrowSize : 0);
            return {
                width: outerWidth,
                height: outerHeight,
                glyphMarginLeft: glyphMarginLeft,
                glyphMarginWidth: glyphMarginWidth,
                glyphMarginHeight: outerHeight,
                lineNumbersLeft: lineNumbersLeft,
                lineNumbersWidth: lineNumbersWidth,
                lineNumbersHeight: outerHeight,
                decorationsLeft: decorationsLeft,
                decorationsWidth: lineDecorationsWidth,
                decorationsHeight: outerHeight,
                contentLeft: contentLeft,
                contentWidth: contentWidth,
                contentHeight: outerHeight,
                renderMinimap: renderMinimap,
                minimapLeft: minimapLeft,
                minimapWidth: minimapWidth,
                viewportColumn: viewportColumn,
                verticalScrollbarWidth: verticalScrollbarWidth,
                horizontalScrollbarHeight: horizontalScrollbarHeight,
                overviewRuler: {
                    top: verticalArrowSize,
                    width: verticalScrollbarWidth,
                    height: (outerHeight - 2 * verticalArrowSize),
                    right: 0
                }
            };
        };
        return EditorLayoutProvider;
    }());
    exports.EditorLayoutProvider = EditorLayoutProvider;
    var DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \'Courier New\', monospace';
    var DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \'Courier New\', monospace';
    var DEFAULT_LINUX_FONT_FAMILY = '\'Droid Sans Mono\', \'monospace\', monospace, \'Droid Sans Fallback\'';
    /**
     * @internal
     */
    exports.EDITOR_FONT_DEFAULTS = {
        fontFamily: (platform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),
        fontWeight: 'normal',
        fontSize: (platform.isMacintosh ? 12 : 14),
        lineHeight: 0,
        letterSpacing: 0,
    };
    /**
     * @internal
     */
    exports.EDITOR_MODEL_DEFAULTS = {
        tabSize: 4,
        insertSpaces: true,
        detectIndentation: true,
        trimAutoWhitespace: true,
        largeFileOptimizations: true
    };
    /**
     * @internal
     */
    exports.EDITOR_DEFAULTS = {
        inDiffEditor: false,
        wordSeparators: wordHelper_1.USUAL_WORD_SEPARATORS,
        lineNumbersMinChars: 5,
        lineDecorationsWidth: 10,
        readOnly: false,
        mouseStyle: 'text',
        disableLayerHinting: false,
        automaticLayout: false,
        wordWrap: 'off',
        wordWrapColumn: 80,
        wordWrapMinified: true,
        wrappingIndent: WrappingIndent.Same,
        wordWrapBreakBeforeCharacters: '([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋',
        wordWrapBreakAfterCharacters: ' \t})]?|&,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣',
        wordWrapBreakObtrusiveCharacters: '.',
        autoClosingBrackets: true,
        autoIndent: true,
        dragAndDrop: true,
        emptySelectionClipboard: true,
        useTabStops: true,
        multiCursorModifier: 'altKey',
        multiCursorMergeOverlapping: true,
        accessibilitySupport: 'auto',
        showUnused: true,
        viewInfo: {
            extraEditorClassName: '',
            disableMonospaceOptimizations: false,
            rulers: [],
            ariaLabel: nls.localize(1, null),
            renderLineNumbers: 1 /* On */,
            renderCustomLineNumbers: null,
            selectOnLineNumbers: true,
            glyphMargin: true,
            revealHorizontalRightPadding: 30,
            roundedSelection: true,
            overviewRulerLanes: 2,
            overviewRulerBorder: true,
            cursorBlinking: TextEditorCursorBlinkingStyle.Blink,
            mouseWheelZoom: false,
            cursorStyle: TextEditorCursorStyle.Line,
            cursorWidth: 0,
            hideCursorInOverviewRuler: false,
            scrollBeyondLastLine: true,
            scrollBeyondLastColumn: 5,
            smoothScrolling: false,
            stopRenderingLineAfter: 10000,
            renderWhitespace: 'none',
            renderControlCharacters: false,
            fontLigatures: false,
            renderIndentGuides: true,
            highlightActiveIndentGuide: true,
            renderLineHighlight: 'line',
            scrollbar: {
                vertical: scrollable_1.ScrollbarVisibility.Auto,
                horizontal: scrollable_1.ScrollbarVisibility.Auto,
                arrowSize: 11,
                useShadows: true,
                verticalHasArrows: false,
                horizontalHasArrows: false,
                horizontalScrollbarSize: 10,
                horizontalSliderSize: 10,
                verticalScrollbarSize: 14,
                verticalSliderSize: 14,
                handleMouseWheel: true,
                mouseWheelScrollSensitivity: 1,
            },
            minimap: {
                // {{SQL CARBON EDIT}}
                enabled: false,
                side: 'right',
                showSlider: 'mouseover',
                renderCharacters: true,
                maxColumn: 120
            },
            fixedOverflowWidgets: false,
        },
        contribInfo: {
            selectionClipboard: true,
            hover: {
                enabled: true,
                delay: 300,
                sticky: true
            },
            links: true,
            contextmenu: true,
            quickSuggestions: { other: true, comments: false, strings: false },
            quickSuggestionsDelay: 10,
            parameterHints: true,
            iconsInSuggestions: true,
            formatOnType: false,
            formatOnPaste: false,
            suggestOnTriggerCharacters: true,
            acceptSuggestionOnEnter: 'on',
            acceptSuggestionOnCommitCharacter: true,
            wordBasedSuggestions: true,
            suggestSelection: 'recentlyUsed',
            suggestFontSize: 0,
            suggestLineHeight: 0,
            suggest: {
                filterGraceful: true,
                snippets: 'inline',
                snippetsPreventQuickSuggestions: true
            },
            selectionHighlight: true,
            occurrencesHighlight: true,
            codeLens: true,
            folding: true,
            foldingStrategy: 'auto',
            showFoldingControls: 'mouseover',
            matchBrackets: true,
            find: {
                seedSearchStringFromSelection: true,
                autoFindInSelection: false,
                globalFindClipboard: false
            },
            colorDecorators: true,
            lightbulbEnabled: true,
            codeActionsOnSave: {},
            codeActionsOnSaveTimeout: 750
        },
    };
});

define(__m[103/*vs/nls!vs/editor/common/modes/modesRegistry*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/editor/common/modes/modesRegistry", data); });
define(__m[104/*vs/nls!vs/platform/configuration/common/configurationRegistry*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/platform/configuration/common/configurationRegistry", data); });
define(__m[105/*vs/nls!vs/platform/markers/common/markers*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/platform/markers/common/markers", data); });
define(__m[106/*vs/nls!vs/platform/workspaces/common/workspaces*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/platform/workspaces/common/workspaces", data); });
define(__m[107/*vs/nls!vs/workbench/api/node/extHostDiagnostics*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostDiagnostics", data); });
define(__m[108/*vs/nls!vs/workbench/api/node/extHostExtensionActivator*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostExtensionActivator", data); });
define(__m[109/*vs/nls!vs/workbench/api/node/extHostProgress*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostProgress", data); });
define(__m[110/*vs/nls!vs/workbench/api/node/extHostTask*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostTask", data); });
define(__m[111/*vs/nls!vs/workbench/api/node/extHostTreeViews*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostTreeViews", data); });
define(__m[112/*vs/nls!vs/workbench/api/node/extHostWorkspace*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostWorkspace", data); });
define(__m[113/*vs/nls!vs/workbench/node/extensionHostMain*/], __M([15/*vs/nls*/,17/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/node/extensionHostMain", data); });
define(__m[7/*vs/platform/instantiation/common/instantiation*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // ------ internal util
    var _util;
    (function (_util) {
        _util.serviceIds = new Map();
        _util.DI_TARGET = '$di$target';
        _util.DI_DEPENDENCIES = '$di$dependencies';
        function getServiceDependencies(ctor) {
            return ctor[_util.DI_DEPENDENCIES] || [];
        }
        _util.getServiceDependencies = getServiceDependencies;
    })(_util = exports._util || (exports._util = {}));
    exports.IInstantiationService = createDecorator('instantiationService');
    function storeServiceDependency(id, target, index, optional) {
        if (target[_util.DI_TARGET] === target) {
            target[_util.DI_DEPENDENCIES].push({ id: id, index: index, optional: optional });
        }
        else {
            target[_util.DI_DEPENDENCIES] = [{ id: id, index: index, optional: optional }];
            target[_util.DI_TARGET] = target;
        }
    }
    /**
     * A *only* valid way to create a {{ServiceIdentifier}}.
     */
    function createDecorator(serviceId) {
        if (_util.serviceIds.has(serviceId)) {
            return _util.serviceIds.get(serviceId);
        }
        var id = function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@IServiceName-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(id, target, index, false);
        };
        id.toString = function () { return serviceId; };
        _util.serviceIds.set(serviceId, id);
        return id;
    }
    exports.createDecorator = createDecorator;
    /**
     * Mark a service dependency as optional.
     */
    function optional(serviceIdentifier) {
        return function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@optional-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(serviceIdentifier, target, index, true);
        };
    }
    exports.optional = optional;
});

define(__m[55/*vs/editor/common/services/modeService*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IModeService = instantiation_1.createDecorator('modeService');
});

define(__m[39/*vs/editor/common/services/modelService*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IModelService = instantiation_1.createDecorator('modelService');
    function shouldSynchronizeModel(model) {
        return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);
    }
    exports.shouldSynchronizeModel = shouldSynchronizeModel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[117/*vs/editor/common/modes/languageFeatureRegistry*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,9/*vs/base/common/lifecycle*/,66/*vs/editor/common/modes/languageSelector*/,39/*vs/editor/common/services/modelService*/]), function (require, exports, event_1, lifecycle_1, languageSelector_1, modelService_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function isExclusive(selector) {
        if (typeof selector === 'string') {
            return false;
        }
        else if (Array.isArray(selector)) {
            return selector.every(isExclusive);
        }
        else {
            return selector.exclusive;
        }
    }
    var LanguageFeatureRegistry = /** @class */ (function () {
        function LanguageFeatureRegistry() {
            this._clock = 0;
            this._entries = [];
            this._onDidChange = new event_1.Emitter();
        }
        Object.defineProperty(LanguageFeatureRegistry.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        LanguageFeatureRegistry.prototype.register = function (selector, provider) {
            var _this = this;
            var entry = {
                selector: selector,
                provider: provider,
                _score: -1,
                _time: this._clock++
            };
            this._entries.push(entry);
            this._lastCandidate = undefined;
            this._onDidChange.fire(this._entries.length);
            return lifecycle_1.toDisposable(function () {
                if (entry) {
                    var idx = _this._entries.indexOf(entry);
                    if (idx >= 0) {
                        _this._entries.splice(idx, 1);
                        _this._lastCandidate = undefined;
                        _this._onDidChange.fire(_this._entries.length);
                        entry = undefined;
                    }
                }
            });
        };
        LanguageFeatureRegistry.prototype.has = function (model) {
            return this.all(model).length > 0;
        };
        LanguageFeatureRegistry.prototype.all = function (model) {
            if (!model) {
                return [];
            }
            this._updateScores(model);
            var result = [];
            // from registry
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                if (entry._score > 0) {
                    result.push(entry.provider);
                }
            }
            return result;
        };
        LanguageFeatureRegistry.prototype.ordered = function (model) {
            var result = [];
            this._orderedForEach(model, function (entry) { return result.push(entry.provider); });
            return result;
        };
        LanguageFeatureRegistry.prototype.orderedGroups = function (model) {
            var result = [];
            var lastBucket;
            var lastBucketScore;
            this._orderedForEach(model, function (entry) {
                if (lastBucket && lastBucketScore === entry._score) {
                    lastBucket.push(entry.provider);
                }
                else {
                    lastBucketScore = entry._score;
                    lastBucket = [entry.provider];
                    result.push(lastBucket);
                }
            });
            return result;
        };
        LanguageFeatureRegistry.prototype._orderedForEach = function (model, callback) {
            if (!model) {
                return;
            }
            this._updateScores(model);
            for (var from = 0; from < this._entries.length; from++) {
                var entry = this._entries[from];
                if (entry._score > 0) {
                    callback(entry);
                }
            }
        };
        LanguageFeatureRegistry.prototype._updateScores = function (model) {
            var candidate = {
                uri: model.uri.toString(),
                language: model.getLanguageIdentifier().language
            };
            if (this._lastCandidate
                && this._lastCandidate.language === candidate.language
                && this._lastCandidate.uri === candidate.uri) {
                // nothing has changed
                return;
            }
            this._lastCandidate = candidate;
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                entry._score = languageSelector_1.score(entry.selector, model.uri, model.getLanguageIdentifier().language, modelService_1.shouldSynchronizeModel(model));
                if (isExclusive(entry.selector) && entry._score > 0) {
                    // support for one exclusive selector that overwrites
                    // any other selector
                    for (var _b = 0, _c = this._entries; _b < _c.length; _b++) {
                        var entry_1 = _c[_b];
                        entry_1._score = 0;
                    }
                    entry._score = 1000;
                    break;
                }
            }
            // needs sorting
            this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);
        };
        LanguageFeatureRegistry._compareByScoreAndTime = function (a, b) {
            if (a._score < b._score) {
                return 1;
            }
            else if (a._score > b._score) {
                return -1;
            }
            else if (a._time < b._time) {
                return 1;
            }
            else if (a._time > b._time) {
                return -1;
            }
            else {
                return 0;
            }
        };
        return LanguageFeatureRegistry;
    }());
    exports.default = LanguageFeatureRegistry;
});

define(__m[36/*vs/editor/common/modes*/], __M([0/*require*/,1/*exports*/,117/*vs/editor/common/modes/languageFeatureRegistry*/,235/*vs/editor/common/modes/tokenizationRegistry*/,18/*vs/base/common/types*/]), function (require, exports, languageFeatureRegistry_1, tokenizationRegistry_1, types_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Open ended enum at runtime
     * @internal
     */
    var LanguageId;
    (function (LanguageId) {
        LanguageId[LanguageId["Null"] = 0] = "Null";
        LanguageId[LanguageId["PlainText"] = 1] = "PlainText";
    })(LanguageId = exports.LanguageId || (exports.LanguageId = {}));
    /**
     * @internal
     */
    var LanguageIdentifier = /** @class */ (function () {
        function LanguageIdentifier(language, id) {
            this.language = language;
            this.id = id;
        }
        return LanguageIdentifier;
    }());
    exports.LanguageIdentifier = LanguageIdentifier;
    /**
     * A font style. Values are 2^x such that a bit mask can be used.
     * @internal
     */
    var FontStyle;
    (function (FontStyle) {
        FontStyle[FontStyle["NotSet"] = -1] = "NotSet";
        FontStyle[FontStyle["None"] = 0] = "None";
        FontStyle[FontStyle["Italic"] = 1] = "Italic";
        FontStyle[FontStyle["Bold"] = 2] = "Bold";
        FontStyle[FontStyle["Underline"] = 4] = "Underline";
    })(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
    /**
     * Open ended enum at runtime
     * @internal
     */
    var ColorId;
    (function (ColorId) {
        ColorId[ColorId["None"] = 0] = "None";
        ColorId[ColorId["DefaultForeground"] = 1] = "DefaultForeground";
        ColorId[ColorId["DefaultBackground"] = 2] = "DefaultBackground";
    })(ColorId = exports.ColorId || (exports.ColorId = {}));
    /**
     * A standard token type. Values are 2^x such that a bit mask can be used.
     * @internal
     */
    var StandardTokenType;
    (function (StandardTokenType) {
        StandardTokenType[StandardTokenType["Other"] = 0] = "Other";
        StandardTokenType[StandardTokenType["Comment"] = 1] = "Comment";
        StandardTokenType[StandardTokenType["String"] = 2] = "String";
        StandardTokenType[StandardTokenType["RegEx"] = 4] = "RegEx";
    })(StandardTokenType = exports.StandardTokenType || (exports.StandardTokenType = {}));
    /**
     * Helpers to manage the "collapsed" metadata of an entire StackElement stack.
     * The following assumptions have been made:
     *  - languageId < 256 => needs 8 bits
     *  - unique color count < 512 => needs 9 bits
     *
     * The binary format is:
     * - -------------------------------------------
     *     3322 2222 2222 1111 1111 1100 0000 0000
     *     1098 7654 3210 9876 5432 1098 7654 3210
     * - -------------------------------------------
     *     xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
     *     bbbb bbbb bfff ffff ffFF FTTT LLLL LLLL
     * - -------------------------------------------
     *  - L = LanguageId (8 bits)
     *  - T = StandardTokenType (3 bits)
     *  - F = FontStyle (3 bits)
     *  - f = foreground color (9 bits)
     *  - b = background color (9 bits)
     *
     * @internal
     */
    var MetadataConsts;
    (function (MetadataConsts) {
        MetadataConsts[MetadataConsts["LANGUAGEID_MASK"] = 255] = "LANGUAGEID_MASK";
        MetadataConsts[MetadataConsts["TOKEN_TYPE_MASK"] = 1792] = "TOKEN_TYPE_MASK";
        MetadataConsts[MetadataConsts["FONT_STYLE_MASK"] = 14336] = "FONT_STYLE_MASK";
        MetadataConsts[MetadataConsts["FOREGROUND_MASK"] = 8372224] = "FOREGROUND_MASK";
        MetadataConsts[MetadataConsts["BACKGROUND_MASK"] = 4286578688] = "BACKGROUND_MASK";
        MetadataConsts[MetadataConsts["LANGUAGEID_OFFSET"] = 0] = "LANGUAGEID_OFFSET";
        MetadataConsts[MetadataConsts["TOKEN_TYPE_OFFSET"] = 8] = "TOKEN_TYPE_OFFSET";
        MetadataConsts[MetadataConsts["FONT_STYLE_OFFSET"] = 11] = "FONT_STYLE_OFFSET";
        MetadataConsts[MetadataConsts["FOREGROUND_OFFSET"] = 14] = "FOREGROUND_OFFSET";
        MetadataConsts[MetadataConsts["BACKGROUND_OFFSET"] = 23] = "BACKGROUND_OFFSET";
    })(MetadataConsts = exports.MetadataConsts || (exports.MetadataConsts = {}));
    /**
     * @internal
     */
    var TokenMetadata = /** @class */ (function () {
        function TokenMetadata() {
        }
        TokenMetadata.getLanguageId = function (metadata) {
            return (metadata & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;
        };
        TokenMetadata.getTokenType = function (metadata) {
            return (metadata & 1792 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;
        };
        TokenMetadata.getFontStyle = function (metadata) {
            return (metadata & 14336 /* FONT_STYLE_MASK */) >>> 11 /* FONT_STYLE_OFFSET */;
        };
        TokenMetadata.getForeground = function (metadata) {
            return (metadata & 8372224 /* FOREGROUND_MASK */) >>> 14 /* FOREGROUND_OFFSET */;
        };
        TokenMetadata.getBackground = function (metadata) {
            return (metadata & 4286578688 /* BACKGROUND_MASK */) >>> 23 /* BACKGROUND_OFFSET */;
        };
        TokenMetadata.getClassNameFromMetadata = function (metadata) {
            var foreground = this.getForeground(metadata);
            var className = 'mtk' + foreground;
            var fontStyle = this.getFontStyle(metadata);
            if (fontStyle & 1 /* Italic */) {
                className += ' mtki';
            }
            if (fontStyle & 2 /* Bold */) {
                className += ' mtkb';
            }
            if (fontStyle & 4 /* Underline */) {
                className += ' mtku';
            }
            return className;
        };
        TokenMetadata.getInlineStyleFromMetadata = function (metadata, colorMap) {
            var foreground = this.getForeground(metadata);
            var fontStyle = this.getFontStyle(metadata);
            var result = "color: " + colorMap[foreground] + ";";
            if (fontStyle & 1 /* Italic */) {
                result += 'font-style: italic;';
            }
            if (fontStyle & 2 /* Bold */) {
                result += 'font-weight: bold;';
            }
            if (fontStyle & 4 /* Underline */) {
                result += 'text-decoration: underline;';
            }
            return result;
        };
        return TokenMetadata;
    }());
    exports.TokenMetadata = TokenMetadata;
    /**
     * How a suggest provider was triggered.
     */
    var SuggestTriggerKind;
    (function (SuggestTriggerKind) {
        SuggestTriggerKind[SuggestTriggerKind["Invoke"] = 0] = "Invoke";
        SuggestTriggerKind[SuggestTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
        SuggestTriggerKind[SuggestTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
    })(SuggestTriggerKind = exports.SuggestTriggerKind || (exports.SuggestTriggerKind = {}));
    /**
     * @internal
     */
    var CodeActionTrigger;
    (function (CodeActionTrigger) {
        CodeActionTrigger[CodeActionTrigger["Automatic"] = 1] = "Automatic";
        CodeActionTrigger[CodeActionTrigger["Manual"] = 2] = "Manual";
    })(CodeActionTrigger = exports.CodeActionTrigger || (exports.CodeActionTrigger = {}));
    /**
     * A document highlight kind.
     */
    var DocumentHighlightKind;
    (function (DocumentHighlightKind) {
        /**
         * A textual occurrence.
         */
        DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
        /**
         * Read-access of a symbol, like reading a variable.
         */
        DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
        /**
         * Write-access of a symbol, like writing to a variable.
         */
        DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
    })(DocumentHighlightKind = exports.DocumentHighlightKind || (exports.DocumentHighlightKind = {}));
    /**
     * A symbol kind.
     */
    var SymbolKind;
    (function (SymbolKind) {
        SymbolKind[SymbolKind["File"] = 0] = "File";
        SymbolKind[SymbolKind["Module"] = 1] = "Module";
        SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
        SymbolKind[SymbolKind["Package"] = 3] = "Package";
        SymbolKind[SymbolKind["Class"] = 4] = "Class";
        SymbolKind[SymbolKind["Method"] = 5] = "Method";
        SymbolKind[SymbolKind["Property"] = 6] = "Property";
        SymbolKind[SymbolKind["Field"] = 7] = "Field";
        SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
        SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
        SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
        SymbolKind[SymbolKind["Function"] = 11] = "Function";
        SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
        SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
        SymbolKind[SymbolKind["String"] = 14] = "String";
        SymbolKind[SymbolKind["Number"] = 15] = "Number";
        SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
        SymbolKind[SymbolKind["Array"] = 17] = "Array";
        SymbolKind[SymbolKind["Object"] = 18] = "Object";
        SymbolKind[SymbolKind["Key"] = 19] = "Key";
        SymbolKind[SymbolKind["Null"] = 20] = "Null";
        SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
        SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
        SymbolKind[SymbolKind["Event"] = 23] = "Event";
        SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
        SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    /**
     * @internal
     */
    exports.symbolKindToCssClass = (function () {
        var _fromMapping = Object.create(null);
        _fromMapping[SymbolKind.File] = 'file';
        _fromMapping[SymbolKind.Module] = 'module';
        _fromMapping[SymbolKind.Namespace] = 'namespace';
        _fromMapping[SymbolKind.Package] = 'package';
        _fromMapping[SymbolKind.Class] = 'class';
        _fromMapping[SymbolKind.Method] = 'method';
        _fromMapping[SymbolKind.Property] = 'property';
        _fromMapping[SymbolKind.Field] = 'field';
        _fromMapping[SymbolKind.Constructor] = 'constructor';
        _fromMapping[SymbolKind.Enum] = 'enum';
        _fromMapping[SymbolKind.Interface] = 'interface';
        _fromMapping[SymbolKind.Function] = 'function';
        _fromMapping[SymbolKind.Variable] = 'variable';
        _fromMapping[SymbolKind.Constant] = 'constant';
        _fromMapping[SymbolKind.String] = 'string';
        _fromMapping[SymbolKind.Number] = 'number';
        _fromMapping[SymbolKind.Boolean] = 'boolean';
        _fromMapping[SymbolKind.Array] = 'array';
        _fromMapping[SymbolKind.Object] = 'object';
        _fromMapping[SymbolKind.Key] = 'key';
        _fromMapping[SymbolKind.Null] = 'null';
        _fromMapping[SymbolKind.EnumMember] = 'enum-member';
        _fromMapping[SymbolKind.Struct] = 'struct';
        _fromMapping[SymbolKind.Event] = 'event';
        _fromMapping[SymbolKind.Operator] = 'operator';
        _fromMapping[SymbolKind.TypeParameter] = 'type-parameter';
        return function toCssClassName(kind) {
            return "symbol-icon " + (_fromMapping[kind] || 'property');
        };
    })();
    var FoldingRangeKind = /** @class */ (function () {
        /**
         * Creates a new [FoldingRangeKind](#FoldingRangeKind).
         *
         * @param value of the kind.
         */
        function FoldingRangeKind(value) {
            this.value = value;
        }
        /**
         * Kind for folding range representing a comment. The value of the kind is 'comment'.
         */
        FoldingRangeKind.Comment = new FoldingRangeKind('comment');
        /**
         * Kind for folding range representing a import. The value of the kind is 'imports'.
         */
        FoldingRangeKind.Imports = new FoldingRangeKind('imports');
        /**
         * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).
         * The value of the kind is 'region'.
         */
        FoldingRangeKind.Region = new FoldingRangeKind('region');
        return FoldingRangeKind;
    }());
    exports.FoldingRangeKind = FoldingRangeKind;
    /**
     * @internal
     */
    function isResourceFileEdit(thing) {
        return types_1.isObject(thing) && (Boolean(thing.newUri) || Boolean(thing.oldUri));
    }
    exports.isResourceFileEdit = isResourceFileEdit;
    /**
     * @internal
     */
    function isResourceTextEdit(thing) {
        return types_1.isObject(thing) && thing.resource && Array.isArray(thing.edits);
    }
    exports.isResourceTextEdit = isResourceTextEdit;
    var CommentThreadCollapsibleState;
    (function (CommentThreadCollapsibleState) {
        /**
         * Determines an item is collapsed
         */
        CommentThreadCollapsibleState[CommentThreadCollapsibleState["Collapsed"] = 0] = "Collapsed";
        /**
         * Determines an item is expanded
         */
        CommentThreadCollapsibleState[CommentThreadCollapsibleState["Expanded"] = 1] = "Expanded";
    })(CommentThreadCollapsibleState = exports.CommentThreadCollapsibleState || (exports.CommentThreadCollapsibleState = {}));
    // --- feature registries ------
    /**
     * @internal
     */
    exports.ReferenceProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.RenameProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.SuggestRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.SignatureHelpProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.HoverProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentSymbolProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentHighlightProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DefinitionProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.ImplementationProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.TypeDefinitionProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.CodeLensProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.CodeActionProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentFormattingEditProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentRangeFormattingEditProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.OnTypeFormattingEditProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.LinkProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.ColorProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.FoldingRangeProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.TokenizationRegistry = new tokenizationRegistry_1.TokenizationRegistryImpl();
});

define(__m[119/*vs/editor/common/core/lineTokens*/], __M([0/*require*/,1/*exports*/,36/*vs/editor/common/modes*/]), function (require, exports, modes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var LineTokens = /** @class */ (function () {
        function LineTokens(tokens, text) {
            this._tokens = tokens;
            this._tokensCount = (this._tokens.length >>> 1);
            this._text = text;
        }
        LineTokens.prototype.equals = function (other) {
            if (other instanceof LineTokens) {
                return this.slicedEquals(other, 0, this._tokensCount);
            }
            return false;
        };
        LineTokens.prototype.slicedEquals = function (other, sliceFromTokenIndex, sliceTokenCount) {
            if (this._text !== other._text) {
                return false;
            }
            if (this._tokensCount !== other._tokensCount) {
                return false;
            }
            var from = (sliceFromTokenIndex << 1);
            var to = from + (sliceTokenCount << 1);
            for (var i = from; i < to; i++) {
                if (this._tokens[i] !== other._tokens[i]) {
                    return false;
                }
            }
            return true;
        };
        LineTokens.prototype.getLineContent = function () {
            return this._text;
        };
        LineTokens.prototype.getCount = function () {
            return this._tokensCount;
        };
        LineTokens.prototype.getStartOffset = function (tokenIndex) {
            if (tokenIndex > 0) {
                return this._tokens[(tokenIndex - 1) << 1];
            }
            return 0;
        };
        LineTokens.prototype.getLanguageId = function (tokenIndex) {
            var metadata = this._tokens[(tokenIndex << 1) + 1];
            return modes_1.TokenMetadata.getLanguageId(metadata);
        };
        LineTokens.prototype.getStandardTokenType = function (tokenIndex) {
            var metadata = this._tokens[(tokenIndex << 1) + 1];
            return modes_1.TokenMetadata.getTokenType(metadata);
        };
        LineTokens.prototype.getForeground = function (tokenIndex) {
            var metadata = this._tokens[(tokenIndex << 1) + 1];
            return modes_1.TokenMetadata.getForeground(metadata);
        };
        LineTokens.prototype.getClassName = function (tokenIndex) {
            var metadata = this._tokens[(tokenIndex << 1) + 1];
            return modes_1.TokenMetadata.getClassNameFromMetadata(metadata);
        };
        LineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {
            var metadata = this._tokens[(tokenIndex << 1) + 1];
            return modes_1.TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);
        };
        LineTokens.prototype.getEndOffset = function (tokenIndex) {
            return this._tokens[tokenIndex << 1];
        };
        /**
         * Find the token containing offset `offset`.
         * @param offset The search offset
         * @return The index of the token containing the offset.
         */
        LineTokens.prototype.findTokenIndexAtOffset = function (offset) {
            return LineTokens.findIndexInTokensArray(this._tokens, offset);
        };
        LineTokens.prototype.inflate = function () {
            return this;
        };
        LineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaOffset) {
            return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);
        };
        LineTokens.convertToEndOffset = function (tokens, lineTextLength) {
            var tokenCount = (tokens.length >>> 1);
            var lastTokenIndex = tokenCount - 1;
            for (var tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {
                tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];
            }
            tokens[lastTokenIndex << 1] = lineTextLength;
        };
        LineTokens.findIndexInTokensArray = function (tokens, desiredIndex) {
            if (tokens.length <= 2) {
                return 0;
            }
            var low = 0;
            var high = (tokens.length >>> 1) - 1;
            while (low < high) {
                var mid = low + Math.floor((high - low) / 2);
                var endOffset = tokens[(mid << 1)];
                if (endOffset === desiredIndex) {
                    return mid + 1;
                }
                else if (endOffset < desiredIndex) {
                    low = mid + 1;
                }
                else if (endOffset > desiredIndex) {
                    high = mid;
                }
            }
            return low;
        };
        return LineTokens;
    }());
    exports.LineTokens = LineTokens;
    var SlicedLineTokens = /** @class */ (function () {
        function SlicedLineTokens(source, startOffset, endOffset, deltaOffset) {
            this._source = source;
            this._startOffset = startOffset;
            this._endOffset = endOffset;
            this._deltaOffset = deltaOffset;
            this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);
            this._tokensCount = 0;
            for (var i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {
                var tokenStartOffset = source.getStartOffset(i);
                if (tokenStartOffset >= endOffset) {
                    break;
                }
                this._tokensCount++;
            }
        }
        SlicedLineTokens.prototype.equals = function (other) {
            if (other instanceof SlicedLineTokens) {
                return (this._startOffset === other._startOffset
                    && this._endOffset === other._endOffset
                    && this._deltaOffset === other._deltaOffset
                    && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));
            }
            return false;
        };
        SlicedLineTokens.prototype.getCount = function () {
            return this._tokensCount;
        };
        SlicedLineTokens.prototype.getForeground = function (tokenIndex) {
            return this._source.getForeground(this._firstTokenIndex + tokenIndex);
        };
        SlicedLineTokens.prototype.getEndOffset = function (tokenIndex) {
            var tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);
            return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;
        };
        SlicedLineTokens.prototype.getClassName = function (tokenIndex) {
            return this._source.getClassName(this._firstTokenIndex + tokenIndex);
        };
        SlicedLineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {
            return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);
        };
        SlicedLineTokens.prototype.findTokenIndexAtOffset = function (offset) {
            return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
        };
        return SlicedLineTokens;
    }());
    exports.SlicedLineTokens = SlicedLineTokens;
});

define(__m[58/*vs/editor/common/modes/nullMode*/], __M([0/*require*/,1/*exports*/,36/*vs/editor/common/modes*/,126/*vs/editor/common/core/token*/]), function (require, exports, modes_1, token_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var NullStateImpl = /** @class */ (function () {
        function NullStateImpl() {
        }
        NullStateImpl.prototype.clone = function () {
            return this;
        };
        NullStateImpl.prototype.equals = function (other) {
            return (this === other);
        };
        return NullStateImpl;
    }());
    exports.NULL_STATE = new NullStateImpl();
    exports.NULL_MODE_ID = 'vs.editor.nullMode';
    exports.NULL_LANGUAGE_IDENTIFIER = new modes_1.LanguageIdentifier(exports.NULL_MODE_ID, 0 /* Null */);
    function nullTokenize(modeId, buffer, state, deltaOffset) {
        return new token_1.TokenizationResult([new token_1.Token(deltaOffset, '', modeId)], state);
    }
    exports.nullTokenize = nullTokenize;
    function nullTokenize2(languageId, buffer, state, deltaOffset) {
        var tokens = new Uint32Array(2);
        tokens[0] = deltaOffset;
        tokens[1] = ((languageId << 0 /* LANGUAGEID_OFFSET */)
            | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)
            | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)
            | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)
            | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;
        return new token_1.TokenizationResult2(tokens, state);
    }
    exports.nullTokenize2 = nullTokenize2;
});

define(__m[85/*vs/editor/common/model/textModelTokens*/], __M([0/*require*/,1/*exports*/,119/*vs/editor/common/core/lineTokens*/,13/*vs/base/common/arrays*/,27/*vs/editor/common/core/position*/,14/*vs/base/common/errors*/,58/*vs/editor/common/modes/nullMode*/]), function (require, exports, lineTokens_1, arrays, position_1, errors_1, nullMode_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getDefaultMetadata(topLevelLanguageId) {
        return ((topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */)
            | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)
            | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)
            | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)
            | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;
    }
    var EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;
    var ModelLineTokens = /** @class */ (function () {
        function ModelLineTokens(state) {
            this._state = state;
            this._lineTokens = null;
            this._invalid = true;
        }
        ModelLineTokens.prototype.deleteBeginning = function (toChIndex) {
            if (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS) {
                return;
            }
            this.delete(0, toChIndex);
        };
        ModelLineTokens.prototype.deleteEnding = function (fromChIndex) {
            if (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS) {
                return;
            }
            var tokens = new Uint32Array(this._lineTokens);
            var lineTextLength = tokens[tokens.length - 2];
            this.delete(fromChIndex, lineTextLength);
        };
        ModelLineTokens.prototype.delete = function (fromChIndex, toChIndex) {
            if (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {
                return;
            }
            var tokens = new Uint32Array(this._lineTokens);
            var tokensCount = (tokens.length >>> 1);
            // special case: deleting everything
            if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {
                this._lineTokens = EMPTY_LINE_TOKENS;
                return;
            }
            var fromTokenIndex = lineTokens_1.LineTokens.findIndexInTokensArray(tokens, fromChIndex);
            var fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);
            var fromTokenEndOffset = tokens[fromTokenIndex << 1];
            if (toChIndex < fromTokenEndOffset) {
                // the delete range is inside a single token
                var delta_1 = (toChIndex - fromChIndex);
                for (var i = fromTokenIndex; i < tokensCount; i++) {
                    tokens[i << 1] -= delta_1;
                }
                return;
            }
            var dest;
            var lastEnd;
            if (fromTokenStartOffset !== fromChIndex) {
                tokens[fromTokenIndex << 1] = fromChIndex;
                dest = ((fromTokenIndex + 1) << 1);
                lastEnd = fromChIndex;
            }
            else {
                dest = (fromTokenIndex << 1);
                lastEnd = fromTokenStartOffset;
            }
            var delta = (toChIndex - fromChIndex);
            for (var tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {
                var tokenEndOffset = tokens[tokenIndex << 1] - delta;
                if (tokenEndOffset > lastEnd) {
                    tokens[dest++] = tokenEndOffset;
                    tokens[dest++] = tokens[(tokenIndex << 1) + 1];
                    lastEnd = tokenEndOffset;
                }
            }
            if (dest === tokens.length) {
                // nothing to trim
                return;
            }
            var tmp = new Uint32Array(dest);
            tmp.set(tokens.subarray(0, dest), 0);
            this._lineTokens = tmp.buffer;
        };
        ModelLineTokens.prototype.append = function (_otherTokens) {
            if (_otherTokens === EMPTY_LINE_TOKENS) {
                return;
            }
            if (this._lineTokens === EMPTY_LINE_TOKENS) {
                this._lineTokens = _otherTokens;
                return;
            }
            if (this._lineTokens === null) {
                return;
            }
            if (_otherTokens === null) {
                // cannot determine combined line length...
                this._lineTokens = null;
                return;
            }
            var myTokens = new Uint32Array(this._lineTokens);
            var otherTokens = new Uint32Array(_otherTokens);
            var otherTokensCount = (otherTokens.length >>> 1);
            var result = new Uint32Array(myTokens.length + otherTokens.length);
            result.set(myTokens, 0);
            var dest = myTokens.length;
            var delta = myTokens[myTokens.length - 2];
            for (var i = 0; i < otherTokensCount; i++) {
                result[dest++] = otherTokens[(i << 1)] + delta;
                result[dest++] = otherTokens[(i << 1) + 1];
            }
            this._lineTokens = result.buffer;
        };
        ModelLineTokens.prototype.insert = function (chIndex, textLength) {
            if (!this._lineTokens) {
                // nothing to do
                return;
            }
            var tokens = new Uint32Array(this._lineTokens);
            var tokensCount = (tokens.length >>> 1);
            var fromTokenIndex = lineTokens_1.LineTokens.findIndexInTokensArray(tokens, chIndex);
            if (fromTokenIndex > 0) {
                var fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);
                if (fromTokenStartOffset === chIndex) {
                    fromTokenIndex--;
                }
            }
            for (var tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {
                tokens[tokenIndex << 1] += textLength;
            }
        };
        return ModelLineTokens;
    }());
    var ModelLinesTokens = /** @class */ (function () {
        function ModelLinesTokens(languageIdentifier, tokenizationSupport) {
            this.languageIdentifier = languageIdentifier;
            this.tokenizationSupport = tokenizationSupport;
            this._tokens = [];
            if (this.tokenizationSupport) {
                var initialState = null;
                try {
                    initialState = this.tokenizationSupport.getInitialState();
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                    this.tokenizationSupport = null;
                }
                if (initialState) {
                    this._tokens[0] = new ModelLineTokens(initialState);
                }
            }
            this._invalidLineStartIndex = 0;
            this._lastState = null;
        }
        Object.defineProperty(ModelLinesTokens.prototype, "inValidLineStartIndex", {
            get: function () {
                return this._invalidLineStartIndex;
            },
            enumerable: true,
            configurable: true
        });
        ModelLinesTokens.prototype.getTokens = function (topLevelLanguageId, lineIndex, lineText) {
            var rawLineTokens = null;
            if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {
                rawLineTokens = this._tokens[lineIndex]._lineTokens;
            }
            if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {
                return new lineTokens_1.LineTokens(new Uint32Array(rawLineTokens), lineText);
            }
            var lineTokens = new Uint32Array(2);
            lineTokens[0] = lineText.length;
            lineTokens[1] = getDefaultMetadata(topLevelLanguageId);
            return new lineTokens_1.LineTokens(lineTokens, lineText);
        };
        ModelLinesTokens.prototype.isCheapToTokenize = function (lineNumber) {
            var firstInvalidLineNumber = this._invalidLineStartIndex + 1;
            return (firstInvalidLineNumber >= lineNumber);
        };
        ModelLinesTokens.prototype.hasLinesToTokenize = function (buffer) {
            return (this._invalidLineStartIndex < buffer.getLineCount());
        };
        ModelLinesTokens.prototype.invalidateLine = function (lineIndex) {
            this._setIsInvalid(lineIndex, true);
            if (lineIndex < this._invalidLineStartIndex) {
                this._setIsInvalid(this._invalidLineStartIndex, true);
                this._invalidLineStartIndex = lineIndex;
            }
        };
        ModelLinesTokens.prototype._setIsInvalid = function (lineIndex, invalid) {
            if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {
                this._tokens[lineIndex]._invalid = invalid;
            }
        };
        ModelLinesTokens.prototype._isInvalid = function (lineIndex) {
            if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {
                return this._tokens[lineIndex]._invalid;
            }
            return true;
        };
        ModelLinesTokens.prototype._getState = function (lineIndex) {
            if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {
                return this._tokens[lineIndex]._state;
            }
            return null;
        };
        ModelLinesTokens.prototype._setTokens = function (topLevelLanguageId, lineIndex, lineTextLength, tokens) {
            var target;
            if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {
                target = this._tokens[lineIndex];
            }
            else {
                target = new ModelLineTokens(null);
                this._tokens[lineIndex] = target;
            }
            if (lineTextLength === 0) {
                target._lineTokens = EMPTY_LINE_TOKENS;
                return;
            }
            if (!tokens || tokens.length === 0) {
                tokens = new Uint32Array(2);
                tokens[0] = 0;
                tokens[1] = getDefaultMetadata(topLevelLanguageId);
            }
            lineTokens_1.LineTokens.convertToEndOffset(tokens, lineTextLength);
            target._lineTokens = tokens.buffer;
        };
        ModelLinesTokens.prototype._setState = function (lineIndex, state) {
            if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {
                this._tokens[lineIndex]._state = state;
            }
            else {
                var tmp = new ModelLineTokens(state);
                this._tokens[lineIndex] = tmp;
            }
        };
        //#region Editing
        ModelLinesTokens.prototype.applyEdits = function (range, eolCount, firstLineLength) {
            var deletingLinesCnt = range.endLineNumber - range.startLineNumber;
            var insertingLinesCnt = eolCount;
            var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
            for (var j = editingLinesCnt; j >= 0; j--) {
                this.invalidateLine(range.startLineNumber + j - 1);
            }
            this._acceptDeleteRange(range);
            this._acceptInsertText(new position_1.Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);
        };
        ModelLinesTokens.prototype._acceptDeleteRange = function (range) {
            var firstLineIndex = range.startLineNumber - 1;
            if (firstLineIndex >= this._tokens.length) {
                return;
            }
            if (range.startLineNumber === range.endLineNumber) {
                if (range.startColumn === range.endColumn) {
                    // Nothing to delete
                    return;
                }
                this._tokens[firstLineIndex].delete(range.startColumn - 1, range.endColumn - 1);
                return;
            }
            var firstLine = this._tokens[firstLineIndex];
            firstLine.deleteEnding(range.startColumn - 1);
            var lastLineIndex = range.endLineNumber - 1;
            var lastLineTokens = null;
            if (lastLineIndex < this._tokens.length) {
                var lastLine = this._tokens[lastLineIndex];
                lastLine.deleteBeginning(range.endColumn - 1);
                lastLineTokens = lastLine._lineTokens;
            }
            // Take remaining text on last line and append it to remaining text on first line
            firstLine.append(lastLineTokens);
            // Delete middle lines
            this._tokens.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
        };
        ModelLinesTokens.prototype._acceptInsertText = function (position, eolCount, firstLineLength) {
            if (eolCount === 0 && firstLineLength === 0) {
                // Nothing to insert
                return;
            }
            var lineIndex = position.lineNumber - 1;
            if (lineIndex >= this._tokens.length) {
                return;
            }
            if (eolCount === 0) {
                // Inserting text on one line
                this._tokens[lineIndex].insert(position.column - 1, firstLineLength);
                return;
            }
            var line = this._tokens[lineIndex];
            line.deleteEnding(position.column - 1);
            line.insert(position.column - 1, firstLineLength);
            var insert = new Array(eolCount);
            for (var i = eolCount - 1; i >= 0; i--) {
                insert[i] = new ModelLineTokens(null);
            }
            this._tokens = arrays.arrayInsert(this._tokens, position.lineNumber, insert);
        };
        //#endregion
        //#region Tokenization
        ModelLinesTokens.prototype._tokenizeOneLine = function (buffer, eventBuilder) {
            if (!this.hasLinesToTokenize(buffer)) {
                return buffer.getLineCount() + 1;
            }
            var lineNumber = this._invalidLineStartIndex + 1;
            this._updateTokensUntilLine(buffer, eventBuilder, lineNumber);
            return lineNumber;
        };
        ModelLinesTokens.prototype._tokenizeText = function (buffer, text, state) {
            var r = null;
            try {
                r = this.tokenizationSupport.tokenize2(text, state, 0);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
            if (!r) {
                r = nullMode_1.nullTokenize2(this.languageIdentifier.id, text, state, 0);
            }
            return r;
        };
        ModelLinesTokens.prototype._updateTokensUntilLine = function (buffer, eventBuilder, lineNumber) {
            if (!this.tokenizationSupport) {
                this._invalidLineStartIndex = buffer.getLineCount();
                return;
            }
            var linesLength = buffer.getLineCount();
            var endLineIndex = lineNumber - 1;
            // Validate all states up to and including endLineIndex
            for (var lineIndex = this._invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {
                var endStateIndex = lineIndex + 1;
                var r = null;
                var text = buffer.getLineContent(lineIndex + 1);
                try {
                    // Tokenize only the first X characters
                    var freshState = this._getState(lineIndex).clone();
                    r = this.tokenizationSupport.tokenize2(text, freshState, 0);
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                }
                if (!r) {
                    r = nullMode_1.nullTokenize2(this.languageIdentifier.id, text, this._getState(lineIndex), 0);
                }
                this._setTokens(this.languageIdentifier.id, lineIndex, text.length, r.tokens);
                eventBuilder.registerChangedTokens(lineIndex + 1);
                this._setIsInvalid(lineIndex, false);
                if (endStateIndex < linesLength) {
                    if (this._getState(endStateIndex) !== null && r.endState.equals(this._getState(endStateIndex))) {
                        // The end state of this line remains the same
                        var nextInvalidLineIndex = lineIndex + 1;
                        while (nextInvalidLineIndex < linesLength) {
                            if (this._isInvalid(nextInvalidLineIndex)) {
                                break;
                            }
                            if (nextInvalidLineIndex + 1 < linesLength) {
                                if (this._getState(nextInvalidLineIndex + 1) === null) {
                                    break;
                                }
                            }
                            else {
                                if (this._lastState === null) {
                                    break;
                                }
                            }
                            nextInvalidLineIndex++;
                        }
                        this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, nextInvalidLineIndex);
                        lineIndex = nextInvalidLineIndex - 1; // -1 because the outer loop increments it
                    }
                    else {
                        this._setState(endStateIndex, r.endState);
                    }
                }
                else {
                    this._lastState = r.endState;
                }
            }
            this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, endLineIndex + 1);
        };
        return ModelLinesTokens;
    }());
    exports.ModelLinesTokens = ModelLinesTokens;
    var ModelTokensChangedEventBuilder = /** @class */ (function () {
        function ModelTokensChangedEventBuilder() {
            this._ranges = [];
        }
        ModelTokensChangedEventBuilder.prototype.registerChangedTokens = function (lineNumber) {
            var ranges = this._ranges;
            var rangesLength = ranges.length;
            var previousRange = rangesLength > 0 ? ranges[rangesLength - 1] : null;
            if (previousRange && previousRange.toLineNumber === lineNumber - 1) {
                // extend previous range
                previousRange.toLineNumber++;
            }
            else {
                // insert new range
                ranges[rangesLength] = {
                    fromLineNumber: lineNumber,
                    toLineNumber: lineNumber
                };
            }
        };
        ModelTokensChangedEventBuilder.prototype.build = function () {
            if (this._ranges.length === 0) {
                return null;
            }
            return {
                ranges: this._ranges
            };
        };
        return ModelTokensChangedEventBuilder;
    }());
    exports.ModelTokensChangedEventBuilder = ModelTokensChangedEventBuilder;
});











define(__m[122/*vs/editor/common/model/textModel*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,3/*vs/base/common/event*/,25/*vs/editor/common/model*/,36/*vs/editor/common/modes*/,136/*vs/editor/common/model/editStack*/,24/*vs/editor/common/core/range*/,54/*vs/editor/common/core/selection*/,141/*vs/editor/common/model/textModelEvents*/,14/*vs/base/common/errors*/,8/*vs/base/common/strings*/,139/*vs/editor/common/model/intervalTree*/,9/*vs/base/common/lifecycle*/,115/*vs/base/common/stopwatch*/,58/*vs/editor/common/modes/nullMode*/,46/*vs/editor/common/modes/supports*/,45/*vs/editor/common/modes/supports/richEditBrackets*/,27/*vs/editor/common/core/position*/,73/*vs/editor/common/modes/languageConfigurationRegistry*/,41/*vs/editor/common/model/wordHelper*/,85/*vs/editor/common/model/textModelTokens*/,137/*vs/editor/common/model/indentationGuesser*/,83/*vs/editor/common/config/editorOptions*/,59/*vs/editor/common/model/textModelSearch*/,2/*vs/base/common/winjs.base*/,153/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder*/]), function (require, exports, uri_1, event_1, model, modes_1, editStack_1, range_1, selection_1, textModelEvents_1, errors_1, strings, intervalTree_1, lifecycle_1, stopwatch_1, nullMode_1, supports_1, richEditBrackets_1, position_1, languageConfigurationRegistry_1, wordHelper_1, textModelTokens_1, indentationGuesser_1, editorOptions_1, textModelSearch_1, winjs_base_1, pieceTreeTextBufferBuilder_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function createTextBufferBuilder() {
        return new pieceTreeTextBufferBuilder_1.PieceTreeTextBufferBuilder();
    }
    function createTextBufferFactory(text) {
        var builder = createTextBufferBuilder();
        builder.acceptChunk(text);
        return builder.finish();
    }
    exports.createTextBufferFactory = createTextBufferFactory;
    function createTextBufferFactoryFromStream(stream, filter) {
        return new winjs_base_1.TPromise(function (c, e) {
            var done = false;
            var builder = createTextBufferBuilder();
            stream.on('data', function (chunk) {
                if (filter) {
                    chunk = filter(chunk);
                }
                builder.acceptChunk(chunk);
            });
            stream.on('error', function (error) {
                if (!done) {
                    done = true;
                    e(error);
                }
            });
            stream.on('end', function () {
                if (!done) {
                    done = true;
                    c(builder.finish());
                }
            });
        });
    }
    exports.createTextBufferFactoryFromStream = createTextBufferFactoryFromStream;
    function createTextBufferFactoryFromSnapshot(snapshot) {
        var builder = createTextBufferBuilder();
        var chunk;
        while (typeof (chunk = snapshot.read()) === 'string') {
            builder.acceptChunk(chunk);
        }
        return builder.finish();
    }
    exports.createTextBufferFactoryFromSnapshot = createTextBufferFactoryFromSnapshot;
    function createTextBuffer(value, defaultEOL) {
        var factory = (typeof value === 'string' ? createTextBufferFactory(value) : value);
        return factory.create(defaultEOL);
    }
    exports.createTextBuffer = createTextBuffer;
    var MODEL_ID = 0;
    /**
     * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.
     */
    function singleLetter(result) {
        var LETTERS_CNT = (90 /* Z */ - 65 /* A */ + 1);
        result = result % (2 * LETTERS_CNT);
        if (result < LETTERS_CNT) {
            return String.fromCharCode(97 /* a */ + result);
        }
        return String.fromCharCode(65 /* A */ + result - LETTERS_CNT);
    }
    var LIMIT_FIND_COUNT = 999;
    exports.LONG_LINE_BOUNDARY = 10000;
    var TextModelSnapshot = /** @class */ (function () {
        function TextModelSnapshot(source) {
            this._source = source;
            this._eos = false;
        }
        TextModelSnapshot.prototype.read = function () {
            if (this._eos) {
                return null;
            }
            var result = [], resultCnt = 0, resultLength = 0;
            do {
                var tmp = this._source.read();
                if (tmp === null) {
                    // end-of-stream
                    this._eos = true;
                    if (resultCnt === 0) {
                        return null;
                    }
                    else {
                        return result.join('');
                    }
                }
                if (tmp.length > 0) {
                    result[resultCnt++] = tmp;
                    resultLength += tmp.length;
                }
                if (resultLength >= 64 * 1024) {
                    return result.join('');
                }
            } while (true);
        };
        return TextModelSnapshot;
    }());
    var TextModel = /** @class */ (function (_super) {
        __extends(TextModel, _super);
        //#endregion
        function TextModel(source, creationOptions, languageIdentifier, associatedResource) {
            if (associatedResource === void 0) { associatedResource = null; }
            var _this = _super.call(this) || this;
            //#region Events
            _this._onWillDispose = _this._register(new event_1.Emitter());
            _this.onWillDispose = _this._onWillDispose.event;
            _this._onDidChangeDecorations = _this._register(new DidChangeDecorationsEmitter());
            _this.onDidChangeDecorations = _this._onDidChangeDecorations.event;
            _this._onDidChangeLanguage = _this._register(new event_1.Emitter());
            _this.onDidChangeLanguage = _this._onDidChangeLanguage.event;
            _this._onDidChangeLanguageConfiguration = _this._register(new event_1.Emitter());
            _this.onDidChangeLanguageConfiguration = _this._onDidChangeLanguageConfiguration.event;
            _this._onDidChangeTokens = _this._register(new event_1.Emitter());
            _this.onDidChangeTokens = _this._onDidChangeTokens.event;
            _this._onDidChangeOptions = _this._register(new event_1.Emitter());
            _this.onDidChangeOptions = _this._onDidChangeOptions.event;
            _this._eventEmitter = _this._register(new DidChangeContentEmitter());
            // Generate a new unique model id
            MODEL_ID++;
            _this.id = '$model' + MODEL_ID;
            _this.isForSimpleWidget = creationOptions.isForSimpleWidget;
            if (typeof associatedResource === 'undefined' || associatedResource === null) {
                _this._associatedResource = uri_1.default.parse('inmemory://model/' + MODEL_ID);
            }
            else {
                _this._associatedResource = associatedResource;
            }
            _this._attachedEditorCount = 0;
            _this._buffer = createTextBuffer(source, creationOptions.defaultEOL);
            _this._options = TextModel.resolveOptions(_this._buffer, creationOptions);
            var bufferLineCount = _this._buffer.getLineCount();
            var bufferTextLength = _this._buffer.getValueLengthInRange(new range_1.Range(1, 1, bufferLineCount, _this._buffer.getLineLength(bufferLineCount) + 1), model.EndOfLinePreference.TextDefined);
            // !!! Make a decision in the ctor and permanently respect this decision !!!
            // If a model is too large at construction time, it will never get tokenized,
            // under no circumstances.
            if (creationOptions.largeFileOptimizations) {
                _this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)
                    || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));
            }
            else {
                _this._isTooLargeForTokenization = false;
            }
            _this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);
            _this._setVersionId(1);
            _this._isDisposed = false;
            _this._isDisposing = false;
            _this._languageIdentifier = languageIdentifier || nullMode_1.NULL_LANGUAGE_IDENTIFIER;
            _this._tokenizationListener = modes_1.TokenizationRegistry.onDidChange(function (e) {
                if (e.changedLanguages.indexOf(_this._languageIdentifier.language) === -1) {
                    return;
                }
                _this._resetTokenizationState();
                _this.emitModelTokensChangedEvent({
                    ranges: [{
                            fromLineNumber: 1,
                            toLineNumber: _this.getLineCount()
                        }]
                });
                if (_this._shouldAutoTokenize()) {
                    _this._warmUpTokens();
                }
            });
            _this._revalidateTokensTimeout = -1;
            _this._languageRegistryListener = languageConfigurationRegistry_1.LanguageConfigurationRegistry.onDidChange(function (e) {
                if (e.languageIdentifier.id === _this._languageIdentifier.id) {
                    _this._onDidChangeLanguageConfiguration.fire({});
                }
            });
            _this._resetTokenizationState();
            _this._instanceId = singleLetter(MODEL_ID);
            _this._lastDecorationId = 0;
            _this._decorations = Object.create(null);
            _this._decorationsTree = new DecorationsTrees();
            _this._commandManager = new editStack_1.EditStack(_this);
            _this._isUndoing = false;
            _this._isRedoing = false;
            _this._trimAutoWhitespaceLines = null;
            return _this;
        }
        TextModel.createFromString = function (text, options, languageIdentifier, uri) {
            if (options === void 0) { options = TextModel.DEFAULT_CREATION_OPTIONS; }
            if (languageIdentifier === void 0) { languageIdentifier = null; }
            if (uri === void 0) { uri = null; }
            return new TextModel(text, options, languageIdentifier, uri);
        };
        TextModel.resolveOptions = function (textBuffer, options) {
            if (options.detectIndentation) {
                var guessedIndentation = indentationGuesser_1.guessIndentation(textBuffer, options.tabSize, options.insertSpaces);
                return new model.TextModelResolvedOptions({
                    tabSize: guessedIndentation.tabSize,
                    insertSpaces: guessedIndentation.insertSpaces,
                    trimAutoWhitespace: options.trimAutoWhitespace,
                    defaultEOL: options.defaultEOL
                });
            }
            return new model.TextModelResolvedOptions({
                tabSize: options.tabSize,
                insertSpaces: options.insertSpaces,
                trimAutoWhitespace: options.trimAutoWhitespace,
                defaultEOL: options.defaultEOL
            });
        };
        TextModel.prototype.onDidChangeRawContentFast = function (listener) {
            return this._eventEmitter.fastEvent(function (e) { return listener(e.rawContentChangedEvent); });
        };
        TextModel.prototype.onDidChangeRawContent = function (listener) {
            return this._eventEmitter.slowEvent(function (e) { return listener(e.rawContentChangedEvent); });
        };
        TextModel.prototype.onDidChangeContent = function (listener) {
            return this._eventEmitter.slowEvent(function (e) { return listener(e.contentChangedEvent); });
        };
        TextModel.prototype.dispose = function () {
            this._isDisposing = true;
            this._onWillDispose.fire();
            this._commandManager = null;
            this._decorations = null;
            this._decorationsTree = null;
            this._tokenizationListener.dispose();
            this._languageRegistryListener.dispose();
            this._clearTimers();
            this._tokens = null;
            this._isDisposed = true;
            // Null out members, such that any use of a disposed model will throw exceptions sooner rather than later
            this._buffer = null;
            _super.prototype.dispose.call(this);
            this._isDisposing = false;
        };
        TextModel.prototype._assertNotDisposed = function () {
            if (this._isDisposed) {
                throw new Error('Model is disposed!');
            }
        };
        TextModel.prototype.equalsTextBuffer = function (other) {
            this._assertNotDisposed();
            return this._buffer.equals(other);
        };
        TextModel.prototype._emitContentChangedEvent = function (rawChange, change) {
            if (this._isDisposing) {
                // Do not confuse listeners by emitting any event after disposing
                return;
            }
            this._eventEmitter.fire(new textModelEvents_1.InternalModelContentChangeEvent(rawChange, change));
        };
        TextModel.prototype.setValue = function (value) {
            this._assertNotDisposed();
            if (value === null) {
                // There's nothing to do
                return;
            }
            var textBuffer = createTextBuffer(value, this._options.defaultEOL);
            this.setValueFromTextBuffer(textBuffer);
        };
        TextModel.prototype._createContentChanged2 = function (range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {
            return {
                changes: [{
                        range: range,
                        rangeOffset: rangeOffset,
                        rangeLength: rangeLength,
                        text: text,
                    }],
                eol: this._buffer.getEOL(),
                versionId: this.getVersionId(),
                isUndoing: isUndoing,
                isRedoing: isRedoing,
                isFlush: isFlush
            };
        };
        TextModel.prototype.setValueFromTextBuffer = function (textBuffer) {
            this._assertNotDisposed();
            if (textBuffer === null) {
                // There's nothing to do
                return;
            }
            var oldFullModelRange = this.getFullModelRange();
            var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
            var endLineNumber = this.getLineCount();
            var endColumn = this.getLineMaxColumn(endLineNumber);
            this._buffer = textBuffer;
            this._increaseVersionId();
            // Cancel tokenization, clear all tokens and begin tokenizing
            this._resetTokenizationState();
            // Destroy all my decorations
            this._decorations = Object.create(null);
            this._decorationsTree = new DecorationsTrees();
            // Destroy my edit history and settings
            this._commandManager = new editStack_1.EditStack(this);
            this._trimAutoWhitespaceLines = null;
            this._emitContentChangedEvent(new textModelEvents_1.ModelRawContentChangedEvent([
                new textModelEvents_1.ModelRawFlush()
            ], this._versionId, false, false), this._createContentChanged2(new range_1.Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));
        };
        TextModel.prototype.setEOL = function (eol) {
            this._assertNotDisposed();
            var newEOL = (eol === model.EndOfLineSequence.CRLF ? '\r\n' : '\n');
            if (this._buffer.getEOL() === newEOL) {
                // Nothing to do
                return;
            }
            var oldFullModelRange = this.getFullModelRange();
            var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
            var endLineNumber = this.getLineCount();
            var endColumn = this.getLineMaxColumn(endLineNumber);
            this._onBeforeEOLChange();
            this._buffer.setEOL(newEOL);
            this._increaseVersionId();
            this._onAfterEOLChange();
            this._emitContentChangedEvent(new textModelEvents_1.ModelRawContentChangedEvent([
                new textModelEvents_1.ModelRawEOLChanged()
            ], this._versionId, false, false), this._createContentChanged2(new range_1.Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));
        };
        TextModel.prototype._onBeforeEOLChange = function () {
            // Ensure all decorations get their `range` set.
            var versionId = this.getVersionId();
            var allDecorations = this._decorationsTree.search(0, false, false, versionId);
            this._ensureNodesHaveRanges(allDecorations);
        };
        TextModel.prototype._onAfterEOLChange = function () {
            // Transform back `range` to offsets
            var versionId = this.getVersionId();
            var allDecorations = this._decorationsTree.collectNodesPostOrder();
            for (var i = 0, len = allDecorations.length; i < len; i++) {
                var node = allDecorations[i];
                var delta = node.cachedAbsoluteStart - node.start;
                var startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);
                var endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);
                node.cachedAbsoluteStart = startOffset;
                node.cachedAbsoluteEnd = endOffset;
                node.cachedVersionId = versionId;
                node.start = startOffset - delta;
                node.end = endOffset - delta;
                intervalTree_1.recomputeMaxEnd(node);
            }
        };
        TextModel.prototype._resetTokenizationState = function () {
            this._clearTimers();
            var tokenizationSupport = (this._isTooLargeForTokenization
                ? null
                : modes_1.TokenizationRegistry.get(this._languageIdentifier.language));
            this._tokens = new textModelTokens_1.ModelLinesTokens(this._languageIdentifier, tokenizationSupport);
            this._beginBackgroundTokenization();
        };
        TextModel.prototype._clearTimers = function () {
            if (this._revalidateTokensTimeout !== -1) {
                clearTimeout(this._revalidateTokensTimeout);
                this._revalidateTokensTimeout = -1;
            }
        };
        TextModel.prototype.onBeforeAttached = function () {
            this._attachedEditorCount++;
            // Warm up tokens for the editor
            this._warmUpTokens();
        };
        TextModel.prototype.onBeforeDetached = function () {
            this._attachedEditorCount--;
        };
        TextModel.prototype._shouldAutoTokenize = function () {
            return this.isAttachedToEditor();
        };
        TextModel.prototype.isAttachedToEditor = function () {
            return this._attachedEditorCount > 0;
        };
        TextModel.prototype.getAttachedEditorCount = function () {
            return this._attachedEditorCount;
        };
        TextModel.prototype.isTooLargeForSyncing = function () {
            return this._isTooLargeForSyncing;
        };
        TextModel.prototype.isTooLargeForTokenization = function () {
            return this._isTooLargeForTokenization;
        };
        TextModel.prototype.isDisposed = function () {
            return this._isDisposed;
        };
        TextModel.prototype.isDominatedByLongLines = function () {
            this._assertNotDisposed();
            if (this.isTooLargeForTokenization()) {
                // Cannot word wrap huge files anyways, so it doesn't really matter
                return false;
            }
            var smallLineCharCount = 0;
            var longLineCharCount = 0;
            var lineCount = this._buffer.getLineCount();
            for (var lineNumber = 1; lineNumber <= lineCount; lineNumber++) {
                var lineLength = this._buffer.getLineLength(lineNumber);
                if (lineLength >= exports.LONG_LINE_BOUNDARY) {
                    longLineCharCount += lineLength;
                }
                else {
                    smallLineCharCount += lineLength;
                }
            }
            return (longLineCharCount > smallLineCharCount);
        };
        Object.defineProperty(TextModel.prototype, "uri", {
            get: function () {
                return this._associatedResource;
            },
            enumerable: true,
            configurable: true
        });
        //#region Options
        TextModel.prototype.getOptions = function () {
            this._assertNotDisposed();
            return this._options;
        };
        TextModel.prototype.updateOptions = function (_newOpts) {
            this._assertNotDisposed();
            var tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;
            var insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;
            var trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;
            var newOpts = new model.TextModelResolvedOptions({
                tabSize: tabSize,
                insertSpaces: insertSpaces,
                defaultEOL: this._options.defaultEOL,
                trimAutoWhitespace: trimAutoWhitespace
            });
            if (this._options.equals(newOpts)) {
                return;
            }
            var e = this._options.createChangeEvent(newOpts);
            this._options = newOpts;
            this._onDidChangeOptions.fire(e);
        };
        TextModel.prototype.detectIndentation = function (defaultInsertSpaces, defaultTabSize) {
            this._assertNotDisposed();
            var guessedIndentation = indentationGuesser_1.guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);
            this.updateOptions({
                insertSpaces: guessedIndentation.insertSpaces,
                tabSize: guessedIndentation.tabSize
            });
        };
        TextModel._normalizeIndentationFromWhitespace = function (str, tabSize, insertSpaces) {
            var spacesCnt = 0;
            for (var i = 0; i < str.length; i++) {
                if (str.charAt(i) === '\t') {
                    spacesCnt += tabSize;
                }
                else {
                    spacesCnt++;
                }
            }
            var result = '';
            if (!insertSpaces) {
                var tabsCnt = Math.floor(spacesCnt / tabSize);
                spacesCnt = spacesCnt % tabSize;
                for (var i = 0; i < tabsCnt; i++) {
                    result += '\t';
                }
            }
            for (var i = 0; i < spacesCnt; i++) {
                result += ' ';
            }
            return result;
        };
        TextModel.normalizeIndentation = function (str, tabSize, insertSpaces) {
            var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);
            if (firstNonWhitespaceIndex === -1) {
                firstNonWhitespaceIndex = str.length;
            }
            return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), tabSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);
        };
        TextModel.prototype.normalizeIndentation = function (str) {
            this._assertNotDisposed();
            return TextModel.normalizeIndentation(str, this._options.tabSize, this._options.insertSpaces);
        };
        TextModel.prototype.getOneIndent = function () {
            this._assertNotDisposed();
            var tabSize = this._options.tabSize;
            var insertSpaces = this._options.insertSpaces;
            if (insertSpaces) {
                var result = '';
                for (var i = 0; i < tabSize; i++) {
                    result += ' ';
                }
                return result;
            }
            else {
                return '\t';
            }
        };
        //#endregion
        //#region Reading
        TextModel.prototype.getVersionId = function () {
            this._assertNotDisposed();
            return this._versionId;
        };
        TextModel.prototype.mightContainRTL = function () {
            return this._buffer.mightContainRTL();
        };
        TextModel.prototype.mightContainNonBasicASCII = function () {
            return this._buffer.mightContainNonBasicASCII();
        };
        TextModel.prototype.getAlternativeVersionId = function () {
            this._assertNotDisposed();
            return this._alternativeVersionId;
        };
        TextModel.prototype.getOffsetAt = function (rawPosition) {
            this._assertNotDisposed();
            var position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, false);
            return this._buffer.getOffsetAt(position.lineNumber, position.column);
        };
        TextModel.prototype.getPositionAt = function (rawOffset) {
            this._assertNotDisposed();
            var offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));
            return this._buffer.getPositionAt(offset);
        };
        TextModel.prototype._increaseVersionId = function () {
            this._setVersionId(this._versionId + 1);
        };
        TextModel.prototype._setVersionId = function (newVersionId) {
            this._versionId = newVersionId;
            this._alternativeVersionId = this._versionId;
        };
        TextModel.prototype._overwriteAlternativeVersionId = function (newAlternativeVersionId) {
            this._alternativeVersionId = newAlternativeVersionId;
        };
        TextModel.prototype.getValue = function (eol, preserveBOM) {
            if (preserveBOM === void 0) { preserveBOM = false; }
            this._assertNotDisposed();
            var fullModelRange = this.getFullModelRange();
            var fullModelValue = this.getValueInRange(fullModelRange, eol);
            if (preserveBOM) {
                return this._buffer.getBOM() + fullModelValue;
            }
            return fullModelValue;
        };
        TextModel.prototype.createSnapshot = function (preserveBOM) {
            if (preserveBOM === void 0) { preserveBOM = false; }
            return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));
        };
        TextModel.prototype.getValueLength = function (eol, preserveBOM) {
            if (preserveBOM === void 0) { preserveBOM = false; }
            this._assertNotDisposed();
            var fullModelRange = this.getFullModelRange();
            var fullModelValue = this.getValueLengthInRange(fullModelRange, eol);
            if (preserveBOM) {
                return this._buffer.getBOM().length + fullModelValue;
            }
            return fullModelValue;
        };
        TextModel.prototype.getValueInRange = function (rawRange, eol) {
            if (eol === void 0) { eol = model.EndOfLinePreference.TextDefined; }
            this._assertNotDisposed();
            return this._buffer.getValueInRange(this.validateRange(rawRange), eol);
        };
        TextModel.prototype.getValueLengthInRange = function (rawRange, eol) {
            if (eol === void 0) { eol = model.EndOfLinePreference.TextDefined; }
            this._assertNotDisposed();
            return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);
        };
        TextModel.prototype.getLineCount = function () {
            this._assertNotDisposed();
            return this._buffer.getLineCount();
        };
        TextModel.prototype.getLineContent = function (lineNumber) {
            this._assertNotDisposed();
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value for lineNumber');
            }
            return this._buffer.getLineContent(lineNumber);
        };
        TextModel.prototype.getLineLength = function (lineNumber) {
            this._assertNotDisposed();
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value for lineNumber');
            }
            return this._buffer.getLineLength(lineNumber);
        };
        TextModel.prototype.getLinesContent = function () {
            this._assertNotDisposed();
            return this._buffer.getLinesContent();
        };
        TextModel.prototype.getEOL = function () {
            this._assertNotDisposed();
            return this._buffer.getEOL();
        };
        TextModel.prototype.getLineMinColumn = function (lineNumber) {
            this._assertNotDisposed();
            return 1;
        };
        TextModel.prototype.getLineMaxColumn = function (lineNumber) {
            this._assertNotDisposed();
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value for lineNumber');
            }
            return this._buffer.getLineLength(lineNumber) + 1;
        };
        TextModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
            this._assertNotDisposed();
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value for lineNumber');
            }
            return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);
        };
        TextModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
            this._assertNotDisposed();
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value for lineNumber');
            }
            return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);
        };
        /**
         * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.
         * Will try to not allocate if possible.
         */
        TextModel.prototype._validateRangeRelaxedNoAllocations = function (range) {
            var linesCount = this._buffer.getLineCount();
            var initialStartLineNumber = range.startLineNumber;
            var initialStartColumn = range.startColumn;
            var startLineNumber;
            var startColumn;
            if (initialStartLineNumber < 1) {
                startLineNumber = 1;
                startColumn = 1;
            }
            else if (initialStartLineNumber > linesCount) {
                startLineNumber = linesCount;
                startColumn = this.getLineMaxColumn(startLineNumber);
            }
            else {
                startLineNumber = initialStartLineNumber | 0;
                if (initialStartColumn <= 1) {
                    startColumn = 1;
                }
                else {
                    var maxColumn = this.getLineMaxColumn(startLineNumber);
                    if (initialStartColumn >= maxColumn) {
                        startColumn = maxColumn;
                    }
                    else {
                        startColumn = initialStartColumn | 0;
                    }
                }
            }
            var initialEndLineNumber = range.endLineNumber;
            var initialEndColumn = range.endColumn;
            var endLineNumber;
            var endColumn;
            if (initialEndLineNumber < 1) {
                endLineNumber = 1;
                endColumn = 1;
            }
            else if (initialEndLineNumber > linesCount) {
                endLineNumber = linesCount;
                endColumn = this.getLineMaxColumn(endLineNumber);
            }
            else {
                endLineNumber = initialEndLineNumber | 0;
                if (initialEndColumn <= 1) {
                    endColumn = 1;
                }
                else {
                    var maxColumn = this.getLineMaxColumn(endLineNumber);
                    if (initialEndColumn >= maxColumn) {
                        endColumn = maxColumn;
                    }
                    else {
                        endColumn = initialEndColumn | 0;
                    }
                }
            }
            if (initialStartLineNumber === startLineNumber
                && initialStartColumn === startColumn
                && initialEndLineNumber === endLineNumber
                && initialEndColumn === endColumn
                && range instanceof range_1.Range
                && !(range instanceof selection_1.Selection)) {
                return range;
            }
            return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);
        };
        /**
         * @param strict Do NOT allow a position inside a high-low surrogate pair
         */
        TextModel.prototype._isValidPosition = function (lineNumber, column, strict) {
            if (isNaN(lineNumber)) {
                return false;
            }
            if (lineNumber < 1) {
                return false;
            }
            var lineCount = this._buffer.getLineCount();
            if (lineNumber > lineCount) {
                return false;
            }
            if (isNaN(column)) {
                return false;
            }
            if (column < 1) {
                return false;
            }
            var maxColumn = this.getLineMaxColumn(lineNumber);
            if (column > maxColumn) {
                return false;
            }
            if (strict) {
                if (column > 1) {
                    var charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);
                    if (strings.isHighSurrogate(charCodeBefore)) {
                        return false;
                    }
                }
            }
            return true;
        };
        /**
         * @param strict Do NOT allow a position inside a high-low surrogate pair
         */
        TextModel.prototype._validatePosition = function (_lineNumber, _column, strict) {
            var lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);
            var column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);
            var lineCount = this._buffer.getLineCount();
            if (lineNumber < 1) {
                return new position_1.Position(1, 1);
            }
            if (lineNumber > lineCount) {
                return new position_1.Position(lineCount, this.getLineMaxColumn(lineCount));
            }
            if (column <= 1) {
                return new position_1.Position(lineNumber, 1);
            }
            var maxColumn = this.getLineMaxColumn(lineNumber);
            if (column >= maxColumn) {
                return new position_1.Position(lineNumber, maxColumn);
            }
            if (strict) {
                // If the position would end up in the middle of a high-low surrogate pair,
                // we move it to before the pair
                // !!At this point, column > 1
                var charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);
                if (strings.isHighSurrogate(charCodeBefore)) {
                    return new position_1.Position(lineNumber, column - 1);
                }
            }
            return new position_1.Position(lineNumber, column);
        };
        TextModel.prototype.validatePosition = function (position) {
            this._assertNotDisposed();
            // Avoid object allocation and cover most likely case
            if (position instanceof position_1.Position) {
                if (this._isValidPosition(position.lineNumber, position.column, true)) {
                    return position;
                }
            }
            return this._validatePosition(position.lineNumber, position.column, true);
        };
        /**
         * @param strict Do NOT allow a range to have its boundaries inside a high-low surrogate pair
         */
        TextModel.prototype._isValidRange = function (range, strict) {
            var startLineNumber = range.startLineNumber;
            var startColumn = range.startColumn;
            var endLineNumber = range.endLineNumber;
            var endColumn = range.endColumn;
            if (!this._isValidPosition(startLineNumber, startColumn, false)) {
                return false;
            }
            if (!this._isValidPosition(endLineNumber, endColumn, false)) {
                return false;
            }
            if (strict) {
                var charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);
                var charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);
                var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);
                var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);
                if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
                    return true;
                }
                return false;
            }
            return true;
        };
        TextModel.prototype.validateRange = function (_range) {
            this._assertNotDisposed();
            // Avoid object allocation and cover most likely case
            if ((_range instanceof range_1.Range) && !(_range instanceof selection_1.Selection)) {
                if (this._isValidRange(_range, true)) {
                    return _range;
                }
            }
            var start = this._validatePosition(_range.startLineNumber, _range.startColumn, false);
            var end = this._validatePosition(_range.endLineNumber, _range.endColumn, false);
            var startLineNumber = start.lineNumber;
            var startColumn = start.column;
            var endLineNumber = end.lineNumber;
            var endColumn = end.column;
            var charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);
            var charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);
            var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);
            var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);
            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
                return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);
            }
            if (startLineNumber === endLineNumber && startColumn === endColumn) {
                // do not expand a collapsed range, simply move it to a valid location
                return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);
            }
            if (startInsideSurrogatePair && endInsideSurrogatePair) {
                // expand range at both ends
                return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);
            }
            if (startInsideSurrogatePair) {
                // only expand range at the start
                return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);
            }
            // only expand range at the end
            return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);
        };
        TextModel.prototype.modifyPosition = function (rawPosition, offset) {
            this._assertNotDisposed();
            var candidate = this.getOffsetAt(rawPosition) + offset;
            return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));
        };
        TextModel.prototype.getFullModelRange = function () {
            this._assertNotDisposed();
            var lineCount = this.getLineCount();
            return new range_1.Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));
        };
        TextModel.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {
            return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
        };
        TextModel.prototype.findMatches = function (searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount) {
            if (limitResultCount === void 0) { limitResultCount = LIMIT_FIND_COUNT; }
            this._assertNotDisposed();
            var searchRange;
            if (range_1.Range.isIRange(rawSearchScope)) {
                searchRange = this.validateRange(rawSearchScope);
            }
            else {
                searchRange = this.getFullModelRange();
            }
            if (!isRegex && searchString.indexOf('\n') < 0) {
                // not regex, not multi line
                var searchParams = new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators);
                var searchData = searchParams.parseSearchRequest();
                if (!searchData) {
                    return [];
                }
                return this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
            }
            return textModelSearch_1.TextModelSearch.findMatches(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);
        };
        TextModel.prototype.findNextMatch = function (searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {
            this._assertNotDisposed();
            var searchStart = this.validatePosition(rawSearchStart);
            if (!isRegex && searchString.indexOf('\n') < 0) {
                var searchParams = new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators);
                var searchData = searchParams.parseSearchRequest();
                var lineCount = this.getLineCount();
                var searchRange = new range_1.Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));
                var ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);
                textModelSearch_1.TextModelSearch.findNextMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);
                if (ret.length > 0) {
                    return ret[0];
                }
                searchRange = new range_1.Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));
                ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);
                if (ret.length > 0) {
                    return ret[0];
                }
                return null;
            }
            return textModelSearch_1.TextModelSearch.findNextMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);
        };
        TextModel.prototype.findPreviousMatch = function (searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {
            this._assertNotDisposed();
            var searchStart = this.validatePosition(rawSearchStart);
            return textModelSearch_1.TextModelSearch.findPreviousMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);
        };
        //#endregion
        //#region Editing
        TextModel.prototype.pushStackElement = function () {
            this._commandManager.pushStackElement();
        };
        TextModel.prototype.pushEOL = function (eol) {
            var currentEOL = (this.getEOL() === '\n' ? model.EndOfLineSequence.LF : model.EndOfLineSequence.CRLF);
            if (currentEOL === eol) {
                return;
            }
            try {
                this._onDidChangeDecorations.beginDeferredEmit();
                this._eventEmitter.beginDeferredEmit();
                this._commandManager.pushEOL(eol);
            }
            finally {
                this._eventEmitter.endDeferredEmit();
                this._onDidChangeDecorations.endDeferredEmit();
            }
        };
        TextModel.prototype.pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {
            try {
                this._onDidChangeDecorations.beginDeferredEmit();
                this._eventEmitter.beginDeferredEmit();
                return this._pushEditOperations(beforeCursorState, editOperations, cursorStateComputer);
            }
            finally {
                this._eventEmitter.endDeferredEmit();
                this._onDidChangeDecorations.endDeferredEmit();
            }
        };
        TextModel.prototype._pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {
            var _this = this;
            if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
                // Go through each saved line number and insert a trim whitespace edit
                // if it is safe to do so (no conflicts with other edits).
                var incomingEdits = editOperations.map(function (op) {
                    return {
                        range: _this.validateRange(op.range),
                        text: op.text
                    };
                });
                // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor
                // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace
                var editsAreNearCursors = true;
                for (var i = 0, len = beforeCursorState.length; i < len; i++) {
                    var sel = beforeCursorState[i];
                    var foundEditNearSel = false;
                    for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
                        var editRange = incomingEdits[j].range;
                        var selIsAbove = editRange.startLineNumber > sel.endLineNumber;
                        var selIsBelow = sel.startLineNumber > editRange.endLineNumber;
                        if (!selIsAbove && !selIsBelow) {
                            foundEditNearSel = true;
                            break;
                        }
                    }
                    if (!foundEditNearSel) {
                        editsAreNearCursors = false;
                        break;
                    }
                }
                if (editsAreNearCursors) {
                    for (var i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {
                        var trimLineNumber = this._trimAutoWhitespaceLines[i];
                        var maxLineColumn = this.getLineMaxColumn(trimLineNumber);
                        var allowTrimLine = true;
                        for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
                            var editRange = incomingEdits[j].range;
                            var editText = incomingEdits[j].text;
                            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {
                                // `trimLine` is completely outside this edit
                                continue;
                            }
                            // At this point:
                            //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber
                            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn
                                && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\n') {
                                // This edit inserts a new line (and maybe other text) after `trimLine`
                                continue;
                            }
                            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1
                                && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\n') {
                                // This edit inserts a new line (and maybe other text) before `trimLine`
                                continue;
                            }
                            // Looks like we can't trim this line as it would interfere with an incoming edit
                            allowTrimLine = false;
                            break;
                        }
                        if (allowTrimLine) {
                            editOperations.push({
                                range: new range_1.Range(trimLineNumber, 1, trimLineNumber, maxLineColumn),
                                text: null
                            });
                        }
                    }
                }
                this._trimAutoWhitespaceLines = null;
            }
            return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);
        };
        TextModel.prototype.applyEdits = function (rawOperations) {
            try {
                this._onDidChangeDecorations.beginDeferredEmit();
                this._eventEmitter.beginDeferredEmit();
                return this._applyEdits(rawOperations);
            }
            finally {
                this._eventEmitter.endDeferredEmit();
                this._onDidChangeDecorations.endDeferredEmit();
            }
        };
        TextModel._eolCount = function (text) {
            var eolCount = 0;
            var firstLineLength = 0;
            for (var i = 0, len = text.length; i < len; i++) {
                var chr = text.charCodeAt(i);
                if (chr === 13 /* CarriageReturn */) {
                    if (eolCount === 0) {
                        firstLineLength = i;
                    }
                    eolCount++;
                    if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* LineFeed */) {
                        // \r\n... case
                        i++; // skip \n
                    }
                    else {
                        // \r... case
                    }
                }
                else if (chr === 10 /* LineFeed */) {
                    if (eolCount === 0) {
                        firstLineLength = i;
                    }
                    eolCount++;
                }
            }
            if (eolCount === 0) {
                firstLineLength = text.length;
            }
            return [eolCount, firstLineLength];
        };
        TextModel.prototype._applyEdits = function (rawOperations) {
            for (var i = 0, len = rawOperations.length; i < len; i++) {
                rawOperations[i].range = this.validateRange(rawOperations[i].range);
            }
            var oldLineCount = this._buffer.getLineCount();
            var result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace);
            var newLineCount = this._buffer.getLineCount();
            var contentChanges = result.changes;
            this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;
            if (contentChanges.length !== 0) {
                var rawContentChanges = [];
                var lineCount = oldLineCount;
                for (var i = 0, len = contentChanges.length; i < len; i++) {
                    var change = contentChanges[i];
                    var _a = TextModel._eolCount(change.text), eolCount = _a[0], firstLineLength = _a[1];
                    this._tokens.applyEdits(change.range, eolCount, firstLineLength);
                    this._onDidChangeDecorations.fire();
                    this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);
                    var startLineNumber = change.range.startLineNumber;
                    var endLineNumber = change.range.endLineNumber;
                    var deletingLinesCnt = endLineNumber - startLineNumber;
                    var insertingLinesCnt = eolCount;
                    var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
                    var changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);
                    for (var j = editingLinesCnt; j >= 0; j--) {
                        var editLineNumber = startLineNumber + j;
                        var currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;
                        rawContentChanges.push(new textModelEvents_1.ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));
                    }
                    if (editingLinesCnt < deletingLinesCnt) {
                        // Must delete some lines
                        var spliceStartLineNumber = startLineNumber + editingLinesCnt;
                        rawContentChanges.push(new textModelEvents_1.ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));
                    }
                    if (editingLinesCnt < insertingLinesCnt) {
                        // Must insert some lines
                        var spliceLineNumber = startLineNumber + editingLinesCnt;
                        var cnt = insertingLinesCnt - editingLinesCnt;
                        var fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;
                        var newLines = [];
                        for (var i_1 = 0; i_1 < cnt; i_1++) {
                            var lineNumber = fromLineNumber + i_1;
                            newLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);
                        }
                        rawContentChanges.push(new textModelEvents_1.ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));
                    }
                    lineCount += changeLineCountDelta;
                }
                this._increaseVersionId();
                this._emitContentChangedEvent(new textModelEvents_1.ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {
                    changes: contentChanges,
                    eol: this._buffer.getEOL(),
                    versionId: this.getVersionId(),
                    isUndoing: this._isUndoing,
                    isRedoing: this._isRedoing,
                    isFlush: false
                });
            }
            if (this._tokens.hasLinesToTokenize(this._buffer)) {
                this._beginBackgroundTokenization();
            }
            return result.reverseEdits;
        };
        TextModel.prototype._undo = function () {
            this._isUndoing = true;
            var r = this._commandManager.undo();
            this._isUndoing = false;
            if (!r) {
                return null;
            }
            this._overwriteAlternativeVersionId(r.recordedVersionId);
            return r.selections;
        };
        TextModel.prototype.undo = function () {
            try {
                this._onDidChangeDecorations.beginDeferredEmit();
                this._eventEmitter.beginDeferredEmit();
                return this._undo();
            }
            finally {
                this._eventEmitter.endDeferredEmit();
                this._onDidChangeDecorations.endDeferredEmit();
            }
        };
        TextModel.prototype.canUndo = function () {
            return this._commandManager.canUndo();
        };
        TextModel.prototype._redo = function () {
            this._isRedoing = true;
            var r = this._commandManager.redo();
            this._isRedoing = false;
            if (!r) {
                return null;
            }
            this._overwriteAlternativeVersionId(r.recordedVersionId);
            return r.selections;
        };
        TextModel.prototype.redo = function () {
            try {
                this._onDidChangeDecorations.beginDeferredEmit();
                this._eventEmitter.beginDeferredEmit();
                return this._redo();
            }
            finally {
                this._eventEmitter.endDeferredEmit();
                this._onDidChangeDecorations.endDeferredEmit();
            }
        };
        TextModel.prototype.canRedo = function () {
            return this._commandManager.canRedo();
        };
        //#endregion
        //#region Decorations
        TextModel.prototype.changeDecorations = function (callback, ownerId) {
            if (ownerId === void 0) { ownerId = 0; }
            this._assertNotDisposed();
            try {
                this._onDidChangeDecorations.beginDeferredEmit();
                return this._changeDecorations(ownerId, callback);
            }
            finally {
                this._onDidChangeDecorations.endDeferredEmit();
            }
        };
        TextModel.prototype._changeDecorations = function (ownerId, callback) {
            var _this = this;
            var changeAccessor = {
                addDecoration: function (range, options) {
                    _this._onDidChangeDecorations.fire();
                    return _this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];
                },
                changeDecoration: function (id, newRange) {
                    _this._onDidChangeDecorations.fire();
                    _this._changeDecorationImpl(id, newRange);
                },
                changeDecorationOptions: function (id, options) {
                    _this._onDidChangeDecorations.fire();
                    _this._changeDecorationOptionsImpl(id, _normalizeOptions(options));
                },
                removeDecoration: function (id) {
                    _this._onDidChangeDecorations.fire();
                    _this._deltaDecorationsImpl(ownerId, [id], []);
                },
                deltaDecorations: function (oldDecorations, newDecorations) {
                    if (oldDecorations.length === 0 && newDecorations.length === 0) {
                        // nothing to do
                        return [];
                    }
                    _this._onDidChangeDecorations.fire();
                    return _this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
                }
            };
            var result = null;
            try {
                result = callback(changeAccessor);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
            // Invalidate change accessor
            changeAccessor.addDecoration = null;
            changeAccessor.changeDecoration = null;
            changeAccessor.removeDecoration = null;
            changeAccessor.deltaDecorations = null;
            return result;
        };
        TextModel.prototype.deltaDecorations = function (oldDecorations, newDecorations, ownerId) {
            if (ownerId === void 0) { ownerId = 0; }
            this._assertNotDisposed();
            if (!oldDecorations) {
                oldDecorations = [];
            }
            if (oldDecorations.length === 0 && newDecorations.length === 0) {
                // nothing to do
                return [];
            }
            try {
                this._onDidChangeDecorations.beginDeferredEmit();
                this._onDidChangeDecorations.fire();
                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
            }
            finally {
                this._onDidChangeDecorations.endDeferredEmit();
            }
        };
        TextModel.prototype._getTrackedRange = function (id) {
            return this.getDecorationRange(id);
        };
        TextModel.prototype._setTrackedRange = function (id, newRange, newStickiness) {
            var node = (id ? this._decorations[id] : null);
            if (!node) {
                if (!newRange) {
                    // node doesn't exist, the request is to delete => nothing to do
                    return null;
                }
                // node doesn't exist, the request is to set => add the tracked range
                return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];
            }
            if (!newRange) {
                // node exists, the request is to delete => delete node
                this._decorationsTree.delete(node);
                delete this._decorations[node.id];
                return null;
            }
            // node exists, the request is to set => change the tracked range and its options
            var range = this._validateRangeRelaxedNoAllocations(newRange);
            var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);
            var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);
            this._decorationsTree.delete(node);
            node.reset(this.getVersionId(), startOffset, endOffset, range);
            node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);
            this._decorationsTree.insert(node);
            return node.id;
        };
        TextModel.prototype.removeAllDecorationsWithOwnerId = function (ownerId) {
            if (this._isDisposed) {
                return;
            }
            var nodes = this._decorationsTree.collectNodesFromOwner(ownerId);
            for (var i = 0, len = nodes.length; i < len; i++) {
                var node = nodes[i];
                this._decorationsTree.delete(node);
                delete this._decorations[node.id];
            }
        };
        TextModel.prototype.getDecorationOptions = function (decorationId) {
            var node = this._decorations[decorationId];
            if (!node) {
                return null;
            }
            return node.options;
        };
        TextModel.prototype.getDecorationRange = function (decorationId) {
            var node = this._decorations[decorationId];
            if (!node) {
                return null;
            }
            var versionId = this.getVersionId();
            if (node.cachedVersionId !== versionId) {
                this._decorationsTree.resolveNode(node, versionId);
            }
            if (node.range === null) {
                node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);
            }
            return node.range;
        };
        TextModel.prototype.getLineDecorations = function (lineNumber, ownerId, filterOutValidation) {
            if (ownerId === void 0) { ownerId = 0; }
            if (filterOutValidation === void 0) { filterOutValidation = false; }
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                return [];
            }
            return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);
        };
        TextModel.prototype.getLinesDecorations = function (_startLineNumber, _endLineNumber, ownerId, filterOutValidation) {
            if (ownerId === void 0) { ownerId = 0; }
            if (filterOutValidation === void 0) { filterOutValidation = false; }
            var lineCount = this.getLineCount();
            var startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));
            var endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));
            var endColumn = this.getLineMaxColumn(endLineNumber);
            return this._getDecorationsInRange(new range_1.Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);
        };
        TextModel.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {
            if (ownerId === void 0) { ownerId = 0; }
            if (filterOutValidation === void 0) { filterOutValidation = false; }
            var validatedRange = this.validateRange(range);
            return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);
        };
        TextModel.prototype.getOverviewRulerDecorations = function (ownerId, filterOutValidation) {
            if (ownerId === void 0) { ownerId = 0; }
            if (filterOutValidation === void 0) { filterOutValidation = false; }
            var versionId = this.getVersionId();
            var result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);
            return this._ensureNodesHaveRanges(result);
        };
        TextModel.prototype.getAllDecorations = function (ownerId, filterOutValidation) {
            if (ownerId === void 0) { ownerId = 0; }
            if (filterOutValidation === void 0) { filterOutValidation = false; }
            var versionId = this.getVersionId();
            var result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);
            return this._ensureNodesHaveRanges(result);
        };
        TextModel.prototype._getDecorationsInRange = function (filterRange, filterOwnerId, filterOutValidation) {
            var startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);
            var endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);
            var versionId = this.getVersionId();
            var result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);
            return this._ensureNodesHaveRanges(result);
        };
        TextModel.prototype._ensureNodesHaveRanges = function (nodes) {
            for (var i = 0, len = nodes.length; i < len; i++) {
                var node = nodes[i];
                if (node.range === null) {
                    node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);
                }
            }
            return nodes;
        };
        TextModel.prototype._getRangeAt = function (start, end) {
            return this._buffer.getRangeAt(start, end - start);
        };
        TextModel.prototype._changeDecorationImpl = function (decorationId, _range) {
            var node = this._decorations[decorationId];
            if (!node) {
                return;
            }
            var range = this._validateRangeRelaxedNoAllocations(_range);
            var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);
            var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);
            this._decorationsTree.delete(node);
            node.reset(this.getVersionId(), startOffset, endOffset, range);
            this._decorationsTree.insert(node);
        };
        TextModel.prototype._changeDecorationOptionsImpl = function (decorationId, options) {
            var node = this._decorations[decorationId];
            if (!node) {
                return;
            }
            var nodeWasInOverviewRuler = (node.options.overviewRuler.color ? true : false);
            var nodeIsInOverviewRuler = (options.overviewRuler.color ? true : false);
            if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {
                // Delete + Insert due to an overview ruler status change
                this._decorationsTree.delete(node);
                node.setOptions(options);
                this._decorationsTree.insert(node);
            }
            else {
                node.setOptions(options);
            }
        };
        TextModel.prototype._deltaDecorationsImpl = function (ownerId, oldDecorationsIds, newDecorations) {
            var versionId = this.getVersionId();
            var oldDecorationsLen = oldDecorationsIds.length;
            var oldDecorationIndex = 0;
            var newDecorationsLen = newDecorations.length;
            var newDecorationIndex = 0;
            var result = new Array(newDecorationsLen);
            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {
                var node = null;
                if (oldDecorationIndex < oldDecorationsLen) {
                    // (1) get ourselves an old node
                    do {
                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];
                    } while (!node && oldDecorationIndex < oldDecorationsLen);
                    // (2) remove the node from the tree (if it exists)
                    if (node) {
                        this._decorationsTree.delete(node);
                    }
                }
                if (newDecorationIndex < newDecorationsLen) {
                    // (3) create a new node if necessary
                    if (!node) {
                        var internalDecorationId = (++this._lastDecorationId);
                        var decorationId = this._instanceId + ";" + internalDecorationId;
                        node = new intervalTree_1.IntervalNode(decorationId, 0, 0);
                        this._decorations[decorationId] = node;
                    }
                    // (4) initialize node
                    var newDecoration = newDecorations[newDecorationIndex];
                    var range = this._validateRangeRelaxedNoAllocations(newDecoration.range);
                    var options = _normalizeOptions(newDecoration.options);
                    var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);
                    var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);
                    node.ownerId = ownerId;
                    node.reset(versionId, startOffset, endOffset, range);
                    node.setOptions(options);
                    this._decorationsTree.insert(node);
                    result[newDecorationIndex] = node.id;
                    newDecorationIndex++;
                }
                else {
                    if (node) {
                        delete this._decorations[node.id];
                    }
                }
            }
            return result;
        };
        //#endregion
        //#region Tokenization
        TextModel.prototype.tokenizeViewport = function (startLineNumber, endLineNumber) {
            if (!this._tokens.tokenizationSupport) {
                return;
            }
            // we tokenize `this._tokens.inValidLineStartIndex` lines in around 20ms so it's a good baseline.
            var contextBefore = Math.floor(this._tokens.inValidLineStartIndex * 0.3);
            startLineNumber = Math.max(1, startLineNumber - contextBefore);
            if (startLineNumber <= this._tokens.inValidLineStartIndex) {
                this.forceTokenization(endLineNumber);
                return;
            }
            var eventBuilder = new textModelTokens_1.ModelTokensChangedEventBuilder();
            var nonWhitespaceColumn = this.getLineFirstNonWhitespaceColumn(startLineNumber);
            var fakeLines = [];
            var i = startLineNumber - 1;
            var initialState = null;
            if (nonWhitespaceColumn > 0) {
                while (nonWhitespaceColumn > 0 && i >= 1) {
                    var newNonWhitespaceIndex = this.getLineFirstNonWhitespaceColumn(i);
                    if (newNonWhitespaceIndex === 0) {
                        i--;
                        continue;
                    }
                    if (newNonWhitespaceIndex < nonWhitespaceColumn) {
                        initialState = this._tokens._getState(i - 1);
                        if (initialState) {
                            break;
                        }
                        fakeLines.push(this.getLineContent(i));
                        nonWhitespaceColumn = newNonWhitespaceIndex;
                    }
                    i--;
                }
            }
            if (!initialState) {
                initialState = this._tokens.tokenizationSupport.getInitialState();
            }
            var state = initialState.clone();
            for (var i_2 = fakeLines.length - 1; i_2 >= 0; i_2--) {
                var r = this._tokens._tokenizeText(this._buffer, fakeLines[i_2], state);
                if (r) {
                    state = r.endState.clone();
                }
                else {
                    state = initialState.clone();
                }
            }
            var contextAfter = Math.floor(this._tokens.inValidLineStartIndex * 0.4);
            endLineNumber = Math.min(this.getLineCount(), endLineNumber + contextAfter);
            for (var i_3 = startLineNumber; i_3 <= endLineNumber; i_3++) {
                var text = this.getLineContent(i_3);
                var r = this._tokens._tokenizeText(this._buffer, text, state);
                if (r) {
                    this._tokens._setTokens(this._tokens.languageIdentifier.id, i_3 - 1, text.length, r.tokens);
                    /*
                     * we think it's valid and give it a state but we don't update `_invalidLineStartIndex` then the top-to-bottom tokenization
                     * goes through the viewport, it can skip them if they already have correct tokens and state, and the lines after the viewport
                     * can still be tokenized.
                     */
                    this._tokens._setIsInvalid(i_3 - 1, false);
                    this._tokens._setState(i_3 - 1, state);
                    state = r.endState.clone();
                    eventBuilder.registerChangedTokens(i_3);
                }
                else {
                    state = initialState.clone();
                }
            }
            var e = eventBuilder.build();
            if (e) {
                this._onDidChangeTokens.fire(e);
            }
        };
        TextModel.prototype.forceTokenization = function (lineNumber) {
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value for lineNumber');
            }
            var eventBuilder = new textModelTokens_1.ModelTokensChangedEventBuilder();
            this._tokens._updateTokensUntilLine(this._buffer, eventBuilder, lineNumber);
            var e = eventBuilder.build();
            if (e) {
                this._onDidChangeTokens.fire(e);
            }
        };
        TextModel.prototype.isCheapToTokenize = function (lineNumber) {
            return this._tokens.isCheapToTokenize(lineNumber);
        };
        TextModel.prototype.tokenizeIfCheap = function (lineNumber) {
            if (this.isCheapToTokenize(lineNumber)) {
                this.forceTokenization(lineNumber);
            }
        };
        TextModel.prototype.getLineTokens = function (lineNumber) {
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value for lineNumber');
            }
            return this._getLineTokens(lineNumber);
        };
        TextModel.prototype._getLineTokens = function (lineNumber) {
            var lineText = this._buffer.getLineContent(lineNumber);
            return this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);
        };
        TextModel.prototype.getLanguageIdentifier = function () {
            return this._languageIdentifier;
        };
        TextModel.prototype.getModeId = function () {
            return this._languageIdentifier.language;
        };
        TextModel.prototype.setMode = function (languageIdentifier) {
            if (this._languageIdentifier.id === languageIdentifier.id) {
                // There's nothing to do
                return;
            }
            var e = {
                oldLanguage: this._languageIdentifier.language,
                newLanguage: languageIdentifier.language
            };
            this._languageIdentifier = languageIdentifier;
            // Cancel tokenization, clear all tokens and begin tokenizing
            this._resetTokenizationState();
            this.emitModelTokensChangedEvent({
                ranges: [{
                        fromLineNumber: 1,
                        toLineNumber: this.getLineCount()
                    }]
            });
            this._onDidChangeLanguage.fire(e);
            this._onDidChangeLanguageConfiguration.fire({});
        };
        TextModel.prototype.getLanguageIdAtPosition = function (_lineNumber, _column) {
            if (!this._tokens.tokenizationSupport) {
                return this._languageIdentifier.id;
            }
            var _a = this.validatePosition({ lineNumber: _lineNumber, column: _column }), lineNumber = _a.lineNumber, column = _a.column;
            var lineTokens = this._getLineTokens(lineNumber);
            return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(column - 1));
        };
        TextModel.prototype._beginBackgroundTokenization = function () {
            var _this = this;
            if (this._shouldAutoTokenize() && this._revalidateTokensTimeout === -1) {
                this._revalidateTokensTimeout = setTimeout(function () {
                    _this._revalidateTokensTimeout = -1;
                    _this._revalidateTokensNow();
                }, 0);
            }
        };
        TextModel.prototype._warmUpTokens = function () {
            // Warm up first 100 lines (if it takes less than 50ms)
            var maxLineNumber = Math.min(100, this.getLineCount());
            this._revalidateTokensNow(maxLineNumber);
            if (this._tokens.hasLinesToTokenize(this._buffer)) {
                this._beginBackgroundTokenization();
            }
        };
        TextModel.prototype._revalidateTokensNow = function (toLineNumber) {
            if (toLineNumber === void 0) { toLineNumber = this._buffer.getLineCount(); }
            var MAX_ALLOWED_TIME = 20;
            var eventBuilder = new textModelTokens_1.ModelTokensChangedEventBuilder();
            var sw = stopwatch_1.StopWatch.create(false);
            while (this._tokens.hasLinesToTokenize(this._buffer)) {
                if (sw.elapsed() > MAX_ALLOWED_TIME) {
                    // Stop if MAX_ALLOWED_TIME is reached
                    break;
                }
                var tokenizedLineNumber = this._tokens._tokenizeOneLine(this._buffer, eventBuilder);
                if (tokenizedLineNumber >= toLineNumber) {
                    break;
                }
            }
            if (this._tokens.hasLinesToTokenize(this._buffer)) {
                this._beginBackgroundTokenization();
            }
            var e = eventBuilder.build();
            if (e) {
                this._onDidChangeTokens.fire(e);
            }
        };
        TextModel.prototype.emitModelTokensChangedEvent = function (e) {
            if (!this._isDisposing) {
                this._onDidChangeTokens.fire(e);
            }
        };
        // Having tokens allows implementing additional helper methods
        TextModel.prototype.getWordAtPosition = function (_position) {
            this._assertNotDisposed();
            var position = this.validatePosition(_position);
            var lineContent = this.getLineContent(position.lineNumber);
            var lineTokens = this._getLineTokens(position.lineNumber);
            var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
            // (1). First try checking right biased word
            var _a = TextModel._findLanguageBoundaries(lineTokens, tokenIndex), rbStartOffset = _a[0], rbEndOffset = _a[1];
            var rightBiasedWord = wordHelper_1.getWordAtText(position.column, languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);
            if (rightBiasedWord) {
                return rightBiasedWord;
            }
            // (2). Else, if we were at a language boundary, check the left biased word
            if (tokenIndex > 0 && rbStartOffset === position.column - 1) {
                // edge case, where `position` sits between two tokens belonging to two different languages
                var _b = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1), lbStartOffset = _b[0], lbEndOffset = _b[1];
                var leftBiasedWord = wordHelper_1.getWordAtText(position.column, languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);
                if (leftBiasedWord) {
                    return leftBiasedWord;
                }
            }
            return null;
        };
        TextModel._findLanguageBoundaries = function (lineTokens, tokenIndex) {
            var languageId = lineTokens.getLanguageId(tokenIndex);
            // go left until a different language is hit
            var startOffset;
            for (var i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {
                startOffset = lineTokens.getStartOffset(i);
            }
            // go right until a different language is hit
            var endOffset;
            for (var i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {
                endOffset = lineTokens.getEndOffset(i);
            }
            return [startOffset, endOffset];
        };
        TextModel.prototype.getWordUntilPosition = function (position) {
            var wordAtPosition = this.getWordAtPosition(position);
            if (!wordAtPosition) {
                return {
                    word: '',
                    startColumn: position.column,
                    endColumn: position.column
                };
            }
            return {
                word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),
                startColumn: wordAtPosition.startColumn,
                endColumn: position.column
            };
        };
        TextModel.prototype.findMatchingBracketUp = function (_bracket, _position) {
            var bracket = _bracket.toLowerCase();
            var position = this.validatePosition(_position);
            var lineTokens = this._getLineTokens(position.lineNumber);
            var languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));
            var bracketsSupport = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(languageId);
            if (!bracketsSupport) {
                return null;
            }
            var data = bracketsSupport.textIsBracket[bracket];
            if (!data) {
                return null;
            }
            return this._findMatchingBracketUp(data, position);
        };
        TextModel.prototype.matchBracket = function (position) {
            return this._matchBracket(this.validatePosition(position));
        };
        TextModel.prototype._matchBracket = function (position) {
            var lineNumber = position.lineNumber;
            var lineTokens = this._getLineTokens(lineNumber);
            var lineText = this._buffer.getLineContent(lineNumber);
            var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
            if (tokenIndex < 0) {
                return null;
            }
            var currentModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));
            // check that the token is not to be ignored
            if (currentModeBrackets && !supports_1.ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {
                // limit search to not go before `maxBracketLength`
                var searchStartOffset = Math.max(lineTokens.getStartOffset(tokenIndex), position.column - 1 - currentModeBrackets.maxBracketLength);
                // limit search to not go after `maxBracketLength`
                var searchEndOffset = Math.min(lineTokens.getEndOffset(tokenIndex), position.column - 1 + currentModeBrackets.maxBracketLength);
                // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets
                // `bestResult` will contain the most right-side result
                var bestResult = null;
                while (true) {
                    var foundBracket = richEditBrackets_1.BracketsUtils.findNextBracketInToken(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                    if (!foundBracket) {
                        // there are no more brackets in this text
                        break;
                    }
                    // check that we didn't hit a bracket too far away from position
                    if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
                        var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);
                        foundBracketText = foundBracketText.toLowerCase();
                        var r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);
                        // check that we can actually match this bracket
                        if (r) {
                            bestResult = r;
                        }
                    }
                    searchStartOffset = foundBracket.endColumn - 1;
                }
                if (bestResult) {
                    return bestResult;
                }
            }
            // If position is in between two tokens, try also looking in the previous token
            if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {
                var searchEndOffset = lineTokens.getStartOffset(tokenIndex);
                tokenIndex--;
                var prevModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));
                // check that previous token is not to be ignored
                if (prevModeBrackets && !supports_1.ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {
                    // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`
                    var searchStartOffset = Math.max(lineTokens.getStartOffset(tokenIndex), position.column - 1 - prevModeBrackets.maxBracketLength);
                    var foundBracket = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                    // check that we didn't hit a bracket too far away from position
                    if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
                        var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);
                        foundBracketText = foundBracketText.toLowerCase();
                        var r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText]);
                        // check that we can actually match this bracket
                        if (r) {
                            return r;
                        }
                    }
                }
            }
            return null;
        };
        TextModel.prototype._matchFoundBracket = function (foundBracket, data, isOpen) {
            if (!data) {
                return null;
            }
            if (isOpen) {
                var matched = this._findMatchingBracketDown(data, foundBracket.getEndPosition());
                if (matched) {
                    return [foundBracket, matched];
                }
            }
            else {
                var matched = this._findMatchingBracketUp(data, foundBracket.getStartPosition());
                if (matched) {
                    return [foundBracket, matched];
                }
            }
            return null;
        };
        TextModel.prototype._findMatchingBracketUp = function (bracket, position) {
            // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
            var languageId = bracket.languageIdentifier.id;
            var reversedBracketRegex = bracket.reversedRegex;
            var count = -1;
            for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
                var lineTokens = this._getLineTokens(lineNumber);
                var tokenCount = lineTokens.getCount();
                var lineText = this._buffer.getLineContent(lineNumber);
                var tokenIndex = tokenCount - 1;
                var searchStopOffset = -1;
                if (lineNumber === position.lineNumber) {
                    tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                    searchStopOffset = position.column - 1;
                }
                for (; tokenIndex >= 0; tokenIndex--) {
                    var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                    var tokenType = lineTokens.getStandardTokenType(tokenIndex);
                    var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);
                    var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);
                    if (searchStopOffset === -1) {
                        searchStopOffset = tokenEndOffset;
                    }
                    if (tokenLanguageId === languageId && !supports_1.ignoreBracketsInToken(tokenType)) {
                        while (true) {
                            var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, lineNumber, lineText, tokenStartOffset, searchStopOffset);
                            if (!r) {
                                break;
                            }
                            var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                            hitText = hitText.toLowerCase();
                            if (hitText === bracket.open) {
                                count++;
                            }
                            else if (hitText === bracket.close) {
                                count--;
                            }
                            if (count === 0) {
                                return r;
                            }
                            searchStopOffset = r.startColumn - 1;
                        }
                    }
                    searchStopOffset = -1;
                }
            }
            return null;
        };
        TextModel.prototype._findMatchingBracketDown = function (bracket, position) {
            // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
            var languageId = bracket.languageIdentifier.id;
            var bracketRegex = bracket.forwardRegex;
            var count = 1;
            for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {
                var lineTokens = this._getLineTokens(lineNumber);
                var tokenCount = lineTokens.getCount();
                var lineText = this._buffer.getLineContent(lineNumber);
                var tokenIndex = 0;
                var searchStartOffset = 0;
                if (lineNumber === position.lineNumber) {
                    tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                    searchStartOffset = position.column - 1;
                }
                for (; tokenIndex < tokenCount; tokenIndex++) {
                    var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                    var tokenType = lineTokens.getStandardTokenType(tokenIndex);
                    var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);
                    var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);
                    if (searchStartOffset === 0) {
                        searchStartOffset = tokenStartOffset;
                    }
                    if (tokenLanguageId === languageId && !supports_1.ignoreBracketsInToken(tokenType)) {
                        while (true) {
                            var r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(bracketRegex, lineNumber, lineText, searchStartOffset, tokenEndOffset);
                            if (!r) {
                                break;
                            }
                            var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                            hitText = hitText.toLowerCase();
                            if (hitText === bracket.open) {
                                count++;
                            }
                            else if (hitText === bracket.close) {
                                count--;
                            }
                            if (count === 0) {
                                return r;
                            }
                            searchStartOffset = r.endColumn - 1;
                        }
                    }
                    searchStartOffset = 0;
                }
            }
            return null;
        };
        TextModel.prototype.findPrevBracket = function (_position) {
            var position = this.validatePosition(_position);
            var languageId = -1;
            var modeBrackets = null;
            for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
                var lineTokens = this._getLineTokens(lineNumber);
                var tokenCount = lineTokens.getCount();
                var lineText = this._buffer.getLineContent(lineNumber);
                var tokenIndex = tokenCount - 1;
                var searchStopOffset = -1;
                if (lineNumber === position.lineNumber) {
                    tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                    searchStopOffset = position.column - 1;
                }
                for (; tokenIndex >= 0; tokenIndex--) {
                    var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                    var tokenType = lineTokens.getStandardTokenType(tokenIndex);
                    var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);
                    var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);
                    if (searchStopOffset === -1) {
                        searchStopOffset = tokenEndOffset;
                    }
                    if (languageId !== tokenLanguageId) {
                        languageId = tokenLanguageId;
                        modeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(languageId);
                    }
                    if (modeBrackets && !supports_1.ignoreBracketsInToken(tokenType)) {
                        var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(modeBrackets.reversedRegex, lineNumber, lineText, tokenStartOffset, searchStopOffset);
                        if (r) {
                            return this._toFoundBracket(modeBrackets, r);
                        }
                    }
                    searchStopOffset = -1;
                }
            }
            return null;
        };
        TextModel.prototype.findNextBracket = function (_position) {
            var position = this.validatePosition(_position);
            var languageId = -1;
            var modeBrackets = null;
            for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {
                var lineTokens = this._getLineTokens(lineNumber);
                var tokenCount = lineTokens.getCount();
                var lineText = this._buffer.getLineContent(lineNumber);
                var tokenIndex = 0;
                var searchStartOffset = 0;
                if (lineNumber === position.lineNumber) {
                    tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                    searchStartOffset = position.column - 1;
                }
                for (; tokenIndex < tokenCount; tokenIndex++) {
                    var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                    var tokenType = lineTokens.getStandardTokenType(tokenIndex);
                    var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);
                    var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);
                    if (searchStartOffset === 0) {
                        searchStartOffset = tokenStartOffset;
                    }
                    if (languageId !== tokenLanguageId) {
                        languageId = tokenLanguageId;
                        modeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(languageId);
                    }
                    if (modeBrackets && !supports_1.ignoreBracketsInToken(tokenType)) {
                        var r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, tokenEndOffset);
                        if (r) {
                            return this._toFoundBracket(modeBrackets, r);
                        }
                    }
                    searchStartOffset = 0;
                }
            }
            return null;
        };
        TextModel.prototype._toFoundBracket = function (modeBrackets, r) {
            if (!r) {
                return null;
            }
            var text = this.getValueInRange(r);
            text = text.toLowerCase();
            var data = modeBrackets.textIsBracket[text];
            if (!data) {
                return null;
            }
            return {
                range: r,
                open: data.open,
                close: data.close,
                isOpen: modeBrackets.textIsOpenBracket[text]
            };
        };
        /**
         * Returns:
         *  - -1 => the line consists of whitespace
         *  - otherwise => the indent level is returned value
         */
        TextModel.computeIndentLevel = function (line, tabSize) {
            var indent = 0;
            var i = 0;
            var len = line.length;
            while (i < len) {
                var chCode = line.charCodeAt(i);
                if (chCode === 32 /* Space */) {
                    indent++;
                }
                else if (chCode === 9 /* Tab */) {
                    indent = indent - indent % tabSize + tabSize;
                }
                else {
                    break;
                }
                i++;
            }
            if (i === len) {
                return -1; // line only consists of whitespace
            }
            return indent;
        };
        TextModel.prototype._computeIndentLevel = function (lineIndex) {
            return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);
        };
        TextModel.prototype.getActiveIndentGuide = function (lineNumber, minLineNumber, maxLineNumber) {
            var _this = this;
            this._assertNotDisposed();
            var lineCount = this.getLineCount();
            if (lineNumber < 1 || lineNumber > lineCount) {
                throw new Error('Illegal value for lineNumber');
            }
            var foldingRules = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);
            var offSide = foldingRules && foldingRules.offSide;
            var up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */
            var up_aboveContentLineIndent = -1;
            var up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */
            var up_belowContentLineIndent = -1;
            var up_resolveIndents = function (lineNumber) {
                if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {
                    up_aboveContentLineIndex = -1;
                    up_aboveContentLineIndent = -1;
                    // must find previous line with content
                    for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
                        var indent_1 = _this._computeIndentLevel(lineIndex);
                        if (indent_1 >= 0) {
                            up_aboveContentLineIndex = lineIndex;
                            up_aboveContentLineIndent = indent_1;
                            break;
                        }
                    }
                }
                if (up_belowContentLineIndex === -2) {
                    up_belowContentLineIndex = -1;
                    up_belowContentLineIndent = -1;
                    // must find next line with content
                    for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {
                        var indent_2 = _this._computeIndentLevel(lineIndex);
                        if (indent_2 >= 0) {
                            up_belowContentLineIndex = lineIndex;
                            up_belowContentLineIndent = indent_2;
                            break;
                        }
                    }
                }
            };
            var down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */
            var down_aboveContentLineIndent = -1;
            var down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */
            var down_belowContentLineIndent = -1;
            var down_resolveIndents = function (lineNumber) {
                if (down_aboveContentLineIndex === -2) {
                    down_aboveContentLineIndex = -1;
                    down_aboveContentLineIndent = -1;
                    // must find previous line with content
                    for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
                        var indent_3 = _this._computeIndentLevel(lineIndex);
                        if (indent_3 >= 0) {
                            down_aboveContentLineIndex = lineIndex;
                            down_aboveContentLineIndent = indent_3;
                            break;
                        }
                    }
                }
                if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {
                    down_belowContentLineIndex = -1;
                    down_belowContentLineIndent = -1;
                    // must find next line with content
                    for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {
                        var indent_4 = _this._computeIndentLevel(lineIndex);
                        if (indent_4 >= 0) {
                            down_belowContentLineIndex = lineIndex;
                            down_belowContentLineIndent = indent_4;
                            break;
                        }
                    }
                }
            };
            var startLineNumber = 0;
            var goUp = true;
            var endLineNumber = 0;
            var goDown = true;
            var indent = 0;
            for (var distance = 0; goUp || goDown; distance++) {
                var upLineNumber = lineNumber - distance;
                var downLineNumber = lineNumber + distance;
                if (distance !== 0 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {
                    goUp = false;
                }
                if (distance !== 0 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {
                    goDown = false;
                }
                if (distance > 50000) {
                    // stop processing
                    goUp = false;
                    goDown = false;
                }
                if (goUp) {
                    // compute indent level going up
                    var upLineIndentLevel = void 0;
                    var currentIndent = this._computeIndentLevel(upLineNumber - 1);
                    if (currentIndent >= 0) {
                        // This line has content (besides whitespace)
                        // Use the line's indent
                        up_belowContentLineIndex = upLineNumber - 1;
                        up_belowContentLineIndent = currentIndent;
                        upLineIndentLevel = Math.ceil(currentIndent / this._options.tabSize);
                    }
                    else {
                        up_resolveIndents(upLineNumber);
                        upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);
                    }
                    if (distance === 0) {
                        // This is the initial line number
                        startLineNumber = upLineNumber;
                        endLineNumber = downLineNumber;
                        indent = upLineIndentLevel;
                        if (indent === 0) {
                            // No need to continue
                            return { startLineNumber: startLineNumber, endLineNumber: endLineNumber, indent: indent };
                        }
                        continue;
                    }
                    if (upLineIndentLevel >= indent) {
                        startLineNumber = upLineNumber;
                    }
                    else {
                        goUp = false;
                    }
                }
                if (goDown) {
                    // compute indent level going down
                    var downLineIndentLevel = void 0;
                    var currentIndent = this._computeIndentLevel(downLineNumber - 1);
                    if (currentIndent >= 0) {
                        // This line has content (besides whitespace)
                        // Use the line's indent
                        down_aboveContentLineIndex = downLineNumber - 1;
                        down_aboveContentLineIndent = currentIndent;
                        downLineIndentLevel = Math.ceil(currentIndent / this._options.tabSize);
                    }
                    else {
                        down_resolveIndents(downLineNumber);
                        downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);
                    }
                    if (downLineIndentLevel >= indent) {
                        endLineNumber = downLineNumber;
                    }
                    else {
                        goDown = false;
                    }
                }
            }
            return { startLineNumber: startLineNumber, endLineNumber: endLineNumber, indent: indent };
        };
        TextModel.prototype.getLinesIndentGuides = function (startLineNumber, endLineNumber) {
            this._assertNotDisposed();
            var lineCount = this.getLineCount();
            if (startLineNumber < 1 || startLineNumber > lineCount) {
                throw new Error('Illegal value for startLineNumber');
            }
            if (endLineNumber < 1 || endLineNumber > lineCount) {
                throw new Error('Illegal value for endLineNumber');
            }
            var foldingRules = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);
            var offSide = foldingRules && foldingRules.offSide;
            var result = new Array(endLineNumber - startLineNumber + 1);
            var aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */
            var aboveContentLineIndent = -1;
            var belowContentLineIndex = -2; /* -2 is a marker for not having computed it */
            var belowContentLineIndent = -1;
            for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
                var resultIndex = lineNumber - startLineNumber;
                var currentIndent = this._computeIndentLevel(lineNumber - 1);
                if (currentIndent >= 0) {
                    // This line has content (besides whitespace)
                    // Use the line's indent
                    aboveContentLineIndex = lineNumber - 1;
                    aboveContentLineIndent = currentIndent;
                    result[resultIndex] = Math.ceil(currentIndent / this._options.tabSize);
                    continue;
                }
                if (aboveContentLineIndex === -2) {
                    aboveContentLineIndex = -1;
                    aboveContentLineIndent = -1;
                    // must find previous line with content
                    for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
                        var indent = this._computeIndentLevel(lineIndex);
                        if (indent >= 0) {
                            aboveContentLineIndex = lineIndex;
                            aboveContentLineIndent = indent;
                            break;
                        }
                    }
                }
                if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {
                    belowContentLineIndex = -1;
                    belowContentLineIndent = -1;
                    // must find next line with content
                    for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {
                        var indent = this._computeIndentLevel(lineIndex);
                        if (indent >= 0) {
                            belowContentLineIndex = lineIndex;
                            belowContentLineIndent = indent;
                            break;
                        }
                    }
                }
                result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);
            }
            return result;
        };
        TextModel.prototype._getIndentLevelForWhitespaceLine = function (offSide, aboveContentLineIndent, belowContentLineIndent) {
            if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {
                // At the top or bottom of the file
                return 0;
            }
            else if (aboveContentLineIndent < belowContentLineIndent) {
                // we are inside the region above
                return (1 + Math.floor(aboveContentLineIndent / this._options.tabSize));
            }
            else if (aboveContentLineIndent === belowContentLineIndent) {
                // we are in between two regions
                return Math.ceil(belowContentLineIndent / this._options.tabSize);
            }
            else {
                if (offSide) {
                    // same level as region below
                    return Math.ceil(belowContentLineIndent / this._options.tabSize);
                }
                else {
                    // we are inside the region that ends below
                    return (1 + Math.floor(belowContentLineIndent / this._options.tabSize));
                }
            }
        };
        TextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB
        TextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;
        TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines
        TextModel.DEFAULT_CREATION_OPTIONS = {
            isForSimpleWidget: false,
            tabSize: editorOptions_1.EDITOR_MODEL_DEFAULTS.tabSize,
            insertSpaces: editorOptions_1.EDITOR_MODEL_DEFAULTS.insertSpaces,
            detectIndentation: false,
            defaultEOL: model.DefaultEndOfLine.LF,
            trimAutoWhitespace: editorOptions_1.EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,
            largeFileOptimizations: editorOptions_1.EDITOR_MODEL_DEFAULTS.largeFileOptimizations,
        };
        return TextModel;
    }(lifecycle_1.Disposable));
    exports.TextModel = TextModel;
    //#region Decorations
    var DecorationsTrees = /** @class */ (function () {
        function DecorationsTrees() {
            this._decorationsTree0 = new intervalTree_1.IntervalTree();
            this._decorationsTree1 = new intervalTree_1.IntervalTree();
        }
        DecorationsTrees.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {
            var r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);
            var r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);
            return r0.concat(r1);
        };
        DecorationsTrees.prototype.search = function (filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {
            if (overviewRulerOnly) {
                return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);
            }
            else {
                var r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);
                var r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);
                return r0.concat(r1);
            }
        };
        DecorationsTrees.prototype.collectNodesFromOwner = function (ownerId) {
            var r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);
            var r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);
            return r0.concat(r1);
        };
        DecorationsTrees.prototype.collectNodesPostOrder = function () {
            var r0 = this._decorationsTree0.collectNodesPostOrder();
            var r1 = this._decorationsTree1.collectNodesPostOrder();
            return r0.concat(r1);
        };
        DecorationsTrees.prototype.insert = function (node) {
            if (intervalTree_1.getNodeIsInOverviewRuler(node)) {
                this._decorationsTree1.insert(node);
            }
            else {
                this._decorationsTree0.insert(node);
            }
        };
        DecorationsTrees.prototype.delete = function (node) {
            if (intervalTree_1.getNodeIsInOverviewRuler(node)) {
                this._decorationsTree1.delete(node);
            }
            else {
                this._decorationsTree0.delete(node);
            }
        };
        DecorationsTrees.prototype.resolveNode = function (node, cachedVersionId) {
            if (intervalTree_1.getNodeIsInOverviewRuler(node)) {
                this._decorationsTree1.resolveNode(node, cachedVersionId);
            }
            else {
                this._decorationsTree0.resolveNode(node, cachedVersionId);
            }
        };
        DecorationsTrees.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {
            this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);
            this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);
        };
        return DecorationsTrees;
    }());
    function cleanClassName(className) {
        return className.replace(/[^a-z0-9\-_]/gi, ' ');
    }
    var ModelDecorationOverviewRulerOptions = /** @class */ (function () {
        function ModelDecorationOverviewRulerOptions(options) {
            this.color = strings.empty;
            this.darkColor = strings.empty;
            this.hcColor = strings.empty;
            this.position = model.OverviewRulerLane.Center;
            this._resolvedColor = null;
            if (options && options.color) {
                this.color = options.color;
            }
            if (options && options.darkColor) {
                this.darkColor = options.darkColor;
                this.hcColor = options.darkColor;
            }
            if (options && options.hcColor) {
                this.hcColor = options.hcColor;
            }
            if (options && options.hasOwnProperty('position')) {
                this.position = options.position;
            }
        }
        return ModelDecorationOverviewRulerOptions;
    }());
    exports.ModelDecorationOverviewRulerOptions = ModelDecorationOverviewRulerOptions;
    var ModelDecorationOptions = /** @class */ (function () {
        function ModelDecorationOptions(options) {
            this.stickiness = options.stickiness || model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;
            this.zIndex = options.zIndex || 0;
            this.className = options.className ? cleanClassName(options.className) : strings.empty;
            this.hoverMessage = options.hoverMessage || [];
            this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || [];
            this.isWholeLine = options.isWholeLine || false;
            this.showIfCollapsed = options.showIfCollapsed || false;
            this.overviewRuler = new ModelDecorationOverviewRulerOptions(options.overviewRuler);
            this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : strings.empty;
            this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : strings.empty;
            this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : strings.empty;
            this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : strings.empty;
            this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;
            this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : strings.empty;
            this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : strings.empty;
        }
        ModelDecorationOptions.register = function (options) {
            return new ModelDecorationOptions(options);
        };
        ModelDecorationOptions.createDynamic = function (options) {
            return new ModelDecorationOptions(options);
        };
        return ModelDecorationOptions;
    }());
    exports.ModelDecorationOptions = ModelDecorationOptions;
    ModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});
    /**
     * The order carefully matches the values of the enum.
     */
    var TRACKED_RANGE_OPTIONS = [
        ModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges }),
        ModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges }),
        ModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore }),
        ModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter }),
    ];
    function _normalizeOptions(options) {
        if (options instanceof ModelDecorationOptions) {
            return options;
        }
        return ModelDecorationOptions.createDynamic(options);
    }
    var DidChangeDecorationsEmitter = /** @class */ (function (_super) {
        __extends(DidChangeDecorationsEmitter, _super);
        function DidChangeDecorationsEmitter() {
            var _this = _super.call(this) || this;
            _this._actual = _this._register(new event_1.Emitter());
            _this.event = _this._actual.event;
            _this._deferredCnt = 0;
            _this._shouldFire = false;
            return _this;
        }
        DidChangeDecorationsEmitter.prototype.beginDeferredEmit = function () {
            this._deferredCnt++;
        };
        DidChangeDecorationsEmitter.prototype.endDeferredEmit = function () {
            this._deferredCnt--;
            if (this._deferredCnt === 0) {
                if (this._shouldFire) {
                    this._shouldFire = false;
                    this._actual.fire({});
                }
            }
        };
        DidChangeDecorationsEmitter.prototype.fire = function () {
            this._shouldFire = true;
        };
        return DidChangeDecorationsEmitter;
    }(lifecycle_1.Disposable));
    exports.DidChangeDecorationsEmitter = DidChangeDecorationsEmitter;
    //#endregion
    var DidChangeContentEmitter = /** @class */ (function (_super) {
        __extends(DidChangeContentEmitter, _super);
        function DidChangeContentEmitter() {
            var _this = _super.call(this) || this;
            /**
             * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.
             */
            _this._fastEmitter = _this._register(new event_1.Emitter());
            _this.fastEvent = _this._fastEmitter.event;
            _this._slowEmitter = _this._register(new event_1.Emitter());
            _this.slowEvent = _this._slowEmitter.event;
            _this._deferredCnt = 0;
            _this._deferredEvent = null;
            return _this;
        }
        DidChangeContentEmitter.prototype.beginDeferredEmit = function () {
            this._deferredCnt++;
        };
        DidChangeContentEmitter.prototype.endDeferredEmit = function () {
            this._deferredCnt--;
            if (this._deferredCnt === 0) {
                if (this._deferredEvent !== null) {
                    var e = this._deferredEvent;
                    this._deferredEvent = null;
                    this._fastEmitter.fire(e);
                    this._slowEmitter.fire(e);
                }
            }
        };
        DidChangeContentEmitter.prototype.fire = function (e) {
            if (this._deferredCnt > 0) {
                if (this._deferredEvent) {
                    this._deferredEvent = this._deferredEvent.merge(e);
                }
                else {
                    this._deferredEvent = e;
                }
                return;
            }
            this._fastEmitter.fire(e);
            this._slowEmitter.fire(e);
        };
        return DidChangeContentEmitter;
    }(lifecycle_1.Disposable));
    exports.DidChangeContentEmitter = DidChangeContentEmitter;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[123/*vs/editor/common/services/resourceConfiguration*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ITextResourceConfigurationService = instantiation_1.createDecorator('textResourceConfigurationService');
});

define(__m[124/*vs/platform/commands/common/commands*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,9/*vs/base/common/lifecycle*/,18/*vs/base/common/types*/,7/*vs/platform/instantiation/common/instantiation*/,51/*vs/base/common/linkedList*/]), function (require, exports, winjs_base_1, lifecycle_1, types_1, instantiation_1, linkedList_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ICommandService = instantiation_1.createDecorator('commandService');
    exports.CommandsRegistry = new /** @class */ (function () {
        function class_1() {
            this._commands = new Map();
        }
        class_1.prototype.registerCommand = function (idOrCommand, handler) {
            var _this = this;
            if (!idOrCommand) {
                throw new Error("invalid command");
            }
            if (typeof idOrCommand === 'string') {
                if (!handler) {
                    throw new Error("invalid command");
                }
                return this.registerCommand({ id: idOrCommand, handler: handler });
            }
            // add argument validation if rich command metadata is provided
            if (idOrCommand.description) {
                var constraints_1 = [];
                for (var _i = 0, _a = idOrCommand.description.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    constraints_1.push(arg.constraint);
                }
                var actualHandler_1 = idOrCommand.handler;
                idOrCommand.handler = function (accessor) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    types_1.validateConstraints(args, constraints_1);
                    return actualHandler_1.apply(void 0, [accessor].concat(args));
                };
            }
            // find a place to store the command
            var id = idOrCommand.id;
            var commands = this._commands.get(id);
            if (!commands) {
                commands = new linkedList_1.LinkedList();
                this._commands.set(id, commands);
            }
            var removeFn = commands.unshift(idOrCommand);
            return lifecycle_1.toDisposable(function () {
                removeFn();
                if (_this._commands.get(id).isEmpty()) {
                    _this._commands.delete(id);
                }
            });
        };
        class_1.prototype.registerCommandAlias = function (oldId, newId) {
            return exports.CommandsRegistry.registerCommand(oldId, function (accessor) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var _a;
                (_a = accessor.get(exports.ICommandService)).executeCommand.apply(_a, [newId].concat(args));
            });
        };
        class_1.prototype.getCommand = function (id) {
            var list = this._commands.get(id);
            if (!list || list.isEmpty()) {
                return undefined;
            }
            return list.iterator().next().value;
        };
        class_1.prototype.getCommands = function () {
            var _this = this;
            var result = Object.create(null);
            this._commands.forEach(function (value, key) {
                result[key] = _this.getCommand(key);
            });
            return result;
        };
        return class_1;
    }());
    exports.NullCommandService = {
        _serviceBrand: undefined,
        onWillExecuteCommand: function () { return ({ dispose: function () { } }); },
        executeCommand: function () {
            return winjs_base_1.TPromise.as(undefined);
        }
    };
});











define(__m[42/*vs/platform/contextkey/common/contextkey*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/,8/*vs/base/common/strings*/]), function (require, exports, instantiation_1, strings_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ContextKeyExprType;
    (function (ContextKeyExprType) {
        ContextKeyExprType[ContextKeyExprType["Defined"] = 1] = "Defined";
        ContextKeyExprType[ContextKeyExprType["Not"] = 2] = "Not";
        ContextKeyExprType[ContextKeyExprType["Equals"] = 3] = "Equals";
        ContextKeyExprType[ContextKeyExprType["NotEquals"] = 4] = "NotEquals";
        ContextKeyExprType[ContextKeyExprType["And"] = 5] = "And";
        ContextKeyExprType[ContextKeyExprType["Regex"] = 6] = "Regex";
        // {{SQL CARBON EDIT}}
        ContextKeyExprType[ContextKeyExprType["GreaterThanEquals"] = 7] = "GreaterThanEquals";
        ContextKeyExprType[ContextKeyExprType["LessThanEquals"] = 8] = "LessThanEquals";
        //
    })(ContextKeyExprType = exports.ContextKeyExprType || (exports.ContextKeyExprType = {}));
    var ContextKeyExpr = /** @class */ (function () {
        function ContextKeyExpr() {
        }
        ContextKeyExpr.has = function (key) {
            return new ContextKeyDefinedExpr(key);
        };
        ContextKeyExpr.equals = function (key, value) {
            return new ContextKeyEqualsExpr(key, value);
        };
        ContextKeyExpr.notEquals = function (key, value) {
            return new ContextKeyNotEqualsExpr(key, value);
        };
        ContextKeyExpr.regex = function (key, value) {
            return new ContextKeyRegexExpr(key, value);
        };
        ContextKeyExpr.not = function (key) {
            return new ContextKeyNotExpr(key);
        };
        ContextKeyExpr.and = function () {
            var expr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                expr[_i] = arguments[_i];
            }
            return new ContextKeyAndExpr(expr);
        };
        // {{SQL CARBON EDIT}}
        ContextKeyExpr.greaterThanEquals = function (key, value) {
            return new ContextKeyGreaterThanEqualsExpr(key, value);
        };
        ContextKeyExpr.lessThanEquals = function (key, value) {
            return new ContextKeyLessThanEqualsExpr(key, value);
        };
        //
        ContextKeyExpr.deserialize = function (serialized) {
            var _this = this;
            if (!serialized) {
                return null;
            }
            var pieces = serialized.split('&&');
            var result = new ContextKeyAndExpr(pieces.map(function (p) { return _this._deserializeOne(p); }));
            return result.normalize();
        };
        ContextKeyExpr._deserializeOne = function (serializedOne) {
            serializedOne = serializedOne.trim();
            if (serializedOne.indexOf('!=') >= 0) {
                var pieces = serializedOne.split('!=');
                return new ContextKeyNotEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1]));
            }
            if (serializedOne.indexOf('==') >= 0) {
                var pieces = serializedOne.split('==');
                return new ContextKeyEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1]));
            }
            if (serializedOne.indexOf('=~') >= 0) {
                var pieces = serializedOne.split('=~');
                return new ContextKeyRegexExpr(pieces[0].trim(), this._deserializeRegexValue(pieces[1]));
            }
            // {{SQL CARBON EDIT}}
            if (serializedOne.indexOf('>=') >= 0) {
                var pieces = serializedOne.split('>=');
                return new ContextKeyGreaterThanEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1]));
            }
            if (serializedOne.indexOf('<=') >= 0) {
                var pieces = serializedOne.split('<=');
                return new ContextKeyLessThanEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1]));
            }
            //
            if (/^\!\s*/.test(serializedOne)) {
                return new ContextKeyNotExpr(serializedOne.substr(1).trim());
            }
            return new ContextKeyDefinedExpr(serializedOne);
        };
        ContextKeyExpr._deserializeValue = function (serializedValue) {
            serializedValue = serializedValue.trim();
            if (serializedValue === 'true') {
                return true;
            }
            if (serializedValue === 'false') {
                return false;
            }
            var m = /^'([^']*)'$/.exec(serializedValue);
            if (m) {
                return m[1].trim();
            }
            return serializedValue;
        };
        ContextKeyExpr._deserializeRegexValue = function (serializedValue) {
            if (strings_1.isFalsyOrWhitespace(serializedValue)) {
                console.warn('missing regexp-value for =~-expression');
                return null;
            }
            var start = serializedValue.indexOf('/');
            var end = serializedValue.lastIndexOf('/');
            if (start === end || start < 0 /* || to < 0 */) {
                console.warn("bad regexp-value '" + serializedValue + "', missing /-enclosure");
                return null;
            }
            var value = serializedValue.slice(start + 1, end);
            var caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';
            try {
                return new RegExp(value, caseIgnoreFlag);
            }
            catch (e) {
                console.warn("bad regexp-value '" + serializedValue + "', parse error: " + e);
                return null;
            }
        };
        return ContextKeyExpr;
    }());
    exports.ContextKeyExpr = ContextKeyExpr;
    function cmp(a, b) {
        var aType = a.getType();
        var bType = b.getType();
        if (aType !== bType) {
            return aType - bType;
        }
        switch (aType) {
            case ContextKeyExprType.Defined:
                return a.cmp(b);
            case ContextKeyExprType.Not:
                return a.cmp(b);
            case ContextKeyExprType.Equals:
                return a.cmp(b);
            case ContextKeyExprType.NotEquals:
                return a.cmp(b);
            case ContextKeyExprType.Regex:
                return a.cmp(b);
            // {{SQL CARBON EDIT}}
            case ContextKeyExprType.GreaterThanEquals:
                return a.cmp(b);
            case ContextKeyExprType.LessThanEquals:
                return a.cmp(b);
            //
            default:
                throw new Error('Unknown ContextKeyExpr!');
        }
    }
    var ContextKeyDefinedExpr = /** @class */ (function () {
        function ContextKeyDefinedExpr(key) {
            this.key = key;
        }
        ContextKeyDefinedExpr.prototype.getType = function () {
            return ContextKeyExprType.Defined;
        };
        ContextKeyDefinedExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            return 0;
        };
        ContextKeyDefinedExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyDefinedExpr) {
                return (this.key === other.key);
            }
            return false;
        };
        ContextKeyDefinedExpr.prototype.evaluate = function (context) {
            return (!!context.getValue(this.key));
        };
        ContextKeyDefinedExpr.prototype.normalize = function () {
            return this;
        };
        ContextKeyDefinedExpr.prototype.serialize = function () {
            return this.key;
        };
        ContextKeyDefinedExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyDefinedExpr;
    }());
    exports.ContextKeyDefinedExpr = ContextKeyDefinedExpr;
    var ContextKeyEqualsExpr = /** @class */ (function () {
        function ContextKeyEqualsExpr(key, value) {
            this.key = key;
            this.value = value;
        }
        ContextKeyEqualsExpr.prototype.getType = function () {
            return ContextKeyExprType.Equals;
        };
        ContextKeyEqualsExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            if (this.value < other.value) {
                return -1;
            }
            if (this.value > other.value) {
                return 1;
            }
            return 0;
        };
        ContextKeyEqualsExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyEqualsExpr) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        ContextKeyEqualsExpr.prototype.evaluate = function (context) {
            /* tslint:disable:triple-equals */
            // Intentional ==
            return (context.getValue(this.key) == this.value);
            /* tslint:enable:triple-equals */
        };
        ContextKeyEqualsExpr.prototype.normalize = function () {
            if (typeof this.value === 'boolean') {
                if (this.value) {
                    return new ContextKeyDefinedExpr(this.key);
                }
                return new ContextKeyNotExpr(this.key);
            }
            return this;
        };
        ContextKeyEqualsExpr.prototype.serialize = function () {
            if (typeof this.value === 'boolean') {
                return this.normalize().serialize();
            }
            return this.key + ' == \'' + this.value + '\'';
        };
        ContextKeyEqualsExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyEqualsExpr;
    }());
    exports.ContextKeyEqualsExpr = ContextKeyEqualsExpr;
    var ContextKeyNotEqualsExpr = /** @class */ (function () {
        function ContextKeyNotEqualsExpr(key, value) {
            this.key = key;
            this.value = value;
        }
        ContextKeyNotEqualsExpr.prototype.getType = function () {
            return ContextKeyExprType.NotEquals;
        };
        ContextKeyNotEqualsExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            if (this.value < other.value) {
                return -1;
            }
            if (this.value > other.value) {
                return 1;
            }
            return 0;
        };
        ContextKeyNotEqualsExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyNotEqualsExpr) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        ContextKeyNotEqualsExpr.prototype.evaluate = function (context) {
            /* tslint:disable:triple-equals */
            // Intentional !=
            return (context.getValue(this.key) != this.value);
            /* tslint:enable:triple-equals */
        };
        ContextKeyNotEqualsExpr.prototype.normalize = function () {
            if (typeof this.value === 'boolean') {
                if (this.value) {
                    return new ContextKeyNotExpr(this.key);
                }
                return new ContextKeyDefinedExpr(this.key);
            }
            return this;
        };
        ContextKeyNotEqualsExpr.prototype.serialize = function () {
            if (typeof this.value === 'boolean') {
                return this.normalize().serialize();
            }
            return this.key + ' != \'' + this.value + '\'';
        };
        ContextKeyNotEqualsExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyNotEqualsExpr;
    }());
    exports.ContextKeyNotEqualsExpr = ContextKeyNotEqualsExpr;
    var ContextKeyNotExpr = /** @class */ (function () {
        function ContextKeyNotExpr(key) {
            this.key = key;
        }
        ContextKeyNotExpr.prototype.getType = function () {
            return ContextKeyExprType.Not;
        };
        ContextKeyNotExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            return 0;
        };
        ContextKeyNotExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyNotExpr) {
                return (this.key === other.key);
            }
            return false;
        };
        ContextKeyNotExpr.prototype.evaluate = function (context) {
            return (!context.getValue(this.key));
        };
        ContextKeyNotExpr.prototype.normalize = function () {
            return this;
        };
        ContextKeyNotExpr.prototype.serialize = function () {
            return '!' + this.key;
        };
        ContextKeyNotExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyNotExpr;
    }());
    exports.ContextKeyNotExpr = ContextKeyNotExpr;
    var ContextKeyRegexExpr = /** @class */ (function () {
        function ContextKeyRegexExpr(key, regexp) {
            this.key = key;
            this.regexp = regexp;
            //
        }
        ContextKeyRegexExpr.prototype.getType = function () {
            return ContextKeyExprType.Regex;
        };
        ContextKeyRegexExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            var source = this.regexp ? this.regexp.source : undefined;
            if (source < other.regexp.source) {
                return -1;
            }
            if (source > other.regexp.source) {
                return 1;
            }
            return 0;
        };
        ContextKeyRegexExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyRegexExpr) {
                var source = this.regexp ? this.regexp.source : undefined;
                return (this.key === other.key && source === other.regexp.source);
            }
            return false;
        };
        ContextKeyRegexExpr.prototype.evaluate = function (context) {
            return this.regexp ? this.regexp.test(context.getValue(this.key)) : false;
        };
        ContextKeyRegexExpr.prototype.normalize = function () {
            return this;
        };
        ContextKeyRegexExpr.prototype.serialize = function () {
            var value = this.regexp
                ? "/" + this.regexp.source + "/" + (this.regexp.ignoreCase ? 'i' : '')
                : '/invalid/';
            return this.key + " =~ " + value;
        };
        ContextKeyRegexExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyRegexExpr;
    }());
    exports.ContextKeyRegexExpr = ContextKeyRegexExpr;
    var ContextKeyAndExpr = /** @class */ (function () {
        function ContextKeyAndExpr(expr) {
            this.expr = ContextKeyAndExpr._normalizeArr(expr);
        }
        ContextKeyAndExpr.prototype.getType = function () {
            return ContextKeyExprType.And;
        };
        ContextKeyAndExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyAndExpr) {
                if (this.expr.length !== other.expr.length) {
                    return false;
                }
                for (var i = 0, len = this.expr.length; i < len; i++) {
                    if (!this.expr[i].equals(other.expr[i])) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        };
        ContextKeyAndExpr.prototype.evaluate = function (context) {
            for (var i = 0, len = this.expr.length; i < len; i++) {
                if (!this.expr[i].evaluate(context)) {
                    return false;
                }
            }
            return true;
        };
        ContextKeyAndExpr._normalizeArr = function (arr) {
            var expr = [];
            if (arr) {
                for (var i = 0, len = arr.length; i < len; i++) {
                    var e = arr[i];
                    if (!e) {
                        continue;
                    }
                    e = e.normalize();
                    if (!e) {
                        continue;
                    }
                    if (e instanceof ContextKeyAndExpr) {
                        expr = expr.concat(e.expr);
                        continue;
                    }
                    expr.push(e);
                }
                expr.sort(cmp);
            }
            return expr;
        };
        ContextKeyAndExpr.prototype.normalize = function () {
            if (this.expr.length === 0) {
                return null;
            }
            if (this.expr.length === 1) {
                return this.expr[0];
            }
            return this;
        };
        ContextKeyAndExpr.prototype.serialize = function () {
            if (this.expr.length === 0) {
                return '';
            }
            if (this.expr.length === 1) {
                return this.normalize().serialize();
            }
            return this.expr.map(function (e) { return e.serialize(); }).join(' && ');
        };
        ContextKeyAndExpr.prototype.keys = function () {
            var result = [];
            for (var _i = 0, _a = this.expr; _i < _a.length; _i++) {
                var expr = _a[_i];
                result.push.apply(result, expr.keys());
            }
            return result;
        };
        return ContextKeyAndExpr;
    }());
    exports.ContextKeyAndExpr = ContextKeyAndExpr;
    // {{SQL CARBON EDIT}}
    var ContextKeyGreaterThanEqualsExpr = /** @class */ (function () {
        function ContextKeyGreaterThanEqualsExpr(key, value) {
            this.key = key;
            this.value = value;
        }
        ContextKeyGreaterThanEqualsExpr.prototype.getType = function () {
            return ContextKeyExprType.GreaterThanEquals;
        };
        ContextKeyGreaterThanEqualsExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            if (this.value < other.value) {
                return -1;
            }
            if (this.value > other.value) {
                return 1;
            }
            return 0;
        };
        ContextKeyGreaterThanEqualsExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyGreaterThanEqualsExpr) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        ContextKeyGreaterThanEqualsExpr.prototype.evaluate = function (context) {
            var keyInt = parseFloat(context.getValue(this.key));
            var valueInt = parseFloat(this.value);
            return (keyInt >= valueInt);
        };
        ContextKeyGreaterThanEqualsExpr.prototype.normalize = function () {
            return this;
        };
        ContextKeyGreaterThanEqualsExpr.prototype.serialize = function () {
            return this.key + ' >= \'' + this.value + '\'';
        };
        ContextKeyGreaterThanEqualsExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyGreaterThanEqualsExpr;
    }());
    exports.ContextKeyGreaterThanEqualsExpr = ContextKeyGreaterThanEqualsExpr;
    // {{SQL CARBON EDIT}}
    var ContextKeyLessThanEqualsExpr = /** @class */ (function () {
        function ContextKeyLessThanEqualsExpr(key, value) {
            this.key = key;
            this.value = value;
        }
        ContextKeyLessThanEqualsExpr.prototype.getType = function () {
            return ContextKeyExprType.LessThanEquals;
        };
        ContextKeyLessThanEqualsExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            if (this.value < other.value) {
                return -1;
            }
            if (this.value > other.value) {
                return 1;
            }
            return 0;
        };
        ContextKeyLessThanEqualsExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyLessThanEqualsExpr) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        ContextKeyLessThanEqualsExpr.prototype.evaluate = function (context) {
            var keyInt = parseFloat(context.getValue(this.key));
            var valueInt = parseFloat(this.value);
            return (keyInt <= valueInt);
        };
        ContextKeyLessThanEqualsExpr.prototype.normalize = function () {
            return this;
        };
        ContextKeyLessThanEqualsExpr.prototype.serialize = function () {
            return this.key + ' <= \'' + this.value + '\'';
        };
        ContextKeyLessThanEqualsExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyLessThanEqualsExpr;
    }());
    exports.ContextKeyLessThanEqualsExpr = ContextKeyLessThanEqualsExpr;
    var RawContextKey = /** @class */ (function (_super) {
        __extends(RawContextKey, _super);
        function RawContextKey(key, defaultValue) {
            var _this = _super.call(this, key) || this;
            _this._defaultValue = defaultValue;
            return _this;
        }
        RawContextKey.prototype.bindTo = function (target) {
            return target.createKey(this.key, this._defaultValue);
        };
        RawContextKey.prototype.getValue = function (target) {
            return target.getContextKeyValue(this.key);
        };
        RawContextKey.prototype.toNegated = function () {
            return ContextKeyExpr.not(this.key);
        };
        RawContextKey.prototype.isEqualTo = function (value) {
            return ContextKeyExpr.equals(this.key, value);
        };
        RawContextKey.prototype.notEqualsTo = function (value) {
            return ContextKeyExpr.notEquals(this.key, value);
        };
        return RawContextKey;
    }(ContextKeyDefinedExpr));
    exports.RawContextKey = RawContextKey;
    exports.IContextKeyService = instantiation_1.createDecorator('contextKeyService');
    exports.SET_CONTEXT_COMMAND_ID = 'setContext';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[61/*vs/platform/environment/common/environment*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IEnvironmentService = instantiation_1.createDecorator('environmentService');
});











define(__m[43/*vs/platform/files/common/files*/], __M([0/*require*/,1/*exports*/,16/*vs/base/common/paths*/,10/*vs/base/common/platform*/,7/*vs/platform/instantiation/common/instantiation*/,8/*vs/base/common/strings*/,26/*vs/base/common/resources*/,18/*vs/base/common/types*/]), function (require, exports, paths, platform_1, instantiation_1, strings_1, resources_1, types_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IFileService = instantiation_1.createDecorator('fileService');
    var FileType;
    (function (FileType) {
        FileType[FileType["Unknown"] = 0] = "Unknown";
        FileType[FileType["File"] = 1] = "File";
        FileType[FileType["Directory"] = 2] = "Directory";
        FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
    })(FileType = exports.FileType || (exports.FileType = {}));
    var FileSystemProviderCapabilities;
    (function (FileSystemProviderCapabilities) {
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileReadWrite"] = 2] = "FileReadWrite";
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileOpenReadWriteClose"] = 4] = "FileOpenReadWriteClose";
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileFolderCopy"] = 8] = "FileFolderCopy";
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["PathCaseSensitive"] = 1024] = "PathCaseSensitive";
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["Readonly"] = 2048] = "Readonly";
    })(FileSystemProviderCapabilities = exports.FileSystemProviderCapabilities || (exports.FileSystemProviderCapabilities = {}));
    var FileOperation;
    (function (FileOperation) {
        FileOperation[FileOperation["CREATE"] = 0] = "CREATE";
        FileOperation[FileOperation["DELETE"] = 1] = "DELETE";
        FileOperation[FileOperation["MOVE"] = 2] = "MOVE";
        FileOperation[FileOperation["COPY"] = 3] = "COPY";
    })(FileOperation = exports.FileOperation || (exports.FileOperation = {}));
    var FileOperationEvent = /** @class */ (function () {
        function FileOperationEvent(_resource, _operation, _target) {
            this._resource = _resource;
            this._operation = _operation;
            this._target = _target;
        }
        Object.defineProperty(FileOperationEvent.prototype, "resource", {
            get: function () {
                return this._resource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileOperationEvent.prototype, "target", {
            get: function () {
                return this._target;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileOperationEvent.prototype, "operation", {
            get: function () {
                return this._operation;
            },
            enumerable: true,
            configurable: true
        });
        return FileOperationEvent;
    }());
    exports.FileOperationEvent = FileOperationEvent;
    /**
     * Possible changes that can occur to a file.
     */
    var FileChangeType;
    (function (FileChangeType) {
        FileChangeType[FileChangeType["UPDATED"] = 0] = "UPDATED";
        FileChangeType[FileChangeType["ADDED"] = 1] = "ADDED";
        FileChangeType[FileChangeType["DELETED"] = 2] = "DELETED";
    })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
    var FileChangesEvent = /** @class */ (function () {
        function FileChangesEvent(changes) {
            this._changes = changes;
        }
        Object.defineProperty(FileChangesEvent.prototype, "changes", {
            get: function () {
                return this._changes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns true if this change event contains the provided file with the given change type. In case of
         * type DELETED, this method will also return true if a folder got deleted that is the parent of the
         * provided file path.
         */
        FileChangesEvent.prototype.contains = function (resource, type) {
            if (!resource) {
                return false;
            }
            return this._changes.some(function (change) {
                if (change.type !== type) {
                    return false;
                }
                // For deleted also return true when deleted folder is parent of target path
                if (type === FileChangeType.DELETED) {
                    return resources_1.isEqualOrParent(resource, change.resource, !platform_1.isLinux /* ignorecase */);
                }
                return resources_1.isEqual(resource, change.resource, !platform_1.isLinux /* ignorecase */);
            });
        };
        /**
         * Returns the changes that describe added files.
         */
        FileChangesEvent.prototype.getAdded = function () {
            return this.getOfType(FileChangeType.ADDED);
        };
        /**
         * Returns if this event contains added files.
         */
        FileChangesEvent.prototype.gotAdded = function () {
            return this.hasType(FileChangeType.ADDED);
        };
        /**
         * Returns the changes that describe deleted files.
         */
        FileChangesEvent.prototype.getDeleted = function () {
            return this.getOfType(FileChangeType.DELETED);
        };
        /**
         * Returns if this event contains deleted files.
         */
        FileChangesEvent.prototype.gotDeleted = function () {
            return this.hasType(FileChangeType.DELETED);
        };
        /**
         * Returns the changes that describe updated files.
         */
        FileChangesEvent.prototype.getUpdated = function () {
            return this.getOfType(FileChangeType.UPDATED);
        };
        /**
         * Returns if this event contains updated files.
         */
        FileChangesEvent.prototype.gotUpdated = function () {
            return this.hasType(FileChangeType.UPDATED);
        };
        FileChangesEvent.prototype.getOfType = function (type) {
            return this._changes.filter(function (change) { return change.type === type; });
        };
        FileChangesEvent.prototype.hasType = function (type) {
            return this._changes.some(function (change) {
                return change.type === type;
            });
        };
        return FileChangesEvent;
    }());
    exports.FileChangesEvent = FileChangesEvent;
    function isParent(path, candidate, ignoreCase) {
        if (!path || !candidate || path === candidate) {
            return false;
        }
        if (candidate.length > path.length) {
            return false;
        }
        if (candidate.charAt(candidate.length - 1) !== paths.nativeSep) {
            candidate += paths.nativeSep;
        }
        if (ignoreCase) {
            return strings_1.startsWithIgnoreCase(path, candidate);
        }
        return path.indexOf(candidate) === 0;
    }
    exports.isParent = isParent;
    var StringSnapshot = /** @class */ (function () {
        function StringSnapshot(_value) {
            this._value = _value;
        }
        StringSnapshot.prototype.read = function () {
            var ret = this._value;
            this._value = null;
            return ret;
        };
        return StringSnapshot;
    }());
    exports.StringSnapshot = StringSnapshot;
    /**
     * Helper method to convert a snapshot into its full string form.
     */
    function snapshotToString(snapshot) {
        var chunks = [];
        var chunk;
        while (typeof (chunk = snapshot.read()) === 'string') {
            chunks.push(chunk);
        }
        return chunks.join('');
    }
    exports.snapshotToString = snapshotToString;
    var FileOperationError = /** @class */ (function (_super) {
        __extends(FileOperationError, _super);
        function FileOperationError(message, fileOperationResult, options) {
            var _this = _super.call(this, message) || this;
            _this.fileOperationResult = fileOperationResult;
            _this.options = options;
            return _this;
        }
        FileOperationError.isFileOperationError = function (obj) {
            return obj instanceof Error && !types_1.isUndefinedOrNull(obj.fileOperationResult);
        };
        return FileOperationError;
    }(Error));
    exports.FileOperationError = FileOperationError;
    var FileOperationResult;
    (function (FileOperationResult) {
        FileOperationResult[FileOperationResult["FILE_IS_BINARY"] = 0] = "FILE_IS_BINARY";
        FileOperationResult[FileOperationResult["FILE_IS_DIRECTORY"] = 1] = "FILE_IS_DIRECTORY";
        FileOperationResult[FileOperationResult["FILE_NOT_FOUND"] = 2] = "FILE_NOT_FOUND";
        FileOperationResult[FileOperationResult["FILE_NOT_MODIFIED_SINCE"] = 3] = "FILE_NOT_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MODIFIED_SINCE"] = 4] = "FILE_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MOVE_CONFLICT"] = 5] = "FILE_MOVE_CONFLICT";
        FileOperationResult[FileOperationResult["FILE_READ_ONLY"] = 6] = "FILE_READ_ONLY";
        FileOperationResult[FileOperationResult["FILE_PERMISSION_DENIED"] = 7] = "FILE_PERMISSION_DENIED";
        FileOperationResult[FileOperationResult["FILE_TOO_LARGE"] = 8] = "FILE_TOO_LARGE";
        FileOperationResult[FileOperationResult["FILE_INVALID_PATH"] = 9] = "FILE_INVALID_PATH";
        FileOperationResult[FileOperationResult["FILE_EXCEED_MEMORY_LIMIT"] = 10] = "FILE_EXCEED_MEMORY_LIMIT";
    })(FileOperationResult = exports.FileOperationResult || (exports.FileOperationResult = {}));
    exports.AutoSaveConfiguration = {
        OFF: 'off',
        AFTER_DELAY: 'afterDelay',
        ON_FOCUS_CHANGE: 'onFocusChange',
        ON_WINDOW_CHANGE: 'onWindowChange'
    };
    exports.HotExitConfiguration = {
        OFF: 'off',
        ON_EXIT: 'onExit',
        ON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'
    };
    exports.CONTENT_CHANGE_EVENT_BUFFER_DELAY = 1000;
    exports.FILES_ASSOCIATIONS_CONFIG = 'files.associations';
    exports.FILES_EXCLUDE_CONFIG = 'files.exclude';
    exports.SUPPORTED_ENCODINGS = {
        utf8: {
            labelLong: 'UTF-8',
            labelShort: 'UTF-8',
            order: 1,
            alias: 'utf8bom'
        },
        utf8bom: {
            labelLong: 'UTF-8 with BOM',
            labelShort: 'UTF-8 with BOM',
            encodeOnly: true,
            order: 2,
            alias: 'utf8'
        },
        utf16le: {
            labelLong: 'UTF-16 LE',
            labelShort: 'UTF-16 LE',
            order: 3
        },
        utf16be: {
            labelLong: 'UTF-16 BE',
            labelShort: 'UTF-16 BE',
            order: 4
        },
        windows1252: {
            labelLong: 'Western (Windows 1252)',
            labelShort: 'Windows 1252',
            order: 5
        },
        iso88591: {
            labelLong: 'Western (ISO 8859-1)',
            labelShort: 'ISO 8859-1',
            order: 6
        },
        iso88593: {
            labelLong: 'Western (ISO 8859-3)',
            labelShort: 'ISO 8859-3',
            order: 7
        },
        iso885915: {
            labelLong: 'Western (ISO 8859-15)',
            labelShort: 'ISO 8859-15',
            order: 8
        },
        macroman: {
            labelLong: 'Western (Mac Roman)',
            labelShort: 'Mac Roman',
            order: 9
        },
        cp437: {
            labelLong: 'DOS (CP 437)',
            labelShort: 'CP437',
            order: 10
        },
        windows1256: {
            labelLong: 'Arabic (Windows 1256)',
            labelShort: 'Windows 1256',
            order: 11
        },
        iso88596: {
            labelLong: 'Arabic (ISO 8859-6)',
            labelShort: 'ISO 8859-6',
            order: 12
        },
        windows1257: {
            labelLong: 'Baltic (Windows 1257)',
            labelShort: 'Windows 1257',
            order: 13
        },
        iso88594: {
            labelLong: 'Baltic (ISO 8859-4)',
            labelShort: 'ISO 8859-4',
            order: 14
        },
        iso885914: {
            labelLong: 'Celtic (ISO 8859-14)',
            labelShort: 'ISO 8859-14',
            order: 15
        },
        windows1250: {
            labelLong: 'Central European (Windows 1250)',
            labelShort: 'Windows 1250',
            order: 16
        },
        iso88592: {
            labelLong: 'Central European (ISO 8859-2)',
            labelShort: 'ISO 8859-2',
            order: 17
        },
        cp852: {
            labelLong: 'Central European (CP 852)',
            labelShort: 'CP 852',
            order: 18
        },
        windows1251: {
            labelLong: 'Cyrillic (Windows 1251)',
            labelShort: 'Windows 1251',
            order: 19
        },
        cp866: {
            labelLong: 'Cyrillic (CP 866)',
            labelShort: 'CP 866',
            order: 20
        },
        iso88595: {
            labelLong: 'Cyrillic (ISO 8859-5)',
            labelShort: 'ISO 8859-5',
            order: 21
        },
        koi8r: {
            labelLong: 'Cyrillic (KOI8-R)',
            labelShort: 'KOI8-R',
            order: 22
        },
        koi8u: {
            labelLong: 'Cyrillic (KOI8-U)',
            labelShort: 'KOI8-U',
            order: 23
        },
        iso885913: {
            labelLong: 'Estonian (ISO 8859-13)',
            labelShort: 'ISO 8859-13',
            order: 24
        },
        windows1253: {
            labelLong: 'Greek (Windows 1253)',
            labelShort: 'Windows 1253',
            order: 25
        },
        iso88597: {
            labelLong: 'Greek (ISO 8859-7)',
            labelShort: 'ISO 8859-7',
            order: 26
        },
        windows1255: {
            labelLong: 'Hebrew (Windows 1255)',
            labelShort: 'Windows 1255',
            order: 27
        },
        iso88598: {
            labelLong: 'Hebrew (ISO 8859-8)',
            labelShort: 'ISO 8859-8',
            order: 28
        },
        iso885910: {
            labelLong: 'Nordic (ISO 8859-10)',
            labelShort: 'ISO 8859-10',
            order: 29
        },
        iso885916: {
            labelLong: 'Romanian (ISO 8859-16)',
            labelShort: 'ISO 8859-16',
            order: 30
        },
        windows1254: {
            labelLong: 'Turkish (Windows 1254)',
            labelShort: 'Windows 1254',
            order: 31
        },
        iso88599: {
            labelLong: 'Turkish (ISO 8859-9)',
            labelShort: 'ISO 8859-9',
            order: 32
        },
        windows1258: {
            labelLong: 'Vietnamese (Windows 1258)',
            labelShort: 'Windows 1258',
            order: 33
        },
        gbk: {
            labelLong: 'Simplified Chinese (GBK)',
            labelShort: 'GBK',
            order: 34
        },
        gb18030: {
            labelLong: 'Simplified Chinese (GB18030)',
            labelShort: 'GB18030',
            order: 35
        },
        cp950: {
            labelLong: 'Traditional Chinese (Big5)',
            labelShort: 'Big5',
            order: 36
        },
        big5hkscs: {
            labelLong: 'Traditional Chinese (Big5-HKSCS)',
            labelShort: 'Big5-HKSCS',
            order: 37
        },
        shiftjis: {
            labelLong: 'Japanese (Shift JIS)',
            labelShort: 'Shift JIS',
            order: 38
        },
        eucjp: {
            labelLong: 'Japanese (EUC-JP)',
            labelShort: 'EUC-JP',
            order: 39
        },
        euckr: {
            labelLong: 'Korean (EUC-KR)',
            labelShort: 'EUC-KR',
            order: 40
        },
        windows874: {
            labelLong: 'Thai (Windows 874)',
            labelShort: 'Windows 874',
            order: 41
        },
        iso885911: {
            labelLong: 'Latin/Thai (ISO 8859-11)',
            labelShort: 'ISO 8859-11',
            order: 42
        },
        koi8ru: {
            labelLong: 'Cyrillic (KOI8-RU)',
            labelShort: 'KOI8-RU',
            order: 43
        },
        koi8t: {
            labelLong: 'Tajik (KOI8-T)',
            labelShort: 'KOI8-T',
            order: 44
        },
        gb2312: {
            labelLong: 'Simplified Chinese (GB 2312)',
            labelShort: 'GB 2312',
            order: 45
        },
        cp865: {
            labelLong: 'Nordic DOS (CP 865)',
            labelShort: 'CP 865',
            order: 46
        },
        cp850: {
            labelLong: 'Western European DOS (CP 850)',
            labelShort: 'CP 850',
            order: 47
        }
    };
    var FileKind;
    (function (FileKind) {
        FileKind[FileKind["FILE"] = 0] = "FILE";
        FileKind[FileKind["FOLDER"] = 1] = "FOLDER";
        FileKind[FileKind["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
    })(FileKind = exports.FileKind || (exports.FileKind = {}));
    exports.MIN_MAX_MEMORY_SIZE_MB = 2048;
    exports.FALLBACK_MAX_MEMORY_SIZE_MB = 4096;
});

define(__m[128/*vs/platform/keybinding/common/keybinding*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var KeybindingSource;
    (function (KeybindingSource) {
        KeybindingSource[KeybindingSource["Default"] = 1] = "Default";
        KeybindingSource[KeybindingSource["User"] = 2] = "User";
    })(KeybindingSource = exports.KeybindingSource || (exports.KeybindingSource = {}));
    exports.IKeybindingService = instantiation_1.createDecorator('keybindingService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[38/*vs/platform/log/common/log*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/,9/*vs/base/common/lifecycle*/,10/*vs/base/common/platform*/,3/*vs/base/common/event*/]), function (require, exports, instantiation_1, lifecycle_1, platform_1, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ILogService = instantiation_1.createDecorator('logService');
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Trace"] = 0] = "Trace";
        LogLevel[LogLevel["Debug"] = 1] = "Debug";
        LogLevel[LogLevel["Info"] = 2] = "Info";
        LogLevel[LogLevel["Warning"] = 3] = "Warning";
        LogLevel[LogLevel["Error"] = 4] = "Error";
        LogLevel[LogLevel["Critical"] = 5] = "Critical";
        LogLevel[LogLevel["Off"] = 6] = "Off";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
    exports.DEFAULT_LOG_LEVEL = LogLevel.Info;
    var AbstractLogService = /** @class */ (function (_super) {
        __extends(AbstractLogService, _super);
        function AbstractLogService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.level = exports.DEFAULT_LOG_LEVEL;
            _this._onDidChangeLogLevel = _this._register(new event_1.Emitter());
            _this.onDidChangeLogLevel = _this._onDidChangeLogLevel.event;
            return _this;
        }
        AbstractLogService.prototype.setLevel = function (level) {
            if (this.level !== level) {
                this.level = level;
                this._onDidChangeLogLevel.fire(this.level);
            }
        };
        AbstractLogService.prototype.getLevel = function () {
            return this.level;
        };
        return AbstractLogService;
    }(lifecycle_1.Disposable));
    exports.AbstractLogService = AbstractLogService;
    var ConsoleLogMainService = /** @class */ (function (_super) {
        __extends(ConsoleLogMainService, _super);
        function ConsoleLogMainService(logLevel) {
            if (logLevel === void 0) { logLevel = exports.DEFAULT_LOG_LEVEL; }
            var _this = _super.call(this) || this;
            _this.setLevel(logLevel);
            _this.useColors = !platform_1.isWindows;
            return _this;
        }
        ConsoleLogMainService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Trace) {
                if (this.useColors) {
                    console.log.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.log.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Debug) {
                if (this.useColors) {
                    console.log.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.log.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Info) {
                if (this.useColors) {
                    console.log.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.log.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Warning) {
                if (this.useColors) {
                    console.warn.apply(console, ["\u001B[93m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.warn.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Error) {
                if (this.useColors) {
                    console.error.apply(console, ["\u001B[91m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.error.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Critical) {
                if (this.useColors) {
                    console.error.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.error.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.dispose = function () {
            // noop
        };
        return ConsoleLogMainService;
    }(AbstractLogService));
    exports.ConsoleLogMainService = ConsoleLogMainService;
    var ConsoleLogService = /** @class */ (function (_super) {
        __extends(ConsoleLogService, _super);
        function ConsoleLogService(logLevel) {
            if (logLevel === void 0) { logLevel = exports.DEFAULT_LOG_LEVEL; }
            var _this = _super.call(this) || this;
            _this.setLevel(logLevel);
            return _this;
        }
        ConsoleLogService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Trace) {
                console.log.apply(console, ['%cTRACE', 'color: #888', message].concat(args));
            }
        };
        ConsoleLogService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Debug) {
                console.log.apply(console, ['%cDEBUG', 'background: #eee; color: #888', message].concat(args));
            }
        };
        ConsoleLogService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Info) {
                console.log.apply(console, ['%c INFO', 'color: #33f', message].concat(args));
            }
        };
        ConsoleLogService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Warning) {
                console.log.apply(console, ['%c WARN', 'color: #993', message].concat(args));
            }
        };
        ConsoleLogService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Error) {
                console.log.apply(console, ['%c  ERR', 'color: #f33', message].concat(args));
            }
        };
        ConsoleLogService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Critical) {
                console.log.apply(console, ['%cCRITI', 'background: #f33; color: white', message].concat(args));
            }
        };
        ConsoleLogService.prototype.dispose = function () { };
        return ConsoleLogService;
    }(AbstractLogService));
    exports.ConsoleLogService = ConsoleLogService;
    var MultiplexLogService = /** @class */ (function (_super) {
        __extends(MultiplexLogService, _super);
        function MultiplexLogService(logServices) {
            var _this = _super.call(this) || this;
            _this.logServices = logServices;
            if (logServices.length) {
                _this.setLevel(logServices[0].getLevel());
            }
            return _this;
        }
        MultiplexLogService.prototype.setLevel = function (level) {
            for (var _i = 0, _a = this.logServices; _i < _a.length; _i++) {
                var logService = _a[_i];
                logService.setLevel(level);
            }
            _super.prototype.setLevel.call(this, level);
        };
        MultiplexLogService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.trace.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.debug.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.info.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.warn.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.error.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.critical.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.dispose = function () {
            for (var _i = 0, _a = this.logServices; _i < _a.length; _i++) {
                var logService = _a[_i];
                logService.dispose();
            }
        };
        return MultiplexLogService;
    }(AbstractLogService));
    exports.MultiplexLogService = MultiplexLogService;
    var DelegatedLogService = /** @class */ (function (_super) {
        __extends(DelegatedLogService, _super);
        function DelegatedLogService(logService) {
            var _this = _super.call(this) || this;
            _this.logService = logService;
            _this._register(logService);
            return _this;
        }
        Object.defineProperty(DelegatedLogService.prototype, "onDidChangeLogLevel", {
            get: function () {
                return this.logService.onDidChangeLogLevel;
            },
            enumerable: true,
            configurable: true
        });
        DelegatedLogService.prototype.setLevel = function (level) {
            this.logService.setLevel(level);
        };
        DelegatedLogService.prototype.getLevel = function () {
            return this.logService.getLevel();
        };
        DelegatedLogService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).trace.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).debug.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).info.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).warn.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).error.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).critical.apply(_a, [message].concat(args));
        };
        return DelegatedLogService;
    }(lifecycle_1.Disposable));
    exports.DelegatedLogService = DelegatedLogService;
    var NullLogService = /** @class */ (function () {
        function NullLogService() {
            this.onDidChangeLogLevel = new event_1.Emitter().event;
        }
        NullLogService.prototype.setLevel = function (level) { };
        NullLogService.prototype.getLevel = function () { return LogLevel.Info; };
        NullLogService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.dispose = function () { };
        return NullLogService;
    }());
    exports.NullLogService = NullLogService;
    function getLogLevel(environmentService) {
        if (environmentService.verbose) {
            return LogLevel.Trace;
        }
        if (typeof environmentService.args.log === 'string') {
            var logLevel = environmentService.args.log.toLowerCase();
            switch (logLevel) {
                case 'trace':
                    return LogLevel.Trace;
                case 'debug':
                    return LogLevel.Debug;
                case 'info':
                    return LogLevel.Info;
                case 'warn':
                    return LogLevel.Warning;
                case 'error':
                    return LogLevel.Error;
                case 'critical':
                    return LogLevel.Critical;
                case 'off':
                    return LogLevel.Off;
            }
        }
        return exports.DEFAULT_LOG_LEVEL;
    }
    exports.getLogLevel = getLogLevel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[130/*vs/platform/log/node/spdlogService*/], __M([0/*require*/,1/*exports*/,22/*path*/,38/*vs/platform/log/common/log*/]), function (require, exports, path, log_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function createSpdLogService(processName, logLevel, logsFolder) {
        // Do not crash if spdlog cannot be loaded
        try {
            var _spdlog = require.__$__nodeRequire('spdlog');
            _spdlog.setAsyncMode(8192, 2000);
            var logfilePath = path.join(logsFolder, processName + ".log");
            var logger = new _spdlog.RotatingLogger(processName, logfilePath, 1024 * 1024 * 5, 6);
            logger.setLevel(0);
            return new SpdLogService(logger, logLevel);
        }
        catch (e) {
            console.error(e);
        }
        return new log_1.NullLogService();
    }
    exports.createSpdLogService = createSpdLogService;
    var SpdLogService = /** @class */ (function (_super) {
        __extends(SpdLogService, _super);
        function SpdLogService(logger, level) {
            if (level === void 0) { level = log_1.LogLevel.Error; }
            var _this = _super.call(this) || this;
            _this.logger = logger;
            _this.setLevel(level);
            return _this;
        }
        SpdLogService.prototype.trace = function () {
            if (this.getLevel() <= log_1.LogLevel.Trace) {
                this.logger.trace(this.format(arguments));
            }
        };
        SpdLogService.prototype.debug = function () {
            if (this.getLevel() <= log_1.LogLevel.Debug) {
                this.logger.debug(this.format(arguments));
            }
        };
        SpdLogService.prototype.info = function () {
            if (this.getLevel() <= log_1.LogLevel.Info) {
                this.logger.info(this.format(arguments));
            }
        };
        SpdLogService.prototype.warn = function () {
            if (this.getLevel() <= log_1.LogLevel.Warning) {
                this.logger.warn(this.format(arguments));
            }
        };
        SpdLogService.prototype.error = function () {
            if (this.getLevel() <= log_1.LogLevel.Error) {
                var arg = arguments[0];
                if (arg instanceof Error) {
                    var array = Array.prototype.slice.call(arguments);
                    array[0] = arg.stack;
                    this.logger.error(this.format(array));
                }
                else {
                    this.logger.error(this.format(arguments));
                }
            }
        };
        SpdLogService.prototype.critical = function () {
            if (this.getLevel() <= log_1.LogLevel.Critical) {
                this.logger.critical(this.format(arguments));
            }
        };
        SpdLogService.prototype.dispose = function () {
            this.logger.drop();
        };
        SpdLogService.prototype.format = function (args) {
            var result = '';
            for (var i = 0; i < args.length; i++) {
                var a = args[i];
                if (typeof a === 'object') {
                    try {
                        a = JSON.stringify(a);
                    }
                    catch (e) { }
                }
                result += (i > 0 ? ' ' : '') + a;
            }
            return result;
        };
        return SpdLogService;
    }(log_1.AbstractLogService));
});

define(__m[64/*vs/platform/markers/common/markers*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/,105/*vs/nls!vs/platform/markers/common/markers*/,34/*vs/base/common/severity*/]), function (require, exports, instantiation_1, nls_1, severity_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var MarkerTag;
    (function (MarkerTag) {
        MarkerTag[MarkerTag["Unnecessary"] = 1] = "Unnecessary";
    })(MarkerTag = exports.MarkerTag || (exports.MarkerTag = {}));
    var MarkerSeverity;
    (function (MarkerSeverity) {
        MarkerSeverity[MarkerSeverity["Hint"] = 1] = "Hint";
        MarkerSeverity[MarkerSeverity["Info"] = 2] = "Info";
        MarkerSeverity[MarkerSeverity["Warning"] = 4] = "Warning";
        MarkerSeverity[MarkerSeverity["Error"] = 8] = "Error";
    })(MarkerSeverity = exports.MarkerSeverity || (exports.MarkerSeverity = {}));
    (function (MarkerSeverity) {
        function compare(a, b) {
            return b - a;
        }
        MarkerSeverity.compare = compare;
        var _displayStrings = Object.create(null);
        _displayStrings[MarkerSeverity.Error] = nls_1.localize(0, null);
        _displayStrings[MarkerSeverity.Warning] = nls_1.localize(1, null);
        _displayStrings[MarkerSeverity.Info] = nls_1.localize(2, null);
        function toString(a) {
            return _displayStrings[a] || '';
        }
        MarkerSeverity.toString = toString;
        function fromSeverity(severity) {
            switch (severity) {
                case severity_1.default.Error: return MarkerSeverity.Error;
                case severity_1.default.Warning: return MarkerSeverity.Warning;
                case severity_1.default.Info: return MarkerSeverity.Info;
                case severity_1.default.Ignore: return MarkerSeverity.Hint;
            }
        }
        MarkerSeverity.fromSeverity = fromSeverity;
    })(MarkerSeverity = exports.MarkerSeverity || (exports.MarkerSeverity = {}));
    var IMarkerData;
    (function (IMarkerData) {
        var emptyString = '';
        function makeKey(markerData) {
            var result = [emptyString];
            if (markerData.source) {
                result.push(markerData.source.replace('¦', '\¦'));
            }
            else {
                result.push(emptyString);
            }
            if (markerData.code) {
                result.push(markerData.code.replace('¦', '\¦'));
            }
            else {
                result.push(emptyString);
            }
            if (markerData.severity !== void 0 && markerData.severity !== null) {
                result.push(MarkerSeverity.toString(markerData.severity));
            }
            else {
                result.push(emptyString);
            }
            if (markerData.message) {
                result.push(markerData.message.replace('¦', '\¦'));
            }
            else {
                result.push(emptyString);
            }
            if (markerData.startLineNumber !== void 0 && markerData.startLineNumber !== null) {
                result.push(markerData.startLineNumber.toString());
            }
            else {
                result.push(emptyString);
            }
            if (markerData.startColumn !== void 0 && markerData.startColumn !== null) {
                result.push(markerData.startColumn.toString());
            }
            else {
                result.push(emptyString);
            }
            if (markerData.endLineNumber !== void 0 && markerData.endLineNumber !== null) {
                result.push(markerData.endLineNumber.toString());
            }
            else {
                result.push(emptyString);
            }
            if (markerData.endColumn !== void 0 && markerData.endColumn !== null) {
                result.push(markerData.endColumn.toString());
            }
            else {
                result.push(emptyString);
            }
            result.push(emptyString);
            return result.join('¦');
        }
        IMarkerData.makeKey = makeKey;
    })(IMarkerData = exports.IMarkerData || (exports.IMarkerData = {}));
    exports.IMarkerService = instantiation_1.createDecorator('markerService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[65/*vs/platform/node/package*/], __M([0/*require*/,1/*exports*/,22/*path*/,4/*vs/base/common/uri*/]), function (require, exports, path, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var rootPath = path.dirname(uri_1.default.parse(require.toUrl('')).fsPath);
    var packageJsonPath = path.join(rootPath, 'package.json');
    exports.default = require.__$__nodeRequire(packageJsonPath);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[133/*vs/platform/node/product*/], __M([0/*require*/,1/*exports*/,22/*path*/,4/*vs/base/common/uri*/]), function (require, exports, path, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var rootPath = path.dirname(uri_1.default.parse(require.toUrl('')).fsPath);
    var productJsonPath = path.join(rootPath, 'product.json');
    var product = require.__$__nodeRequire(productJsonPath);
    if (process.env['VSCODE_DEV']) {
        product.nameShort += ' Dev';
        product.nameLong += ' Dev';
        product.dataFolderName += '-dev';
    }
    exports.default = product;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[134/*vs/platform/notification/common/notification*/], __M([0/*require*/,1/*exports*/,34/*vs/base/common/severity*/,7/*vs/platform/instantiation/common/instantiation*/,3/*vs/base/common/event*/]), function (require, exports, severity_1, instantiation_1, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Severity = severity_1.default;
    exports.INotificationService = instantiation_1.createDecorator('notificationService');
    var NoOpNotification = /** @class */ (function () {
        function NoOpNotification() {
            this.progress = new NoOpProgress();
            this._onDidClose = new event_1.Emitter();
        }
        Object.defineProperty(NoOpNotification.prototype, "onDidClose", {
            get: function () {
                return this._onDidClose.event;
            },
            enumerable: true,
            configurable: true
        });
        NoOpNotification.prototype.updateSeverity = function (severity) { };
        NoOpNotification.prototype.updateMessage = function (message) { };
        NoOpNotification.prototype.updateActions = function (actions) { };
        NoOpNotification.prototype.close = function () {
            this._onDidClose.dispose();
        };
        return NoOpNotification;
    }());
    exports.NoOpNotification = NoOpNotification;
    var NoOpProgress = /** @class */ (function () {
        function NoOpProgress() {
        }
        NoOpProgress.prototype.infinite = function () { };
        NoOpProgress.prototype.done = function () { };
        NoOpProgress.prototype.total = function (value) { };
        NoOpProgress.prototype.worked = function (value) { };
        return NoOpProgress;
    }());
    exports.NoOpProgress = NoOpProgress;
});

define(__m[135/*vs/platform/progress/common/progress*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/,29/*vs/base/common/cancellation*/,9/*vs/base/common/lifecycle*/]), function (require, exports, instantiation_1, cancellation_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IProgressService = instantiation_1.createDecorator('progressService');
    exports.emptyProgressRunner = Object.freeze({
        total: function () { },
        worked: function () { },
        done: function () { }
    });
    exports.emptyProgress = Object.freeze({ report: function () { } });
    var Progress = /** @class */ (function () {
        function Progress(callback) {
            this._callback = callback;
        }
        Object.defineProperty(Progress.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        Progress.prototype.report = function (item) {
            this._value = item;
            this._callback(this._value);
        };
        return Progress;
    }());
    exports.Progress = Progress;
    var LongRunningOperation = /** @class */ (function () {
        function LongRunningOperation(progressService) {
            this.progressService = progressService;
            this.currentOperationId = 0;
            this.currentOperationDisposables = [];
        }
        LongRunningOperation.prototype.start = function (progressDelay) {
            var _this = this;
            // Stop any previous operation
            this.stop();
            // Start new
            var newOperationId = ++this.currentOperationId;
            var newOperationToken = new cancellation_1.CancellationTokenSource();
            this.currentProgressTimeout = setTimeout(function () {
                if (newOperationId === _this.currentOperationId) {
                    _this.currentProgressRunner = _this.progressService.show(true);
                }
            }, progressDelay);
            this.currentOperationDisposables.push(lifecycle_1.toDisposable(function () { return clearTimeout(_this.currentProgressTimeout); }), lifecycle_1.toDisposable(function () { return newOperationToken.cancel(); }), lifecycle_1.toDisposable(function () { return _this.currentProgressRunner ? _this.currentProgressRunner.done() : void 0; }));
            return {
                id: newOperationId,
                token: newOperationToken.token,
                stop: function () { return _this.doStop(newOperationId); },
                isCurrent: function () { return _this.currentOperationId === newOperationId; }
            };
        };
        LongRunningOperation.prototype.stop = function () {
            this.doStop(this.currentOperationId);
        };
        LongRunningOperation.prototype.doStop = function (operationId) {
            if (this.currentOperationId === operationId) {
                this.currentOperationDisposables = lifecycle_1.dispose(this.currentOperationDisposables);
            }
        };
        LongRunningOperation.prototype.dispose = function () {
            this.currentOperationDisposables = lifecycle_1.dispose(this.currentOperationDisposables);
        };
        return LongRunningOperation;
    }());
    exports.LongRunningOperation = LongRunningOperation;
});

define(__m[31/*vs/platform/registry/common/platform*/], __M([0/*require*/,1/*exports*/,18/*vs/base/common/types*/,32/*vs/base/common/assert*/]), function (require, exports, Types, Assert) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RegistryImpl = /** @class */ (function () {
        function RegistryImpl() {
            this.data = {};
        }
        RegistryImpl.prototype.add = function (id, data) {
            Assert.ok(Types.isString(id));
            Assert.ok(Types.isObject(data));
            Assert.ok(!this.data.hasOwnProperty(id), 'There is already an extension with this id');
            this.data[id] = data;
        };
        RegistryImpl.prototype.knows = function (id) {
            return this.data.hasOwnProperty(id);
        };
        RegistryImpl.prototype.as = function (id) {
            return this.data[id] || null;
        };
        return RegistryImpl;
    }());
    exports.Registry = new RegistryImpl();
});

define(__m[67/*vs/editor/common/modes/modesRegistry*/], __M([0/*require*/,1/*exports*/,103/*vs/nls!vs/editor/common/modes/modesRegistry*/,3/*vs/base/common/event*/,31/*vs/platform/registry/common/platform*/,73/*vs/editor/common/modes/languageConfigurationRegistry*/,36/*vs/editor/common/modes*/]), function (require, exports, nls, event_1, platform_1, languageConfigurationRegistry_1, modes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // Define extension point ids
    exports.Extensions = {
        ModesRegistry: 'editor.modesRegistry'
    };
    var EditorModesRegistry = /** @class */ (function () {
        function EditorModesRegistry() {
            this._onDidAddLanguages = new event_1.Emitter();
            this.onDidAddLanguages = this._onDidAddLanguages.event;
            this._languages = [];
        }
        // --- languages
        EditorModesRegistry.prototype.registerLanguage = function (def) {
            this._languages.push(def);
            this._onDidAddLanguages.fire([def]);
        };
        EditorModesRegistry.prototype.registerLanguages = function (def) {
            this._languages = this._languages.concat(def);
            this._onDidAddLanguages.fire(def);
        };
        EditorModesRegistry.prototype.getLanguages = function () {
            return this._languages.slice(0);
        };
        return EditorModesRegistry;
    }());
    exports.EditorModesRegistry = EditorModesRegistry;
    exports.ModesRegistry = new EditorModesRegistry();
    platform_1.Registry.add(exports.Extensions.ModesRegistry, exports.ModesRegistry);
    exports.PLAINTEXT_MODE_ID = 'plaintext';
    exports.PLAINTEXT_LANGUAGE_IDENTIFIER = new modes_1.LanguageIdentifier(exports.PLAINTEXT_MODE_ID, 1 /* PlainText */);
    exports.ModesRegistry.registerLanguage({
        id: exports.PLAINTEXT_MODE_ID,
        extensions: ['.txt', '.gitignore'],
        aliases: [nls.localize(0, null), 'text'],
        mimetypes: ['text/plain']
    });
    languageConfigurationRegistry_1.LanguageConfigurationRegistry.register(exports.PLAINTEXT_LANGUAGE_IDENTIFIER, {
        brackets: [
            ['(', ')'],
            ['[', ']'],
            ['{', '}'],
        ]
    });
});

define(__m[138/*vs/platform/jsonschemas/common/jsonContributionRegistry*/], __M([0/*require*/,1/*exports*/,31/*vs/platform/registry/common/platform*/,3/*vs/base/common/event*/]), function (require, exports, platform, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Extensions = {
        JSONContribution: 'base.contributions.json'
    };
    function normalizeId(id) {
        if (id.length > 0 && id.charAt(id.length - 1) === '#') {
            return id.substring(0, id.length - 1);
        }
        return id;
    }
    var JSONContributionRegistry = /** @class */ (function () {
        function JSONContributionRegistry() {
            this._onDidChangeSchema = new event_1.Emitter();
            this.onDidChangeSchema = this._onDidChangeSchema.event;
            this.schemasById = {};
        }
        JSONContributionRegistry.prototype.registerSchema = function (uri, unresolvedSchemaContent) {
            this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;
            this._onDidChangeSchema.fire(uri);
        };
        JSONContributionRegistry.prototype.notifySchemaChanged = function (uri) {
            this._onDidChangeSchema.fire(uri);
        };
        JSONContributionRegistry.prototype.getSchemaContributions = function () {
            return {
                schemas: this.schemasById,
            };
        };
        return JSONContributionRegistry;
    }());
    var jsonContributionRegistry = new JSONContributionRegistry();
    platform.Registry.add(exports.Extensions.JSONContribution, jsonContributionRegistry);
});

define(__m[40/*vs/platform/configuration/common/configurationRegistry*/], __M([0/*require*/,1/*exports*/,104/*vs/nls!vs/platform/configuration/common/configurationRegistry*/,3/*vs/base/common/event*/,31/*vs/platform/registry/common/platform*/,18/*vs/base/common/types*/,8/*vs/base/common/strings*/,138/*vs/platform/jsonschemas/common/jsonContributionRegistry*/]), function (require, exports, nls, event_1, platform_1, types, strings, jsonContributionRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Extensions = {
        Configuration: 'base.contributions.configuration'
    };
    var ConfigurationScope;
    (function (ConfigurationScope) {
        ConfigurationScope[ConfigurationScope["APPLICATION"] = 1] = "APPLICATION";
        ConfigurationScope[ConfigurationScope["WINDOW"] = 2] = "WINDOW";
        ConfigurationScope[ConfigurationScope["RESOURCE"] = 3] = "RESOURCE";
    })(ConfigurationScope = exports.ConfigurationScope || (exports.ConfigurationScope = {}));
    exports.allSettings = { properties: {}, patternProperties: {} };
    exports.applicationSettings = { properties: {}, patternProperties: {} };
    exports.windowSettings = { properties: {}, patternProperties: {} };
    exports.resourceSettings = { properties: {}, patternProperties: {} };
    exports.editorConfigurationSchemaId = 'vscode://schemas/settings/editor';
    var contributionRegistry = platform_1.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);
    var ConfigurationRegistry = /** @class */ (function () {
        function ConfigurationRegistry() {
            this.overrideIdentifiers = [];
            this._onDidSchemaChange = new event_1.Emitter();
            this.onDidSchemaChange = this._onDidSchemaChange.event;
            this._onDidRegisterConfiguration = new event_1.Emitter();
            this.onDidRegisterConfiguration = this._onDidRegisterConfiguration.event;
            this.configurationContributors = [];
            this.editorConfigurationSchema = { properties: {}, patternProperties: {}, additionalProperties: false, errorMessage: 'Unknown editor configuration setting' };
            this.configurationProperties = {};
            this.excludedConfigurationProperties = {};
            this.computeOverridePropertyPattern();
            contributionRegistry.registerSchema(exports.editorConfigurationSchemaId, this.editorConfigurationSchema);
        }
        ConfigurationRegistry.prototype.registerConfiguration = function (configuration, validate) {
            if (validate === void 0) { validate = true; }
            this.registerConfigurations([configuration], [], validate);
        };
        ConfigurationRegistry.prototype.registerConfigurations = function (configurations, defaultConfigurations, validate) {
            var _this = this;
            if (validate === void 0) { validate = true; }
            var configurationNode = this.toConfiguration(defaultConfigurations);
            if (configurationNode) {
                configurations.push(configurationNode);
            }
            var properties = [];
            configurations.forEach(function (configuration) {
                properties.push.apply(properties, _this.validateAndRegisterProperties(configuration, validate)); // fills in defaults
                _this.configurationContributors.push(configuration);
                _this.registerJSONConfiguration(configuration);
                _this.updateSchemaForOverrideSettingsConfiguration(configuration);
            });
            this._onDidRegisterConfiguration.fire(properties);
        };
        ConfigurationRegistry.prototype.notifyConfigurationSchemaUpdated = function (configuration) {
            contributionRegistry.notifySchemaChanged(exports.editorConfigurationSchemaId);
        };
        ConfigurationRegistry.prototype.registerOverrideIdentifiers = function (overrideIdentifiers) {
            var _a;
            (_a = this.overrideIdentifiers).push.apply(_a, overrideIdentifiers);
            this.updateOverridePropertyPatternKey();
        };
        ConfigurationRegistry.prototype.toConfiguration = function (defaultConfigurations) {
            var configurationNode = {
                id: 'defaultOverrides',
                title: nls.localize(0, null),
                properties: {}
            };
            for (var _i = 0, defaultConfigurations_1 = defaultConfigurations; _i < defaultConfigurations_1.length; _i++) {
                var defaultConfiguration = defaultConfigurations_1[_i];
                for (var key in defaultConfiguration.defaults) {
                    var defaultValue = defaultConfiguration.defaults[key];
                    if (exports.OVERRIDE_PROPERTY_PATTERN.test(key) && typeof defaultValue === 'object') {
                        configurationNode.properties[key] = {
                            type: 'object',
                            default: defaultValue,
                            description: nls.localize(1, null, key),
                            $ref: exports.editorConfigurationSchemaId
                        };
                    }
                }
            }
            return Object.keys(configurationNode.properties).length ? configurationNode : null;
        };
        ConfigurationRegistry.prototype.validateAndRegisterProperties = function (configuration, validate, scope, overridable) {
            if (validate === void 0) { validate = true; }
            if (scope === void 0) { scope = ConfigurationScope.WINDOW; }
            if (overridable === void 0) { overridable = false; }
            scope = types.isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;
            overridable = configuration.overridable || overridable;
            var propertyKeys = [];
            var properties = configuration.properties;
            if (properties) {
                for (var key in properties) {
                    var message = void 0;
                    if (validate && (message = validateProperty(key))) {
                        console.warn(message);
                        delete properties[key];
                        continue;
                    }
                    // fill in default values
                    var property = properties[key];
                    var defaultValue = property.default;
                    if (types.isUndefined(defaultValue)) {
                        property.default = getDefaultValue(property.type);
                    }
                    // Inherit overridable property from parent
                    if (overridable) {
                        property.overridable = true;
                    }
                    if (exports.OVERRIDE_PROPERTY_PATTERN.test(key)) {
                        property.scope = void 0; // No scope for overridable properties `[${identifier}]`
                    }
                    else {
                        property.scope = types.isUndefinedOrNull(property.scope) ? scope : property.scope;
                    }
                    // Add to properties maps
                    // Property is included by default if 'included' is unspecified
                    if (properties[key].hasOwnProperty('included') && !properties[key].included) {
                        this.excludedConfigurationProperties[key] = properties[key];
                        delete properties[key];
                        continue;
                    }
                    else {
                        this.configurationProperties[key] = properties[key];
                    }
                    propertyKeys.push(key);
                }
            }
            var subNodes = configuration.allOf;
            if (subNodes) {
                for (var _i = 0, subNodes_1 = subNodes; _i < subNodes_1.length; _i++) {
                    var node = subNodes_1[_i];
                    propertyKeys.push.apply(propertyKeys, this.validateAndRegisterProperties(node, validate, scope, overridable));
                }
            }
            return propertyKeys;
        };
        ConfigurationRegistry.prototype.getConfigurations = function () {
            return this.configurationContributors;
        };
        ConfigurationRegistry.prototype.getConfigurationProperties = function () {
            return this.configurationProperties;
        };
        ConfigurationRegistry.prototype.getExcludedConfigurationProperties = function () {
            return this.excludedConfigurationProperties;
        };
        ConfigurationRegistry.prototype.registerJSONConfiguration = function (configuration) {
            function register(configuration) {
                var properties = configuration.properties;
                if (properties) {
                    for (var key in properties) {
                        exports.allSettings.properties[key] = properties[key];
                        switch (properties[key].scope) {
                            case ConfigurationScope.APPLICATION:
                                exports.applicationSettings.properties[key] = properties[key];
                                break;
                            case ConfigurationScope.WINDOW:
                                exports.windowSettings.properties[key] = properties[key];
                                break;
                            case ConfigurationScope.RESOURCE:
                                exports.resourceSettings.properties[key] = properties[key];
                                break;
                        }
                    }
                }
                var subNodes = configuration.allOf;
                if (subNodes) {
                    subNodes.forEach(register);
                }
            }
            register(configuration);
            this._onDidSchemaChange.fire();
        };
        ConfigurationRegistry.prototype.updateSchemaForOverrideSettingsConfiguration = function (configuration) {
            if (configuration.id !== SETTINGS_OVERRRIDE_NODE_ID) {
                this.update(configuration);
                contributionRegistry.registerSchema(exports.editorConfigurationSchemaId, this.editorConfigurationSchema);
            }
        };
        ConfigurationRegistry.prototype.updateOverridePropertyPatternKey = function () {
            var patternProperties = exports.allSettings.patternProperties[this.overridePropertyPattern];
            if (!patternProperties) {
                patternProperties = {
                    type: 'object',
                    description: nls.localize(2, null),
                    errorMessage: 'Unknown Identifier. Use language identifiers',
                    $ref: exports.editorConfigurationSchemaId
                };
            }
            delete exports.allSettings.patternProperties[this.overridePropertyPattern];
            delete exports.applicationSettings.patternProperties[this.overridePropertyPattern];
            delete exports.windowSettings.patternProperties[this.overridePropertyPattern];
            delete exports.resourceSettings.patternProperties[this.overridePropertyPattern];
            this.computeOverridePropertyPattern();
            exports.allSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
            exports.applicationSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
            exports.windowSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
            exports.resourceSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
            this._onDidSchemaChange.fire();
        };
        ConfigurationRegistry.prototype.update = function (configuration) {
            var _this = this;
            var properties = configuration.properties;
            if (properties) {
                for (var key in properties) {
                    if (properties[key].overridable) {
                        this.editorConfigurationSchema.properties[key] = this.getConfigurationProperties()[key];
                    }
                }
            }
            var subNodes = configuration.allOf;
            if (subNodes) {
                subNodes.forEach(function (subNode) { return _this.update(subNode); });
            }
        };
        ConfigurationRegistry.prototype.computeOverridePropertyPattern = function () {
            this.overridePropertyPattern = this.overrideIdentifiers.length ? OVERRIDE_PATTERN_WITH_SUBSTITUTION.replace('${0}', this.overrideIdentifiers.map(function (identifier) { return strings.createRegExp(identifier, false).source; }).join('|')) : OVERRIDE_PROPERTY;
        };
        return ConfigurationRegistry;
    }());
    var SETTINGS_OVERRRIDE_NODE_ID = 'override';
    var OVERRIDE_PROPERTY = '\\[.*\\]$';
    var OVERRIDE_PATTERN_WITH_SUBSTITUTION = '\\[(${0})\\]$';
    exports.OVERRIDE_PROPERTY_PATTERN = new RegExp(OVERRIDE_PROPERTY);
    function getDefaultValue(type) {
        var t = Array.isArray(type) ? type[0] : type;
        switch (t) {
            case 'boolean':
                return false;
            case 'integer':
            case 'number':
                return 0;
            case 'string':
                return '';
            case 'array':
                return [];
            case 'object':
                return {};
            default:
                return null;
        }
    }
    var configurationRegistry = new ConfigurationRegistry();
    platform_1.Registry.add(exports.Extensions.Configuration, configurationRegistry);
    function validateProperty(property) {
        if (exports.OVERRIDE_PROPERTY_PATTERN.test(property)) {
            return nls.localize(3, null, property);
        }
        if (configurationRegistry.getConfigurationProperties()[property] !== void 0) {
            return nls.localize(4, null, property);
        }
        return null;
    }
    exports.validateProperty = validateProperty;
    function getScopes() {
        var scopes = {};
        var configurationProperties = configurationRegistry.getConfigurationProperties();
        for (var _i = 0, _a = Object.keys(configurationProperties); _i < _a.length; _i++) {
            var key = _a[_i];
            scopes[key] = configurationProperties[key].scope;
        }
        scopes['launch'] = ConfigurationScope.RESOURCE;
        scopes['task'] = ConfigurationScope.RESOURCE;
        return scopes;
    }
    exports.getScopes = getScopes;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[30/*vs/platform/configuration/common/configuration*/], __M([0/*require*/,1/*exports*/,20/*vs/base/common/objects*/,18/*vs/base/common/types*/,4/*vs/base/common/uri*/,31/*vs/platform/registry/common/platform*/,7/*vs/platform/instantiation/common/instantiation*/,40/*vs/platform/configuration/common/configurationRegistry*/]), function (require, exports, objects, types, uri_1, platform_1, instantiation_1, configurationRegistry_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IConfigurationService = instantiation_1.createDecorator('configurationService');
    function isConfigurationOverrides(thing) {
        return thing
            && typeof thing === 'object'
            && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')
            && (!thing.resource || thing.resource instanceof uri_1.default);
    }
    exports.isConfigurationOverrides = isConfigurationOverrides;
    var ConfigurationTarget;
    (function (ConfigurationTarget) {
        ConfigurationTarget[ConfigurationTarget["USER"] = 1] = "USER";
        ConfigurationTarget[ConfigurationTarget["WORKSPACE"] = 2] = "WORKSPACE";
        ConfigurationTarget[ConfigurationTarget["WORKSPACE_FOLDER"] = 3] = "WORKSPACE_FOLDER";
        ConfigurationTarget[ConfigurationTarget["DEFAULT"] = 4] = "DEFAULT";
        ConfigurationTarget[ConfigurationTarget["MEMORY"] = 5] = "MEMORY";
    })(ConfigurationTarget = exports.ConfigurationTarget || (exports.ConfigurationTarget = {}));
    function compare(from, to) {
        var added = to.keys.filter(function (key) { return from.keys.indexOf(key) === -1; });
        var removed = from.keys.filter(function (key) { return to.keys.indexOf(key) === -1; });
        var updated = [];
        for (var _i = 0, _a = from.keys; _i < _a.length; _i++) {
            var key = _a[_i];
            var value1 = getConfigurationValue(from.contents, key);
            var value2 = getConfigurationValue(to.contents, key);
            if (!objects.equals(value1, value2)) {
                updated.push(key);
            }
        }
        return { added: added, removed: removed, updated: updated };
    }
    exports.compare = compare;
    function toOverrides(raw, conflictReporter) {
        var overrides = [];
        var configurationProperties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
        for (var _i = 0, _a = Object.keys(raw); _i < _a.length; _i++) {
            var key = _a[_i];
            if (configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key)) {
                var overrideRaw = {};
                for (var keyInOverrideRaw in raw[key]) {
                    if (configurationProperties[keyInOverrideRaw] && configurationProperties[keyInOverrideRaw].overridable) {
                        overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];
                    }
                }
                overrides.push({
                    identifiers: [overrideIdentifierFromKey(key).trim()],
                    contents: toValuesTree(overrideRaw, conflictReporter)
                });
            }
        }
        return overrides;
    }
    exports.toOverrides = toOverrides;
    function toValuesTree(properties, conflictReporter) {
        var root = Object.create(null);
        for (var key in properties) {
            addToValueTree(root, key, properties[key], conflictReporter);
        }
        return root;
    }
    exports.toValuesTree = toValuesTree;
    function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
        var segments = key.split('.');
        var last = segments.pop();
        var curr = settingsTreeRoot;
        for (var i = 0; i < segments.length; i++) {
            var s = segments[i];
            var obj = curr[s];
            switch (typeof obj) {
                case 'undefined':
                    obj = curr[s] = Object.create(null);
                    break;
                case 'object':
                    break;
                default:
                    conflictReporter("Ignoring " + key + " as " + segments.slice(0, i + 1).join('.') + " is " + JSON.stringify(obj));
                    return;
            }
            curr = obj;
        }
        if (typeof curr === 'object') {
            curr[last] = value; // workaround https://github.com/Microsoft/vscode/issues/13606
        }
        else {
            conflictReporter("Ignoring " + key + " as " + segments.join('.') + " is " + JSON.stringify(curr));
        }
    }
    exports.addToValueTree = addToValueTree;
    function removeFromValueTree(valueTree, key) {
        var segments = key.split('.');
        doRemoveFromValueTree(valueTree, segments);
    }
    exports.removeFromValueTree = removeFromValueTree;
    function doRemoveFromValueTree(valueTree, segments) {
        var first = segments.shift();
        if (segments.length === 0) {
            // Reached last segment
            delete valueTree[first];
            return;
        }
        if (Object.keys(valueTree).indexOf(first) !== -1) {
            var value = valueTree[first];
            if (typeof value === 'object' && !Array.isArray(value)) {
                doRemoveFromValueTree(value, segments);
                if (Object.keys(value).length === 0) {
                    delete valueTree[first];
                }
            }
        }
    }
    /**
     * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)
     */
    function getConfigurationValue(config, settingPath, defaultValue) {
        function accessSetting(config, path) {
            var current = config;
            for (var i = 0; i < path.length; i++) {
                if (typeof current !== 'object' || current === null) {
                    return undefined;
                }
                current = current[path[i]];
            }
            return current;
        }
        var path = settingPath.split('.');
        var result = accessSetting(config, path);
        return typeof result === 'undefined' ? defaultValue : result;
    }
    exports.getConfigurationValue = getConfigurationValue;
    function merge(base, add, overwrite) {
        Object.keys(add).forEach(function (key) {
            if (key in base) {
                if (types.isObject(base[key]) && types.isObject(add[key])) {
                    merge(base[key], add[key], overwrite);
                }
                else if (overwrite) {
                    base[key] = add[key];
                }
            }
            else {
                base[key] = add[key];
            }
        });
    }
    exports.merge = merge;
    function getConfigurationKeys() {
        var properties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
        return Object.keys(properties);
    }
    exports.getConfigurationKeys = getConfigurationKeys;
    function getDefaultValues() {
        var valueTreeRoot = Object.create(null);
        var properties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
        for (var key in properties) {
            var value = properties[key].default;
            addToValueTree(valueTreeRoot, key, value, function (message) { return console.error("Conflict in default settings: " + message); });
        }
        return valueTreeRoot;
    }
    exports.getDefaultValues = getDefaultValues;
    function overrideIdentifierFromKey(key) {
        return key.substring(1, key.length - 1);
    }
    exports.overrideIdentifierFromKey = overrideIdentifierFromKey;
    function keyFromOverrideIdentifier(overrideIdentifier) {
        return "[" + overrideIdentifier + "]";
    }
    exports.keyFromOverrideIdentifier = keyFromOverrideIdentifier;
});











define(__m[70/*vs/platform/configuration/common/configurationModels*/], __M([0/*require*/,1/*exports*/,158/*vs/base/common/json*/,21/*vs/base/common/map*/,13/*vs/base/common/arrays*/,18/*vs/base/common/types*/,20/*vs/base/common/objects*/,40/*vs/platform/configuration/common/configurationRegistry*/,30/*vs/platform/configuration/common/configuration*/]), function (require, exports, json, map_1, arrays, types, objects, configurationRegistry_1, configuration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ConfigurationModel = /** @class */ (function () {
        function ConfigurationModel(_contents, _keys, _overrides) {
            if (_contents === void 0) { _contents = {}; }
            if (_keys === void 0) { _keys = []; }
            if (_overrides === void 0) { _overrides = []; }
            this._contents = _contents;
            this._keys = _keys;
            this._overrides = _overrides;
            this.isFrozen = false;
        }
        Object.defineProperty(ConfigurationModel.prototype, "contents", {
            get: function () {
                return this.checkAndFreeze(this._contents);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationModel.prototype, "overrides", {
            get: function () {
                return this.checkAndFreeze(this._overrides);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationModel.prototype, "keys", {
            get: function () {
                return this.checkAndFreeze(this._keys);
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationModel.prototype.getValue = function (section) {
            return section ? configuration_1.getConfigurationValue(this.contents, section) : this.contents;
        };
        ConfigurationModel.prototype.override = function (identifier) {
            var overrideContents = this.getContentsForOverrideIdentifer(identifier);
            if (!overrideContents || typeof overrideContents !== 'object' || !Object.keys(overrideContents).length) {
                // If there are no valid overrides, return self
                return this;
            }
            var contents = {};
            for (var _i = 0, _a = arrays.distinct(Object.keys(this.contents).concat(Object.keys(overrideContents))); _i < _a.length; _i++) {
                var key = _a[_i];
                var contentsForKey = this.contents[key];
                var overrideContentsForKey = overrideContents[key];
                // If there are override contents for the key, clone and merge otherwise use base contents
                if (overrideContentsForKey) {
                    // Clone and merge only if base contents and override contents are of type object otherwise just override
                    if (typeof contentsForKey === 'object' && typeof overrideContentsForKey === 'object') {
                        contentsForKey = objects.deepClone(contentsForKey);
                        this.mergeContents(contentsForKey, overrideContentsForKey);
                    }
                    else {
                        contentsForKey = overrideContentsForKey;
                    }
                }
                contents[key] = contentsForKey;
            }
            return new ConfigurationModel(contents);
        };
        ConfigurationModel.prototype.merge = function () {
            var others = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                others[_i] = arguments[_i];
            }
            var contents = objects.deepClone(this.contents);
            var overrides = objects.deepClone(this.overrides);
            var keys = this.keys.slice();
            for (var _a = 0, others_1 = others; _a < others_1.length; _a++) {
                var other = others_1[_a];
                this.mergeContents(contents, other.contents);
                var _loop_1 = function (otherOverride) {
                    var override = overrides.filter(function (o) { return arrays.equals(o.identifiers, otherOverride.identifiers); })[0];
                    if (override) {
                        this_1.mergeContents(override.contents, otherOverride.contents);
                    }
                    else {
                        overrides.push(objects.deepClone(otherOverride));
                    }
                };
                var this_1 = this;
                for (var _b = 0, _c = other.overrides; _b < _c.length; _b++) {
                    var otherOverride = _c[_b];
                    _loop_1(otherOverride);
                }
                for (var _d = 0, _e = other.keys; _d < _e.length; _d++) {
                    var key = _e[_d];
                    if (keys.indexOf(key) === -1) {
                        keys.push(key);
                    }
                }
            }
            return new ConfigurationModel(contents, keys, overrides);
        };
        ConfigurationModel.prototype.freeze = function () {
            // {{SQL CARBON EDIT}}
            // this.isFrozen = true;
            return this;
        };
        ConfigurationModel.prototype.mergeContents = function (source, target) {
            for (var _i = 0, _a = Object.keys(target); _i < _a.length; _i++) {
                var key = _a[_i];
                if (key in source) {
                    if (types.isObject(source[key]) && types.isObject(target[key])) {
                        this.mergeContents(source[key], target[key]);
                        continue;
                    }
                }
                source[key] = objects.deepClone(target[key]);
            }
        };
        ConfigurationModel.prototype.checkAndFreeze = function (data) {
            if (this.isFrozen && !Object.isFrozen(data)) {
                return objects.deepFreeze(data);
            }
            return data;
        };
        ConfigurationModel.prototype.getContentsForOverrideIdentifer = function (identifier) {
            for (var _i = 0, _a = this.overrides; _i < _a.length; _i++) {
                var override = _a[_i];
                if (override.identifiers.indexOf(identifier) !== -1) {
                    return override.contents;
                }
            }
            return null;
        };
        ConfigurationModel.prototype.toJSON = function () {
            return {
                contents: this.contents,
                overrides: this.overrides,
                keys: this.keys
            };
        };
        // Update methods
        ConfigurationModel.prototype.setValue = function (key, value) {
            this.addKey(key);
            configuration_1.addToValueTree(this.contents, key, value, function (e) { throw new Error(e); });
        };
        ConfigurationModel.prototype.removeValue = function (key) {
            if (this.removeKey(key)) {
                configuration_1.removeFromValueTree(this.contents, key);
            }
        };
        ConfigurationModel.prototype.addKey = function (key) {
            var index = this.keys.length;
            for (var i = 0; i < index; i++) {
                if (key.indexOf(this.keys[i]) === 0) {
                    index = i;
                }
            }
            this.keys.splice(index, 1, key);
        };
        ConfigurationModel.prototype.removeKey = function (key) {
            var index = this.keys.indexOf(key);
            if (index !== -1) {
                this.keys.splice(index, 1);
                return true;
            }
            return false;
        };
        return ConfigurationModel;
    }());
    exports.ConfigurationModel = ConfigurationModel;
    var DefaultConfigurationModel = /** @class */ (function (_super) {
        __extends(DefaultConfigurationModel, _super);
        function DefaultConfigurationModel() {
            var _this = this;
            var contents = configuration_1.getDefaultValues();
            var keys = configuration_1.getConfigurationKeys();
            var overrides = [];
            for (var _i = 0, _a = Object.keys(contents); _i < _a.length; _i++) {
                var key = _a[_i];
                if (configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key)) {
                    overrides.push({
                        identifiers: [configuration_1.overrideIdentifierFromKey(key).trim()],
                        contents: configuration_1.toValuesTree(contents[key], function (message) { return console.error("Conflict in default settings file: " + message); })
                    });
                }
            }
            _this = _super.call(this, contents, keys, overrides) || this;
            return _this;
        }
        return DefaultConfigurationModel;
    }(ConfigurationModel));
    exports.DefaultConfigurationModel = DefaultConfigurationModel;
    var ConfigurationModelParser = /** @class */ (function () {
        function ConfigurationModelParser(_name) {
            this._name = _name;
            this._configurationModel = null;
            this._parseErrors = [];
        }
        Object.defineProperty(ConfigurationModelParser.prototype, "configurationModel", {
            get: function () {
                return this._configurationModel || new ConfigurationModel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationModelParser.prototype, "errors", {
            get: function () {
                return this._parseErrors;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationModelParser.prototype.parse = function (content) {
            var raw = this.parseContent(content);
            var configurationModel = this.parseRaw(raw);
            this._configurationModel = new ConfigurationModel(configurationModel.contents, configurationModel.keys, configurationModel.overrides);
        };
        ConfigurationModelParser.prototype.parseContent = function (content) {
            var raw = {};
            var currentProperty = null;
            var currentParent = [];
            var previousParents = [];
            var parseErrors = [];
            function onValue(value) {
                if (Array.isArray(currentParent)) {
                    currentParent.push(value);
                }
                else if (currentProperty) {
                    currentParent[currentProperty] = value;
                }
            }
            var visitor = {
                onObjectBegin: function () {
                    var object = {};
                    onValue(object);
                    previousParents.push(currentParent);
                    currentParent = object;
                    currentProperty = null;
                },
                onObjectProperty: function (name) {
                    currentProperty = name;
                },
                onObjectEnd: function () {
                    currentParent = previousParents.pop();
                },
                onArrayBegin: function () {
                    var array = [];
                    onValue(array);
                    previousParents.push(currentParent);
                    currentParent = array;
                    currentProperty = null;
                },
                onArrayEnd: function () {
                    currentParent = previousParents.pop();
                },
                onLiteralValue: onValue,
                onError: function (error) {
                    parseErrors.push({ error: error });
                }
            };
            if (content) {
                try {
                    json.visit(content, visitor);
                    raw = currentParent[0] || {};
                }
                catch (e) {
                    console.error("Error while parsing settings file " + this._name + ": " + e);
                    this._parseErrors = [e];
                }
            }
            return raw;
        };
        ConfigurationModelParser.prototype.parseRaw = function (raw) {
            var _this = this;
            var contents = configuration_1.toValuesTree(raw, function (message) { return console.error("Conflict in settings file " + _this._name + ": " + message); });
            var keys = Object.keys(raw);
            var overrides = configuration_1.toOverrides(raw, function (message) { return console.error("Conflict in settings file " + _this._name + ": " + message); });
            return { contents: contents, keys: keys, overrides: overrides };
        };
        return ConfigurationModelParser;
    }());
    exports.ConfigurationModelParser = ConfigurationModelParser;
    var Configuration = /** @class */ (function () {
        function Configuration(_defaultConfiguration, _userConfiguration, _workspaceConfiguration, _folderConfigurations, _memoryConfiguration, _memoryConfigurationByResource, _freeze) {
            if (_workspaceConfiguration === void 0) { _workspaceConfiguration = new ConfigurationModel(); }
            if (_folderConfigurations === void 0) { _folderConfigurations = new map_1.ResourceMap(); }
            if (_memoryConfiguration === void 0) { _memoryConfiguration = new ConfigurationModel(); }
            if (_memoryConfigurationByResource === void 0) { _memoryConfigurationByResource = new map_1.ResourceMap(); }
            if (_freeze === void 0) { _freeze = true; }
            this._defaultConfiguration = _defaultConfiguration;
            this._userConfiguration = _userConfiguration;
            this._workspaceConfiguration = _workspaceConfiguration;
            this._folderConfigurations = _folderConfigurations;
            this._memoryConfiguration = _memoryConfiguration;
            this._memoryConfigurationByResource = _memoryConfigurationByResource;
            this._freeze = _freeze;
            this._workspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations = new map_1.ResourceMap();
        }
        Configuration.prototype.getValue = function (section, overrides, workspace) {
            var consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);
            return consolidateConfigurationModel.getValue(section);
        };
        Configuration.prototype.updateValue = function (key, value, overrides) {
            if (overrides === void 0) { overrides = {}; }
            var memoryConfiguration;
            if (overrides.resource) {
                memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);
                if (!memoryConfiguration) {
                    memoryConfiguration = new ConfigurationModel();
                    this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);
                }
            }
            else {
                memoryConfiguration = this._memoryConfiguration;
            }
            if (value === void 0) {
                memoryConfiguration.removeValue(key);
            }
            else {
                memoryConfiguration.setValue(key, value);
            }
            if (!overrides.resource) {
                this._workspaceConsolidatedConfiguration = null;
            }
        };
        Configuration.prototype.inspect = function (key, overrides, workspace) {
            var consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);
            var folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource, workspace);
            var memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;
            return {
                default: overrides.overrideIdentifier ? this._defaultConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._defaultConfiguration.freeze().getValue(key),
                user: overrides.overrideIdentifier ? this._userConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._userConfiguration.freeze().getValue(key),
                workspace: workspace ? overrides.overrideIdentifier ? this._workspaceConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._workspaceConfiguration.freeze().getValue(key) : void 0,
                workspaceFolder: folderConfigurationModel ? overrides.overrideIdentifier ? folderConfigurationModel.freeze().override(overrides.overrideIdentifier).getValue(key) : folderConfigurationModel.freeze().getValue(key) : void 0,
                memory: overrides.overrideIdentifier ? memoryConfigurationModel.freeze().override(overrides.overrideIdentifier).getValue(key) : memoryConfigurationModel.freeze().getValue(key),
                value: consolidateConfigurationModel.getValue(key)
            };
        };
        Configuration.prototype.keys = function (workspace) {
            var folderConfigurationModel = this.getFolderConfigurationModelForResource(null, workspace);
            return {
                default: this._defaultConfiguration.freeze().keys,
                user: this._userConfiguration.freeze().keys,
                workspace: this._workspaceConfiguration.freeze().keys,
                workspaceFolder: folderConfigurationModel ? folderConfigurationModel.freeze().keys : []
            };
        };
        Configuration.prototype.updateDefaultConfiguration = function (defaultConfiguration) {
            this._defaultConfiguration = defaultConfiguration;
            this._workspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations.clear();
        };
        Configuration.prototype.updateUserConfiguration = function (userConfiguration) {
            this._userConfiguration = userConfiguration;
            this._workspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations.clear();
        };
        Configuration.prototype.updateWorkspaceConfiguration = function (workspaceConfiguration) {
            this._workspaceConfiguration = workspaceConfiguration;
            this._workspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations.clear();
        };
        Configuration.prototype.updateFolderConfiguration = function (resource, configuration) {
            this._folderConfigurations.set(resource, configuration);
            this._foldersConsolidatedConfigurations.delete(resource);
        };
        Configuration.prototype.deleteFolderConfiguration = function (resource) {
            this.folders.delete(resource);
            this._foldersConsolidatedConfigurations.delete(resource);
        };
        Object.defineProperty(Configuration.prototype, "defaults", {
            get: function () {
                return this._defaultConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Configuration.prototype, "user", {
            get: function () {
                return this._userConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Configuration.prototype, "workspace", {
            get: function () {
                return this._workspaceConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Configuration.prototype, "folders", {
            get: function () {
                return this._folderConfigurations;
            },
            enumerable: true,
            configurable: true
        });
        Configuration.prototype.getConsolidateConfigurationModel = function (overrides, workspace) {
            var configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);
            return overrides.overrideIdentifier ? configurationModel.override(overrides.overrideIdentifier) : configurationModel;
        };
        Configuration.prototype.getConsolidatedConfigurationModelForResource = function (_a, workspace) {
            var resource = _a.resource;
            var consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
            if (workspace && resource) {
                var root = workspace.getFolder(resource);
                if (root) {
                    consolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;
                }
                var memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);
                if (memoryConfigurationForResource) {
                    consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);
                }
            }
            return consolidateConfiguration;
        };
        Configuration.prototype.getWorkspaceConsolidatedConfiguration = function () {
            if (!this._workspaceConsolidatedConfiguration) {
                this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
                if (this._freeze) {
                    this._workspaceConfiguration = this._workspaceConfiguration.freeze();
                }
            }
            return this._workspaceConsolidatedConfiguration;
        };
        Configuration.prototype.getFolderConsolidatedConfiguration = function (folder) {
            var folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);
            if (!folderConsolidatedConfiguration) {
                var workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
                var folderConfiguration = this._folderConfigurations.get(folder);
                if (folderConfiguration) {
                    folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);
                    if (this._freeze) {
                        folderConsolidatedConfiguration = folderConsolidatedConfiguration.freeze();
                    }
                    this._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);
                }
                else {
                    folderConsolidatedConfiguration = workspaceConsolidateConfiguration;
                }
            }
            return folderConsolidatedConfiguration;
        };
        Configuration.prototype.getFolderConfigurationModelForResource = function (resource, workspace) {
            if (workspace && resource) {
                var root = workspace.getFolder(resource);
                if (root) {
                    return this._folderConfigurations.get(root.uri);
                }
            }
            return null;
        };
        Configuration.prototype.toData = function () {
            var _this = this;
            return {
                defaults: {
                    contents: this._defaultConfiguration.contents,
                    overrides: this._defaultConfiguration.overrides,
                    keys: this._defaultConfiguration.keys
                },
                user: {
                    contents: this._userConfiguration.contents,
                    overrides: this._userConfiguration.overrides,
                    keys: this._userConfiguration.keys
                },
                workspace: {
                    contents: this._workspaceConfiguration.contents,
                    overrides: this._workspaceConfiguration.overrides,
                    keys: this._workspaceConfiguration.keys
                },
                folders: this._folderConfigurations.keys().reduce(function (result, folder) {
                    var _a = _this._folderConfigurations.get(folder), contents = _a.contents, overrides = _a.overrides, keys = _a.keys;
                    result[folder.toString()] = { contents: contents, overrides: overrides, keys: keys };
                    return result;
                }, Object.create({})),
                isComplete: true
            };
        };
        Configuration.prototype.allKeys = function (workspace) {
            var keys = this.keys(workspace);
            var all = keys.default.slice();
            var addKeys = function (keys) {
                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                    var key = keys_1[_i];
                    if (all.indexOf(key) === -1) {
                        all.push(key);
                    }
                }
            };
            addKeys(keys.user);
            addKeys(keys.workspace);
            for (var _i = 0, _a = this.folders.keys(); _i < _a.length; _i++) {
                var resource = _a[_i];
                addKeys(this.folders.get(resource).keys);
            }
            return all;
        };
        return Configuration;
    }());
    exports.Configuration = Configuration;
    var AbstractConfigurationChangeEvent = /** @class */ (function () {
        function AbstractConfigurationChangeEvent() {
        }
        AbstractConfigurationChangeEvent.prototype.doesConfigurationContains = function (configuration, config) {
            var _a;
            var changedKeysTree = configuration.contents;
            var requestedTree = configuration_1.toValuesTree((_a = {}, _a[config] = true, _a), function () { });
            var key;
            while (typeof requestedTree === 'object' && (key = Object.keys(requestedTree)[0])) { // Only one key should present, since we added only one property
                changedKeysTree = changedKeysTree[key];
                if (!changedKeysTree) {
                    return false; // Requested tree is not found
                }
                requestedTree = requestedTree[key];
            }
            return true;
        };
        AbstractConfigurationChangeEvent.prototype.updateKeys = function (configuration, keys, resource) {
            for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
                var key = keys_2[_i];
                configuration.setValue(key, {});
            }
        };
        return AbstractConfigurationChangeEvent;
    }());
    exports.AbstractConfigurationChangeEvent = AbstractConfigurationChangeEvent;
    var ConfigurationChangeEvent = /** @class */ (function (_super) {
        __extends(ConfigurationChangeEvent, _super);
        function ConfigurationChangeEvent(_changedConfiguration, _changedConfigurationByResource) {
            if (_changedConfiguration === void 0) { _changedConfiguration = new ConfigurationModel(); }
            if (_changedConfigurationByResource === void 0) { _changedConfigurationByResource = new map_1.ResourceMap(); }
            var _this = _super.call(this) || this;
            _this._changedConfiguration = _changedConfiguration;
            _this._changedConfigurationByResource = _changedConfigurationByResource;
            return _this;
        }
        Object.defineProperty(ConfigurationChangeEvent.prototype, "changedConfiguration", {
            get: function () {
                return this._changedConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationChangeEvent.prototype, "changedConfigurationByResource", {
            get: function () {
                return this._changedConfigurationByResource;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationChangeEvent.prototype.change = function (arg1, arg2) {
            if (arg1 instanceof ConfigurationChangeEvent) {
                this._changedConfiguration = this._changedConfiguration.merge(arg1._changedConfiguration);
                for (var _i = 0, _a = arg1._changedConfigurationByResource.keys(); _i < _a.length; _i++) {
                    var resource = _a[_i];
                    var changedConfigurationByResource = this.getOrSetChangedConfigurationForResource(resource);
                    changedConfigurationByResource = changedConfigurationByResource.merge(arg1._changedConfigurationByResource.get(resource));
                    this._changedConfigurationByResource.set(resource, changedConfigurationByResource);
                }
            }
            else {
                this.changeWithKeys(arg1, arg2);
            }
            return this;
        };
        ConfigurationChangeEvent.prototype.telemetryData = function (source, sourceConfig) {
            this._source = source;
            this._sourceConfig = sourceConfig;
            return this;
        };
        Object.defineProperty(ConfigurationChangeEvent.prototype, "affectedKeys", {
            get: function () {
                var keys = this._changedConfiguration.keys.slice();
                this._changedConfigurationByResource.forEach(function (model) { return keys.push.apply(keys, model.keys); });
                return arrays.distinct(keys);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationChangeEvent.prototype, "source", {
            get: function () {
                return this._source;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationChangeEvent.prototype, "sourceConfig", {
            get: function () {
                return this._sourceConfig;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationChangeEvent.prototype.affectsConfiguration = function (config, resource) {
            var configurationModelsToSearch = [this._changedConfiguration];
            if (resource) {
                var model = this._changedConfigurationByResource.get(resource);
                if (model) {
                    configurationModelsToSearch.push(model);
                }
            }
            else {
                configurationModelsToSearch.push.apply(configurationModelsToSearch, this._changedConfigurationByResource.values());
            }
            for (var _i = 0, configurationModelsToSearch_1 = configurationModelsToSearch; _i < configurationModelsToSearch_1.length; _i++) {
                var configuration = configurationModelsToSearch_1[_i];
                if (this.doesConfigurationContains(configuration, config)) {
                    return true;
                }
            }
            return false;
        };
        ConfigurationChangeEvent.prototype.changeWithKeys = function (keys, resource) {
            var changedConfiguration = resource ? this.getOrSetChangedConfigurationForResource(resource) : this._changedConfiguration;
            this.updateKeys(changedConfiguration, keys);
        };
        ConfigurationChangeEvent.prototype.getOrSetChangedConfigurationForResource = function (resource) {
            var changedConfigurationByResource = this._changedConfigurationByResource.get(resource);
            if (!changedConfigurationByResource) {
                changedConfigurationByResource = new ConfigurationModel();
                this._changedConfigurationByResource.set(resource, changedConfigurationByResource);
            }
            return changedConfigurationByResource;
        };
        return ConfigurationChangeEvent;
    }(AbstractConfigurationChangeEvent));
    exports.ConfigurationChangeEvent = ConfigurationChangeEvent;
});

define(__m[71/*vs/platform/search/common/search*/], __M([0/*require*/,1/*exports*/,33/*vs/base/common/glob*/,20/*vs/base/common/objects*/,16/*vs/base/common/paths*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, glob, objects, paths, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VIEW_ID = 'workbench.view.search';
    exports.ISearchHistoryService = instantiation_1.createDecorator('searchHistoryService');
    exports.ISearchService = instantiation_1.createDecorator('searchService');
    /**
     * TODO@roblou - split text from file search entirely, or share code in a more natural way.
     */
    var SearchProviderType;
    (function (SearchProviderType) {
        SearchProviderType[SearchProviderType["file"] = 0] = "file";
        SearchProviderType[SearchProviderType["fileIndex"] = 1] = "fileIndex";
        SearchProviderType[SearchProviderType["text"] = 2] = "text";
    })(SearchProviderType = exports.SearchProviderType || (exports.SearchProviderType = {}));
    var QueryType;
    (function (QueryType) {
        QueryType[QueryType["File"] = 1] = "File";
        QueryType[QueryType["Text"] = 2] = "Text";
    })(QueryType = exports.QueryType || (exports.QueryType = {}));
    // ---- very simple implementation of the search model --------------------
    var FileMatch = /** @class */ (function () {
        function FileMatch(resource) {
            this.resource = resource;
            this.lineMatches = [];
            // empty
        }
        return FileMatch;
    }());
    exports.FileMatch = FileMatch;
    var LineMatch = /** @class */ (function () {
        function LineMatch(preview, lineNumber, offsetAndLengths) {
            this.preview = preview;
            this.lineNumber = lineNumber;
            this.offsetAndLengths = offsetAndLengths;
            // empty
        }
        return LineMatch;
    }());
    exports.LineMatch = LineMatch;
    function getExcludes(configuration) {
        var fileExcludes = configuration && configuration.files && configuration.files.exclude;
        var searchExcludes = configuration && configuration.search && configuration.search.exclude;
        if (!fileExcludes && !searchExcludes) {
            return undefined;
        }
        if (!fileExcludes || !searchExcludes) {
            return fileExcludes || searchExcludes;
        }
        var allExcludes = Object.create(null);
        // clone the config as it could be frozen
        allExcludes = objects.mixin(allExcludes, objects.deepClone(fileExcludes));
        allExcludes = objects.mixin(allExcludes, objects.deepClone(searchExcludes), true);
        return allExcludes;
    }
    exports.getExcludes = getExcludes;
    function pathIncludedInQuery(query, fsPath) {
        if (query.excludePattern && glob.match(query.excludePattern, fsPath)) {
            return false;
        }
        if (query.includePattern && !glob.match(query.includePattern, fsPath)) {
            return false;
        }
        // If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present
        if (query.usingSearchPaths) {
            return query.folderQueries.every(function (fq) {
                var searchPath = fq.folder.fsPath;
                if (paths.isEqualOrParent(fsPath, searchPath)) {
                    return !fq.includePattern || !!glob.match(fq.includePattern, fsPath);
                }
                else {
                    return false;
                }
            });
        }
        return true;
    }
    exports.pathIncludedInQuery = pathIncludedInQuery;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[143/*vs/platform/statusbar/common/statusbar*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IStatusbarService = instantiation_1.createDecorator('statusbarService');
    var StatusbarAlignment;
    (function (StatusbarAlignment) {
        StatusbarAlignment[StatusbarAlignment["LEFT"] = 0] = "LEFT";
        StatusbarAlignment[StatusbarAlignment["RIGHT"] = 1] = "RIGHT";
    })(StatusbarAlignment = exports.StatusbarAlignment || (exports.StatusbarAlignment = {}));
});

define(__m[144/*vs/platform/telemetry/common/telemetry*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ITelemetryService = instantiation_1.createDecorator('telemetryService');
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define(__m[145/*vs/platform/telemetry/common/telemetryUtils*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,74/*vs/base/common/mime*/,16/*vs/base/common/paths*/,30/*vs/platform/configuration/common/configuration*/,128/*vs/platform/keybinding/common/keybinding*/,38/*vs/platform/log/common/log*/]), function (require, exports, winjs_base_1, mime_1, paths, configuration_1, keybinding_1, log_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NullTelemetryService = new /** @class */ (function () {
        function class_1() {
        }
        class_1.prototype.publicLog = function (eventName, data) {
            return winjs_base_1.TPromise.wrap(null);
        };
        class_1.prototype.getTelemetryInfo = function () {
            return winjs_base_1.TPromise.wrap({
                instanceId: 'someValue.instanceId',
                sessionId: 'someValue.sessionId',
                machineId: 'someValue.machineId'
            });
        };
        return class_1;
    }());
    function combinedAppender() {
        var appenders = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            appenders[_i] = arguments[_i];
        }
        return {
            log: function (e, d) { return appenders.forEach(function (a) { return a.log(e, d); }); },
            dispose: function () { return winjs_base_1.TPromise.join(appenders.map(function (a) { return a.dispose(); })); }
        };
    }
    exports.combinedAppender = combinedAppender;
    exports.NullAppender = { log: function () { return null; }, dispose: function () { return winjs_base_1.TPromise.as(null); } };
    var LogAppender = /** @class */ (function () {
        function LogAppender(_logService) {
            this._logService = _logService;
            this.commonPropertiesRegex = /^sessionID$|^version$|^timestamp$|^commitHash$|^common\./;
        }
        LogAppender.prototype.dispose = function () {
            return winjs_base_1.TPromise.as(undefined);
        };
        LogAppender.prototype.log = function (eventName, data) {
            var _this = this;
            var strippedData = {};
            Object.keys(data).forEach(function (key) {
                if (!_this.commonPropertiesRegex.test(key)) {
                    strippedData[key] = data[key];
                }
            });
            this._logService.trace("telemetry/" + eventName, strippedData);
        };
        LogAppender = __decorate([
            __param(0, log_1.ILogService)
        ], LogAppender);
        return LogAppender;
    }());
    exports.LogAppender = LogAppender;
    function telemetryURIDescriptor(uri, hashPath) {
        var fsPath = uri && uri.fsPath;
        return fsPath ? { mimeType: mime_1.guessMimeTypes(fsPath).join(', '), ext: paths.extname(fsPath), path: hashPath(fsPath) } : {};
    }
    exports.telemetryURIDescriptor = telemetryURIDescriptor;
    /**
     * Only add settings that cannot contain any personal/private information of users (PII).
     */
    var configurationValueWhitelist = [
        'editor.tabCompletion',
        'editor.fontFamily',
        'editor.fontWeight',
        'editor.fontSize',
        'editor.lineHeight',
        'editor.letterSpacing',
        'editor.lineNumbers',
        'editor.rulers',
        'editor.wordSeparators',
        'editor.tabSize',
        'editor.insertSpaces',
        'editor.detectIndentation',
        'editor.roundedSelection',
        'editor.scrollBeyondLastLine',
        'editor.minimap.enabled',
        'editor.minimap.side',
        'editor.minimap.renderCharacters',
        'editor.minimap.maxColumn',
        'editor.find.seedSearchStringFromSelection',
        'editor.find.autoFindInSelection',
        'editor.wordWrap',
        'editor.wordWrapColumn',
        'editor.wrappingIndent',
        'editor.mouseWheelScrollSensitivity',
        'editor.multiCursorModifier',
        'editor.quickSuggestions',
        'editor.quickSuggestionsDelay',
        'editor.parameterHints',
        'editor.autoClosingBrackets',
        'editor.autoIndent',
        'editor.formatOnType',
        'editor.formatOnPaste',
        'editor.suggestOnTriggerCharacters',
        'editor.acceptSuggestionOnEnter',
        'editor.acceptSuggestionOnCommitCharacter',
        'editor.snippetSuggestions',
        'editor.emptySelectionClipboard',
        'editor.wordBasedSuggestions',
        'editor.suggestSelection',
        'editor.suggestFontSize',
        'editor.suggestLineHeight',
        'editor.selectionHighlight',
        'editor.occurrencesHighlight',
        'editor.overviewRulerLanes',
        'editor.overviewRulerBorder',
        'editor.cursorBlinking',
        'editor.cursorStyle',
        'editor.mouseWheelZoom',
        'editor.fontLigatures',
        'editor.hideCursorInOverviewRuler',
        'editor.renderWhitespace',
        'editor.renderControlCharacters',
        'editor.renderIndentGuides',
        'editor.renderLineHighlight',
        'editor.codeLens',
        'editor.folding',
        'editor.showFoldingControls',
        'editor.matchBrackets',
        'editor.glyphMargin',
        'editor.useTabStops',
        'editor.trimAutoWhitespace',
        'editor.stablePeek',
        'editor.dragAndDrop',
        'editor.formatOnSave',
        'editor.colorDecorators',
        'breadcrumbs.enabled',
        'breadcrumbs.filePath',
        'breadcrumbs.symbolPath',
        'breadcrumbs.useQuickPick',
        'explorer.openEditors.visible',
        'extensions.autoUpdate',
        'files.associations',
        'files.autoGuessEncoding',
        'files.autoSave',
        'files.autoSaveDelay',
        'files.encoding',
        'files.eol',
        'files.hotExit',
        'files.trimTrailingWhitespace',
        'git.confirmSync',
        'git.enabled',
        'http.proxyStrictSSL',
        'javascript.validate.enable',
        'php.builtInCompletions.enable',
        'php.validate.enable',
        'php.validate.run',
        'terminal.integrated.fontFamily',
        'window.openFilesInNewWindow',
        'window.restoreWindows',
        'window.zoomLevel',
        'workbench.editor.enablePreview',
        'workbench.editor.enablePreviewFromQuickOpen',
        'workbench.editor.showTabs',
        'workbench.editor.swipeToNavigate',
        'workbench.sideBar.location',
        'workbench.startupEditor',
        'workbench.statusBar.visible',
        'workbench.welcome.enabled',
    ];
    function configurationTelemetry(telemetryService, configurationService) {
        return configurationService.onDidChangeConfiguration(function (event) {
            if (event.source !== configuration_1.ConfigurationTarget.DEFAULT) {
                /* __GDPR__
                    "updateConfiguration" : {
                        "configurationSource" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                        "configurationKeys": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                    }
                */
                telemetryService.publicLog('updateConfiguration', {
                    configurationSource: configuration_1.ConfigurationTarget[event.source],
                    configurationKeys: flattenKeys(event.sourceConfig)
                });
                /* __GDPR__
                    "updateConfigurationValues" : {
                        "configurationSource" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                        "configurationValues": { "classification": "CustomerContent", "purpose": "FeatureInsight" }
                    }
                */
                telemetryService.publicLog('updateConfigurationValues', {
                    configurationSource: configuration_1.ConfigurationTarget[event.source],
                    configurationValues: flattenValues(event.sourceConfig, configurationValueWhitelist)
                });
            }
        });
    }
    exports.configurationTelemetry = configurationTelemetry;
    function keybindingsTelemetry(telemetryService, keybindingService) {
        return keybindingService.onDidUpdateKeybindings(function (event) {
            if (event.source === keybinding_1.KeybindingSource.User && event.keybindings) {
                /* __GDPR__
                    "updateKeybindings" : {
                        "bindings": { "classification": "CustomerContent", "purpose": "FeatureInsight" }
                    }
                */
                telemetryService.publicLog('updateKeybindings', {
                    bindings: event.keybindings.map(function (binding) { return ({
                        key: binding.key,
                        command: binding.command,
                        when: binding.when,
                        args: binding.args ? true : undefined
                    }); })
                });
            }
        });
    }
    exports.keybindingsTelemetry = keybindingsTelemetry;
    function flattenKeys(value) {
        if (!value) {
            return [];
        }
        var result = [];
        flatKeys(result, '', value);
        return result;
    }
    function flatKeys(result, prefix, value) {
        if (value && typeof value === 'object' && !Array.isArray(value)) {
            Object.keys(value)
                .forEach(function (key) { return flatKeys(result, prefix ? prefix + "." + key : key, value[key]); });
        }
        else {
            result.push(prefix);
        }
    }
    function flattenValues(value, keys) {
        if (!value) {
            return [];
        }
        return keys.reduce(function (array, key) {
            var _a;
            var v = key.split('.')
                .reduce(function (tmp, k) { return tmp && typeof tmp === 'object' ? tmp[k] : undefined; }, value);
            if (typeof v !== 'undefined') {
                array.push((_a = {}, _a[key] = v, _a));
            }
            return array;
        }, []);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[146/*vs/platform/workspaces/common/workspaces*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/,43/*vs/platform/files/common/files*/,106/*vs/nls!vs/platform/workspaces/common/workspaces*/,16/*vs/base/common/paths*/,10/*vs/base/common/platform*/,62/*vs/base/common/labels*/,4/*vs/base/common/uri*/,23/*vs/base/common/network*/]), function (require, exports, instantiation_1, files_1, nls_1, paths_1, platform_1, labels_1, uri_1, network_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWorkspacesMainService = instantiation_1.createDecorator('workspacesMainService');
    exports.IWorkspacesService = instantiation_1.createDecorator('workspacesService');
    exports.WORKSPACE_EXTENSION = 'code-workspace';
    exports.WORKSPACE_FILTER = [{ name: nls_1.localize(0, null), extensions: [exports.WORKSPACE_EXTENSION] }];
    exports.UNTITLED_WORKSPACE_NAME = 'workspace.json';
    function isStoredWorkspaceFolder(thing) {
        return isRawFileWorkspaceFolder(thing) || isRawUriWorkspaceFolder(thing);
    }
    exports.isStoredWorkspaceFolder = isStoredWorkspaceFolder;
    function isRawFileWorkspaceFolder(thing) {
        return thing
            && typeof thing === 'object'
            && typeof thing.path === 'string'
            && (!thing.name || typeof thing.name === 'string');
    }
    exports.isRawFileWorkspaceFolder = isRawFileWorkspaceFolder;
    function isRawUriWorkspaceFolder(thing) {
        return thing
            && typeof thing === 'object'
            && typeof thing.uri === 'string'
            && (!thing.name || typeof thing.name === 'string');
    }
    exports.isRawUriWorkspaceFolder = isRawUriWorkspaceFolder;
    function getWorkspaceLabel(workspace, environmentService, uriDisplayService, options) {
        // Workspace: Single Folder
        if (isSingleFolderWorkspaceIdentifier(workspace)) {
            // Folder on disk
            if (workspace.scheme === network_1.Schemas.file) {
                return options && options.verbose ? uriDisplayService.getLabel(workspace) : labels_1.getBaseLabel(workspace);
            }
            // Remote folder
            return options && options.verbose ? uriDisplayService.getLabel(workspace) : labels_1.getBaseLabel(workspace) + " (" + workspace.scheme + ")";
        }
        // Workspace: Untitled
        if (files_1.isParent(workspace.configPath, environmentService.workspacesHome, !platform_1.isLinux /* ignore case */)) {
            return nls_1.localize(1, null);
        }
        // Workspace: Saved
        var filename = paths_1.basename(workspace.configPath);
        var workspaceName = filename.substr(0, filename.length - exports.WORKSPACE_EXTENSION.length - 1);
        if (options && options.verbose) {
            return nls_1.localize(2, null, uriDisplayService.getLabel(uri_1.default.file(paths_1.join(paths_1.dirname(workspace.configPath), workspaceName))));
        }
        return nls_1.localize(3, null, workspaceName);
    }
    exports.getWorkspaceLabel = getWorkspaceLabel;
    function isSingleFolderWorkspaceIdentifier(obj) {
        return obj instanceof uri_1.default;
    }
    exports.isSingleFolderWorkspaceIdentifier = isSingleFolderWorkspaceIdentifier;
    function isWorkspaceIdentifier(obj) {
        var workspaceIdentifier = obj;
        return workspaceIdentifier && typeof workspaceIdentifier.id === 'string' && typeof workspaceIdentifier.configPath === 'string';
    }
    exports.isWorkspaceIdentifier = isWorkspaceIdentifier;
});

define(__m[72/*vs/platform/workspace/common/workspace*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,16/*vs/base/common/paths*/,26/*vs/base/common/resources*/,7/*vs/platform/instantiation/common/instantiation*/,21/*vs/base/common/map*/,146/*vs/platform/workspaces/common/workspaces*/,13/*vs/base/common/arrays*/,10/*vs/base/common/platform*/]), function (require, exports, uri_1, paths, resources, instantiation_1, map_1, workspaces_1, arrays_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWorkspaceContextService = instantiation_1.createDecorator('contextService');
    var WorkbenchState;
    (function (WorkbenchState) {
        WorkbenchState[WorkbenchState["EMPTY"] = 1] = "EMPTY";
        WorkbenchState[WorkbenchState["FOLDER"] = 2] = "FOLDER";
        WorkbenchState[WorkbenchState["WORKSPACE"] = 3] = "WORKSPACE";
    })(WorkbenchState = exports.WorkbenchState || (exports.WorkbenchState = {}));
    var IWorkspace;
    (function (IWorkspace) {
        function isIWorkspace(thing) {
            return thing && typeof thing === 'object'
                && typeof thing.id === 'string'
                && typeof thing.name === 'string'
                && Array.isArray(thing.folders);
        }
        IWorkspace.isIWorkspace = isIWorkspace;
    })(IWorkspace = exports.IWorkspace || (exports.IWorkspace = {}));
    var IWorkspaceFolder;
    (function (IWorkspaceFolder) {
        function isIWorkspaceFolder(thing) {
            return thing && typeof thing === 'object'
                && uri_1.default.isUri(thing.uri)
                && typeof thing.name === 'string'
                && typeof thing.toResource === 'function';
        }
        IWorkspaceFolder.isIWorkspaceFolder = isIWorkspaceFolder;
    })(IWorkspaceFolder = exports.IWorkspaceFolder || (exports.IWorkspaceFolder = {}));
    var Workspace = /** @class */ (function () {
        function Workspace(_id, _name, folders, _configuration, _ctime) {
            if (_name === void 0) { _name = ''; }
            if (folders === void 0) { folders = []; }
            if (_configuration === void 0) { _configuration = null; }
            this._id = _id;
            this._name = _name;
            this._configuration = _configuration;
            this._ctime = _ctime;
            this._foldersMap = map_1.TernarySearchTree.forPaths();
            this.folders = folders;
        }
        Workspace.prototype.update = function (workspace) {
            this._id = workspace.id;
            this._name = workspace.name;
            this._configuration = workspace.configuration;
            this._ctime = workspace.ctime;
            this.folders = workspace.folders;
        };
        Object.defineProperty(Workspace.prototype, "folders", {
            get: function () {
                return this._folders;
            },
            set: function (folders) {
                this._folders = folders;
                this.updateFoldersMap();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Workspace.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Workspace.prototype, "ctime", {
            get: function () {
                return this._ctime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Workspace.prototype, "name", {
            get: function () {
                return this._name;
            },
            set: function (name) {
                this._name = name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Workspace.prototype, "configuration", {
            get: function () {
                return this._configuration;
            },
            set: function (configuration) {
                this._configuration = configuration;
            },
            enumerable: true,
            configurable: true
        });
        Workspace.prototype.getFolder = function (resource) {
            if (!resource) {
                return null;
            }
            return this._foldersMap.findSubstr(resource.toString());
        };
        Workspace.prototype.updateFoldersMap = function () {
            this._foldersMap = map_1.TernarySearchTree.forPaths();
            for (var _i = 0, _a = this.folders; _i < _a.length; _i++) {
                var folder = _a[_i];
                this._foldersMap.set(folder.uri.toString(), folder);
            }
        };
        Workspace.prototype.toJSON = function () {
            return { id: this.id, folders: this.folders, name: this.name, configuration: this.configuration };
        };
        return Workspace;
    }());
    exports.Workspace = Workspace;
    var WorkspaceFolder = /** @class */ (function () {
        function WorkspaceFolder(data, raw) {
            this.raw = raw;
            this.uri = data.uri;
            this.index = data.index;
            this.name = data.name;
        }
        WorkspaceFolder.prototype.toResource = function (relativePath) {
            return this.uri.with({ path: paths.join(this.uri.path, relativePath) });
        };
        WorkspaceFolder.prototype.toJSON = function () {
            return { uri: this.uri, name: this.name, index: this.index };
        };
        return WorkspaceFolder;
    }());
    exports.WorkspaceFolder = WorkspaceFolder;
    function toWorkspaceFolders(configuredFolders, relativeTo) {
        var workspaceFolders = parseWorkspaceFolders(configuredFolders, relativeTo);
        return ensureUnique(arrays_1.coalesce(workspaceFolders))
            .map(function (_a, index) {
            var uri = _a.uri, raw = _a.raw, name = _a.name;
            return new WorkspaceFolder({ uri: uri, name: name || resources.basenameOrAuthority(uri), index: index }, raw);
        });
    }
    exports.toWorkspaceFolders = toWorkspaceFolders;
    function parseWorkspaceFolders(configuredFolders, relativeTo) {
        return configuredFolders.map(function (configuredFolder, index) {
            var uri;
            if (workspaces_1.isRawFileWorkspaceFolder(configuredFolder)) {
                uri = toUri(configuredFolder.path, relativeTo);
            }
            else if (workspaces_1.isRawUriWorkspaceFolder(configuredFolder)) {
                try {
                    uri = uri_1.default.parse(configuredFolder.uri);
                    // this makes sure all workspace folder are absolute
                    if (uri.path[0] !== '/') {
                        uri = uri.with({ path: '/' + uri.path });
                    }
                }
                catch (e) {
                    console.warn(e);
                    // ignore
                }
            }
            if (!uri) {
                return void 0;
            }
            return new WorkspaceFolder({ uri: uri, name: configuredFolder.name, index: index }, configuredFolder);
        });
    }
    function toUri(path, relativeTo) {
        if (path) {
            if (paths.isAbsolute(path)) {
                return uri_1.default.file(path);
            }
            if (relativeTo) {
                return relativeTo.with({ path: paths.join(relativeTo.path, path) });
            }
        }
        return null;
    }
    function ensureUnique(folders) {
        return arrays_1.distinct(folders, function (folder) { return platform_1.isLinux ? folder.uri.toString() : folder.uri.toString().toLowerCase(); });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[148/*vs/platform/uriDisplay/common/uriDisplay*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,61/*vs/platform/environment/common/environment*/,72/*vs/platform/workspace/common/workspace*/,7/*vs/platform/instantiation/common/instantiation*/,26/*vs/base/common/resources*/,10/*vs/base/common/platform*/,62/*vs/base/common/labels*/,8/*vs/base/common/strings*/]), function (require, exports, event_1, environment_1, workspace_1, instantiation_1, resources_1, platform_1, labels_1, strings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var URI_DISPLAY_SERVICE_ID = 'uriDisplay';
    var sepRegexp = /\//g;
    var labelMatchingRegexp = /\$\{scheme\}|\$\{authority\}|\$\{path\}/g;
    function hasDriveLetter(path) {
        return platform_1.isWindows && path && path[2] === ':';
    }
    var UriDisplayService = /** @class */ (function () {
        function UriDisplayService(environmentService, contextService) {
            this.environmentService = environmentService;
            this.contextService = contextService;
            this.formaters = new Map();
            this._onDidRegisterFormater = new event_1.Emitter();
        }
        Object.defineProperty(UriDisplayService.prototype, "onDidRegisterFormater", {
            get: function () {
                return this._onDidRegisterFormater.event;
            },
            enumerable: true,
            configurable: true
        });
        UriDisplayService.prototype.getLabel = function (resource, relative) {
            if (!resource) {
                return undefined;
            }
            var formater = this.formaters.get(resource.scheme);
            if (!formater) {
                return labels_1.getPathLabel(resource.path, this.environmentService, relative ? this.contextService : undefined);
            }
            if (relative) {
                var baseResource = this.contextService && this.contextService.getWorkspaceFolder(resource);
                if (baseResource) {
                    var relativeLabel = void 0;
                    if (resources_1.isEqual(baseResource.uri, resource, !platform_1.isLinux)) {
                        relativeLabel = ''; // no label if resources are identical
                    }
                    else {
                        var baseResourceLabel = this.formatUri(baseResource.uri, formater);
                        relativeLabel = strings_1.ltrim(this.formatUri(resource, formater).substring(baseResourceLabel.length), formater.separator);
                    }
                    var hasMultipleRoots = this.contextService.getWorkspace().folders.length > 1;
                    if (hasMultipleRoots) {
                        var rootName = (baseResource && baseResource.name) ? baseResource.name : resources_1.basenameOrAuthority(baseResource.uri);
                        relativeLabel = relativeLabel ? (rootName + ' • ' + relativeLabel) : rootName; // always show root basename if there are multiple
                    }
                    return relativeLabel;
                }
            }
            return this.formatUri(resource, formater);
        };
        UriDisplayService.prototype.registerFormater = function (scheme, formater) {
            var _this = this;
            this.formaters.set(scheme, formater);
            this._onDidRegisterFormater.fire({ scheme: scheme, formater: formater });
            return {
                dispose: function () { return _this.formaters.delete(scheme); }
            };
        };
        UriDisplayService.prototype.formatUri = function (resource, formater) {
            var label = formater.label.replace(labelMatchingRegexp, function (match) {
                switch (match) {
                    case '${scheme}': return resource.scheme;
                    case '${authority}': return resource.authority;
                    case '${path}': return resource.path;
                    default: return '';
                }
            });
            // convert \c:\something => C:\something
            if (formater.normalizeDriveLetter && hasDriveLetter(label)) {
                label = label.charAt(1).toUpperCase() + label.substr(2);
            }
            if (formater.tildify) {
                label = labels_1.tildify(label, this.environmentService.userHome);
            }
            return label.replace(sepRegexp, formater.separator);
        };
        UriDisplayService = __decorate([
            __param(0, environment_1.IEnvironmentService),
            __param(1, workspace_1.IWorkspaceContextService)
        ], UriDisplayService);
        return UriDisplayService;
    }());
    exports.UriDisplayService = UriDisplayService;
    exports.IUriDisplayService = instantiation_1.createDecorator(URI_DISPLAY_SERVICE_ID);
});











define(__m[48/*vs/workbench/api/node/extHostExtensionActivator*/], __M([0/*require*/,1/*exports*/,108/*vs/nls!vs/workbench/api/node/extHostExtensionActivator*/,34/*vs/base/common/severity*/,2/*vs/base/common/winjs.base*/]), function (require, exports, nls, severity_1, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var hasOwnProperty = Object.hasOwnProperty;
    var NO_OP_VOID_PROMISE = winjs_base_1.TPromise.wrap(void 0);
    var ExtensionActivationTimes = /** @class */ (function () {
        function ExtensionActivationTimes(startup, codeLoadingTime, activateCallTime, activateResolvedTime) {
            this.startup = startup;
            this.codeLoadingTime = codeLoadingTime;
            this.activateCallTime = activateCallTime;
            this.activateResolvedTime = activateResolvedTime;
        }
        ExtensionActivationTimes.NONE = new ExtensionActivationTimes(false, -1, -1, -1);
        return ExtensionActivationTimes;
    }());
    exports.ExtensionActivationTimes = ExtensionActivationTimes;
    var ExtensionActivationTimesBuilder = /** @class */ (function () {
        function ExtensionActivationTimesBuilder(startup) {
            this._startup = startup;
            this._codeLoadingStart = -1;
            this._codeLoadingStop = -1;
            this._activateCallStart = -1;
            this._activateCallStop = -1;
            this._activateResolveStart = -1;
            this._activateResolveStop = -1;
        }
        ExtensionActivationTimesBuilder.prototype._delta = function (start, stop) {
            if (start === -1 || stop === -1) {
                return -1;
            }
            return stop - start;
        };
        ExtensionActivationTimesBuilder.prototype.build = function () {
            return new ExtensionActivationTimes(this._startup, this._delta(this._codeLoadingStart, this._codeLoadingStop), this._delta(this._activateCallStart, this._activateCallStop), this._delta(this._activateResolveStart, this._activateResolveStop));
        };
        ExtensionActivationTimesBuilder.prototype.codeLoadingStart = function () {
            this._codeLoadingStart = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.codeLoadingStop = function () {
            this._codeLoadingStop = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.activateCallStart = function () {
            this._activateCallStart = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.activateCallStop = function () {
            this._activateCallStop = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.activateResolveStart = function () {
            this._activateResolveStart = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.activateResolveStop = function () {
            this._activateResolveStop = Date.now();
        };
        return ExtensionActivationTimesBuilder;
    }());
    exports.ExtensionActivationTimesBuilder = ExtensionActivationTimesBuilder;
    var ActivatedExtension = /** @class */ (function () {
        function ActivatedExtension(activationFailed, activationFailedError, activationTimes, module, exports, subscriptions) {
            this.activationFailed = activationFailed;
            this.activationFailedError = activationFailedError;
            this.activationTimes = activationTimes;
            this.module = module;
            this.exports = exports;
            this.subscriptions = subscriptions;
        }
        return ActivatedExtension;
    }());
    exports.ActivatedExtension = ActivatedExtension;
    var EmptyExtension = /** @class */ (function (_super) {
        __extends(EmptyExtension, _super);
        function EmptyExtension(activationTimes) {
            return _super.call(this, false, null, activationTimes, { activate: undefined, deactivate: undefined }, undefined, []) || this;
        }
        return EmptyExtension;
    }(ActivatedExtension));
    exports.EmptyExtension = EmptyExtension;
    var FailedExtension = /** @class */ (function (_super) {
        __extends(FailedExtension, _super);
        function FailedExtension(activationError) {
            return _super.call(this, true, activationError, ExtensionActivationTimes.NONE, { activate: undefined, deactivate: undefined }, undefined, []) || this;
        }
        return FailedExtension;
    }(ActivatedExtension));
    exports.FailedExtension = FailedExtension;
    var ExtensionActivatedByEvent = /** @class */ (function () {
        function ExtensionActivatedByEvent(startup, activationEvent) {
            this.startup = startup;
            this.activationEvent = activationEvent;
        }
        return ExtensionActivatedByEvent;
    }());
    exports.ExtensionActivatedByEvent = ExtensionActivatedByEvent;
    var ExtensionActivatedByAPI = /** @class */ (function () {
        function ExtensionActivatedByAPI(startup) {
            this.startup = startup;
        }
        return ExtensionActivatedByAPI;
    }());
    exports.ExtensionActivatedByAPI = ExtensionActivatedByAPI;
    var ExtensionsActivator = /** @class */ (function () {
        function ExtensionsActivator(registry, host) {
            this._registry = registry;
            this._host = host;
            this._activatingExtensions = {};
            this._activatedExtensions = {};
            this._alreadyActivatedEvents = Object.create(null);
        }
        ExtensionsActivator.prototype.isActivated = function (extensionId) {
            return hasOwnProperty.call(this._activatedExtensions, extensionId);
        };
        ExtensionsActivator.prototype.getActivatedExtension = function (extensionId) {
            if (!hasOwnProperty.call(this._activatedExtensions, extensionId)) {
                throw new Error('Extension `' + extensionId + '` is not known or not activated');
            }
            return this._activatedExtensions[extensionId];
        };
        ExtensionsActivator.prototype.activateByEvent = function (activationEvent, reason) {
            var _this = this;
            if (this._alreadyActivatedEvents[activationEvent]) {
                return NO_OP_VOID_PROMISE;
            }
            var activateExtensions = this._registry.getExtensionDescriptionsForActivationEvent(activationEvent);
            return this._activateExtensions(activateExtensions, reason, 0).then(function () {
                _this._alreadyActivatedEvents[activationEvent] = true;
            });
        };
        ExtensionsActivator.prototype.activateById = function (extensionId, reason) {
            var desc = this._registry.getExtensionDescription(extensionId);
            if (!desc) {
                throw new Error('Extension `' + extensionId + '` is not known');
            }
            return this._activateExtensions([desc], reason, 0);
        };
        /**
         * Handle semantics related to dependencies for `currentExtension`.
         * semantics: `redExtensions` must wait for `greenExtensions`.
         */
        ExtensionsActivator.prototype._handleActivateRequest = function (currentExtension, greenExtensions, redExtensions) {
            var depIds = (typeof currentExtension.extensionDependencies === 'undefined' ? [] : currentExtension.extensionDependencies);
            var currentExtensionGetsGreenLight = true;
            for (var j = 0, lenJ = depIds.length; j < lenJ; j++) {
                var depId = depIds[j];
                var depDesc = this._registry.getExtensionDescription(depId);
                if (!depDesc) {
                    // Error condition 1: unknown dependency
                    this._host.showMessage(severity_1.default.Error, nls.localize(0, null, depId, currentExtension.id));
                    var error = new Error("Unknown dependency '" + depId + "'");
                    this._activatedExtensions[currentExtension.id] = new FailedExtension(error);
                    return;
                }
                if (hasOwnProperty.call(this._activatedExtensions, depId)) {
                    var dep = this._activatedExtensions[depId];
                    if (dep.activationFailed) {
                        // Error condition 2: a dependency has already failed activation
                        this._host.showMessage(severity_1.default.Error, nls.localize(1, null, depId, currentExtension.id));
                        var error = new Error("Dependency " + depId + " failed to activate");
                        error.detail = dep.activationFailedError;
                        this._activatedExtensions[currentExtension.id] = new FailedExtension(error);
                        return;
                    }
                }
                else {
                    // must first wait for the dependency to activate
                    currentExtensionGetsGreenLight = false;
                    greenExtensions[depId] = depDesc;
                }
            }
            if (currentExtensionGetsGreenLight) {
                greenExtensions[currentExtension.id] = currentExtension;
            }
            else {
                redExtensions.push(currentExtension);
            }
        };
        ExtensionsActivator.prototype._activateExtensions = function (extensionDescriptions, reason, recursionLevel) {
            var _this = this;
            // console.log(recursionLevel, '_activateExtensions: ', extensionDescriptions.map(p => p.id));
            if (extensionDescriptions.length === 0) {
                return winjs_base_1.TPromise.as(void 0);
            }
            extensionDescriptions = extensionDescriptions.filter(function (p) { return !hasOwnProperty.call(_this._activatedExtensions, p.id); });
            if (extensionDescriptions.length === 0) {
                return winjs_base_1.TPromise.as(void 0);
            }
            if (recursionLevel > 10) {
                // More than 10 dependencies deep => most likely a dependency loop
                for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                    // Error condition 3: dependency loop
                    this._host.showMessage(severity_1.default.Error, nls.localize(2, null, extensionDescriptions[i].id));
                    var error = new Error('More than 10 levels of dependencies (most likely a dependency loop)');
                    this._activatedExtensions[extensionDescriptions[i].id] = new FailedExtension(error);
                }
                return winjs_base_1.TPromise.as(void 0);
            }
            var greenMap = Object.create(null), red = [];
            for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                this._handleActivateRequest(extensionDescriptions[i], greenMap, red);
            }
            // Make sure no red is also green
            for (var i = 0, len = red.length; i < len; i++) {
                if (greenMap[red[i].id]) {
                    delete greenMap[red[i].id];
                }
            }
            var green = Object.keys(greenMap).map(function (id) { return greenMap[id]; });
            // console.log('greenExtensions: ', green.map(p => p.id));
            // console.log('redExtensions: ', red.map(p => p.id));
            if (red.length === 0) {
                // Finally reached only leafs!
                return winjs_base_1.TPromise.join(green.map(function (p) { return _this._activateExtension(p, reason); })).then(function (_) { return void 0; });
            }
            return this._activateExtensions(green, reason, recursionLevel + 1).then(function (_) {
                return _this._activateExtensions(red, reason, recursionLevel + 1);
            });
        };
        ExtensionsActivator.prototype._activateExtension = function (extensionDescription, reason) {
            var _this = this;
            if (hasOwnProperty.call(this._activatedExtensions, extensionDescription.id)) {
                return winjs_base_1.TPromise.as(void 0);
            }
            if (hasOwnProperty.call(this._activatingExtensions, extensionDescription.id)) {
                return this._activatingExtensions[extensionDescription.id];
            }
            this._activatingExtensions[extensionDescription.id] = this._host.actualActivateExtension(extensionDescription, reason).then(null, function (err) {
                _this._host.showMessage(severity_1.default.Error, nls.localize(3, null, extensionDescription.id, err.message));
                console.error('Activating extension `' + extensionDescription.id + '` failed: ', err.message);
                console.log('Here is the error stack: ', err.stack);
                // Treat the extension as being empty
                return new FailedExtension(err);
            }).then(function (x) {
                _this._activatedExtensions[extensionDescription.id] = x;
                delete _this._activatingExtensions[extensionDescription.id];
            });
            return this._activatingExtensions[extensionDescription.id];
        };
        return ExtensionsActivator;
    }());
    exports.ExtensionsActivator = ExtensionsActivator;
});

define(__m[150/*vs/workbench/api/node/extHostHeapService*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostHeapService = /** @class */ (function () {
        function ExtHostHeapService() {
            this._data = new Map();
        }
        ExtHostHeapService.prototype.keep = function (obj) {
            var id = ExtHostHeapService._idPool++;
            this._data.set(id, obj);
            return id;
        };
        ExtHostHeapService.prototype.delete = function (id) {
            return this._data.delete(id);
        };
        ExtHostHeapService.prototype.get = function (id) {
            return this._data.get(id);
        };
        ExtHostHeapService.prototype.$onGarbageCollection = function (ids) {
            for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
                var id = ids_1[_i];
                this.delete(id);
            }
        };
        ExtHostHeapService._idPool = 0;
        return ExtHostHeapService;
    }());
    exports.ExtHostHeapService = ExtHostHeapService;
});











define(__m[151/*vs/workbench/api/node/extHostLogService*/], __M([0/*require*/,1/*exports*/,16/*vs/base/common/paths*/,38/*vs/platform/log/common/log*/,130/*vs/platform/log/node/spdlogService*/]), function (require, exports, paths_1, log_1, spdlogService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostLogService = /** @class */ (function (_super) {
        __extends(ExtHostLogService, _super);
        function ExtHostLogService(_windowId, logLevel, _logsPath) {
            var _this = _super.call(this, spdlogService_1.createSpdLogService("exthost" + _windowId, logLevel, _logsPath)) || this;
            _this._windowId = _windowId;
            _this._logsPath = _logsPath;
            _this._loggers = new Map();
            return _this;
        }
        ExtHostLogService.prototype.$setLevel = function (level) {
            this.setLevel(level);
        };
        ExtHostLogService.prototype.getExtLogger = function (extensionID) {
            var logger = this._loggers.get(extensionID);
            if (!logger) {
                logger = this.createLogger(extensionID);
                this._loggers.set(extensionID, logger);
            }
            return logger;
        };
        ExtHostLogService.prototype.getLogDirectory = function (extensionID) {
            return paths_1.join(this._logsPath, extensionID + "_" + this._windowId);
        };
        ExtHostLogService.prototype.createLogger = function (extensionID) {
            var logsDirPath = this.getLogDirectory(extensionID);
            var logService = spdlogService_1.createSpdLogService(extensionID, this.getLevel(), logsDirPath);
            this._register(this.onDidChangeLogLevel(function (level) { return logService.setLevel(level); }));
            return new ExtHostLogger(logService);
        };
        return ExtHostLogService;
    }(log_1.DelegatedLogService));
    exports.ExtHostLogService = ExtHostLogService;
    var ExtHostLogger = /** @class */ (function () {
        function ExtHostLogger(_logService) {
            this._logService = _logService;
        }
        ExtHostLogger.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            return (_a = this._logService).trace.apply(_a, [message].concat(args));
        };
        ExtHostLogger.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            return (_a = this._logService).debug.apply(_a, [message].concat(args));
        };
        ExtHostLogger.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            return (_a = this._logService).info.apply(_a, [message].concat(args));
        };
        ExtHostLogger.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            return (_a = this._logService).warn.apply(_a, [message].concat(args));
        };
        ExtHostLogger.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            return (_a = this._logService).error.apply(_a, [message].concat(args));
        };
        ExtHostLogger.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            return (_a = this._logService).critical.apply(_a, [message].concat(args));
        };
        return ExtHostLogger;
    }());
    exports.ExtHostLogger = ExtHostLogger;
});









define(__m[152/*vs/workbench/api/node/extHostSearch.fileIndex*/], __M([0/*require*/,1/*exports*/,22/*path*/,13/*vs/base/common/arrays*/,29/*vs/base/common/cancellation*/,80/*vs/base/common/errorMessage*/,33/*vs/base/common/glob*/,26/*vs/base/common/resources*/,8/*vs/base/common/strings*/,2/*vs/base/common/winjs.base*/,118/*vs/base/parts/quickopen/common/quickOpenScorer*/]), function (require, exports, path, arrays, cancellation_1, errorMessage_1, glob, resources, strings, winjs_base_1, quickOpenScorer_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     *  Computes the patterns that the provider handles. Discards sibling clauses and 'false' patterns
     */
    function resolvePatternsForProvider(globalPattern, folderPattern) {
        var merged = __assign({}, (globalPattern || {}), (folderPattern || {}));
        return Object.keys(merged)
            .filter(function (key) {
            var value = merged[key];
            return typeof value === 'boolean' && value;
        });
    }
    exports.resolvePatternsForProvider = resolvePatternsForProvider;
    var QueryGlobTester = /** @class */ (function () {
        function QueryGlobTester(config, folderQuery) {
            this._excludeExpression = __assign({}, (config.excludePattern || {}), (folderQuery.excludePattern || {}));
            this._parsedExcludeExpression = glob.parse(this._excludeExpression);
            // Empty includeExpression means include nothing, so no {} shortcuts
            var includeExpression = config.includePattern;
            if (folderQuery.includePattern) {
                if (includeExpression) {
                    includeExpression = __assign({}, includeExpression, folderQuery.includePattern);
                }
                else {
                    includeExpression = folderQuery.includePattern;
                }
            }
            if (includeExpression) {
                this._parsedIncludeExpression = glob.parse(includeExpression);
            }
        }
        /**
         * Guaranteed sync - siblingsFn should not return a promise.
         */
        QueryGlobTester.prototype.includedInQuerySync = function (testPath, basename, hasSibling) {
            if (this._parsedExcludeExpression && this._parsedExcludeExpression(testPath, basename, hasSibling)) {
                return false;
            }
            if (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename, hasSibling)) {
                return false;
            }
            return true;
        };
        /**
         * Guaranteed async.
         */
        QueryGlobTester.prototype.includedInQuery = function (testPath, basename, hasSibling) {
            var _this = this;
            var excludeP = this._parsedExcludeExpression ?
                winjs_base_1.TPromise.as(this._parsedExcludeExpression(testPath, basename, hasSibling)).then(function (result) { return !!result; }) :
                winjs_base_1.TPromise.wrap(false);
            return excludeP.then(function (excluded) {
                if (excluded) {
                    return false;
                }
                return _this._parsedIncludeExpression ?
                    winjs_base_1.TPromise.as(_this._parsedIncludeExpression(testPath, basename, hasSibling)).then(function (result) { return !!result; }) :
                    winjs_base_1.TPromise.wrap(true);
            }).then(function (included) {
                return included;
            });
        };
        QueryGlobTester.prototype.hasSiblingExcludeClauses = function () {
            return hasSiblingClauses(this._excludeExpression);
        };
        return QueryGlobTester;
    }());
    exports.QueryGlobTester = QueryGlobTester;
    function hasSiblingClauses(pattern) {
        for (var key in pattern) {
            if (typeof pattern[key] !== 'boolean') {
                return true;
            }
        }
        return false;
    }
    var FileIndexSearchEngine = /** @class */ (function () {
        function FileIndexSearchEngine(config, provider) {
            this.config = config;
            this.provider = provider;
            this.filePattern = config.filePattern;
            this.includePattern = config.includePattern && glob.parse(config.includePattern);
            this.maxResults = config.maxResults || null;
            this.exists = config.exists;
            this.resultCount = 0;
            this.isLimitHit = false;
            this.activeCancellationTokens = new Set();
            if (this.filePattern) {
                this.normalizedFilePatternLowercase = strings.stripWildcards(this.filePattern).toLowerCase();
            }
            this.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);
        }
        FileIndexSearchEngine.prototype.cancel = function () {
            this.isCanceled = true;
            this.activeCancellationTokens.forEach(function (t) { return t.cancel(); });
            this.activeCancellationTokens = new Set();
        };
        FileIndexSearchEngine.prototype.search = function (_onResult) {
            var _this = this;
            if (this.config.folderQueries.length !== 1) {
                throw new Error('Searches just one folder');
            }
            var folderQuery = this.config.folderQueries[0];
            return new winjs_base_1.TPromise(function (resolve, reject) {
                var onResult = function (match) {
                    _this.resultCount++;
                    _onResult(match);
                };
                if (_this.isCanceled) {
                    return resolve({ isLimitHit: _this.isLimitHit });
                }
                // For each extra file
                if (_this.config.extraFileResources) {
                    _this.config.extraFileResources
                        .forEach(function (extraFile) {
                        var extraFileStr = extraFile.toString(); // ?
                        var basename = path.basename(extraFileStr);
                        if (_this.globalExcludePattern && _this.globalExcludePattern(extraFileStr, basename)) {
                            return; // excluded
                        }
                        // File: Check for match on file pattern and include pattern
                        _this.matchFile(onResult, { base: extraFile, basename: basename });
                    });
                }
                return _this.searchInFolder(folderQuery, _onResult)
                    .then(function () {
                    resolve({ isLimitHit: _this.isLimitHit });
                }, function (errs) {
                    var errMsg = errs
                        .map(function (err) { return errorMessage_1.toErrorMessage(err); })
                        .filter(function (msg) { return !!msg; })[0];
                    reject(new Error(errMsg));
                });
            });
        };
        FileIndexSearchEngine.prototype.searchInFolder = function (fq, onResult) {
            var _this = this;
            var cancellation = new cancellation_1.CancellationTokenSource();
            return new winjs_base_1.TPromise(function (resolve, reject) {
                var options = _this.getSearchOptionsForFolder(fq);
                var tree = _this.initDirectoryTree();
                var queryTester = new QueryGlobTester(_this.config, fq);
                var noSiblingsClauses = !queryTester.hasSiblingExcludeClauses();
                var onProviderResult = function (uri) {
                    if (_this.isCanceled) {
                        return;
                    }
                    // TODO@rob - ???
                    var relativePath = path.relative(fq.folder.path, uri.path);
                    if (noSiblingsClauses) {
                        var basename = path.basename(uri.path);
                        _this.matchFile(onResult, { base: fq.folder, relativePath: relativePath, basename: basename, original: uri });
                        return;
                    }
                    // TODO: Optimize siblings clauses with ripgrep here.
                    _this.addDirectoryEntries(tree, fq.folder, relativePath, onResult);
                };
                new winjs_base_1.TPromise(function (resolve) { return process.nextTick(resolve); })
                    .then(function () {
                    _this.activeCancellationTokens.add(cancellation);
                    return _this.provider.provideFileIndex(options, cancellation.token);
                })
                    .then(function (results) {
                    _this.activeCancellationTokens.delete(cancellation);
                    if (_this.isCanceled) {
                        return null;
                    }
                    results.forEach(onProviderResult);
                    _this.matchDirectoryTree(tree, queryTester, onResult);
                    return null;
                }).then(function () {
                    cancellation.dispose();
                    resolve(undefined);
                }, function (err) {
                    cancellation.dispose();
                    reject(err);
                });
            });
        };
        FileIndexSearchEngine.prototype.getSearchOptionsForFolder = function (fq) {
            var includes = resolvePatternsForProvider(this.config.includePattern, fq.includePattern);
            var excludes = resolvePatternsForProvider(this.config.excludePattern, fq.excludePattern);
            return {
                folder: fq.folder,
                excludes: excludes,
                includes: includes,
                useIgnoreFiles: !this.config.disregardIgnoreFiles,
                followSymlinks: !this.config.ignoreSymlinks
            };
        };
        FileIndexSearchEngine.prototype.initDirectoryTree = function () {
            var tree = {
                rootEntries: [],
                pathToEntries: Object.create(null)
            };
            tree.pathToEntries['.'] = tree.rootEntries;
            return tree;
        };
        FileIndexSearchEngine.prototype.addDirectoryEntries = function (_a, base, relativeFile, onResult) {
            var pathToEntries = _a.pathToEntries;
            // Support relative paths to files from a root resource (ignores excludes)
            if (relativeFile === this.filePattern) {
                var basename = path.basename(this.filePattern);
                this.matchFile(onResult, { base: base, relativePath: this.filePattern, basename: basename });
            }
            function add(relativePath) {
                var basename = path.basename(relativePath);
                var dirname = path.dirname(relativePath);
                var entries = pathToEntries[dirname];
                if (!entries) {
                    entries = pathToEntries[dirname] = [];
                    add(dirname);
                }
                entries.push({
                    base: base,
                    relativePath: relativePath,
                    basename: basename
                });
            }
            add(relativeFile);
        };
        FileIndexSearchEngine.prototype.matchDirectoryTree = function (_a, queryTester, onResult) {
            var rootEntries = _a.rootEntries, pathToEntries = _a.pathToEntries;
            var self = this;
            var filePattern = this.filePattern;
            function matchDirectory(entries) {
                // self.directoriesWalked++;
                for (var i = 0, n = entries.length; i < n; i++) {
                    var entry = entries[i];
                    var relativePath = entry.relativePath, basename = entry.basename;
                    // Check exclude pattern
                    // If the user searches for the exact file name, we adjust the glob matching
                    // to ignore filtering by siblings because the user seems to know what she
                    // is searching for and we want to include the result in that case anyway
                    var hasSibling = glob.hasSiblingFn(function () { return entries.map(function (entry) { return entry.basename; }); });
                    if (!queryTester.includedInQuerySync(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {
                        continue;
                    }
                    var sub = pathToEntries[relativePath];
                    if (sub) {
                        matchDirectory(sub);
                    }
                    else {
                        // self.filesWalked++;
                        if (relativePath === filePattern) {
                            continue; // ignore file if its path matches with the file pattern because that is already matched above
                        }
                        self.matchFile(onResult, entry);
                    }
                    if (self.isLimitHit) {
                        break;
                    }
                }
            }
            matchDirectory(rootEntries);
        };
        FileIndexSearchEngine.prototype.matchFile = function (onResult, candidate) {
            if (this.isFilePatternMatch(candidate.relativePath) && (!this.includePattern || this.includePattern(candidate.relativePath, candidate.basename))) {
                if (this.exists || (this.maxResults && this.resultCount >= this.maxResults)) {
                    this.isLimitHit = true;
                    this.cancel();
                }
                if (!this.isLimitHit) {
                    onResult(candidate);
                }
            }
        };
        FileIndexSearchEngine.prototype.isFilePatternMatch = function (path) {
            // Check for search pattern
            if (this.filePattern) {
                if (this.filePattern === '*') {
                    return true; // support the all-matching wildcard
                }
                return strings.fuzzyContains(path, this.normalizedFilePatternLowercase);
            }
            // No patterns means we match all
            return true;
        };
        return FileIndexSearchEngine;
    }());
    exports.FileIndexSearchEngine = FileIndexSearchEngine;
    var FileIndexSearchManager = /** @class */ (function () {
        function FileIndexSearchManager() {
            this.caches = Object.create(null);
            this.folderCacheKeys = new Map();
        }
        FileIndexSearchManager.prototype.fileSearch = function (config, provider, onBatch) {
            var _this = this;
            if (config.sortByScore) {
                var sortedSearch_1 = this.trySortedSearchFromCache(config);
                if (!sortedSearch_1) {
                    var engineConfig = config.maxResults ? __assign({}, config, { maxResults: null }) :
                        config;
                    var engine_1 = new FileIndexSearchEngine(engineConfig, provider);
                    sortedSearch_1 = this.doSortedSearch(engine_1, config);
                }
                return new winjs_base_1.TPromise(function (c, e) {
                    sortedSearch_1.then(function (complete) {
                        _this.sendAsBatches(complete.results, onBatch, FileIndexSearchManager.BATCH_SIZE);
                        c(complete);
                    }, e, onBatch);
                }, function () {
                    sortedSearch_1.cancel();
                });
            }
            var engine = new FileIndexSearchEngine(config, provider);
            return this.doSearch(engine)
                .then(function (complete) {
                _this.sendAsBatches(complete.results, onBatch, FileIndexSearchManager.BATCH_SIZE);
                return {
                    limitHit: complete.limitHit
                };
            });
        };
        FileIndexSearchManager.prototype.getFolderCacheKey = function (config) {
            var uri = config.folderQueries[0].folder.toString();
            var folderCacheKey = config.cacheKey && uri + "_" + config.cacheKey;
            if (!this.folderCacheKeys.get(config.cacheKey)) {
                this.folderCacheKeys.set(config.cacheKey, new Set());
            }
            this.folderCacheKeys.get(config.cacheKey).add(folderCacheKey);
            return folderCacheKey;
        };
        FileIndexSearchManager.prototype.rawMatchToSearchItem = function (match) {
            return {
                resource: match.original || resources.joinPath(match.base, match.relativePath)
            };
        };
        FileIndexSearchManager.prototype.doSortedSearch = function (engine, config) {
            var _this = this;
            var searchPromise;
            var allResultsPromise = new winjs_base_1.TPromise(function (c, e) {
                searchPromise = _this.doSearch(engine).then(c, e);
            }, function () {
                searchPromise.cancel();
            });
            var folderCacheKey = this.getFolderCacheKey(config);
            var cache;
            if (folderCacheKey) {
                cache = this.getOrCreateCache(folderCacheKey);
                cache.resultsToSearchCache[config.filePattern] = allResultsPromise;
                allResultsPromise.then(null, function (err) {
                    delete cache.resultsToSearchCache[config.filePattern];
                });
                allResultsPromise = this.preventCancellation(allResultsPromise);
            }
            var chained;
            return new winjs_base_1.TPromise(function (c, e) {
                chained = allResultsPromise.then(function (complete) {
                    var scorerCache = cache ? cache.scorerCache : Object.create(null);
                    return _this.sortResults(config, complete.results, scorerCache)
                        .then(function (sortedResults) {
                        c({
                            limitHit: complete.limitHit || typeof config.maxResults === 'number' && complete.results.length > config.maxResults,
                            results: sortedResults
                        });
                    });
                }, e);
            }, function () {
                chained.cancel();
            });
        };
        FileIndexSearchManager.prototype.getOrCreateCache = function (cacheKey) {
            var existing = this.caches[cacheKey];
            if (existing) {
                return existing;
            }
            return this.caches[cacheKey] = new Cache();
        };
        FileIndexSearchManager.prototype.trySortedSearchFromCache = function (config) {
            var _this = this;
            var folderCacheKey = this.getFolderCacheKey(config);
            var cache = folderCacheKey && this.caches[folderCacheKey];
            if (!cache) {
                return undefined;
            }
            var cached = this.getResultsFromCache(cache, config.filePattern);
            if (cached) {
                var chained_1;
                return new winjs_base_1.TPromise(function (c, e) {
                    chained_1 = cached.then(function (complete) {
                        return _this.sortResults(config, complete.results, cache.scorerCache)
                            .then(function (sortedResults) {
                            c({
                                limitHit: complete.limitHit || typeof config.maxResults === 'number' && complete.results.length > config.maxResults,
                                results: sortedResults
                            });
                        });
                    }, e);
                }, function () {
                    chained_1.cancel();
                });
            }
            return undefined;
        };
        FileIndexSearchManager.prototype.sortResults = function (config, results, scorerCache) {
            // we use the same compare function that is used later when showing the results using fuzzy scoring
            // this is very important because we are also limiting the number of results by config.maxResults
            // and as such we want the top items to be included in this result set if the number of items
            // exceeds config.maxResults.
            var query = quickOpenScorer_1.prepareQuery(config.filePattern);
            var compare = function (matchA, matchB) { return quickOpenScorer_1.compareItemsByScore(matchA, matchB, query, true, FileMatchItemAccessor, scorerCache); };
            return arrays.topAsync(results, compare, config.maxResults, 10000);
        };
        FileIndexSearchManager.prototype.sendAsBatches = function (rawMatches, onBatch, batchSize) {
            var _this = this;
            var serializedMatches = rawMatches.map(function (rawMatch) { return _this.rawMatchToSearchItem(rawMatch); });
            if (batchSize && batchSize > 0) {
                for (var i = 0; i < serializedMatches.length; i += batchSize) {
                    onBatch(serializedMatches.slice(i, i + batchSize));
                }
            }
            else {
                onBatch(serializedMatches);
            }
        };
        FileIndexSearchManager.prototype.getResultsFromCache = function (cache, searchValue) {
            if (path.isAbsolute(searchValue)) {
                return null; // bypass cache if user looks up an absolute path where matching goes directly on disk
            }
            // Find cache entries by prefix of search value
            var hasPathSep = searchValue.indexOf(path.sep) >= 0;
            var cached;
            for (var previousSearch in cache.resultsToSearchCache) {
                // If we narrow down, we might be able to reuse the cached results
                if (strings.startsWith(searchValue, previousSearch)) {
                    if (hasPathSep && previousSearch.indexOf(path.sep) < 0) {
                        continue; // since a path character widens the search for potential more matches, require it in previous search too
                    }
                    var c = cache.resultsToSearchCache[previousSearch];
                    cached = this.preventCancellation(c);
                    break;
                }
            }
            if (!cached) {
                return null;
            }
            return new winjs_base_1.TPromise(function (c, e) {
                cached.then(function (complete) {
                    // Pattern match on results
                    var results = [];
                    var normalizedSearchValueLowercase = strings.stripWildcards(searchValue).toLowerCase();
                    for (var i = 0; i < complete.results.length; i++) {
                        var entry = complete.results[i];
                        // Check if this entry is a match for the search value
                        if (!strings.fuzzyContains(entry.relativePath, normalizedSearchValueLowercase)) {
                            continue;
                        }
                        results.push(entry);
                    }
                    c({
                        limitHit: complete.limitHit,
                        results: results
                    });
                }, e);
            }, function () {
                cached.cancel();
            });
        };
        FileIndexSearchManager.prototype.doSearch = function (engine) {
            var results = [];
            var onResult = function (match) { return results.push(match); };
            return new winjs_base_1.TPromise(function (c, e) {
                engine.search(onResult).then(function (result) {
                    c({
                        limitHit: result.isLimitHit,
                        results: results
                    });
                }, e);
            }, function () {
                engine.cancel();
            });
        };
        FileIndexSearchManager.prototype.clearCache = function (cacheKey) {
            var _this = this;
            if (!this.folderCacheKeys.has(cacheKey)) {
                return winjs_base_1.TPromise.wrap(undefined);
            }
            var expandedKeys = this.folderCacheKeys.get(cacheKey);
            expandedKeys.forEach(function (key) { return delete _this.caches[key]; });
            this.folderCacheKeys.delete(cacheKey);
            return winjs_base_1.TPromise.as(undefined);
        };
        FileIndexSearchManager.prototype.preventCancellation = function (promise) {
            return new winjs_base_1.TPromise(function (c, e) {
                // Allow for piled up cancellations to come through first.
                process.nextTick(function () {
                    promise.then(c, e);
                });
            }, function () {
                // Do not propagate.
            });
        };
        FileIndexSearchManager.BATCH_SIZE = 512;
        return FileIndexSearchManager;
    }());
    exports.FileIndexSearchManager = FileIndexSearchManager;
    var Cache = /** @class */ (function () {
        function Cache() {
            this.resultsToSearchCache = Object.create(null);
            this.scorerCache = Object.create(null);
        }
        return Cache;
    }());
    var FileMatchItemAccessor = new /** @class */ (function () {
        function class_1() {
        }
        class_1.prototype.getItemLabel = function (match) {
            return match.basename; // e.g. myFile.txt
        };
        class_1.prototype.getItemDescription = function (match) {
            return match.relativePath.substr(0, match.relativePath.length - match.basename.length - 1); // e.g. some/path/to/file
        };
        class_1.prototype.getItemPath = function (match) {
            return match.relativePath; // e.g. some/path/to/file/myFile.txt
        };
        return class_1;
    }());
});











define(__m[5/*vs/workbench/api/node/extHostTypes*/], __M([0/*require*/,1/*exports*/,238/*crypto*/,4/*vs/base/common/uri*/,14/*vs/base/common/errors*/,69/*vs/base/common/htmlContent*/,22/*path*/,8/*vs/base/common/strings*/,21/*vs/base/common/map*/,13/*vs/base/common/arrays*/]), function (require, exports, crypto, uri_1, errors_1, htmlContent_1, path_1, strings_1, map_1, arrays_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Disposable = /** @class */ (function () {
        function Disposable(callOnDispose) {
            this._callOnDispose = callOnDispose;
        }
        Disposable.from = function () {
            var disposables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                disposables[_i] = arguments[_i];
            }
            return new Disposable(function () {
                if (disposables) {
                    for (var _i = 0, disposables_1 = disposables; _i < disposables_1.length; _i++) {
                        var disposable = disposables_1[_i];
                        if (disposable && typeof disposable.dispose === 'function') {
                            disposable.dispose();
                        }
                    }
                    disposables = undefined;
                }
            });
        };
        Disposable.prototype.dispose = function () {
            if (typeof this._callOnDispose === 'function') {
                this._callOnDispose();
                this._callOnDispose = undefined;
            }
        };
        return Disposable;
    }());
    exports.Disposable = Disposable;
    var Position = /** @class */ (function () {
        function Position(line, character) {
            if (line < 0) {
                throw errors_1.illegalArgument('line must be non-negative');
            }
            if (character < 0) {
                throw errors_1.illegalArgument('character must be non-negative');
            }
            this._line = line;
            this._character = character;
        }
        Position.Min = function () {
            var positions = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                positions[_i] = arguments[_i];
            }
            var result = positions.pop();
            for (var _a = 0, positions_1 = positions; _a < positions_1.length; _a++) {
                var p = positions_1[_a];
                if (p.isBefore(result)) {
                    result = p;
                }
            }
            return result;
        };
        Position.Max = function () {
            var positions = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                positions[_i] = arguments[_i];
            }
            var result = positions.pop();
            for (var _a = 0, positions_2 = positions; _a < positions_2.length; _a++) {
                var p = positions_2[_a];
                if (p.isAfter(result)) {
                    result = p;
                }
            }
            return result;
        };
        Position.isPosition = function (other) {
            if (!other) {
                return false;
            }
            if (other instanceof Position) {
                return true;
            }
            var _a = other, line = _a.line, character = _a.character;
            if (typeof line === 'number' && typeof character === 'number') {
                return true;
            }
            return false;
        };
        Object.defineProperty(Position.prototype, "line", {
            get: function () {
                return this._line;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Position.prototype, "character", {
            get: function () {
                return this._character;
            },
            enumerable: true,
            configurable: true
        });
        Position.prototype.isBefore = function (other) {
            if (this._line < other._line) {
                return true;
            }
            if (other._line < this._line) {
                return false;
            }
            return this._character < other._character;
        };
        Position.prototype.isBeforeOrEqual = function (other) {
            if (this._line < other._line) {
                return true;
            }
            if (other._line < this._line) {
                return false;
            }
            return this._character <= other._character;
        };
        Position.prototype.isAfter = function (other) {
            return !this.isBeforeOrEqual(other);
        };
        Position.prototype.isAfterOrEqual = function (other) {
            return !this.isBefore(other);
        };
        Position.prototype.isEqual = function (other) {
            return this._line === other._line && this._character === other._character;
        };
        Position.prototype.compareTo = function (other) {
            if (this._line < other._line) {
                return -1;
            }
            else if (this._line > other.line) {
                return 1;
            }
            else {
                // equal line
                if (this._character < other._character) {
                    return -1;
                }
                else if (this._character > other._character) {
                    return 1;
                }
                else {
                    // equal line and character
                    return 0;
                }
            }
        };
        Position.prototype.translate = function (lineDeltaOrChange, characterDelta) {
            if (characterDelta === void 0) { characterDelta = 0; }
            if (lineDeltaOrChange === null || characterDelta === null) {
                throw errors_1.illegalArgument();
            }
            var lineDelta;
            if (typeof lineDeltaOrChange === 'undefined') {
                lineDelta = 0;
            }
            else if (typeof lineDeltaOrChange === 'number') {
                lineDelta = lineDeltaOrChange;
            }
            else {
                lineDelta = typeof lineDeltaOrChange.lineDelta === 'number' ? lineDeltaOrChange.lineDelta : 0;
                characterDelta = typeof lineDeltaOrChange.characterDelta === 'number' ? lineDeltaOrChange.characterDelta : 0;
            }
            if (lineDelta === 0 && characterDelta === 0) {
                return this;
            }
            return new Position(this.line + lineDelta, this.character + characterDelta);
        };
        Position.prototype.with = function (lineOrChange, character) {
            if (character === void 0) { character = this.character; }
            if (lineOrChange === null || character === null) {
                throw errors_1.illegalArgument();
            }
            var line;
            if (typeof lineOrChange === 'undefined') {
                line = this.line;
            }
            else if (typeof lineOrChange === 'number') {
                line = lineOrChange;
            }
            else {
                line = typeof lineOrChange.line === 'number' ? lineOrChange.line : this.line;
                character = typeof lineOrChange.character === 'number' ? lineOrChange.character : this.character;
            }
            if (line === this.line && character === this.character) {
                return this;
            }
            return new Position(line, character);
        };
        Position.prototype.toJSON = function () {
            return { line: this.line, character: this.character };
        };
        return Position;
    }());
    exports.Position = Position;
    var Range = /** @class */ (function () {
        function Range(startLineOrStart, startColumnOrEnd, endLine, endColumn) {
            var start;
            var end;
            if (typeof startLineOrStart === 'number' && typeof startColumnOrEnd === 'number' && typeof endLine === 'number' && typeof endColumn === 'number') {
                start = new Position(startLineOrStart, startColumnOrEnd);
                end = new Position(endLine, endColumn);
            }
            else if (startLineOrStart instanceof Position && startColumnOrEnd instanceof Position) {
                start = startLineOrStart;
                end = startColumnOrEnd;
            }
            if (!start || !end) {
                throw new Error('Invalid arguments');
            }
            if (start.isBefore(end)) {
                this._start = start;
                this._end = end;
            }
            else {
                this._start = end;
                this._end = start;
            }
        }
        Range.isRange = function (thing) {
            if (thing instanceof Range) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return Position.isPosition(thing.start)
                && Position.isPosition(thing.end);
        };
        Object.defineProperty(Range.prototype, "start", {
            get: function () {
                return this._start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Range.prototype, "end", {
            get: function () {
                return this._end;
            },
            enumerable: true,
            configurable: true
        });
        Range.prototype.contains = function (positionOrRange) {
            if (positionOrRange instanceof Range) {
                return this.contains(positionOrRange._start)
                    && this.contains(positionOrRange._end);
            }
            else if (positionOrRange instanceof Position) {
                if (positionOrRange.isBefore(this._start)) {
                    return false;
                }
                if (this._end.isBefore(positionOrRange)) {
                    return false;
                }
                return true;
            }
            return false;
        };
        Range.prototype.isEqual = function (other) {
            return this._start.isEqual(other._start) && this._end.isEqual(other._end);
        };
        Range.prototype.intersection = function (other) {
            var start = Position.Max(other.start, this._start);
            var end = Position.Min(other.end, this._end);
            if (start.isAfter(end)) {
                // this happens when there is no overlap:
                // |-----|
                //          |----|
                return undefined;
            }
            return new Range(start, end);
        };
        Range.prototype.union = function (other) {
            if (this.contains(other)) {
                return this;
            }
            else if (other.contains(this)) {
                return other;
            }
            var start = Position.Min(other.start, this._start);
            var end = Position.Max(other.end, this.end);
            return new Range(start, end);
        };
        Object.defineProperty(Range.prototype, "isEmpty", {
            get: function () {
                return this._start.isEqual(this._end);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Range.prototype, "isSingleLine", {
            get: function () {
                return this._start.line === this._end.line;
            },
            enumerable: true,
            configurable: true
        });
        Range.prototype.with = function (startOrChange, end) {
            if (end === void 0) { end = this.end; }
            if (startOrChange === null || end === null) {
                throw errors_1.illegalArgument();
            }
            var start;
            if (!startOrChange) {
                start = this.start;
            }
            else if (Position.isPosition(startOrChange)) {
                start = startOrChange;
            }
            else {
                start = startOrChange.start || this.start;
                end = startOrChange.end || this.end;
            }
            if (start.isEqual(this._start) && end.isEqual(this.end)) {
                return this;
            }
            return new Range(start, end);
        };
        Range.prototype.toJSON = function () {
            return [this.start, this.end];
        };
        return Range;
    }());
    exports.Range = Range;
    var Selection = /** @class */ (function (_super) {
        __extends(Selection, _super);
        function Selection(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {
            var _this = this;
            var anchor;
            var active;
            if (typeof anchorLineOrAnchor === 'number' && typeof anchorColumnOrActive === 'number' && typeof activeLine === 'number' && typeof activeColumn === 'number') {
                anchor = new Position(anchorLineOrAnchor, anchorColumnOrActive);
                active = new Position(activeLine, activeColumn);
            }
            else if (anchorLineOrAnchor instanceof Position && anchorColumnOrActive instanceof Position) {
                anchor = anchorLineOrAnchor;
                active = anchorColumnOrActive;
            }
            if (!anchor || !active) {
                throw new Error('Invalid arguments');
            }
            _this = _super.call(this, anchor, active) || this;
            _this._anchor = anchor;
            _this._active = active;
            return _this;
        }
        Selection.isSelection = function (thing) {
            if (thing instanceof Selection) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return Range.isRange(thing)
                && Position.isPosition(thing.anchor)
                && Position.isPosition(thing.active)
                && typeof thing.isReversed === 'boolean';
        };
        Object.defineProperty(Selection.prototype, "anchor", {
            get: function () {
                return this._anchor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "active", {
            get: function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "isReversed", {
            get: function () {
                return this._anchor === this._end;
            },
            enumerable: true,
            configurable: true
        });
        Selection.prototype.toJSON = function () {
            return {
                start: this.start,
                end: this.end,
                active: this.active,
                anchor: this.anchor
            };
        };
        return Selection;
    }(Range));
    exports.Selection = Selection;
    var EndOfLine;
    (function (EndOfLine) {
        EndOfLine[EndOfLine["LF"] = 1] = "LF";
        EndOfLine[EndOfLine["CRLF"] = 2] = "CRLF";
    })(EndOfLine = exports.EndOfLine || (exports.EndOfLine = {}));
    var TextEdit = /** @class */ (function () {
        function TextEdit(range, newText) {
            this.range = range;
            this.newText = newText;
        }
        TextEdit.isTextEdit = function (thing) {
            if (thing instanceof TextEdit) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return Range.isRange(thing)
                && typeof thing.newText === 'string';
        };
        TextEdit.replace = function (range, newText) {
            return new TextEdit(range, newText);
        };
        TextEdit.insert = function (position, newText) {
            return TextEdit.replace(new Range(position, position), newText);
        };
        TextEdit.delete = function (range) {
            return TextEdit.replace(range, '');
        };
        TextEdit.setEndOfLine = function (eol) {
            var ret = new TextEdit(undefined, undefined);
            ret.newEol = eol;
            return ret;
        };
        Object.defineProperty(TextEdit.prototype, "range", {
            get: function () {
                return this._range;
            },
            set: function (value) {
                if (value && !Range.isRange(value)) {
                    throw errors_1.illegalArgument('range');
                }
                this._range = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextEdit.prototype, "newText", {
            get: function () {
                return this._newText || '';
            },
            set: function (value) {
                if (value && typeof value !== 'string') {
                    throw errors_1.illegalArgument('newText');
                }
                this._newText = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextEdit.prototype, "newEol", {
            get: function () {
                return this._newEol;
            },
            set: function (value) {
                if (value && typeof value !== 'number') {
                    throw errors_1.illegalArgument('newEol');
                }
                this._newEol = value;
            },
            enumerable: true,
            configurable: true
        });
        TextEdit.prototype.toJSON = function () {
            return {
                range: this.range,
                newText: this.newText,
                newEol: this._newEol
            };
        };
        return TextEdit;
    }());
    exports.TextEdit = TextEdit;
    var WorkspaceEdit = /** @class */ (function () {
        function WorkspaceEdit() {
            this._edits = new Array();
        }
        WorkspaceEdit.prototype.renameFile = function (from, to, options) {
            this._edits.push({ _type: 1, from: from, to: to, options: options });
        };
        WorkspaceEdit.prototype.createFile = function (uri, options) {
            this._edits.push({ _type: 1, from: undefined, to: uri, options: options });
        };
        WorkspaceEdit.prototype.deleteFile = function (uri, options) {
            this._edits.push({ _type: 1, from: uri, to: undefined, options: options });
        };
        WorkspaceEdit.prototype.replace = function (uri, range, newText) {
            this._edits.push({ _type: 2, uri: uri, edit: new TextEdit(range, newText) });
        };
        WorkspaceEdit.prototype.insert = function (resource, position, newText) {
            this.replace(resource, new Range(position, position), newText);
        };
        WorkspaceEdit.prototype.delete = function (resource, range) {
            this.replace(resource, range, '');
        };
        WorkspaceEdit.prototype.has = function (uri) {
            for (var _i = 0, _a = this._edits; _i < _a.length; _i++) {
                var edit = _a[_i];
                if (edit._type === 2 && edit.uri.toString() === uri.toString()) {
                    return true;
                }
            }
            return false;
        };
        WorkspaceEdit.prototype.set = function (uri, edits) {
            if (!edits) {
                // remove all text edits for `uri`
                for (var i = 0; i < this._edits.length; i++) {
                    var element = this._edits[i];
                    if (element._type === 2 && element.uri.toString() === uri.toString()) {
                        this._edits[i] = undefined;
                    }
                }
                this._edits = arrays_1.coalesce(this._edits);
            }
            else {
                // append edit to the end
                for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
                    var edit = edits_1[_i];
                    if (edit) {
                        this._edits.push({ _type: 2, uri: uri, edit: edit });
                    }
                }
            }
        };
        WorkspaceEdit.prototype.get = function (uri) {
            var res = [];
            for (var _i = 0, _a = this._edits; _i < _a.length; _i++) {
                var candidate = _a[_i];
                if (candidate._type === 2 && candidate.uri.toString() === uri.toString()) {
                    res.push(candidate.edit);
                }
            }
            if (res.length === 0) {
                return undefined;
            }
            return res;
        };
        WorkspaceEdit.prototype.entries = function () {
            var textEdits = new Map();
            for (var _i = 0, _a = this._edits; _i < _a.length; _i++) {
                var candidate = _a[_i];
                if (candidate._type === 2) {
                    var textEdit = textEdits.get(candidate.uri.toString());
                    if (!textEdit) {
                        textEdit = [candidate.uri, []];
                        textEdits.set(candidate.uri.toString(), textEdit);
                    }
                    textEdit[1].push(candidate.edit);
                }
            }
            return map_1.values(textEdits);
        };
        WorkspaceEdit.prototype._allEntries = function () {
            var res = [];
            for (var _i = 0, _a = this._edits; _i < _a.length; _i++) {
                var edit = _a[_i];
                if (edit._type === 1) {
                    res.push([edit.from, edit.to, edit.options]);
                }
                else {
                    res.push([edit.uri, [edit.edit]]);
                }
            }
            return res;
        };
        Object.defineProperty(WorkspaceEdit.prototype, "size", {
            get: function () {
                return this.entries().length;
            },
            enumerable: true,
            configurable: true
        });
        WorkspaceEdit.prototype.toJSON = function () {
            return this.entries();
        };
        return WorkspaceEdit;
    }());
    exports.WorkspaceEdit = WorkspaceEdit;
    var SnippetString = /** @class */ (function () {
        function SnippetString(value) {
            this._tabstop = 1;
            this.value = value || '';
        }
        SnippetString.isSnippetString = function (thing) {
            if (thing instanceof SnippetString) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return typeof thing.value === 'string';
        };
        SnippetString._escape = function (value) {
            return value.replace(/\$|}|\\/g, '\\$&');
        };
        SnippetString.prototype.appendText = function (string) {
            this.value += SnippetString._escape(string);
            return this;
        };
        SnippetString.prototype.appendTabstop = function (number) {
            if (number === void 0) { number = this._tabstop++; }
            this.value += '$';
            this.value += number;
            return this;
        };
        SnippetString.prototype.appendPlaceholder = function (value, number) {
            if (number === void 0) { number = this._tabstop++; }
            if (typeof value === 'function') {
                var nested = new SnippetString();
                nested._tabstop = this._tabstop;
                value(nested);
                this._tabstop = nested._tabstop;
                value = nested.value;
            }
            else {
                value = SnippetString._escape(value);
            }
            this.value += '${';
            this.value += number;
            this.value += ':';
            this.value += value;
            this.value += '}';
            return this;
        };
        SnippetString.prototype.appendVariable = function (name, defaultValue) {
            if (typeof defaultValue === 'function') {
                var nested = new SnippetString();
                nested._tabstop = this._tabstop;
                defaultValue(nested);
                this._tabstop = nested._tabstop;
                defaultValue = nested.value;
            }
            else if (typeof defaultValue === 'string') {
                defaultValue = defaultValue.replace(/\$|}/g, '\\$&');
            }
            this.value += '${';
            this.value += name;
            if (defaultValue) {
                this.value += ':';
                this.value += defaultValue;
            }
            this.value += '}';
            return this;
        };
        return SnippetString;
    }());
    exports.SnippetString = SnippetString;
    var DiagnosticTag;
    (function (DiagnosticTag) {
        DiagnosticTag[DiagnosticTag["Unnecessary"] = 1] = "Unnecessary";
    })(DiagnosticTag = exports.DiagnosticTag || (exports.DiagnosticTag = {}));
    var DiagnosticSeverity;
    (function (DiagnosticSeverity) {
        DiagnosticSeverity[DiagnosticSeverity["Hint"] = 3] = "Hint";
        DiagnosticSeverity[DiagnosticSeverity["Information"] = 2] = "Information";
        DiagnosticSeverity[DiagnosticSeverity["Warning"] = 1] = "Warning";
        DiagnosticSeverity[DiagnosticSeverity["Error"] = 0] = "Error";
    })(DiagnosticSeverity = exports.DiagnosticSeverity || (exports.DiagnosticSeverity = {}));
    var Location = /** @class */ (function () {
        function Location(uri, rangeOrPosition) {
            this.uri = uri;
            if (!rangeOrPosition) {
                //that's OK
            }
            else if (rangeOrPosition instanceof Range) {
                this.range = rangeOrPosition;
            }
            else if (rangeOrPosition instanceof Position) {
                this.range = new Range(rangeOrPosition, rangeOrPosition);
            }
            else {
                throw new Error('Illegal argument');
            }
        }
        Location.isLocation = function (thing) {
            if (thing instanceof Location) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return Range.isRange(thing.range)
                && uri_1.default.isUri(thing.uri);
        };
        Location.prototype.toJSON = function () {
            return {
                uri: this.uri,
                range: this.range
            };
        };
        return Location;
    }());
    exports.Location = Location;
    var DiagnosticRelatedInformation = /** @class */ (function () {
        function DiagnosticRelatedInformation(location, message) {
            this.location = location;
            this.message = message;
        }
        DiagnosticRelatedInformation.is = function (thing) {
            if (!thing) {
                return false;
            }
            return typeof thing.message === 'string'
                && thing.location
                && Range.isRange(thing.location.range)
                && uri_1.default.isUri(thing.location.uri);
        };
        return DiagnosticRelatedInformation;
    }());
    exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation;
    var Diagnostic = /** @class */ (function () {
        function Diagnostic(range, message, severity) {
            if (severity === void 0) { severity = DiagnosticSeverity.Error; }
            this.range = range;
            this.message = message;
            this.severity = severity;
        }
        Diagnostic.prototype.toJSON = function () {
            return {
                severity: DiagnosticSeverity[this.severity],
                message: this.message,
                range: this.range,
                source: this.source,
                code: this.code,
            };
        };
        return Diagnostic;
    }());
    exports.Diagnostic = Diagnostic;
    var Hover = /** @class */ (function () {
        function Hover(contents, range) {
            if (!contents) {
                throw new Error('Illegal argument, contents must be defined');
            }
            if (Array.isArray(contents)) {
                this.contents = contents;
            }
            else if (htmlContent_1.isMarkdownString(contents)) {
                this.contents = [contents];
            }
            else {
                this.contents = [contents];
            }
            this.range = range;
        }
        return Hover;
    }());
    exports.Hover = Hover;
    var DocumentHighlightKind;
    (function (DocumentHighlightKind) {
        DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
        DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
        DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
    })(DocumentHighlightKind = exports.DocumentHighlightKind || (exports.DocumentHighlightKind = {}));
    var DocumentHighlight = /** @class */ (function () {
        function DocumentHighlight(range, kind) {
            if (kind === void 0) { kind = DocumentHighlightKind.Text; }
            this.range = range;
            this.kind = kind;
        }
        DocumentHighlight.prototype.toJSON = function () {
            return {
                range: this.range,
                kind: DocumentHighlightKind[this.kind]
            };
        };
        return DocumentHighlight;
    }());
    exports.DocumentHighlight = DocumentHighlight;
    var SymbolKind;
    (function (SymbolKind) {
        SymbolKind[SymbolKind["File"] = 0] = "File";
        SymbolKind[SymbolKind["Module"] = 1] = "Module";
        SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
        SymbolKind[SymbolKind["Package"] = 3] = "Package";
        SymbolKind[SymbolKind["Class"] = 4] = "Class";
        SymbolKind[SymbolKind["Method"] = 5] = "Method";
        SymbolKind[SymbolKind["Property"] = 6] = "Property";
        SymbolKind[SymbolKind["Field"] = 7] = "Field";
        SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
        SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
        SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
        SymbolKind[SymbolKind["Function"] = 11] = "Function";
        SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
        SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
        SymbolKind[SymbolKind["String"] = 14] = "String";
        SymbolKind[SymbolKind["Number"] = 15] = "Number";
        SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
        SymbolKind[SymbolKind["Array"] = 17] = "Array";
        SymbolKind[SymbolKind["Object"] = 18] = "Object";
        SymbolKind[SymbolKind["Key"] = 19] = "Key";
        SymbolKind[SymbolKind["Null"] = 20] = "Null";
        SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
        SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
        SymbolKind[SymbolKind["Event"] = 23] = "Event";
        SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
        SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    var SymbolInformation = /** @class */ (function () {
        function SymbolInformation(name, kind, rangeOrContainer, locationOrUri, containerName) {
            this.name = name;
            this.kind = kind;
            this.containerName = containerName;
            if (typeof rangeOrContainer === 'string') {
                this.containerName = rangeOrContainer;
            }
            if (locationOrUri instanceof Location) {
                this.location = locationOrUri;
            }
            else if (rangeOrContainer instanceof Range) {
                this.location = new Location(locationOrUri, rangeOrContainer);
            }
        }
        SymbolInformation.prototype.toJSON = function () {
            return {
                name: this.name,
                kind: SymbolKind[this.kind],
                location: this.location,
                containerName: this.containerName
            };
        };
        return SymbolInformation;
    }());
    exports.SymbolInformation = SymbolInformation;
    var DocumentSymbol = /** @class */ (function () {
        function DocumentSymbol(name, detail, kind, range, selectionRange) {
            this.name = name;
            this.detail = detail;
            this.kind = kind;
            this.range = range;
            this.selectionRange = selectionRange;
            this.children = [];
            if (!this.range.contains(this.selectionRange)) {
                throw new Error('selectionRange must be contained in fullRange');
            }
        }
        return DocumentSymbol;
    }());
    exports.DocumentSymbol = DocumentSymbol;
    var CodeActionTrigger;
    (function (CodeActionTrigger) {
        CodeActionTrigger[CodeActionTrigger["Automatic"] = 1] = "Automatic";
        CodeActionTrigger[CodeActionTrigger["Manual"] = 2] = "Manual";
    })(CodeActionTrigger = exports.CodeActionTrigger || (exports.CodeActionTrigger = {}));
    var CodeAction = /** @class */ (function () {
        function CodeAction(title, kind) {
            this.title = title;
            this.kind = kind;
        }
        return CodeAction;
    }());
    exports.CodeAction = CodeAction;
    var CodeActionKind = /** @class */ (function () {
        function CodeActionKind(value) {
            this.value = value;
        }
        CodeActionKind.prototype.append = function (parts) {
            return new CodeActionKind(this.value ? this.value + CodeActionKind.sep + parts : parts);
        };
        CodeActionKind.prototype.contains = function (other) {
            return this.value === other.value || strings_1.startsWith(other.value, this.value + CodeActionKind.sep);
        };
        CodeActionKind.sep = '.';
        CodeActionKind.Empty = new CodeActionKind('');
        CodeActionKind.QuickFix = CodeActionKind.Empty.append('quickfix');
        CodeActionKind.Refactor = CodeActionKind.Empty.append('refactor');
        CodeActionKind.RefactorExtract = CodeActionKind.Refactor.append('extract');
        CodeActionKind.RefactorInline = CodeActionKind.Refactor.append('inline');
        CodeActionKind.RefactorRewrite = CodeActionKind.Refactor.append('rewrite');
        CodeActionKind.Source = CodeActionKind.Empty.append('source');
        CodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append('organizeImports');
        return CodeActionKind;
    }());
    exports.CodeActionKind = CodeActionKind;
    var CodeLens = /** @class */ (function () {
        function CodeLens(range, command) {
            this.range = range;
            this.command = command;
        }
        Object.defineProperty(CodeLens.prototype, "isResolved", {
            get: function () {
                return !!this.command;
            },
            enumerable: true,
            configurable: true
        });
        return CodeLens;
    }());
    exports.CodeLens = CodeLens;
    var MarkdownString = /** @class */ (function () {
        function MarkdownString(value) {
            this.value = value || '';
        }
        MarkdownString.prototype.appendText = function (value) {
            // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
            this.value += value.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&');
            return this;
        };
        MarkdownString.prototype.appendMarkdown = function (value) {
            this.value += value;
            return this;
        };
        MarkdownString.prototype.appendCodeblock = function (code, language) {
            if (language === void 0) { language = ''; }
            this.value += '\n```';
            this.value += language;
            this.value += '\n';
            this.value += code;
            this.value += '\n```\n';
            return this;
        };
        return MarkdownString;
    }());
    exports.MarkdownString = MarkdownString;
    var ParameterInformation = /** @class */ (function () {
        function ParameterInformation(label, documentation) {
            this.label = label;
            this.documentation = documentation;
        }
        return ParameterInformation;
    }());
    exports.ParameterInformation = ParameterInformation;
    var SignatureInformation = /** @class */ (function () {
        function SignatureInformation(label, documentation) {
            this.label = label;
            this.documentation = documentation;
            this.parameters = [];
        }
        return SignatureInformation;
    }());
    exports.SignatureInformation = SignatureInformation;
    var SignatureHelp = /** @class */ (function () {
        function SignatureHelp() {
            this.signatures = [];
        }
        return SignatureHelp;
    }());
    exports.SignatureHelp = SignatureHelp;
    var CompletionTriggerKind;
    (function (CompletionTriggerKind) {
        CompletionTriggerKind[CompletionTriggerKind["Invoke"] = 0] = "Invoke";
        CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
        CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
    })(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
    var CompletionItemKind;
    (function (CompletionItemKind) {
        CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
        CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
        CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
        CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
        CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
        CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
        CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
        CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
        CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
        CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
        CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
        CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
        CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
        CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
        CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
        CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
        CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
        CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
        CompletionItemKind[CompletionItemKind["Folder"] = 18] = "Folder";
        CompletionItemKind[CompletionItemKind["EnumMember"] = 19] = "EnumMember";
        CompletionItemKind[CompletionItemKind["Constant"] = 20] = "Constant";
        CompletionItemKind[CompletionItemKind["Struct"] = 21] = "Struct";
        CompletionItemKind[CompletionItemKind["Event"] = 22] = "Event";
        CompletionItemKind[CompletionItemKind["Operator"] = 23] = "Operator";
        CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
    })(CompletionItemKind = exports.CompletionItemKind || (exports.CompletionItemKind = {}));
    var CompletionItem = /** @class */ (function () {
        function CompletionItem(label, kind) {
            this.label = label;
            this.kind = kind;
        }
        CompletionItem.prototype.toJSON = function () {
            return {
                label: this.label,
                kind: CompletionItemKind[this.kind],
                detail: this.detail,
                documentation: this.documentation,
                sortText: this.sortText,
                filterText: this.filterText,
                preselect: this.preselect,
                insertText: this.insertText,
                textEdit: this.textEdit
            };
        };
        return CompletionItem;
    }());
    exports.CompletionItem = CompletionItem;
    var CompletionList = /** @class */ (function () {
        function CompletionList(items, isIncomplete) {
            if (items === void 0) { items = []; }
            if (isIncomplete === void 0) { isIncomplete = false; }
            this.items = items;
            this.isIncomplete = isIncomplete;
        }
        return CompletionList;
    }());
    exports.CompletionList = CompletionList;
    var ViewColumn;
    (function (ViewColumn) {
        ViewColumn[ViewColumn["Active"] = -1] = "Active";
        ViewColumn[ViewColumn["Beside"] = -2] = "Beside";
        ViewColumn[ViewColumn["One"] = 1] = "One";
        ViewColumn[ViewColumn["Two"] = 2] = "Two";
        ViewColumn[ViewColumn["Three"] = 3] = "Three";
        ViewColumn[ViewColumn["Four"] = 4] = "Four";
        ViewColumn[ViewColumn["Five"] = 5] = "Five";
        ViewColumn[ViewColumn["Six"] = 6] = "Six";
        ViewColumn[ViewColumn["Seven"] = 7] = "Seven";
        ViewColumn[ViewColumn["Eight"] = 8] = "Eight";
        ViewColumn[ViewColumn["Nine"] = 9] = "Nine";
    })(ViewColumn = exports.ViewColumn || (exports.ViewColumn = {}));
    var StatusBarAlignment;
    (function (StatusBarAlignment) {
        StatusBarAlignment[StatusBarAlignment["Left"] = 1] = "Left";
        StatusBarAlignment[StatusBarAlignment["Right"] = 2] = "Right";
    })(StatusBarAlignment = exports.StatusBarAlignment || (exports.StatusBarAlignment = {}));
    var TextEditorLineNumbersStyle;
    (function (TextEditorLineNumbersStyle) {
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Off"] = 0] = "Off";
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["On"] = 1] = "On";
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Relative"] = 2] = "Relative";
    })(TextEditorLineNumbersStyle = exports.TextEditorLineNumbersStyle || (exports.TextEditorLineNumbersStyle = {}));
    var TextDocumentSaveReason;
    (function (TextDocumentSaveReason) {
        TextDocumentSaveReason[TextDocumentSaveReason["Manual"] = 1] = "Manual";
        TextDocumentSaveReason[TextDocumentSaveReason["AfterDelay"] = 2] = "AfterDelay";
        TextDocumentSaveReason[TextDocumentSaveReason["FocusOut"] = 3] = "FocusOut";
    })(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
    var TextEditorRevealType;
    (function (TextEditorRevealType) {
        TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
        TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
        TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
    })(TextEditorRevealType = exports.TextEditorRevealType || (exports.TextEditorRevealType = {}));
    var TextEditorSelectionChangeKind;
    (function (TextEditorSelectionChangeKind) {
        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Keyboard"] = 1] = "Keyboard";
        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Mouse"] = 2] = "Mouse";
        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Command"] = 3] = "Command";
    })(TextEditorSelectionChangeKind = exports.TextEditorSelectionChangeKind || (exports.TextEditorSelectionChangeKind = {}));
    /**
     * These values match very carefully the values of `TrackedRangeStickiness`
     */
    var DecorationRangeBehavior;
    (function (DecorationRangeBehavior) {
        /**
         * TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
         */
        DecorationRangeBehavior[DecorationRangeBehavior["OpenOpen"] = 0] = "OpenOpen";
        /**
         * TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
         */
        DecorationRangeBehavior[DecorationRangeBehavior["ClosedClosed"] = 1] = "ClosedClosed";
        /**
         * TrackedRangeStickiness.GrowsOnlyWhenTypingBefore
         */
        DecorationRangeBehavior[DecorationRangeBehavior["OpenClosed"] = 2] = "OpenClosed";
        /**
         * TrackedRangeStickiness.GrowsOnlyWhenTypingAfter
         */
        DecorationRangeBehavior[DecorationRangeBehavior["ClosedOpen"] = 3] = "ClosedOpen";
    })(DecorationRangeBehavior = exports.DecorationRangeBehavior || (exports.DecorationRangeBehavior = {}));
    (function (TextEditorSelectionChangeKind) {
        function fromValue(s) {
            switch (s) {
                case 'keyboard': return TextEditorSelectionChangeKind.Keyboard;
                case 'mouse': return TextEditorSelectionChangeKind.Mouse;
                case 'api': return TextEditorSelectionChangeKind.Command;
            }
            return undefined;
        }
        TextEditorSelectionChangeKind.fromValue = fromValue;
    })(TextEditorSelectionChangeKind = exports.TextEditorSelectionChangeKind || (exports.TextEditorSelectionChangeKind = {}));
    var DocumentLink = /** @class */ (function () {
        function DocumentLink(range, target) {
            if (target && !(target instanceof uri_1.default)) {
                throw errors_1.illegalArgument('target');
            }
            if (!Range.isRange(range) || range.isEmpty) {
                throw errors_1.illegalArgument('range');
            }
            this.range = range;
            this.target = target;
        }
        return DocumentLink;
    }());
    exports.DocumentLink = DocumentLink;
    var Color = /** @class */ (function () {
        function Color(red, green, blue, alpha) {
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.alpha = alpha;
        }
        return Color;
    }());
    exports.Color = Color;
    var ColorInformation = /** @class */ (function () {
        function ColorInformation(range, color) {
            if (color && !(color instanceof Color)) {
                throw errors_1.illegalArgument('color');
            }
            if (!Range.isRange(range) || range.isEmpty) {
                throw errors_1.illegalArgument('range');
            }
            this.range = range;
            this.color = color;
        }
        return ColorInformation;
    }());
    exports.ColorInformation = ColorInformation;
    var ColorPresentation = /** @class */ (function () {
        function ColorPresentation(label) {
            if (!label || typeof label !== 'string') {
                throw errors_1.illegalArgument('label');
            }
            this.label = label;
        }
        return ColorPresentation;
    }());
    exports.ColorPresentation = ColorPresentation;
    var ColorFormat;
    (function (ColorFormat) {
        ColorFormat[ColorFormat["RGB"] = 0] = "RGB";
        ColorFormat[ColorFormat["HEX"] = 1] = "HEX";
        ColorFormat[ColorFormat["HSL"] = 2] = "HSL";
    })(ColorFormat = exports.ColorFormat || (exports.ColorFormat = {}));
    var SourceControlInputBoxValidationType;
    (function (SourceControlInputBoxValidationType) {
        SourceControlInputBoxValidationType[SourceControlInputBoxValidationType["Error"] = 0] = "Error";
        SourceControlInputBoxValidationType[SourceControlInputBoxValidationType["Warning"] = 1] = "Warning";
        SourceControlInputBoxValidationType[SourceControlInputBoxValidationType["Information"] = 2] = "Information";
    })(SourceControlInputBoxValidationType = exports.SourceControlInputBoxValidationType || (exports.SourceControlInputBoxValidationType = {}));
    var TaskRevealKind;
    (function (TaskRevealKind) {
        TaskRevealKind[TaskRevealKind["Always"] = 1] = "Always";
        TaskRevealKind[TaskRevealKind["Silent"] = 2] = "Silent";
        TaskRevealKind[TaskRevealKind["Never"] = 3] = "Never";
    })(TaskRevealKind = exports.TaskRevealKind || (exports.TaskRevealKind = {}));
    var TaskPanelKind;
    (function (TaskPanelKind) {
        TaskPanelKind[TaskPanelKind["Shared"] = 1] = "Shared";
        TaskPanelKind[TaskPanelKind["Dedicated"] = 2] = "Dedicated";
        TaskPanelKind[TaskPanelKind["New"] = 3] = "New";
    })(TaskPanelKind = exports.TaskPanelKind || (exports.TaskPanelKind = {}));
    var TaskGroup = /** @class */ (function () {
        function TaskGroup(id, _label) {
            if (typeof id !== 'string') {
                throw errors_1.illegalArgument('name');
            }
            if (typeof _label !== 'string') {
                throw errors_1.illegalArgument('name');
            }
            this._id = id;
        }
        TaskGroup.from = function (value) {
            switch (value) {
                case 'clean':
                    return TaskGroup.Clean;
                case 'build':
                    return TaskGroup.Build;
                case 'rebuild':
                    return TaskGroup.Rebuild;
                case 'test':
                    return TaskGroup.Test;
                default:
                    return undefined;
            }
        };
        Object.defineProperty(TaskGroup.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        TaskGroup.Clean = new TaskGroup('clean', 'Clean');
        TaskGroup.Build = new TaskGroup('build', 'Build');
        TaskGroup.Rebuild = new TaskGroup('rebuild', 'Rebuild');
        TaskGroup.Test = new TaskGroup('test', 'Test');
        return TaskGroup;
    }());
    exports.TaskGroup = TaskGroup;
    var ProcessExecution = /** @class */ (function () {
        function ProcessExecution(process, varg1, varg2) {
            if (typeof process !== 'string') {
                throw errors_1.illegalArgument('process');
            }
            this._process = process;
            if (varg1 !== void 0) {
                if (Array.isArray(varg1)) {
                    this._args = varg1;
                    this._options = varg2;
                }
                else {
                    this._options = varg1;
                }
            }
            if (this._args === void 0) {
                this._args = [];
            }
        }
        Object.defineProperty(ProcessExecution.prototype, "process", {
            get: function () {
                return this._process;
            },
            set: function (value) {
                if (typeof value !== 'string') {
                    throw errors_1.illegalArgument('process');
                }
                this._process = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ProcessExecution.prototype, "args", {
            get: function () {
                return this._args;
            },
            set: function (value) {
                if (!Array.isArray(value)) {
                    value = [];
                }
                this._args = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ProcessExecution.prototype, "options", {
            get: function () {
                return this._options;
            },
            set: function (value) {
                this._options = value;
            },
            enumerable: true,
            configurable: true
        });
        ProcessExecution.prototype.computeId = function () {
            var hash = crypto.createHash('md5');
            hash.update('process');
            if (this._process !== void 0) {
                hash.update(this._process);
            }
            if (this._args && this._args.length > 0) {
                for (var _i = 0, _a = this._args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    hash.update(arg);
                }
            }
            return hash.digest('hex');
        };
        return ProcessExecution;
    }());
    exports.ProcessExecution = ProcessExecution;
    var ShellExecution = /** @class */ (function () {
        function ShellExecution(arg0, arg1, arg2) {
            if (Array.isArray(arg1)) {
                if (!arg0) {
                    throw errors_1.illegalArgument('command can\'t be undefined or null');
                }
                if (typeof arg0 !== 'string' && typeof arg0.value !== 'string') {
                    throw errors_1.illegalArgument('command');
                }
                this._command = arg0;
                this._args = arg1;
                this._options = arg2;
            }
            else {
                if (typeof arg0 !== 'string') {
                    throw errors_1.illegalArgument('commandLine');
                }
                this._commandLine = arg0;
                this._options = arg1;
            }
        }
        Object.defineProperty(ShellExecution.prototype, "commandLine", {
            get: function () {
                return this._commandLine;
            },
            set: function (value) {
                if (typeof value !== 'string') {
                    throw errors_1.illegalArgument('commandLine');
                }
                this._commandLine = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShellExecution.prototype, "command", {
            get: function () {
                return this._command;
            },
            set: function (value) {
                if (typeof value !== 'string' && typeof value.value !== 'string') {
                    throw errors_1.illegalArgument('command');
                }
                this._command = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShellExecution.prototype, "args", {
            get: function () {
                return this._args;
            },
            set: function (value) {
                this._args = value || [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShellExecution.prototype, "options", {
            get: function () {
                return this._options;
            },
            set: function (value) {
                this._options = value;
            },
            enumerable: true,
            configurable: true
        });
        ShellExecution.prototype.computeId = function () {
            var hash = crypto.createHash('md5');
            hash.update('shell');
            if (this._commandLine !== void 0) {
                hash.update(this._commandLine);
            }
            if (this._command !== void 0) {
                hash.update(typeof this._command === 'string' ? this._command : this._command.value);
            }
            if (this._args && this._args.length > 0) {
                for (var _i = 0, _a = this._args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    hash.update(typeof arg === 'string' ? arg : arg.value);
                }
            }
            return hash.digest('hex');
        };
        return ShellExecution;
    }());
    exports.ShellExecution = ShellExecution;
    var ShellQuoting;
    (function (ShellQuoting) {
        ShellQuoting[ShellQuoting["Escape"] = 1] = "Escape";
        ShellQuoting[ShellQuoting["Strong"] = 2] = "Strong";
        ShellQuoting[ShellQuoting["Weak"] = 3] = "Weak";
    })(ShellQuoting = exports.ShellQuoting || (exports.ShellQuoting = {}));
    var TaskScope;
    (function (TaskScope) {
        TaskScope[TaskScope["Global"] = 1] = "Global";
        TaskScope[TaskScope["Workspace"] = 2] = "Workspace";
    })(TaskScope = exports.TaskScope || (exports.TaskScope = {}));
    var Task = /** @class */ (function () {
        function Task(definition, arg2, arg3, arg4, arg5, arg6) {
            this.definition = definition;
            var problemMatchers;
            if (typeof arg2 === 'string') {
                this.name = arg2;
                this.source = arg3;
                this.execution = arg4;
                problemMatchers = arg5;
            }
            else if (arg2 === TaskScope.Global || arg2 === TaskScope.Workspace) {
                this.target = arg2;
                this.name = arg3;
                this.source = arg4;
                this.execution = arg5;
                problemMatchers = arg6;
            }
            else {
                this.target = arg2;
                this.name = arg3;
                this.source = arg4;
                this.execution = arg5;
                problemMatchers = arg6;
            }
            if (typeof problemMatchers === 'string') {
                this._problemMatchers = [problemMatchers];
                this._hasDefinedMatchers = true;
            }
            else if (Array.isArray(problemMatchers)) {
                this._problemMatchers = problemMatchers;
                this._hasDefinedMatchers = true;
            }
            else {
                this._problemMatchers = [];
                this._hasDefinedMatchers = false;
            }
            this._isBackground = false;
        }
        Object.defineProperty(Task.prototype, "_id", {
            get: function () {
                return this.__id;
            },
            set: function (value) {
                this.__id = value;
            },
            enumerable: true,
            configurable: true
        });
        Task.prototype.clear = function () {
            if (this.__id === void 0) {
                return;
            }
            this.__id = undefined;
            this._scope = undefined;
            this._definition = undefined;
            if (this._execution instanceof ProcessExecution) {
                this._definition = {
                    type: 'process',
                    id: this._execution.computeId()
                };
            }
            else if (this._execution instanceof ShellExecution) {
                this._definition = {
                    type: 'shell',
                    id: this._execution.computeId()
                };
            }
        };
        Object.defineProperty(Task.prototype, "definition", {
            get: function () {
                return this._definition;
            },
            set: function (value) {
                if (value === void 0 || value === null) {
                    throw errors_1.illegalArgument('Kind can\'t be undefined or null');
                }
                this.clear();
                this._definition = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "scope", {
            get: function () {
                return this._scope;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "target", {
            set: function (value) {
                this.clear();
                this._scope = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "name", {
            get: function () {
                return this._name;
            },
            set: function (value) {
                if (typeof value !== 'string') {
                    throw errors_1.illegalArgument('name');
                }
                this.clear();
                this._name = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "execution", {
            get: function () {
                return this._execution;
            },
            set: function (value) {
                if (value === null) {
                    value = undefined;
                }
                this.clear();
                this._execution = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "problemMatchers", {
            get: function () {
                return this._problemMatchers;
            },
            set: function (value) {
                if (!Array.isArray(value)) {
                    this._problemMatchers = [];
                    this._hasDefinedMatchers = false;
                    return;
                }
                this.clear();
                this._problemMatchers = value;
                this._hasDefinedMatchers = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "hasDefinedMatchers", {
            get: function () {
                return this._hasDefinedMatchers;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "isBackground", {
            get: function () {
                return this._isBackground;
            },
            set: function (value) {
                if (value !== true && value !== false) {
                    value = false;
                }
                this.clear();
                this._isBackground = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "source", {
            get: function () {
                return this._source;
            },
            set: function (value) {
                if (typeof value !== 'string' || value.length === 0) {
                    throw errors_1.illegalArgument('source must be a string of length > 0');
                }
                this.clear();
                this._source = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "group", {
            get: function () {
                return this._group;
            },
            set: function (value) {
                if (value === void 0 || value === null) {
                    this._group = undefined;
                    return;
                }
                this.clear();
                this._group = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "presentationOptions", {
            get: function () {
                return this._presentationOptions;
            },
            set: function (value) {
                if (value === null) {
                    value = undefined;
                }
                this.clear();
                this._presentationOptions = value;
            },
            enumerable: true,
            configurable: true
        });
        return Task;
    }());
    exports.Task = Task;
    var ProgressLocation;
    (function (ProgressLocation) {
        ProgressLocation[ProgressLocation["SourceControl"] = 1] = "SourceControl";
        ProgressLocation[ProgressLocation["Window"] = 10] = "Window";
        ProgressLocation[ProgressLocation["Notification"] = 15] = "Notification";
    })(ProgressLocation = exports.ProgressLocation || (exports.ProgressLocation = {}));
    var TreeItem = /** @class */ (function () {
        function TreeItem(arg1, collapsibleState) {
            if (collapsibleState === void 0) { collapsibleState = TreeItemCollapsibleState.None; }
            this.collapsibleState = collapsibleState;
            if (arg1 instanceof uri_1.default) {
                this.resourceUri = arg1;
            }
            else {
                this.label = arg1;
            }
        }
        return TreeItem;
    }());
    exports.TreeItem = TreeItem;
    var TreeItemCollapsibleState;
    (function (TreeItemCollapsibleState) {
        TreeItemCollapsibleState[TreeItemCollapsibleState["None"] = 0] = "None";
        TreeItemCollapsibleState[TreeItemCollapsibleState["Collapsed"] = 1] = "Collapsed";
        TreeItemCollapsibleState[TreeItemCollapsibleState["Expanded"] = 2] = "Expanded";
    })(TreeItemCollapsibleState = exports.TreeItemCollapsibleState || (exports.TreeItemCollapsibleState = {}));
    var ThemeIcon = /** @class */ (function () {
        function ThemeIcon(id) {
            this.id = id;
        }
        ThemeIcon.File = new ThemeIcon('file');
        ThemeIcon.Folder = new ThemeIcon('folder');
        return ThemeIcon;
    }());
    exports.ThemeIcon = ThemeIcon;
    var ThemeColor = /** @class */ (function () {
        function ThemeColor(id) {
            this.id = id;
        }
        return ThemeColor;
    }());
    exports.ThemeColor = ThemeColor;
    var ConfigurationTarget;
    (function (ConfigurationTarget) {
        ConfigurationTarget[ConfigurationTarget["Global"] = 1] = "Global";
        ConfigurationTarget[ConfigurationTarget["Workspace"] = 2] = "Workspace";
        ConfigurationTarget[ConfigurationTarget["WorkspaceFolder"] = 3] = "WorkspaceFolder";
    })(ConfigurationTarget = exports.ConfigurationTarget || (exports.ConfigurationTarget = {}));
    var RelativePattern = /** @class */ (function () {
        function RelativePattern(base, pattern) {
            if (typeof base !== 'string') {
                if (!base || !uri_1.default.isUri(base.uri)) {
                    throw errors_1.illegalArgument('base');
                }
            }
            if (typeof pattern !== 'string') {
                throw errors_1.illegalArgument('pattern');
            }
            this.base = typeof base === 'string' ? base : base.uri.fsPath;
            this.pattern = pattern;
        }
        RelativePattern.prototype.pathToRelative = function (from, to) {
            return path_1.relative(from, to);
        };
        return RelativePattern;
    }());
    exports.RelativePattern = RelativePattern;
    var Breakpoint = /** @class */ (function () {
        function Breakpoint(enabled, condition, hitCondition, logMessage) {
            this.enabled = typeof enabled === 'boolean' ? enabled : true;
            if (typeof condition === 'string') {
                this.condition = condition;
            }
            if (typeof hitCondition === 'string') {
                this.hitCondition = hitCondition;
            }
            if (typeof logMessage === 'string') {
                this.logMessage = logMessage;
            }
        }
        return Breakpoint;
    }());
    exports.Breakpoint = Breakpoint;
    var SourceBreakpoint = /** @class */ (function (_super) {
        __extends(SourceBreakpoint, _super);
        function SourceBreakpoint(location, enabled, condition, hitCondition, logMessage) {
            var _this = _super.call(this, enabled, condition, hitCondition, logMessage) || this;
            if (location === null) {
                throw errors_1.illegalArgument('location');
            }
            _this.location = location;
            return _this;
        }
        return SourceBreakpoint;
    }(Breakpoint));
    exports.SourceBreakpoint = SourceBreakpoint;
    var FunctionBreakpoint = /** @class */ (function (_super) {
        __extends(FunctionBreakpoint, _super);
        function FunctionBreakpoint(functionName, enabled, condition, hitCondition, logMessage) {
            var _this = _super.call(this, enabled, condition, hitCondition, logMessage) || this;
            if (!functionName) {
                throw errors_1.illegalArgument('functionName');
            }
            _this.functionName = functionName;
            return _this;
        }
        return FunctionBreakpoint;
    }(Breakpoint));
    exports.FunctionBreakpoint = FunctionBreakpoint;
    // {{SQL CARBON EDIT}}
    /*
    export class DebugAdapterExecutable implements vscode.DebugAdapterExecutable {
        readonly command: string;
        readonly args: string[];
    
        constructor(command: string, args?: string[]) {
            this.command = command;
            this.args = args;
        }
    }
    */
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Trace"] = 1] = "Trace";
        LogLevel[LogLevel["Debug"] = 2] = "Debug";
        LogLevel[LogLevel["Info"] = 3] = "Info";
        LogLevel[LogLevel["Warning"] = 4] = "Warning";
        LogLevel[LogLevel["Error"] = 5] = "Error";
        LogLevel[LogLevel["Critical"] = 6] = "Critical";
        LogLevel[LogLevel["Off"] = 7] = "Off";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
    //#region file api
    var FileChangeType;
    (function (FileChangeType) {
        FileChangeType[FileChangeType["Changed"] = 1] = "Changed";
        FileChangeType[FileChangeType["Created"] = 2] = "Created";
        FileChangeType[FileChangeType["Deleted"] = 3] = "Deleted";
    })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
    var FileSystemError = /** @class */ (function (_super) {
        __extends(FileSystemError, _super);
        function FileSystemError(uriOrMessage, code, terminator) {
            var _this = _super.call(this, uri_1.default.isUri(uriOrMessage) ? uriOrMessage.toString(true) : uriOrMessage) || this;
            _this.name = code ? code + " (FileSystemError)" : "FileSystemError";
            // workaround when extending builtin objects and when compiling to ES5, see:
            // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
            if (typeof Object.setPrototypeOf === 'function') {
                Object.setPrototypeOf(_this, FileSystemError.prototype);
            }
            if (typeof Error.captureStackTrace === 'function' && typeof terminator === 'function') {
                // nice stack traces
                Error.captureStackTrace(_this, terminator);
            }
            return _this;
        }
        FileSystemError.FileExists = function (messageOrUri) {
            return new FileSystemError(messageOrUri, 'EntryExists', FileSystemError.FileExists);
        };
        FileSystemError.FileNotFound = function (messageOrUri) {
            return new FileSystemError(messageOrUri, 'EntryNotFound', FileSystemError.FileNotFound);
        };
        FileSystemError.FileNotADirectory = function (messageOrUri) {
            return new FileSystemError(messageOrUri, 'EntryNotADirectory', FileSystemError.FileNotADirectory);
        };
        FileSystemError.FileIsADirectory = function (messageOrUri) {
            return new FileSystemError(messageOrUri, 'EntryIsADirectory', FileSystemError.FileIsADirectory);
        };
        FileSystemError.NoPermissions = function (messageOrUri) {
            return new FileSystemError(messageOrUri, 'NoPermissions', FileSystemError.NoPermissions);
        };
        FileSystemError.Unavailable = function (messageOrUri) {
            return new FileSystemError(messageOrUri, 'Unavailable', FileSystemError.Unavailable);
        };
        return FileSystemError;
    }(Error));
    exports.FileSystemError = FileSystemError;
    //#endregion
    //#region folding api
    var FoldingRange = /** @class */ (function () {
        function FoldingRange(start, end, kind) {
            this.start = start;
            this.end = end;
            this.kind = kind;
        }
        return FoldingRange;
    }());
    exports.FoldingRange = FoldingRange;
    var FoldingRangeKind;
    (function (FoldingRangeKind) {
        FoldingRangeKind[FoldingRangeKind["Comment"] = 1] = "Comment";
        FoldingRangeKind[FoldingRangeKind["Imports"] = 2] = "Imports";
        FoldingRangeKind[FoldingRangeKind["Region"] = 3] = "Region";
    })(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
    //#endregion
    var CommentThreadCollapsibleState;
    (function (CommentThreadCollapsibleState) {
        /**
         * Determines an item is collapsed
         */
        CommentThreadCollapsibleState[CommentThreadCollapsibleState["Collapsed"] = 0] = "Collapsed";
        /**
         * Determines an item is expanded
         */
        CommentThreadCollapsibleState[CommentThreadCollapsibleState["Expanded"] = 1] = "Expanded";
    })(CommentThreadCollapsibleState = exports.CommentThreadCollapsibleState || (exports.CommentThreadCollapsibleState = {}));
    var QuickInputButtons = /** @class */ (function () {
        function QuickInputButtons() {
        }
        QuickInputButtons.Back = { iconPath: 'back.svg' };
        return QuickInputButtons;
    }());
    exports.QuickInputButtons = QuickInputButtons;
});











define(__m[28/*sql/workbench/api/common/sqlExtHostTypes*/], __M([0/*require*/,1/*exports*/,5/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, extHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // SQL added extension host types
    var ServiceOptionType;
    (function (ServiceOptionType) {
        ServiceOptionType["string"] = "string";
        ServiceOptionType["multistring"] = "multistring";
        ServiceOptionType["password"] = "password";
        ServiceOptionType["number"] = "number";
        ServiceOptionType["category"] = "category";
        ServiceOptionType["boolean"] = "boolean";
        ServiceOptionType["object"] = "object";
    })(ServiceOptionType = exports.ServiceOptionType || (exports.ServiceOptionType = {}));
    var ConnectionOptionSpecialType;
    (function (ConnectionOptionSpecialType) {
        ConnectionOptionSpecialType["connectionName"] = "connectionName";
        ConnectionOptionSpecialType["serverName"] = "serverName";
        ConnectionOptionSpecialType["databaseName"] = "databaseName";
        ConnectionOptionSpecialType["authType"] = "authType";
        ConnectionOptionSpecialType["userName"] = "userName";
        ConnectionOptionSpecialType["password"] = "password";
        ConnectionOptionSpecialType["appName"] = "appName";
    })(ConnectionOptionSpecialType = exports.ConnectionOptionSpecialType || (exports.ConnectionOptionSpecialType = {}));
    var MetadataType;
    (function (MetadataType) {
        MetadataType[MetadataType["Table"] = 0] = "Table";
        MetadataType[MetadataType["View"] = 1] = "View";
        MetadataType[MetadataType["SProc"] = 2] = "SProc";
        MetadataType[MetadataType["Function"] = 3] = "Function";
    })(MetadataType = exports.MetadataType || (exports.MetadataType = {}));
    var EditRowState;
    (function (EditRowState) {
        EditRowState[EditRowState["clean"] = 0] = "clean";
        EditRowState[EditRowState["dirtyInsert"] = 1] = "dirtyInsert";
        EditRowState[EditRowState["dirtyDelete"] = 2] = "dirtyDelete";
        EditRowState[EditRowState["dirtyUpdate"] = 3] = "dirtyUpdate";
    })(EditRowState = exports.EditRowState || (exports.EditRowState = {}));
    var TaskStatus;
    (function (TaskStatus) {
        TaskStatus[TaskStatus["NotStarted"] = 0] = "NotStarted";
        TaskStatus[TaskStatus["InProgress"] = 1] = "InProgress";
        TaskStatus[TaskStatus["Succeeded"] = 2] = "Succeeded";
        TaskStatus[TaskStatus["SucceededWithWarning"] = 3] = "SucceededWithWarning";
        TaskStatus[TaskStatus["Failed"] = 4] = "Failed";
        TaskStatus[TaskStatus["Canceled"] = 5] = "Canceled";
        TaskStatus[TaskStatus["Canceling"] = 6] = "Canceling";
    })(TaskStatus = exports.TaskStatus || (exports.TaskStatus = {}));
    var TaskExecutionMode;
    (function (TaskExecutionMode) {
        TaskExecutionMode[TaskExecutionMode["execute"] = 0] = "execute";
        TaskExecutionMode[TaskExecutionMode["script"] = 1] = "script";
        TaskExecutionMode[TaskExecutionMode["executeAndScript"] = 2] = "executeAndScript";
    })(TaskExecutionMode = exports.TaskExecutionMode || (exports.TaskExecutionMode = {}));
    var ScriptOperation;
    (function (ScriptOperation) {
        ScriptOperation[ScriptOperation["Select"] = 0] = "Select";
        ScriptOperation[ScriptOperation["Create"] = 1] = "Create";
        ScriptOperation[ScriptOperation["Insert"] = 2] = "Insert";
        ScriptOperation[ScriptOperation["Update"] = 3] = "Update";
        ScriptOperation[ScriptOperation["Delete"] = 4] = "Delete";
        ScriptOperation[ScriptOperation["Execute"] = 5] = "Execute";
        ScriptOperation[ScriptOperation["Alter"] = 6] = "Alter";
    })(ScriptOperation = exports.ScriptOperation || (exports.ScriptOperation = {}));
    var WeekDays;
    (function (WeekDays) {
        WeekDays[WeekDays["sunday"] = 1] = "sunday";
        WeekDays[WeekDays["monday"] = 2] = "monday";
        WeekDays[WeekDays["tuesday"] = 4] = "tuesday";
        WeekDays[WeekDays["wednesday"] = 8] = "wednesday";
        WeekDays[WeekDays["thursday"] = 16] = "thursday";
        WeekDays[WeekDays["friday"] = 32] = "friday";
        WeekDays[WeekDays["weekDays"] = 62] = "weekDays";
        WeekDays[WeekDays["saturday"] = 64] = "saturday";
        WeekDays[WeekDays["weekEnds"] = 65] = "weekEnds";
        WeekDays[WeekDays["everyDay"] = 127] = "everyDay";
    })(WeekDays = exports.WeekDays || (exports.WeekDays = {}));
    var NotifyMethods;
    (function (NotifyMethods) {
        NotifyMethods[NotifyMethods["none"] = 0] = "none";
        NotifyMethods[NotifyMethods["notifyEmail"] = 1] = "notifyEmail";
        NotifyMethods[NotifyMethods["pager"] = 2] = "pager";
        NotifyMethods[NotifyMethods["netSend"] = 4] = "netSend";
        NotifyMethods[NotifyMethods["notifyAll"] = 7] = "notifyAll";
    })(NotifyMethods = exports.NotifyMethods || (exports.NotifyMethods = {}));
    var JobCompletionActionCondition;
    (function (JobCompletionActionCondition) {
        JobCompletionActionCondition[JobCompletionActionCondition["Never"] = 0] = "Never";
        JobCompletionActionCondition[JobCompletionActionCondition["OnSuccess"] = 1] = "OnSuccess";
        JobCompletionActionCondition[JobCompletionActionCondition["OnFailure"] = 2] = "OnFailure";
        JobCompletionActionCondition[JobCompletionActionCondition["Always"] = 3] = "Always";
    })(JobCompletionActionCondition = exports.JobCompletionActionCondition || (exports.JobCompletionActionCondition = {}));
    var JobExecutionStatus;
    (function (JobExecutionStatus) {
        JobExecutionStatus[JobExecutionStatus["Executing"] = 1] = "Executing";
        JobExecutionStatus[JobExecutionStatus["WaitingForWorkerThread"] = 2] = "WaitingForWorkerThread";
        JobExecutionStatus[JobExecutionStatus["BetweenRetries"] = 3] = "BetweenRetries";
        JobExecutionStatus[JobExecutionStatus["Idle"] = 4] = "Idle";
        JobExecutionStatus[JobExecutionStatus["Suspended"] = 5] = "Suspended";
        JobExecutionStatus[JobExecutionStatus["WaitingForStepToFinish"] = 6] = "WaitingForStepToFinish";
        JobExecutionStatus[JobExecutionStatus["PerformingCompletionAction"] = 7] = "PerformingCompletionAction";
    })(JobExecutionStatus = exports.JobExecutionStatus || (exports.JobExecutionStatus = {}));
    var AlertType;
    (function (AlertType) {
        AlertType[AlertType["sqlServerEvent"] = 1] = "sqlServerEvent";
        AlertType[AlertType["sqlServerPerformanceCondition"] = 2] = "sqlServerPerformanceCondition";
        AlertType[AlertType["nonSqlServerEvent"] = 3] = "nonSqlServerEvent";
        AlertType[AlertType["wmiEvent"] = 4] = "wmiEvent";
    })(AlertType = exports.AlertType || (exports.AlertType = {}));
    var FrequencyTypes;
    (function (FrequencyTypes) {
        FrequencyTypes[FrequencyTypes["Unknown"] = 0] = "Unknown";
        FrequencyTypes[FrequencyTypes["OneTime"] = 2] = "OneTime";
        FrequencyTypes[FrequencyTypes["Daily"] = 4] = "Daily";
        FrequencyTypes[FrequencyTypes["Weekly"] = 8] = "Weekly";
        FrequencyTypes[FrequencyTypes["Monthly"] = 16] = "Monthly";
        FrequencyTypes[FrequencyTypes["MonthlyRelative"] = 32] = "MonthlyRelative";
        FrequencyTypes[FrequencyTypes["AutoStart"] = 64] = "AutoStart";
        FrequencyTypes[FrequencyTypes["OnIdle"] = 128] = "OnIdle";
    })(FrequencyTypes = exports.FrequencyTypes || (exports.FrequencyTypes = {}));
    var FrequencySubDayTypes;
    (function (FrequencySubDayTypes) {
        FrequencySubDayTypes[FrequencySubDayTypes["Unknown"] = 0] = "Unknown";
        FrequencySubDayTypes[FrequencySubDayTypes["Once"] = 1] = "Once";
        FrequencySubDayTypes[FrequencySubDayTypes["Second"] = 2] = "Second";
        FrequencySubDayTypes[FrequencySubDayTypes["Minute"] = 4] = "Minute";
        FrequencySubDayTypes[FrequencySubDayTypes["Hour"] = 8] = "Hour";
    })(FrequencySubDayTypes = exports.FrequencySubDayTypes || (exports.FrequencySubDayTypes = {}));
    var FrequencyRelativeIntervals;
    (function (FrequencyRelativeIntervals) {
        FrequencyRelativeIntervals[FrequencyRelativeIntervals["First"] = 1] = "First";
        FrequencyRelativeIntervals[FrequencyRelativeIntervals["Second"] = 2] = "Second";
        FrequencyRelativeIntervals[FrequencyRelativeIntervals["Third"] = 4] = "Third";
        FrequencyRelativeIntervals[FrequencyRelativeIntervals["Fourth"] = 8] = "Fourth";
        FrequencyRelativeIntervals[FrequencyRelativeIntervals["Last"] = 16] = "Last";
    })(FrequencyRelativeIntervals = exports.FrequencyRelativeIntervals || (exports.FrequencyRelativeIntervals = {}));
    var ModelComponentTypes;
    (function (ModelComponentTypes) {
        ModelComponentTypes[ModelComponentTypes["NavContainer"] = 0] = "NavContainer";
        ModelComponentTypes[ModelComponentTypes["DivContainer"] = 1] = "DivContainer";
        ModelComponentTypes[ModelComponentTypes["FlexContainer"] = 2] = "FlexContainer";
        ModelComponentTypes[ModelComponentTypes["Card"] = 3] = "Card";
        ModelComponentTypes[ModelComponentTypes["InputBox"] = 4] = "InputBox";
        ModelComponentTypes[ModelComponentTypes["DropDown"] = 5] = "DropDown";
        ModelComponentTypes[ModelComponentTypes["DeclarativeTable"] = 6] = "DeclarativeTable";
        ModelComponentTypes[ModelComponentTypes["ListBox"] = 7] = "ListBox";
        ModelComponentTypes[ModelComponentTypes["Button"] = 8] = "Button";
        ModelComponentTypes[ModelComponentTypes["CheckBox"] = 9] = "CheckBox";
        ModelComponentTypes[ModelComponentTypes["RadioButton"] = 10] = "RadioButton";
        ModelComponentTypes[ModelComponentTypes["WebView"] = 11] = "WebView";
        ModelComponentTypes[ModelComponentTypes["Text"] = 12] = "Text";
        ModelComponentTypes[ModelComponentTypes["Table"] = 13] = "Table";
        ModelComponentTypes[ModelComponentTypes["DashboardWidget"] = 14] = "DashboardWidget";
        ModelComponentTypes[ModelComponentTypes["DashboardWebview"] = 15] = "DashboardWebview";
        ModelComponentTypes[ModelComponentTypes["Form"] = 16] = "Form";
        ModelComponentTypes[ModelComponentTypes["Group"] = 17] = "Group";
        ModelComponentTypes[ModelComponentTypes["Toolbar"] = 18] = "Toolbar";
        ModelComponentTypes[ModelComponentTypes["LoadingComponent"] = 19] = "LoadingComponent";
        ModelComponentTypes[ModelComponentTypes["TreeComponent"] = 20] = "TreeComponent";
        ModelComponentTypes[ModelComponentTypes["FileBrowserTree"] = 21] = "FileBrowserTree";
        ModelComponentTypes[ModelComponentTypes["Editor"] = 22] = "Editor";
        ModelComponentTypes[ModelComponentTypes["Dom"] = 23] = "Dom";
    })(ModelComponentTypes = exports.ModelComponentTypes || (exports.ModelComponentTypes = {}));
    var ComponentEventType;
    (function (ComponentEventType) {
        ComponentEventType[ComponentEventType["PropertiesChanged"] = 0] = "PropertiesChanged";
        ComponentEventType[ComponentEventType["onDidChange"] = 1] = "onDidChange";
        ComponentEventType[ComponentEventType["onDidClick"] = 2] = "onDidClick";
        ComponentEventType[ComponentEventType["validityChanged"] = 3] = "validityChanged";
        ComponentEventType[ComponentEventType["onMessage"] = 4] = "onMessage";
        ComponentEventType[ComponentEventType["onSelectedRowChanged"] = 5] = "onSelectedRowChanged";
        ComponentEventType[ComponentEventType["onComponentCreated"] = 6] = "onComponentCreated";
    })(ComponentEventType = exports.ComponentEventType || (exports.ComponentEventType = {}));
    var MessageLevel;
    (function (MessageLevel) {
        MessageLevel[MessageLevel["Error"] = 0] = "Error";
        MessageLevel[MessageLevel["Warning"] = 1] = "Warning";
        MessageLevel[MessageLevel["Information"] = 2] = "Information";
    })(MessageLevel = exports.MessageLevel || (exports.MessageLevel = {}));
    /// Card-related APIs that need to be here to avoid early load issues
    // with enums causing requiring of sqlops API to fail.
    var StatusIndicator;
    (function (StatusIndicator) {
        StatusIndicator[StatusIndicator["None"] = 0] = "None";
        StatusIndicator[StatusIndicator["Ok"] = 1] = "Ok";
        StatusIndicator[StatusIndicator["Warning"] = 2] = "Warning";
        StatusIndicator[StatusIndicator["Error"] = 3] = "Error";
    })(StatusIndicator = exports.StatusIndicator || (exports.StatusIndicator = {}));
    var DataProviderType;
    (function (DataProviderType) {
        DataProviderType["ConnectionProvider"] = "ConnectionProvider";
        DataProviderType["BackupProvider"] = "BackupProvider";
        DataProviderType["RestoreProvider"] = "RestoreProvider";
        DataProviderType["ScriptingProvider"] = "ScriptingProvider";
        DataProviderType["ObjectExplorerProvider"] = "ObjectExplorerProvider";
        DataProviderType["TaskServicesProvider"] = "TaskServicesProvider";
        DataProviderType["FileBrowserProvider"] = "FileBrowserProvider";
        DataProviderType["ProfilerProvider"] = "ProfilerProvider";
        DataProviderType["MetadataProvider"] = "MetadataProvider";
        DataProviderType["QueryProvider"] = "QueryProvider";
        DataProviderType["AdminServicesProvider"] = "AdminServicesProvider";
        DataProviderType["AgentServicesProvider"] = "AgentServicesProvider";
        DataProviderType["CapabilitiesProvider"] = "CapabilitiesProvider";
        DataProviderType["DacFxServicesProvider"] = "DacFxServicesProvider";
        DataProviderType["ObjectExplorerNodeProvider"] = "ObjectExplorerNodeProvider";
    })(DataProviderType = exports.DataProviderType || (exports.DataProviderType = {}));
    var DeclarativeDataType;
    (function (DeclarativeDataType) {
        DeclarativeDataType["string"] = "string";
        DeclarativeDataType["category"] = "category";
        DeclarativeDataType["boolean"] = "boolean";
        DeclarativeDataType["editableCategory"] = "editableCategory";
    })(DeclarativeDataType = exports.DeclarativeDataType || (exports.DeclarativeDataType = {}));
    var CardType;
    (function (CardType) {
        CardType["VerticalButton"] = "VerticalButton";
        CardType["Details"] = "Details";
    })(CardType = exports.CardType || (exports.CardType = {}));
    var Orientation;
    (function (Orientation) {
        Orientation["Horizontal"] = "horizontal";
        Orientation["Vertical"] = "vertial";
    })(Orientation = exports.Orientation || (exports.Orientation = {}));
    var TreeComponentItem = /** @class */ (function (_super) {
        __extends(TreeComponentItem, _super);
        function TreeComponentItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TreeComponentItem;
    }(extHostTypes_1.TreeItem));
    exports.TreeComponentItem = TreeComponentItem;
    var AzureResource;
    (function (AzureResource) {
        AzureResource[AzureResource["ResourceManagement"] = 0] = "ResourceManagement";
        AzureResource[AzureResource["Sql"] = 1] = "Sql";
    })(AzureResource = exports.AzureResource || (exports.AzureResource = {}));
    var SqlThemeIcon = /** @class */ (function () {
        function SqlThemeIcon(id) {
            this.id = id;
        }
        SqlThemeIcon.Folder = new SqlThemeIcon('Folder');
        SqlThemeIcon.Root = new SqlThemeIcon('root');
        SqlThemeIcon.Database = new SqlThemeIcon('Database');
        SqlThemeIcon.Server = new SqlThemeIcon('Server');
        SqlThemeIcon.ScalarValuedFunction = new SqlThemeIcon('ScalarValuedFunction');
        SqlThemeIcon.TableValuedFunction = new SqlThemeIcon('TableValuedFunction');
        SqlThemeIcon.AggregateFunction = new SqlThemeIcon('AggregateFunction');
        SqlThemeIcon.FileGroup = new SqlThemeIcon('FileGroup');
        SqlThemeIcon.StoredProcedure = new SqlThemeIcon('StoredProcedure');
        SqlThemeIcon.UserDefinedTableType = new SqlThemeIcon('UserDefinedTableType');
        SqlThemeIcon.View = new SqlThemeIcon('View');
        SqlThemeIcon.Table = new SqlThemeIcon('Table');
        SqlThemeIcon.HistoryTable = new SqlThemeIcon('HistoryTable');
        SqlThemeIcon.ServerLevelLinkedServerLogin = new SqlThemeIcon('ServerLevelLinkedServerLogin');
        SqlThemeIcon.ServerLevelServerAudit = new SqlThemeIcon('ServerLevelServerAudit');
        SqlThemeIcon.ServerLevelCryptographicProvider = new SqlThemeIcon('ServerLevelCryptographicProvider');
        SqlThemeIcon.ServerLevelCredential = new SqlThemeIcon('ServerLevelCredential');
        SqlThemeIcon.ServerLevelServerRole = new SqlThemeIcon('ServerLevelServerRole');
        SqlThemeIcon.ServerLevelLogin = new SqlThemeIcon('ServerLevelLogin');
        SqlThemeIcon.ServerLevelServerAuditSpecification = new SqlThemeIcon('ServerLevelServerAuditSpecification');
        SqlThemeIcon.ServerLevelServerTrigger = new SqlThemeIcon('ServerLevelServerTrigger');
        SqlThemeIcon.ServerLevelLinkedServer = new SqlThemeIcon('ServerLevelLinkedServer');
        SqlThemeIcon.ServerLevelEndpoint = new SqlThemeIcon('ServerLevelEndpoint');
        SqlThemeIcon.Synonym = new SqlThemeIcon('Synonym');
        SqlThemeIcon.DatabaseTrigger = new SqlThemeIcon('DatabaseTrigger');
        SqlThemeIcon.Assembly = new SqlThemeIcon('Assembly');
        SqlThemeIcon.MessageType = new SqlThemeIcon('MessageType');
        SqlThemeIcon.Contract = new SqlThemeIcon('Contract');
        SqlThemeIcon.Queue = new SqlThemeIcon('Queue');
        SqlThemeIcon.Service = new SqlThemeIcon('Service');
        SqlThemeIcon.Route = new SqlThemeIcon('Route');
        SqlThemeIcon.DatabaseAndQueueEventNotification = new SqlThemeIcon('DatabaseAndQueueEventNotification');
        SqlThemeIcon.RemoteServiceBinding = new SqlThemeIcon('RemoteServiceBinding');
        SqlThemeIcon.BrokerPriority = new SqlThemeIcon('BrokerPriority');
        SqlThemeIcon.FullTextCatalog = new SqlThemeIcon('FullTextCatalog');
        SqlThemeIcon.FullTextStopList = new SqlThemeIcon('FullTextStopList');
        SqlThemeIcon.SqlLogFile = new SqlThemeIcon('SqlLogFile');
        SqlThemeIcon.PartitionFunction = new SqlThemeIcon('PartitionFunction');
        SqlThemeIcon.PartitionScheme = new SqlThemeIcon('PartitionScheme');
        SqlThemeIcon.SearchPropertyList = new SqlThemeIcon('SearchPropertyList');
        SqlThemeIcon.User = new SqlThemeIcon('User');
        SqlThemeIcon.Schema = new SqlThemeIcon('Schema');
        SqlThemeIcon.AsymmetricKey = new SqlThemeIcon('AsymmetricKey');
        SqlThemeIcon.Certificate = new SqlThemeIcon('Certificate');
        SqlThemeIcon.SymmetricKey = new SqlThemeIcon('SymmetricKey');
        SqlThemeIcon.DatabaseEncryptionKey = new SqlThemeIcon('DatabaseEncryptionKey');
        SqlThemeIcon.MasterKey = new SqlThemeIcon('MasterKey');
        SqlThemeIcon.DatabaseAuditSpecification = new SqlThemeIcon('DatabaseAuditSpecification');
        SqlThemeIcon.Column = new SqlThemeIcon('Column');
        SqlThemeIcon.Key = new SqlThemeIcon('Key');
        SqlThemeIcon.Constraint = new SqlThemeIcon('Constraint');
        SqlThemeIcon.Trigger = new SqlThemeIcon('Trigger');
        SqlThemeIcon.Index = new SqlThemeIcon('Index');
        SqlThemeIcon.Statistic = new SqlThemeIcon('Statistic');
        SqlThemeIcon.UserDefinedDataType = new SqlThemeIcon('UserDefinedDataType');
        SqlThemeIcon.UserDefinedType = new SqlThemeIcon('UserDefinedType');
        SqlThemeIcon.XmlSchemaCollection = new SqlThemeIcon('XmlSchemaCollection');
        SqlThemeIcon.SystemExactNumeric = new SqlThemeIcon('SystemExactNumeric');
        SqlThemeIcon.SystemApproximateNumeric = new SqlThemeIcon('SystemApproximateNumeric');
        SqlThemeIcon.SystemDateAndTime = new SqlThemeIcon('SystemDateAndTime');
        SqlThemeIcon.SystemCharacterString = new SqlThemeIcon('SystemCharacterString');
        SqlThemeIcon.SystemUnicodeCharacterString = new SqlThemeIcon('SystemUnicodeCharacterString');
        SqlThemeIcon.SystemBinaryString = new SqlThemeIcon('SystemBinaryString');
        SqlThemeIcon.SystemOtherDataType = new SqlThemeIcon('SystemOtherDataType');
        SqlThemeIcon.SystemClrDataType = new SqlThemeIcon('SystemClrDataType');
        SqlThemeIcon.SystemSpatialDataType = new SqlThemeIcon('SystemSpatialDataType');
        SqlThemeIcon.UserDefinedTableTypeColumn = new SqlThemeIcon('UserDefinedTableTypeColumn');
        SqlThemeIcon.UserDefinedTableTypeKey = new SqlThemeIcon('UserDefinedTableTypeKey');
        SqlThemeIcon.UserDefinedTableTypeConstraint = new SqlThemeIcon('UserDefinedTableTypeConstraint');
        SqlThemeIcon.StoredProcedureParameter = new SqlThemeIcon('StoredProcedureParameter');
        SqlThemeIcon.TableValuedFunctionParameter = new SqlThemeIcon('TableValuedFunctionParameter');
        SqlThemeIcon.ScalarValuedFunctionParameter = new SqlThemeIcon('ScalarValuedFunctionParameter');
        SqlThemeIcon.AggregateFunctionParameter = new SqlThemeIcon('AggregateFunctionParameter');
        SqlThemeIcon.DatabaseRole = new SqlThemeIcon('DatabaseRole');
        SqlThemeIcon.ApplicationRole = new SqlThemeIcon('ApplicationRole');
        SqlThemeIcon.FileGroupFile = new SqlThemeIcon('FileGroupFile');
        SqlThemeIcon.SystemMessageType = new SqlThemeIcon('SystemMessageType');
        SqlThemeIcon.SystemContract = new SqlThemeIcon('SystemContract');
        SqlThemeIcon.SystemService = new SqlThemeIcon('SystemService');
        SqlThemeIcon.SystemQueue = new SqlThemeIcon('SystemQueue');
        SqlThemeIcon.Sequence = new SqlThemeIcon('Sequence');
        SqlThemeIcon.SecurityPolicy = new SqlThemeIcon('SecurityPolicy');
        SqlThemeIcon.DatabaseScopedCredential = new SqlThemeIcon('DatabaseScopedCredential');
        SqlThemeIcon.ExternalResource = new SqlThemeIcon('ExternalResource');
        SqlThemeIcon.ExternalDataSource = new SqlThemeIcon('ExternalDataSource');
        SqlThemeIcon.ExternalFileFormat = new SqlThemeIcon('ExternalFileFormat');
        SqlThemeIcon.ExternalTable = new SqlThemeIcon('ExternalTable');
        SqlThemeIcon.ColumnMasterKey = new SqlThemeIcon('ColumnMasterKey');
        SqlThemeIcon.ColumnEncryptionKey = new SqlThemeIcon('ColumnEncryptionKey');
        return SqlThemeIcon;
    }());
    exports.SqlThemeIcon = SqlThemeIcon;
    var FutureMessageType;
    (function (FutureMessageType) {
        FutureMessageType[FutureMessageType["Reply"] = 0] = "Reply";
        FutureMessageType[FutureMessageType["StdIn"] = 1] = "StdIn";
        FutureMessageType[FutureMessageType["IOPub"] = 2] = "IOPub";
    })(FutureMessageType = exports.FutureMessageType || (exports.FutureMessageType = {}));
    var CellRange = /** @class */ (function () {
        function CellRange(start, end) {
            if (typeof (start) !== 'number' || typeof (start) !== 'number' || start < 0 || end < 0) {
                throw new Error('Invalid arguments');
            }
            // Logic taken from range handling.
            if (start <= end) {
                this._start = start;
                this._end = end;
            }
            else {
                this._start = end;
                this._end = start;
            }
        }
        Object.defineProperty(CellRange.prototype, "start", {
            get: function () {
                return this._start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CellRange.prototype, "end", {
            get: function () {
                return this._end;
            },
            enumerable: true,
            configurable: true
        });
        return CellRange;
    }());
    exports.CellRange = CellRange;
});

define(__m[156/*sql/workbench/api/node/extHostNotebookDocumentData*/], __M([0/*require*/,1/*exports*/,32/*vs/base/common/assert*/,23/*vs/base/common/network*/,2/*vs/base/common/winjs.base*/,28/*sql/workbench/api/common/sqlExtHostTypes*/]), function (require, exports, assert_1, network_1, winjs_base_1, sqlExtHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostNotebookDocumentData = /** @class */ (function () {
        function ExtHostNotebookDocumentData(_proxy, _uri, _providerId, _isDirty, _cells) {
            this._proxy = _proxy;
            this._uri = _uri;
            this._providerId = _providerId;
            this._isDirty = _isDirty;
            this._cells = _cells;
            this._isDisposed = false;
        }
        ExtHostNotebookDocumentData.prototype.dispose = function () {
            // we don't really dispose documents but let
            // extensions still read from them. some
            // operations, live saving, will now error tho
            assert_1.ok(!this._isDisposed);
            this._isDisposed = true;
            this._isDirty = false;
        };
        Object.defineProperty(ExtHostNotebookDocumentData.prototype, "document", {
            get: function () {
                if (!this._document) {
                    var data_1 = this;
                    this._document = {
                        get uri() { return data_1._uri; },
                        get fileName() { return data_1._uri.fsPath; },
                        get isUntitled() { return data_1._uri.scheme === network_1.Schemas.untitled; },
                        get providerId() { return data_1._providerId; },
                        get isClosed() { return data_1._isDisposed; },
                        get isDirty() { return data_1._isDirty; },
                        get cells() { return data_1._cells; },
                        get kernelSpec() { return data_1._kernelSpec; },
                        save: function () { return data_1._save(); },
                        validateCellRange: function (range) { return data_1._validateRange(range); },
                    };
                }
                return Object.freeze(this._document);
            },
            enumerable: true,
            configurable: true
        });
        ExtHostNotebookDocumentData.prototype._save = function () {
            if (this._isDisposed) {
                return winjs_base_1.TPromise.wrapError(new Error('Document has been closed'));
            }
            return this._proxy.$trySaveDocument(this._uri);
        };
        ExtHostNotebookDocumentData.prototype.onModelChanged = function (data) {
            if (data) {
                this._isDirty = data.isDirty;
                this._cells = data.cells;
                this._providerId = data.providerId;
                this._kernelSpec = data.kernelSpec;
            }
        };
        // ---- range math
        ExtHostNotebookDocumentData.prototype._validateRange = function (range) {
            if (!(range instanceof sqlExtHostTypes_1.CellRange)) {
                throw new Error('Invalid argument');
            }
            var start = this._validateIndex(range.start);
            var end = this._validateIndex(range.end);
            if (start === range.start && end === range.end) {
                return range;
            }
            return new sqlExtHostTypes_1.CellRange(start, end);
        };
        ExtHostNotebookDocumentData.prototype._validateIndex = function (index) {
            if (typeof (index) !== 'number') {
                throw new Error('Invalid argument');
            }
            if (index < 0) {
                index = 0;
            }
            else if (this._cells.length > 0 && index > this._cells.length) {
                // We allow off by 1 as end needs to be outside current length in order to
                // handle replace scenario. Long term should consider different start vs end validation instead
                index = this._cells.length;
            }
            return index;
        };
        return ExtHostNotebookDocumentData;
    }());
    exports.ExtHostNotebookDocumentData = ExtHostNotebookDocumentData;
});

define(__m[157/*sql/workbench/api/node/extHostNotebookEditor*/], __M([0/*require*/,1/*exports*/,32/*vs/base/common/assert*/,14/*vs/base/common/errors*/,2/*vs/base/common/winjs.base*/,28/*sql/workbench/api/common/sqlExtHostTypes*/]), function (require, exports, assert_1, errors_1, winjs_base_1, sqlExtHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function toICellRange(range) {
        return {
            start: range.start,
            end: range.end
        };
    }
    var NotebookEditorEdit = /** @class */ (function () {
        function NotebookEditorEdit(document, options) {
            this._document = document;
            // TODO add version handling
            this._documentVersionId = 0;
            // this._documentVersionId = document.version;
            this._collectedEdits = [];
            this._undoStopBefore = options ? options.undoStopBefore : true;
            this._undoStopAfter = options ? options.undoStopAfter : false;
        }
        NotebookEditorEdit.prototype.finalize = function () {
            return {
                documentVersionId: this._documentVersionId,
                edits: this._collectedEdits,
                undoStopBefore: this._undoStopBefore,
                undoStopAfter: this._undoStopAfter
            };
        };
        NotebookEditorEdit.prototype.replace = function (location, value) {
            var range = this.getAsRange(location);
            this._pushEdit(range, value, false);
        };
        NotebookEditorEdit.prototype.getAsRange = function (location) {
            var range = null;
            if (typeof (location) === 'number') {
                range = new sqlExtHostTypes_1.CellRange(location, location + 1);
            }
            else if (location instanceof sqlExtHostTypes_1.CellRange) {
                range = location;
            }
            else {
                throw new Error('Unrecognized location');
            }
            return range;
        };
        NotebookEditorEdit.prototype.insertCell = function (value, location) {
            if (location === null || location === undefined) {
                // If not specified, assume adding to end of list
                location = this._document.cells.length;
            }
            this._pushEdit(new sqlExtHostTypes_1.CellRange(location, location), value, true);
        };
        NotebookEditorEdit.prototype.deleteCell = function (index) {
            var range = null;
            if (typeof (index) === 'number') {
                // Currently only allowing single-cell deletion.
                // Do this by saying the range extends over 1 cell so on the main thread
                // we can delete that cell, then handle insertions
                range = new sqlExtHostTypes_1.CellRange(index, index + 1);
            }
            else {
                throw new Error('Unrecognized index');
            }
            this._pushEdit(range, null, true);
        };
        NotebookEditorEdit.prototype._pushEdit = function (range, cell, forceMoveMarkers) {
            var validRange = this._document.validateCellRange(range);
            this._collectedEdits.push({
                range: validRange,
                cell: cell,
                forceMoveMarkers: forceMoveMarkers
            });
        };
        return NotebookEditorEdit;
    }());
    exports.NotebookEditorEdit = NotebookEditorEdit;
    var ExtHostNotebookEditor = /** @class */ (function () {
        function ExtHostNotebookEditor(_proxy, _id, _documentData, _viewColumn) {
            this._proxy = _proxy;
            this._id = _id;
            this._documentData = _documentData;
            this._viewColumn = _viewColumn;
            this._disposed = false;
        }
        ExtHostNotebookEditor.prototype.dispose = function () {
            assert_1.ok(!this._disposed);
            this._disposed = true;
        };
        Object.defineProperty(ExtHostNotebookEditor.prototype, "document", {
            get: function () {
                return this._documentData.document;
            },
            set: function (value) {
                throw errors_1.readonly('document');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostNotebookEditor.prototype, "viewColumn", {
            get: function () {
                return this._viewColumn;
            },
            set: function (value) {
                throw errors_1.readonly('viewColumn');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostNotebookEditor.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostNotebookEditor.prototype.runCell = function (cell) {
            var uri = cell ? cell.uri : undefined;
            return this._proxy.$runCell(this._id, uri);
        };
        ExtHostNotebookEditor.prototype.edit = function (callback, options) {
            if (this._disposed) {
                return winjs_base_1.TPromise.wrapError(new Error('NotebookEditor#edit not possible on closed editors'));
            }
            var edit = new NotebookEditorEdit(this._documentData.document, options);
            callback(edit);
            return this._applyEdit(edit);
        };
        ExtHostNotebookEditor.prototype._applyEdit = function (editBuilder) {
            var editData = editBuilder.finalize();
            // return when there is nothing to do
            if (editData.edits.length === 0) {
                return winjs_base_1.TPromise.wrap(true);
            }
            // check that the edits are not overlapping (i.e. illegal)
            var editRanges = editData.edits.map(function (edit) { return edit.range; });
            // sort ascending (by end and then by start)
            editRanges.sort(function (a, b) {
                if (a.end === b.end) {
                    return a.start - b.start;
                }
                return a.end - b.end;
            });
            // check that no edits are overlapping
            for (var i = 0, count = editRanges.length - 1; i < count; i++) {
                var rangeEnd = editRanges[i].end;
                var nextRangeStart = editRanges[i + 1].start;
                if (nextRangeStart < rangeEnd) {
                    // overlapping ranges
                    return winjs_base_1.TPromise.wrapError(new Error('Overlapping ranges are not allowed!'));
                }
            }
            // prepare data for serialization
            var edits = editData.edits.map(function (edit) {
                return {
                    range: toICellRange(edit.range),
                    cell: edit.cell,
                    forceMoveMarkers: edit.forceMoveMarkers
                };
            });
            return this._proxy.$tryApplyEdits(this._id, editData.documentVersionId, edits, {
                undoStopBefore: editData.undoStopBefore,
                undoStopAfter: editData.undoStopAfter
            });
        };
        return ExtHostNotebookEditor;
    }());
    exports.ExtHostNotebookEditor = ExtHostNotebookEditor;
});











define(__m[76/*vs/workbench/api/node/extHostDocumentData*/], __M([0/*require*/,1/*exports*/,32/*vs/base/common/assert*/,8/*vs/base/common/strings*/,87/*vs/editor/common/model/mirrorTextModel*/,5/*vs/workbench/api/node/extHostTypes*/,41/*vs/editor/common/model/wordHelper*/,2/*vs/base/common/winjs.base*/,23/*vs/base/common/network*/]), function (require, exports, assert_1, strings_1, mirrorTextModel_1, extHostTypes_1, wordHelper_1, winjs_base_1, network_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var _modeId2WordDefinition = new Map();
    function setWordDefinitionFor(modeId, wordDefinition) {
        _modeId2WordDefinition.set(modeId, wordDefinition);
    }
    exports.setWordDefinitionFor = setWordDefinitionFor;
    function getWordDefinitionFor(modeId) {
        return _modeId2WordDefinition.get(modeId);
    }
    exports.getWordDefinitionFor = getWordDefinitionFor;
    var ExtHostDocumentData = /** @class */ (function (_super) {
        __extends(ExtHostDocumentData, _super);
        function ExtHostDocumentData(proxy, uri, lines, eol, languageId, versionId, isDirty) {
            var _this = _super.call(this, uri, lines, eol, versionId) || this;
            _this._textLines = [];
            _this._isDisposed = false;
            _this._proxy = proxy;
            _this._languageId = languageId;
            _this._isDirty = isDirty;
            return _this;
        }
        ExtHostDocumentData.prototype.dispose = function () {
            // we don't really dispose documents but let
            // extensions still read from them. some
            // operations, live saving, will now error tho
            assert_1.ok(!this._isDisposed);
            this._isDisposed = true;
            this._isDirty = false;
        };
        ExtHostDocumentData.prototype.equalLines = function (lines) {
            var len = lines.length;
            if (len !== this._lines.length) {
                return false;
            }
            for (var i = 0; i < len; i++) {
                if (lines[i] !== this._lines[i]) {
                    return false;
                }
            }
            return true;
        };
        Object.defineProperty(ExtHostDocumentData.prototype, "document", {
            get: function () {
                if (!this._document) {
                    var data_1 = this;
                    this._document = {
                        get uri() { return data_1._uri; },
                        get fileName() { return data_1._uri.fsPath; },
                        get isUntitled() { return data_1._uri.scheme === network_1.Schemas.untitled; },
                        get languageId() { return data_1._languageId; },
                        get version() { return data_1._versionId; },
                        get isClosed() { return data_1._isDisposed; },
                        get isDirty() { return data_1._isDirty; },
                        save: function () { return data_1._save(); },
                        getText: function (range) { return range ? data_1._getTextInRange(range) : data_1.getText(); },
                        get eol() { return data_1._eol === '\n' ? extHostTypes_1.EndOfLine.LF : extHostTypes_1.EndOfLine.CRLF; },
                        get lineCount() { return data_1._lines.length; },
                        lineAt: function (lineOrPos) { return data_1._lineAt(lineOrPos); },
                        offsetAt: function (pos) { return data_1._offsetAt(pos); },
                        positionAt: function (offset) { return data_1._positionAt(offset); },
                        validateRange: function (ran) { return data_1._validateRange(ran); },
                        validatePosition: function (pos) { return data_1._validatePosition(pos); },
                        getWordRangeAtPosition: function (pos, regexp) { return data_1._getWordRangeAtPosition(pos, regexp); }
                    };
                }
                return Object.freeze(this._document);
            },
            enumerable: true,
            configurable: true
        });
        ExtHostDocumentData.prototype._acceptLanguageId = function (newLanguageId) {
            assert_1.ok(!this._isDisposed);
            this._languageId = newLanguageId;
        };
        ExtHostDocumentData.prototype._acceptIsDirty = function (isDirty) {
            assert_1.ok(!this._isDisposed);
            this._isDirty = isDirty;
        };
        ExtHostDocumentData.prototype._save = function () {
            if (this._isDisposed) {
                return winjs_base_1.TPromise.wrapError(new Error('Document has been closed'));
            }
            return this._proxy.$trySaveDocument(this._uri);
        };
        ExtHostDocumentData.prototype._getTextInRange = function (_range) {
            var range = this._validateRange(_range);
            if (range.isEmpty) {
                return '';
            }
            if (range.isSingleLine) {
                return this._lines[range.start.line].substring(range.start.character, range.end.character);
            }
            var lineEnding = this._eol, startLineIndex = range.start.line, endLineIndex = range.end.line, resultLines = [];
            resultLines.push(this._lines[startLineIndex].substring(range.start.character));
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this._lines[i]);
            }
            resultLines.push(this._lines[endLineIndex].substring(0, range.end.character));
            return resultLines.join(lineEnding);
        };
        ExtHostDocumentData.prototype._lineAt = function (lineOrPosition) {
            var line;
            if (lineOrPosition instanceof extHostTypes_1.Position) {
                line = lineOrPosition.line;
            }
            else if (typeof lineOrPosition === 'number') {
                line = lineOrPosition;
            }
            if (line < 0 || line >= this._lines.length) {
                throw new Error('Illegal value for `line`');
            }
            var result = this._textLines[line];
            if (!result || result.lineNumber !== line || result.text !== this._lines[line]) {
                var text = this._lines[line];
                var firstNonWhitespaceCharacterIndex = /^(\s*)/.exec(text)[1].length;
                var range = new extHostTypes_1.Range(line, 0, line, text.length);
                var rangeIncludingLineBreak = line < this._lines.length - 1
                    ? new extHostTypes_1.Range(line, 0, line + 1, 0)
                    : range;
                result = Object.freeze({
                    lineNumber: line,
                    range: range,
                    rangeIncludingLineBreak: rangeIncludingLineBreak,
                    text: text,
                    firstNonWhitespaceCharacterIndex: firstNonWhitespaceCharacterIndex,
                    isEmptyOrWhitespace: firstNonWhitespaceCharacterIndex === text.length
                });
                this._textLines[line] = result;
            }
            return result;
        };
        ExtHostDocumentData.prototype._offsetAt = function (position) {
            position = this._validatePosition(position);
            this._ensureLineStarts();
            return this._lineStarts.getAccumulatedValue(position.line - 1) + position.character;
        };
        ExtHostDocumentData.prototype._positionAt = function (offset) {
            offset = Math.floor(offset);
            offset = Math.max(0, offset);
            this._ensureLineStarts();
            var out = this._lineStarts.getIndexOf(offset);
            var lineLength = this._lines[out.index].length;
            // Ensure we return a valid position
            return new extHostTypes_1.Position(out.index, Math.min(out.remainder, lineLength));
        };
        // ---- range math
        ExtHostDocumentData.prototype._validateRange = function (range) {
            if (!(range instanceof extHostTypes_1.Range)) {
                throw new Error('Invalid argument');
            }
            var start = this._validatePosition(range.start);
            var end = this._validatePosition(range.end);
            if (start === range.start && end === range.end) {
                return range;
            }
            return new extHostTypes_1.Range(start.line, start.character, end.line, end.character);
        };
        ExtHostDocumentData.prototype._validatePosition = function (position) {
            if (!(position instanceof extHostTypes_1.Position)) {
                throw new Error('Invalid argument');
            }
            var line = position.line, character = position.character;
            var hasChanged = false;
            if (line < 0) {
                line = 0;
                character = 0;
                hasChanged = true;
            }
            else if (line >= this._lines.length) {
                line = this._lines.length - 1;
                character = this._lines[line].length;
                hasChanged = true;
            }
            else {
                var maxCharacter = this._lines[line].length;
                if (character < 0) {
                    character = 0;
                    hasChanged = true;
                }
                else if (character > maxCharacter) {
                    character = maxCharacter;
                    hasChanged = true;
                }
            }
            if (!hasChanged) {
                return position;
            }
            return new extHostTypes_1.Position(line, character);
        };
        ExtHostDocumentData.prototype._getWordRangeAtPosition = function (_position, regexp) {
            var position = this._validatePosition(_position);
            if (!regexp) {
                // use default when custom-regexp isn't provided
                regexp = getWordDefinitionFor(this._languageId);
            }
            else if (strings_1.regExpLeadsToEndlessLoop(regexp)) {
                // use default when custom-regexp is bad
                console.warn("[getWordRangeAtPosition]: ignoring custom regexp '" + regexp.source + "' because it matches the empty string.");
                regexp = getWordDefinitionFor(this._languageId);
            }
            var wordAtText = wordHelper_1.getWordAtText(position.character + 1, wordHelper_1.ensureValidWordDefinition(regexp), this._lines[position.line], 0);
            if (wordAtText) {
                return new extHostTypes_1.Range(position.line, wordAtText.startColumn - 1, position.line, wordAtText.endColumn - 1);
            }
            return undefined;
        };
        return ExtHostDocumentData;
    }(mirrorTextModel_1.MirrorTextModel));
    exports.ExtHostDocumentData = ExtHostDocumentData;
});











define(__m[77/*vs/workbench/api/node/extHostTreeViews*/], __M([0/*require*/,1/*exports*/,111/*vs/nls!vs/workbench/api/node/extHostTreeViews*/,16/*vs/base/common/paths*/,4/*vs/base/common/uri*/,3/*vs/base/common/event*/,2/*vs/base/common/winjs.base*/,9/*vs/base/common/lifecycle*/,12/*vs/base/common/async*/,5/*vs/workbench/api/node/extHostTypes*/,18/*vs/base/common/types*/,13/*vs/base/common/arrays*/]), function (require, exports, nls_1, paths_1, uri_1, event_1, winjs_base_1, lifecycle_1, async_1, extHostTypes_1, types_1, arrays_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostTreeViews = /** @class */ (function () {
        function ExtHostTreeViews(_proxy, commands, logService) {
            var _this = this;
            this._proxy = _proxy;
            this.commands = commands;
            this.logService = logService;
            this.treeViews = new Map();
            commands.registerArgumentProcessor({
                processArgument: function (arg) {
                    if (arg && arg.$treeViewId && arg.$treeItemHandle) {
                        return _this.convertArgument(arg);
                    }
                    return arg;
                }
            });
        }
        ExtHostTreeViews.prototype.registerTreeDataProvider = function (id, treeDataProvider) {
            var treeView = this.createTreeView(id, { treeDataProvider: treeDataProvider });
            return { dispose: function () { return treeView.dispose(); } };
        };
        ExtHostTreeViews.prototype.createTreeView = function (viewId, options) {
            var _this = this;
            if (!options || !options.treeDataProvider) {
                throw new Error('Options with treeDataProvider is mandatory');
            }
            var treeView = this.createExtHostTreeViewer(viewId, options.treeDataProvider);
            return {
                get onDidCollapseElement() { return treeView.onDidCollapseElement; },
                get onDidExpandElement() { return treeView.onDidExpandElement; },
                get selection() { return treeView.selectedElements; },
                get onDidChangeSelection() { return treeView.onDidChangeSelection; },
                get visible() { return treeView.visible; },
                get onDidChangeVisibility() { return treeView.onDidChangeVisibility; },
                reveal: function (element, options) {
                    return treeView.reveal(element, options);
                },
                dispose: function () {
                    _this.treeViews.delete(viewId);
                    treeView.dispose();
                }
            };
        };
        ExtHostTreeViews.prototype.$getChildren = function (treeViewId, treeItemHandle) {
            var treeView = this.treeViews.get(treeViewId);
            if (!treeView) {
                return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize(0, null, treeViewId)));
            }
            return treeView.getChildren(treeItemHandle);
        };
        ExtHostTreeViews.prototype.$setExpanded = function (treeViewId, treeItemHandle, expanded) {
            var treeView = this.treeViews.get(treeViewId);
            if (!treeView) {
                throw new Error(nls_1.localize(1, null, treeViewId));
            }
            treeView.setExpanded(treeItemHandle, expanded);
        };
        ExtHostTreeViews.prototype.$setSelection = function (treeViewId, treeItemHandles) {
            var treeView = this.treeViews.get(treeViewId);
            if (!treeView) {
                throw new Error(nls_1.localize(2, null, treeViewId));
            }
            treeView.setSelection(treeItemHandles);
        };
        ExtHostTreeViews.prototype.$setVisible = function (treeViewId, isVisible) {
            var treeView = this.treeViews.get(treeViewId);
            if (!treeView) {
                throw new Error(nls_1.localize(3, null, treeViewId));
            }
            treeView.setVisible(isVisible);
        };
        ExtHostTreeViews.prototype.createExtHostTreeViewer = function (id, dataProvider) {
            var treeView = new ExtHostTreeView(id, dataProvider, this._proxy, this.commands.converter, this.logService);
            this.treeViews.set(id, treeView);
            return treeView;
        };
        ExtHostTreeViews.prototype.convertArgument = function (arg) {
            var treeView = this.treeViews.get(arg.$treeViewId);
            return treeView ? treeView.getExtensionElement(arg.$treeItemHandle) : null;
        };
        return ExtHostTreeViews;
    }());
    exports.ExtHostTreeViews = ExtHostTreeViews;
    // {{SQL CARBON EDIT}}
    var ExtHostTreeView = /** @class */ (function (_super) {
        __extends(ExtHostTreeView, _super);
        function ExtHostTreeView(viewId, dataProvider, proxy, commands, logService) {
            var _this = _super.call(this) || this;
            _this.viewId = viewId;
            _this.dataProvider = dataProvider;
            _this.proxy = proxy;
            _this.commands = commands;
            _this.logService = logService;
            _this.roots = null;
            _this.elements = new Map();
            // {{SQL CARBON EDIT}}
            _this.nodes = new Map();
            _this._visible = false;
            _this._selectedHandles = [];
            _this._onDidExpandElement = _this._register(new event_1.Emitter());
            _this.onDidExpandElement = _this._onDidExpandElement.event;
            _this._onDidCollapseElement = _this._register(new event_1.Emitter());
            _this.onDidCollapseElement = _this._onDidCollapseElement.event;
            _this._onDidChangeSelection = _this._register(new event_1.Emitter());
            _this.onDidChangeSelection = _this._onDidChangeSelection.event;
            _this._onDidChangeVisibility = _this._register(new event_1.Emitter());
            _this.onDidChangeVisibility = _this._onDidChangeVisibility.event;
            _this.refreshPromise = winjs_base_1.TPromise.as(null);
            // {{SQL CARBON EDIT}}
            if (_this.proxy) {
                _this.proxy.$registerTreeViewDataProvider(viewId);
            }
            if (_this.dataProvider.onDidChangeTreeData) {
                var refreshingPromise_1, promiseCallback_1;
                _this._register(event_1.debounceEvent(_this.dataProvider.onDidChangeTreeData, function (last, current) {
                    if (!refreshingPromise_1) {
                        // New refresh has started
                        refreshingPromise_1 = new winjs_base_1.TPromise(function (c, e) { return promiseCallback_1 = c; });
                        _this.refreshPromise = _this.refreshPromise.then(function () { return refreshingPromise_1; });
                    }
                    return last ? last.concat([current]) : [current];
                }, 200)(function (elements) {
                    var _promiseCallback = promiseCallback_1;
                    refreshingPromise_1 = null;
                    _this.refresh(elements);
                }));
            }
            return _this;
        }
        Object.defineProperty(ExtHostTreeView.prototype, "visible", {
            get: function () { return this._visible; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTreeView.prototype, "selectedElements", {
            get: function () {
                var _this = this;
                return this._selectedHandles.map(function (handle) { return _this.getExtensionElement(handle); }).filter(function (element) { return !types_1.isUndefinedOrNull(element); });
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTreeView.prototype.getChildren = function (parentHandle) {
            var parentElement = parentHandle ? this.getExtensionElement(parentHandle) : void 0;
            if (parentHandle && !parentElement) {
                console.error("No tree item with id '" + parentHandle + "' found.");
                return winjs_base_1.TPromise.as([]);
            }
            var childrenNodes = this.getChildrenNodes(parentHandle); // Get it from cache
            return (childrenNodes ? winjs_base_1.TPromise.as(childrenNodes) : this.fetchChildrenNodes(parentElement))
                .then(function (nodes) { return nodes.map(function (n) { return n.item; }); });
        };
        ExtHostTreeView.prototype.getExtensionElement = function (treeItemHandle) {
            return this.elements.get(treeItemHandle);
        };
        ExtHostTreeView.prototype.reveal = function (element, options) {
            var _this = this;
            options = options ? options : { select: true, focus: false };
            var select = types_1.isUndefinedOrNull(options.select) ? true : options.select;
            var focus = types_1.isUndefinedOrNull(options.focus) ? false : options.focus;
            if (typeof this.dataProvider.getParent !== 'function') {
                return winjs_base_1.TPromise.wrapError(new Error("Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method"));
            }
            return this.refreshPromise
                .then(function () { return _this.resolveUnknownParentChain(element); })
                .then(function (parentChain) { return _this.resolveTreeNode(element, parentChain[parentChain.length - 1])
                .then(function (treeNode) { return _this.proxy.$reveal(_this.viewId, treeNode.item, parentChain.map(function (p) { return p.item; }), { select: select, focus: focus }); }); }, function (error) { return _this.logService.error(error); });
        };
        ExtHostTreeView.prototype.setExpanded = function (treeItemHandle, expanded) {
            var element = this.getExtensionElement(treeItemHandle);
            if (element) {
                if (expanded) {
                    this._onDidExpandElement.fire(Object.freeze({ element: element }));
                }
                else {
                    this._onDidCollapseElement.fire(Object.freeze({ element: element }));
                }
            }
        };
        ExtHostTreeView.prototype.setSelection = function (treeItemHandles) {
            if (!arrays_1.equals(this._selectedHandles, treeItemHandles)) {
                this._selectedHandles = treeItemHandles;
                this._onDidChangeSelection.fire(Object.freeze({ selection: this.selectedElements }));
            }
        };
        ExtHostTreeView.prototype.setVisible = function (visible) {
            if (visible !== this._visible) {
                this._visible = visible;
                this._onDidChangeVisibility.fire(Object.freeze({ visible: this._visible }));
            }
        };
        // {{SQL CARBON EDIT}}
        ExtHostTreeView.prototype.resolveUnknownParentChain = function (element) {
            var _this = this;
            return this.resolveParent(element)
                .then(function (parent) {
                if (!parent) {
                    return winjs_base_1.TPromise.as([]);
                }
                return _this.resolveUnknownParentChain(parent)
                    .then(function (result) { return _this.resolveTreeNode(parent, result[result.length - 1])
                    .then(function (parentNode) {
                    result.push(parentNode);
                    return result;
                }); });
            });
        };
        ExtHostTreeView.prototype.resolveParent = function (element) {
            var _this = this;
            var node = this.nodes.get(element);
            if (node) {
                return winjs_base_1.TPromise.as(node.parent ? this.elements.get(node.parent.item.handle) : null);
            }
            return async_1.asWinJsPromise(function () { return _this.dataProvider.getParent(element); });
        };
        // {{SQL CARBON EDIT}}
        ExtHostTreeView.prototype.resolveTreeNode = function (element, parent) {
            var _this = this;
            return async_1.asWinJsPromise(function () { return _this.dataProvider.getTreeItem(element); })
                .then(function (extTreeItem) { return _this.createHandle(element, extTreeItem, parent, true); })
                .then(function (handle) { return _this.getChildren(parent ? parent.item.handle : null)
                .then(function () {
                var cachedElement = _this.getExtensionElement(handle);
                if (cachedElement) {
                    var node = _this.nodes.get(cachedElement);
                    if (node) {
                        return winjs_base_1.TPromise.as(node);
                    }
                }
                throw new Error("Cannot resolve tree item for element " + handle);
            }); });
        };
        ExtHostTreeView.prototype.getChildrenNodes = function (parentNodeOrHandle) {
            if (parentNodeOrHandle) {
                var parentNode = void 0;
                if (typeof parentNodeOrHandle === 'string') {
                    var parentElement = this.getExtensionElement(parentNodeOrHandle);
                    parentNode = parentElement ? this.nodes.get(parentElement) : null;
                }
                else {
                    parentNode = parentNodeOrHandle;
                }
                return parentNode ? parentNode.children : null;
            }
            return this.roots;
        };
        ExtHostTreeView.prototype.fetchChildrenNodes = function (parentElement) {
            var _this = this;
            // clear children cache
            this.clearChildren(parentElement);
            var parentNode = parentElement ? this.nodes.get(parentElement) : void 0;
            return async_1.asWinJsPromise(function () { return _this.dataProvider.getChildren(parentElement); })
                .then(function (elements) { return winjs_base_1.TPromise.join((elements || [])
                .filter(function (element) { return !!element; })
                .map(function (element) { return async_1.asWinJsPromise(function () { return _this.dataProvider.getTreeItem(element); })
                .then(function (extTreeItem) { return extTreeItem ? _this.createAndRegisterTreeNode(element, extTreeItem, parentNode) : null; }); })); })
                .then(function (nodes) { return nodes.filter(function (n) { return !!n; }); });
        };
        // {{SQL CARBON EDIT}}
        ExtHostTreeView.prototype.refresh = function (elements) {
            var hasRoot = elements.some(function (element) { return !element; });
            if (hasRoot) {
                this.clearAll(); // clear cache
                this.proxy.$refresh(this.viewId);
            }
            else {
                var handlesToRefresh = this.getHandlesToRefresh(elements);
                if (handlesToRefresh.length) {
                    this.refreshHandles(handlesToRefresh);
                }
            }
        };
        // {{SQL CARBON EDIT}}
        ExtHostTreeView.prototype.getHandlesToRefresh = function (elements) {
            var _this = this;
            var elementsToUpdate = new Set();
            for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
                var element = elements_1[_i];
                var elementNode = this.nodes.get(element);
                if (elementNode && !elementsToUpdate.has(elementNode.item.handle)) {
                    // check if an ancestor of extElement is already in the elements to update list
                    var currentNode = elementNode;
                    while (currentNode && currentNode.parent && !elementsToUpdate.has(currentNode.parent.item.handle)) {
                        var parentElement = this.elements.get(currentNode.parent.item.handle);
                        currentNode = this.nodes.get(parentElement);
                    }
                    if (!currentNode.parent) {
                        elementsToUpdate.add(elementNode.item.handle);
                    }
                }
            }
            var handlesToUpdate = [];
            // Take only top level elements
            elementsToUpdate.forEach(function (handle) {
                var element = _this.elements.get(handle);
                var node = _this.nodes.get(element);
                if (node && (!node.parent || !elementsToUpdate.has(node.parent.item.handle))) {
                    handlesToUpdate.push(handle);
                }
            });
            return handlesToUpdate;
        };
        // {{SQL CARBON EDIT}}
        ExtHostTreeView.prototype.refreshHandles = function (itemHandles) {
            var _this = this;
            var itemsToRefresh = {};
            return winjs_base_1.TPromise.join(itemHandles.map(function (treeItemHandle) {
                return _this.refreshNode(treeItemHandle)
                    .then(function (node) {
                    if (node) {
                        itemsToRefresh[treeItemHandle] = node.item;
                    }
                });
            }))
                .then(function () { return Object.keys(itemsToRefresh).length ? _this.proxy.$refresh(_this.viewId, itemsToRefresh) : null; });
        };
        // {{SQL CARBON EDIT}}
        ExtHostTreeView.prototype.refreshNode = function (treeItemHandle) {
            var _this = this;
            var extElement = this.getExtensionElement(treeItemHandle);
            var existing = this.nodes.get(extElement);
            this.clearChildren(extElement); // clear children cache
            return async_1.asWinJsPromise(function () { return _this.dataProvider.getTreeItem(extElement); })
                .then(function (extTreeItem) {
                if (extTreeItem) {
                    var newNode = _this.createTreeNode(extElement, extTreeItem, existing.parent);
                    _this.updateNodeCache(extElement, newNode, existing, existing.parent);
                    return newNode;
                }
                return null;
            });
        };
        ExtHostTreeView.prototype.createAndRegisterTreeNode = function (element, extTreeItem, parentNode) {
            var node = this.createTreeNode(element, extTreeItem, parentNode);
            if (extTreeItem.id && this.elements.has(node.item.handle)) {
                throw new Error(nls_1.localize(4, null, extTreeItem.id));
            }
            this.addNodeToCache(element, node);
            this.addNodeToParentCache(node, parentNode);
            return node;
        };
        // {{SQL CARBON EDIT}}
        ExtHostTreeView.prototype.createTreeNode = function (element, extensionTreeItem, parent) {
            return {
                item: this.createTreeItem(element, extensionTreeItem, parent),
                parent: parent,
                children: void 0
            };
        };
        // {{SQL CARBON EDIT}}
        ExtHostTreeView.prototype.createTreeItem = function (element, extensionTreeItem, parent) {
            var handle = this.createHandle(element, extensionTreeItem, parent);
            var icon = this.getLightIconPath(extensionTreeItem);
            var item = {
                handle: handle,
                parentHandle: parent ? parent.item.handle : void 0,
                label: extensionTreeItem.label,
                resourceUri: extensionTreeItem.resourceUri,
                tooltip: typeof extensionTreeItem.tooltip === 'string' ? extensionTreeItem.tooltip : void 0,
                command: extensionTreeItem.command ? this.commands.toInternal(extensionTreeItem.command) : void 0,
                contextValue: extensionTreeItem.contextValue,
                icon: icon,
                iconDark: this.getDarkIconPath(extensionTreeItem) || icon,
                themeIcon: extensionTreeItem.iconPath instanceof extHostTypes_1.ThemeIcon ? { id: extensionTreeItem.iconPath.id } : void 0,
                collapsibleState: types_1.isUndefinedOrNull(extensionTreeItem.collapsibleState) ? extHostTypes_1.TreeItemCollapsibleState.None : extensionTreeItem.collapsibleState
            };
            return item;
        };
        ExtHostTreeView.prototype.createHandle = function (element, _a, parent, returnFirst) {
            var id = _a.id, label = _a.label, resourceUri = _a.resourceUri;
            if (id) {
                return ExtHostTreeView.ID_HANDLE_PREFIX + "/" + id;
            }
            var prefix = parent ? parent.item.handle : ExtHostTreeView.LABEL_HANDLE_PREFIX;
            var elementId = label ? label : resourceUri ? paths_1.basename(resourceUri.path) : '';
            elementId = elementId.indexOf('/') !== -1 ? elementId.replace('/', '//') : elementId;
            var existingHandle = this.nodes.has(element) ? this.nodes.get(element).item.handle : void 0;
            var childrenNodes = (this.getChildrenNodes(parent) || []);
            var handle;
            var counter = 0;
            do {
                handle = prefix + "/" + counter + ":" + elementId;
                if (returnFirst || !this.elements.has(handle) || existingHandle === handle) {
                    // Return first if asked for or
                    // Return if handle does not exist or
                    // Return if handle is being reused
                    break;
                }
                counter++;
            } while (counter <= childrenNodes.length);
            return handle;
        };
        ExtHostTreeView.prototype.getLightIconPath = function (extensionTreeItem) {
            if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof extHostTypes_1.ThemeIcon)) {
                if (typeof extensionTreeItem.iconPath === 'string'
                    || extensionTreeItem.iconPath instanceof uri_1.default) {
                    return this.getIconPath(extensionTreeItem.iconPath);
                }
                return this.getIconPath(extensionTreeItem.iconPath['light']);
            }
            return void 0;
        };
        ExtHostTreeView.prototype.getDarkIconPath = function (extensionTreeItem) {
            if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof extHostTypes_1.ThemeIcon) && extensionTreeItem.iconPath['dark']) {
                return this.getIconPath(extensionTreeItem.iconPath['dark']);
            }
            return void 0;
        };
        ExtHostTreeView.prototype.getIconPath = function (iconPath) {
            if (iconPath instanceof uri_1.default) {
                return iconPath.toString();
            }
            return uri_1.default.file(iconPath).toString();
        };
        ExtHostTreeView.prototype.addNodeToCache = function (element, node) {
            this.elements.set(node.item.handle, element);
            this.nodes.set(element, node);
        };
        // {{SQL CARBON EDIT}}
        ExtHostTreeView.prototype.updateNodeCache = function (element, newNode, existing, parentNode) {
            // Remove from the cache
            this.elements.delete(newNode.item.handle);
            this.nodes.delete(element);
            if (newNode.item.handle !== existing.item.handle) {
                this.elements.delete(existing.item.handle);
            }
            // Add the new node to the cache
            this.addNodeToCache(element, newNode);
            // Replace the node in parent's children nodes
            var childrenNodes = (this.getChildrenNodes(parentNode) || []);
            var childNode = childrenNodes.filter(function (c) { return c.item.handle === existing.item.handle; })[0];
            if (childNode) {
                childrenNodes.splice(childrenNodes.indexOf(childNode), 1, newNode);
            }
        };
        ExtHostTreeView.prototype.addNodeToParentCache = function (node, parentNode) {
            if (parentNode) {
                if (!parentNode.children) {
                    parentNode.children = [];
                }
                parentNode.children.push(node);
            }
            else {
                if (!this.roots) {
                    this.roots = [];
                }
                this.roots.push(node);
            }
        };
        ExtHostTreeView.prototype.clearChildren = function (parentElement) {
            if (parentElement) {
                var node = this.nodes.get(parentElement);
                if (node.children) {
                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                        var child = _a[_i];
                        var childEleement = this.elements.get(child.item.handle);
                        if (childEleement) {
                            this.clear(childEleement);
                        }
                    }
                }
                node.children = void 0;
            }
            else {
                this.clearAll();
            }
        };
        ExtHostTreeView.prototype.clear = function (element) {
            var node = this.nodes.get(element);
            if (node.children) {
                for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    var childEleement = this.elements.get(child.item.handle);
                    if (childEleement) {
                        this.clear(childEleement);
                    }
                }
            }
            this.nodes.delete(element);
            this.elements.delete(node.item.handle);
        };
        // {{SQL CARBON EDIT}}
        ExtHostTreeView.prototype.clearAll = function () {
            this.roots = null;
            this.elements.clear();
            this.nodes.clear();
        };
        ExtHostTreeView.prototype.dispose = function () {
            this.clearAll();
        };
        ExtHostTreeView.LABEL_HANDLE_PREFIX = '0';
        ExtHostTreeView.ID_HANDLE_PREFIX = '1';
        return ExtHostTreeView;
    }(lifecycle_1.Disposable));
    exports.ExtHostTreeView = ExtHostTreeView;
});











define(__m[78/*vs/workbench/common/editor*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,3/*vs/base/common/event*/,20/*vs/base/common/objects*/,18/*vs/base/common/types*/,9/*vs/base/common/lifecycle*/,42/*vs/platform/contextkey/common/contextkey*/,31/*vs/platform/registry/common/platform*/,23/*vs/base/common/network*/,218/*vs/base/common/actions*/]), function (require, exports, winjs_base_1, event_1, objects, types, lifecycle_1, contextkey_1, platform_1, network_1, actions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EditorsVisibleContext = new contextkey_1.RawContextKey('editorIsOpen', false);
    exports.EditorGroupActiveEditorDirtyContext = new contextkey_1.RawContextKey('groupActiveEditorDirty', false);
    exports.NoEditorsVisibleContext = exports.EditorsVisibleContext.toNegated();
    exports.TextCompareEditorVisibleContext = new contextkey_1.RawContextKey('textCompareEditorVisible', false);
    exports.ActiveEditorGroupEmptyContext = new contextkey_1.RawContextKey('activeEditorGroupEmpty', false);
    exports.MultipleEditorGroupsContext = new contextkey_1.RawContextKey('multipleEditorGroups', false);
    exports.SingleEditorGroupsContext = exports.MultipleEditorGroupsContext.toNegated();
    exports.InEditorZenModeContext = new contextkey_1.RawContextKey('inZenMode', false);
    exports.SplitEditorsVertically = new contextkey_1.RawContextKey('splitEditorsVertically', false);
    /**
     * Text diff editor id.
     */
    exports.TEXT_DIFF_EDITOR_ID = 'workbench.editors.textDiffEditor';
    /**
     * Binary diff editor id.
     */
    exports.BINARY_DIFF_EDITOR_ID = 'workbench.editors.binaryResourceDiffEditor';
    var Verbosity;
    (function (Verbosity) {
        Verbosity[Verbosity["SHORT"] = 0] = "SHORT";
        Verbosity[Verbosity["MEDIUM"] = 1] = "MEDIUM";
        Verbosity[Verbosity["LONG"] = 2] = "LONG";
    })(Verbosity = exports.Verbosity || (exports.Verbosity = {}));
    /**
     * Editor inputs are lightweight objects that can be passed to the workbench API to open inside the editor part.
     * Each editor input is mapped to an editor that is capable of opening it through the Platform facade.
     */
    var EditorInput = /** @class */ (function (_super) {
        __extends(EditorInput, _super);
        function EditorInput() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._onDidChangeDirty = _this._register(new event_1.Emitter());
            _this._onDidChangeLabel = _this._register(new event_1.Emitter());
            _this._onDispose = _this._register(new event_1.Emitter());
            _this.disposed = false;
            // {{SQL CARBON EDIT}}
            // Saving is not supported in the EditData query editor, so this can be overriden in its Input.
            _this._savingSupported = true;
            return _this;
        }
        Object.defineProperty(EditorInput.prototype, "onDidChangeDirty", {
            get: function () { return this._onDidChangeDirty.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorInput.prototype, "onDidChangeLabel", {
            get: function () { return this._onDidChangeLabel.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorInput.prototype, "onDispose", {
            get: function () { return this._onDispose.event; },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the associated resource of this input if any.
         */
        EditorInput.prototype.getResource = function () {
            return null;
        };
        /**
         * Returns the name of this input that can be shown to the user. Examples include showing the name of the input
         * above the editor area when the input is shown.
         */
        EditorInput.prototype.getName = function () {
            return null;
        };
        /**
         * Returns the description of this input that can be shown to the user. Examples include showing the description of
         * the input above the editor area to the side of the name of the input.
         */
        EditorInput.prototype.getDescription = function (verbosity) {
            return null;
        };
        /**
         * Returns the title of this input that can be shown to the user. Examples include showing the title of
         * the input above the editor area as hover over the input label.
         */
        EditorInput.prototype.getTitle = function (verbosity) {
            return this.getName();
        };
        /**
         * Returns the preferred editor for this input. A list of candidate editors is passed in that whee registered
         * for the input. This allows subclasses to decide late which editor to use for the input on a case by case basis.
         */
        EditorInput.prototype.getPreferredEditorId = function (candidates) {
            if (candidates && candidates.length > 0) {
                return candidates[0];
            }
            return null;
        };
        /**
         * Returns a descriptor suitable for telemetry events or null if none is available.
         *
         * Subclasses should extend if they can contribute.
         */
        EditorInput.prototype.getTelemetryDescriptor = function () {
            /* __GDPR__FRAGMENT__
                "EditorTelemetryDescriptor" : {
                    "typeId" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                }
            */
            return { typeId: this.getTypeId() };
        };
        /**
         * An editor that is dirty will be asked to be saved once it closes.
         */
        EditorInput.prototype.isDirty = function () {
            return false;
        };
        /**
         * Subclasses should bring up a proper dialog for the user if the editor is dirty and return the result.
         */
        EditorInput.prototype.confirmSave = function () {
            return winjs_base_1.TPromise.wrap(ConfirmResult.DONT_SAVE);
        };
        /**
         * Saves the editor if it is dirty. Subclasses return a promise with a boolean indicating the success of the operation.
         */
        EditorInput.prototype.save = function () {
            return winjs_base_1.TPromise.as(true);
        };
        /**
         * Reverts the editor if it is dirty. Subclasses return a promise with a boolean indicating the success of the operation.
         */
        EditorInput.prototype.revert = function (options) {
            return winjs_base_1.TPromise.as(true);
        };
        /**
         * Called when this input is no longer opened in any editor. Subclasses can free resources as needed.
         */
        EditorInput.prototype.close = function () {
            this.dispose();
        };
        /**
         * Subclasses can set this to false if it does not make sense to split the editor input.
         */
        EditorInput.prototype.supportsSplitEditor = function () {
            // {{SQL CARBON EDIT}}
            return false; // TODO reenable when multiple Angular components of the same type can be open simultaneously
        };
        /**
         * Returns true if this input is identical to the otherInput.
         */
        EditorInput.prototype.matches = function (otherInput) {
            return this === otherInput;
        };
        /**
         * Returns whether this input was disposed or not.
         */
        EditorInput.prototype.isDisposed = function () {
            return this.disposed;
        };
        /**
         * Called when an editor input is no longer needed. Allows to free up any resources taken by
         * resolving the editor input.
         */
        EditorInput.prototype.dispose = function () {
            this.disposed = true;
            this._onDispose.fire();
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(EditorInput.prototype, "savingSupported", {
            get: function () {
                return this._savingSupported;
            },
            enumerable: true,
            configurable: true
        });
        EditorInput.prototype.disableSaving = function () {
            this._savingSupported = false;
        };
        return EditorInput;
    }(lifecycle_1.Disposable));
    exports.EditorInput = EditorInput;
    var ConfirmResult;
    (function (ConfirmResult) {
        ConfirmResult[ConfirmResult["SAVE"] = 0] = "SAVE";
        ConfirmResult[ConfirmResult["DONT_SAVE"] = 1] = "DONT_SAVE";
        ConfirmResult[ConfirmResult["CANCEL"] = 2] = "CANCEL";
    })(ConfirmResult = exports.ConfirmResult || (exports.ConfirmResult = {}));
    var EncodingMode;
    (function (EncodingMode) {
        /**
         * Instructs the encoding support to encode the current input with the provided encoding
         */
        EncodingMode[EncodingMode["Encode"] = 0] = "Encode";
        /**
         * Instructs the encoding support to decode the current input with the provided encoding
         */
        EncodingMode[EncodingMode["Decode"] = 1] = "Decode";
    })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
    /**
     * Side by side editor inputs that have a master and details side.
     */
    var SideBySideEditorInput = /** @class */ (function (_super) {
        __extends(SideBySideEditorInput, _super);
        function SideBySideEditorInput(name, description, _details, _master) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.description = description;
            _this._details = _details;
            _this._master = _master;
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(SideBySideEditorInput.prototype, "master", {
            get: function () {
                return this._master;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditorInput.prototype, "details", {
            get: function () {
                return this._details;
            },
            enumerable: true,
            configurable: true
        });
        SideBySideEditorInput.prototype.isDirty = function () {
            return this.master.isDirty();
        };
        SideBySideEditorInput.prototype.confirmSave = function () {
            return this.master.confirmSave();
        };
        SideBySideEditorInput.prototype.save = function () {
            return this.master.save();
        };
        SideBySideEditorInput.prototype.revert = function () {
            return this.master.revert();
        };
        SideBySideEditorInput.prototype.getTelemetryDescriptor = function () {
            var descriptor = this.master.getTelemetryDescriptor();
            return objects.assign(descriptor, _super.prototype.getTelemetryDescriptor.call(this));
        };
        SideBySideEditorInput.prototype.registerListeners = function () {
            var _this = this;
            // When the details or master input gets disposed, dispose this diff editor input
            var onceDetailsDisposed = event_1.once(this.details.onDispose);
            this._register(onceDetailsDisposed(function () {
                if (!_this.isDisposed()) {
                    _this.dispose();
                }
            }));
            var onceMasterDisposed = event_1.once(this.master.onDispose);
            this._register(onceMasterDisposed(function () {
                if (!_this.isDisposed()) {
                    _this.dispose();
                }
            }));
            // Reemit some events from the master side to the outside
            this._register(this.master.onDidChangeDirty(function () { return _this._onDidChangeDirty.fire(); }));
            this._register(this.master.onDidChangeLabel(function () { return _this._onDidChangeLabel.fire(); }));
        };
        SideBySideEditorInput.prototype.resolve = function () {
            return winjs_base_1.TPromise.as(null);
        };
        SideBySideEditorInput.prototype.getTypeId = function () {
            return SideBySideEditorInput.ID;
        };
        SideBySideEditorInput.prototype.getName = function () {
            return this.name;
        };
        SideBySideEditorInput.prototype.getDescription = function () {
            return this.description;
        };
        SideBySideEditorInput.prototype.matches = function (otherInput) {
            if (_super.prototype.matches.call(this, otherInput) === true) {
                return true;
            }
            if (otherInput) {
                if (!(otherInput instanceof SideBySideEditorInput)) {
                    return false;
                }
                var otherDiffInput = otherInput;
                return this.details.matches(otherDiffInput.details) && this.master.matches(otherDiffInput.master);
            }
            return false;
        };
        SideBySideEditorInput.ID = 'workbench.editorinputs.sidebysideEditorInput';
        return SideBySideEditorInput;
    }(EditorInput));
    exports.SideBySideEditorInput = SideBySideEditorInput;
    /**
     * The editor model is the heavyweight counterpart of editor input. Depending on the editor input, it
     * connects to the disk to retrieve content and may allow for saving it back or reverting it. Editor models
     * are typically cached for some while because they are expensive to construct.
     */
    var EditorModel = /** @class */ (function (_super) {
        __extends(EditorModel, _super);
        function EditorModel() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._onDispose = _this._register(new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(EditorModel.prototype, "onDispose", {
            get: function () { return this._onDispose.event; },
            enumerable: true,
            configurable: true
        });
        /**
         * Causes this model to load returning a promise when loading is completed.
         */
        EditorModel.prototype.load = function () {
            return winjs_base_1.TPromise.as(this);
        };
        /**
         * Returns whether this model was loaded or not.
         */
        EditorModel.prototype.isResolved = function () {
            return true;
        };
        /**
         * Subclasses should implement to free resources that have been claimed through loading.
         */
        EditorModel.prototype.dispose = function () {
            this._onDispose.fire();
            _super.prototype.dispose.call(this);
        };
        return EditorModel;
    }(lifecycle_1.Disposable));
    exports.EditorModel = EditorModel;
    function isEditorInputWithOptions(obj) {
        var editorInputWithOptions = obj;
        return !!editorInputWithOptions && !!editorInputWithOptions.editor;
    }
    exports.isEditorInputWithOptions = isEditorInputWithOptions;
    /**
     * The editor options is the base class of options that can be passed in when opening an editor.
     */
    var EditorOptions = /** @class */ (function () {
        function EditorOptions() {
        }
        /**
         * Helper to create EditorOptions inline.
         */
        EditorOptions.create = function (settings) {
            var options = new EditorOptions();
            options.preserveFocus = settings.preserveFocus;
            options.forceReload = settings.forceReload;
            options.revealIfVisible = settings.revealIfVisible;
            options.revealIfOpened = settings.revealIfOpened;
            options.pinned = settings.pinned;
            options.index = settings.index;
            options.inactive = settings.inactive;
            return options;
        };
        return EditorOptions;
    }());
    exports.EditorOptions = EditorOptions;
    /**
     * Base Text Editor Options.
     */
    var TextEditorOptions = /** @class */ (function (_super) {
        __extends(TextEditorOptions, _super);
        function TextEditorOptions() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TextEditorOptions.from = function (input) {
            if (!input || !input.options) {
                return null;
            }
            return TextEditorOptions.create(input.options);
        };
        /**
         * Helper to convert options bag to real class
         */
        TextEditorOptions.create = function (options) {
            if (options === void 0) { options = Object.create(null); }
            var textEditorOptions = new TextEditorOptions();
            if (options.selection) {
                var selection = options.selection;
                textEditorOptions.selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn);
            }
            if (options.viewState) {
                textEditorOptions.editorViewState = options.viewState;
            }
            if (options.forceReload) {
                textEditorOptions.forceReload = true;
            }
            if (options.revealIfVisible) {
                textEditorOptions.revealIfVisible = true;
            }
            if (options.revealIfOpened) {
                textEditorOptions.revealIfOpened = true;
            }
            if (options.preserveFocus) {
                textEditorOptions.preserveFocus = true;
            }
            if (options.revealInCenterIfOutsideViewport) {
                textEditorOptions.revealInCenterIfOutsideViewport = true;
            }
            if (options.pinned) {
                textEditorOptions.pinned = true;
            }
            if (options.inactive) {
                textEditorOptions.inactive = true;
            }
            if (typeof options.index === 'number') {
                textEditorOptions.index = options.index;
            }
            return textEditorOptions;
        };
        /**
         * Returns if this options object has objects defined for the editor.
         */
        TextEditorOptions.prototype.hasOptionsDefined = function () {
            return !!this.editorViewState || (!types.isUndefinedOrNull(this.startLineNumber) && !types.isUndefinedOrNull(this.startColumn));
        };
        /**
         * Tells the editor to set show the given selection when the editor is being opened.
         */
        TextEditorOptions.prototype.selection = function (startLineNumber, startColumn, endLineNumber, endColumn) {
            if (endLineNumber === void 0) { endLineNumber = startLineNumber; }
            if (endColumn === void 0) { endColumn = startColumn; }
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
            return this;
        };
        /**
         * Create a TextEditorOptions inline to be used when the editor is opening.
         */
        TextEditorOptions.fromEditor = function (editor, settings) {
            var options = TextEditorOptions.create(settings);
            // View state
            options.editorViewState = editor.saveViewState();
            return options;
        };
        /**
         * Apply the view state or selection to the given editor.
         *
         * @return if something was applied
         */
        TextEditorOptions.prototype.apply = function (editor, scrollType) {
            // View state
            return this.applyViewState(editor, scrollType);
        };
        TextEditorOptions.prototype.applyViewState = function (editor, scrollType) {
            var gotApplied = false;
            // First try viewstate
            if (this.editorViewState) {
                editor.restoreViewState(this.editorViewState);
                gotApplied = true;
            }
            // Otherwise check for selection
            else if (!types.isUndefinedOrNull(this.startLineNumber) && !types.isUndefinedOrNull(this.startColumn)) {
                // Select
                if (!types.isUndefinedOrNull(this.endLineNumber) && !types.isUndefinedOrNull(this.endColumn)) {
                    var range = {
                        startLineNumber: this.startLineNumber,
                        startColumn: this.startColumn,
                        endLineNumber: this.endLineNumber,
                        endColumn: this.endColumn
                    };
                    editor.setSelection(range);
                    if (this.revealInCenterIfOutsideViewport) {
                        editor.revealRangeInCenterIfOutsideViewport(range, scrollType);
                    }
                    else {
                        editor.revealRangeInCenter(range, scrollType);
                    }
                }
                // Reveal
                else {
                    var pos = {
                        lineNumber: this.startLineNumber,
                        column: this.startColumn
                    };
                    editor.setPosition(pos);
                    if (this.revealInCenterIfOutsideViewport) {
                        editor.revealPositionInCenterIfOutsideViewport(pos, scrollType);
                    }
                    else {
                        editor.revealPositionInCenter(pos, scrollType);
                    }
                }
                gotApplied = true;
            }
            return gotApplied;
        };
        return TextEditorOptions;
    }(EditorOptions));
    exports.TextEditorOptions = TextEditorOptions;
    var EditorCommandsContextActionRunner = /** @class */ (function (_super) {
        __extends(EditorCommandsContextActionRunner, _super);
        function EditorCommandsContextActionRunner(context) {
            var _this = _super.call(this) || this;
            _this.context = context;
            return _this;
        }
        EditorCommandsContextActionRunner.prototype.run = function (action, context) {
            return _super.prototype.run.call(this, action, this.context);
        };
        return EditorCommandsContextActionRunner;
    }(actions_1.ActionRunner));
    exports.EditorCommandsContextActionRunner = EditorCommandsContextActionRunner;
    function toResource(editor, options) {
        if (!editor) {
            return null;
        }
        // Check for side by side if we are asked to
        if (options && options.supportSideBySide && editor instanceof SideBySideEditorInput) {
            editor = editor.master;
        }
        var resource = editor.getResource();
        if (!options || !options.filter) {
            return resource; // return early if no filter is specified
        }
        if (!resource) {
            return null;
        }
        var includeFiles;
        var includeUntitled;
        if (Array.isArray(options.filter)) {
            includeFiles = (options.filter.indexOf(network_1.Schemas.file) >= 0);
            includeUntitled = (options.filter.indexOf(network_1.Schemas.untitled) >= 0);
        }
        else {
            includeFiles = (options.filter === network_1.Schemas.file);
            includeUntitled = (options.filter === network_1.Schemas.untitled);
        }
        if (includeFiles && resource.scheme === network_1.Schemas.file) {
            return resource;
        }
        if (includeUntitled && resource.scheme === network_1.Schemas.untitled) {
            return resource;
        }
        return null;
    }
    exports.toResource = toResource;
    var CloseDirection;
    (function (CloseDirection) {
        CloseDirection[CloseDirection["LEFT"] = 0] = "LEFT";
        CloseDirection[CloseDirection["RIGHT"] = 1] = "RIGHT";
    })(CloseDirection = exports.CloseDirection || (exports.CloseDirection = {}));
    var EditorInputFactoryRegistry = /** @class */ (function () {
        function EditorInputFactoryRegistry() {
            this.editorInputFactoryConstructors = Object.create(null);
            this.editorInputFactoryInstances = Object.create(null);
        }
        EditorInputFactoryRegistry.prototype.setInstantiationService = function (service) {
            this.instantiationService = service;
            for (var key in this.editorInputFactoryConstructors) {
                var element = this.editorInputFactoryConstructors[key];
                this.createEditorInputFactory(key, element);
            }
            this.editorInputFactoryConstructors = {};
        };
        EditorInputFactoryRegistry.prototype.createEditorInputFactory = function (editorInputId, ctor) {
            var instance = this.instantiationService.createInstance(ctor);
            this.editorInputFactoryInstances[editorInputId] = instance;
        };
        EditorInputFactoryRegistry.prototype.registerFileInputFactory = function (factory) {
            this.fileInputFactory = factory;
        };
        EditorInputFactoryRegistry.prototype.getFileInputFactory = function () {
            return this.fileInputFactory;
        };
        EditorInputFactoryRegistry.prototype.registerEditorInputFactory = function (editorInputId, ctor) {
            if (!this.instantiationService) {
                this.editorInputFactoryConstructors[editorInputId] = ctor;
            }
            else {
                this.createEditorInputFactory(editorInputId, ctor);
            }
        };
        EditorInputFactoryRegistry.prototype.getEditorInputFactory = function (editorInputId) {
            return this.editorInputFactoryInstances[editorInputId];
        };
        return EditorInputFactoryRegistry;
    }());
    exports.Extensions = {
        EditorInputFactories: 'workbench.contributions.editor.inputFactories'
    };
    platform_1.Registry.add(exports.Extensions.EditorInputFactories, new EditorInputFactoryRegistry());
});




















define(__m[161/*vs/workbench/common/editor/textEditorModel*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,78/*vs/workbench/common/editor*/,55/*vs/editor/common/services/modeService*/,39/*vs/editor/common/services/modelService*/]), function (require, exports, winjs_base_1, editor_1, modeService_1, modelService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The base text editor model leverages the code editor model. This class is only intended to be subclassed and not instantiated.
     */
    var BaseTextEditorModel = /** @class */ (function (_super) {
        __extends(BaseTextEditorModel, _super);
        function BaseTextEditorModel(modelService, modeService, textEditorModelHandle) {
            var _this = _super.call(this) || this;
            _this.modelService = modelService;
            _this.modeService = modeService;
            if (textEditorModelHandle) {
                _this.handleExistingModel(textEditorModelHandle);
            }
            return _this;
        }
        BaseTextEditorModel.prototype.handleExistingModel = function (textEditorModelHandle) {
            // We need the resource to point to an existing model
            var model = this.modelService.getModel(textEditorModelHandle);
            if (!model) {
                throw new Error("Document with resource " + textEditorModelHandle.toString() + " does not exist");
            }
            this.textEditorModelHandle = textEditorModelHandle;
            // Make sure we clean up when this model gets disposed
            this.registerModelDisposeListener(model);
        };
        BaseTextEditorModel.prototype.registerModelDisposeListener = function (model) {
            var _this = this;
            if (this.modelDisposeListener) {
                this.modelDisposeListener.dispose();
            }
            this.modelDisposeListener = model.onWillDispose(function () {
                _this.textEditorModelHandle = null; // make sure we do not dispose code editor model again
                _this.dispose();
            });
        };
        Object.defineProperty(BaseTextEditorModel.prototype, "textEditorModel", {
            get: function () {
                return this.textEditorModelHandle ? this.modelService.getModel(this.textEditorModelHandle) : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates the text editor model with the provided value, modeId (can be comma separated for multiple values) and optional resource URL.
         */
        BaseTextEditorModel.prototype.createTextEditorModel = function (value, resource, modeId) {
            var firstLineText = this.getFirstLineText(value);
            var mode = this.getOrCreateMode(this.modeService, modeId, firstLineText);
            return winjs_base_1.TPromise.as(this.doCreateTextEditorModel(value, mode, resource));
        };
        BaseTextEditorModel.prototype.doCreateTextEditorModel = function (value, mode, resource) {
            var model = resource && this.modelService.getModel(resource);
            if (!model) {
                model = this.modelService.createModel(value, mode, resource);
                this.createdEditorModel = true;
                // Make sure we clean up when this model gets disposed
                this.registerModelDisposeListener(model);
            }
            else {
                this.modelService.updateModel(model, value);
                this.modelService.setMode(model, mode);
            }
            this.textEditorModelHandle = model.uri;
            return this;
        };
        BaseTextEditorModel.prototype.getFirstLineText = function (value) {
            // text buffer factory
            var textBufferFactory = value;
            if (typeof textBufferFactory.getFirstLineText === 'function') {
                return textBufferFactory.getFirstLineText(100);
            }
            // text model
            var textSnapshot = value;
            return textSnapshot.getLineContent(1).substr(0, 100);
        };
        /**
         * Gets the mode for the given identifier. Subclasses can override to provide their own implementation of this lookup.
         *
         * @param firstLineText optional first line of the text buffer to set the mode on. This can be used to guess a mode from content.
         */
        BaseTextEditorModel.prototype.getOrCreateMode = function (modeService, modeId, firstLineText) {
            return modeService.getOrCreateMode(modeId);
        };
        /**
         * Updates the text editor model with the provided value. If the value is the same as the model has, this is a no-op.
         */
        BaseTextEditorModel.prototype.updateTextEditorModel = function (newValue) {
            if (!this.textEditorModel) {
                return;
            }
            this.modelService.updateModel(this.textEditorModel, newValue);
        };
        BaseTextEditorModel.prototype.createSnapshot = function () {
            var model = this.textEditorModel;
            if (model) {
                return model.createSnapshot(true /* Preserve BOM */);
            }
            return null;
        };
        BaseTextEditorModel.prototype.isResolved = function () {
            return !!this.textEditorModelHandle;
        };
        BaseTextEditorModel.prototype.dispose = function () {
            if (this.modelDisposeListener) {
                this.modelDisposeListener.dispose(); // dispose this first because it will trigger another dispose() otherwise
                this.modelDisposeListener = null;
            }
            if (this.textEditorModelHandle && this.createdEditorModel) {
                this.modelService.destroyModel(this.textEditorModelHandle);
            }
            this.textEditorModelHandle = null;
            this.createdEditorModel = false;
            _super.prototype.dispose.call(this);
        };
        BaseTextEditorModel = __decorate([
            __param(0, modelService_1.IModelService),
            __param(1, modeService_1.IModeService)
        ], BaseTextEditorModel);
        return BaseTextEditorModel;
    }(editor_1.EditorModel));
    exports.BaseTextEditorModel = BaseTextEditorModel;
});

define(__m[162/*vs/workbench/parts/tasks/common/tasks*/], __M([0/*require*/,1/*exports*/,18/*vs/base/common/types*/,20/*vs/base/common/objects*/,42/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, Types, Objects, contextkey_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TASK_RUNNING_STATE = new contextkey_1.RawContextKey('taskRunning', false);
    var ShellQuoting;
    (function (ShellQuoting) {
        /**
         * Use character escaping.
         */
        ShellQuoting[ShellQuoting["Escape"] = 1] = "Escape";
        /**
         * Use strong quoting
         */
        ShellQuoting[ShellQuoting["Strong"] = 2] = "Strong";
        /**
         * Use weak quoting.
         */
        ShellQuoting[ShellQuoting["Weak"] = 3] = "Weak";
    })(ShellQuoting = exports.ShellQuoting || (exports.ShellQuoting = {}));
    (function (ShellQuoting) {
        function from(value) {
            if (!value) {
                return ShellQuoting.Strong;
            }
            switch (value.toLowerCase()) {
                case 'escape':
                    return ShellQuoting.Escape;
                case 'strong':
                    return ShellQuoting.Strong;
                case 'weak':
                    return ShellQuoting.Weak;
                default:
                    return ShellQuoting.Strong;
            }
        }
        ShellQuoting.from = from;
    })(ShellQuoting = exports.ShellQuoting || (exports.ShellQuoting = {}));
    var RevealKind;
    (function (RevealKind) {
        /**
         * Always brings the terminal to front if the task is executed.
         */
        RevealKind[RevealKind["Always"] = 1] = "Always";
        /**
         * Only brings the terminal to front if a problem is detected executing the task
         * (e.g. the task couldn't be started because).
         */
        RevealKind[RevealKind["Silent"] = 2] = "Silent";
        /**
         * The terminal never comes to front when the task is executed.
         */
        RevealKind[RevealKind["Never"] = 3] = "Never";
    })(RevealKind = exports.RevealKind || (exports.RevealKind = {}));
    (function (RevealKind) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'always':
                    return RevealKind.Always;
                case 'silent':
                    return RevealKind.Silent;
                case 'never':
                    return RevealKind.Never;
                default:
                    return RevealKind.Always;
            }
        }
        RevealKind.fromString = fromString;
    })(RevealKind = exports.RevealKind || (exports.RevealKind = {}));
    var PanelKind;
    (function (PanelKind) {
        /**
         * Shares a panel with other tasks. This is the default.
         */
        PanelKind[PanelKind["Shared"] = 1] = "Shared";
        /**
         * Uses a dedicated panel for this tasks. The panel is not
         * shared with other tasks.
         */
        PanelKind[PanelKind["Dedicated"] = 2] = "Dedicated";
        /**
         * Creates a new panel whenever this task is executed.
         */
        PanelKind[PanelKind["New"] = 3] = "New";
    })(PanelKind = exports.PanelKind || (exports.PanelKind = {}));
    (function (PanelKind) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'shared':
                    return PanelKind.Shared;
                case 'dedicated':
                    return PanelKind.Dedicated;
                case 'new':
                    return PanelKind.New;
                default:
                    return PanelKind.Shared;
            }
        }
        PanelKind.fromString = fromString;
    })(PanelKind = exports.PanelKind || (exports.PanelKind = {}));
    var RuntimeType;
    (function (RuntimeType) {
        RuntimeType[RuntimeType["Shell"] = 1] = "Shell";
        RuntimeType[RuntimeType["Process"] = 2] = "Process";
    })(RuntimeType = exports.RuntimeType || (exports.RuntimeType = {}));
    (function (RuntimeType) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'shell':
                    return RuntimeType.Shell;
                case 'process':
                    return RuntimeType.Process;
                default:
                    return RuntimeType.Process;
            }
        }
        RuntimeType.fromString = fromString;
    })(RuntimeType = exports.RuntimeType || (exports.RuntimeType = {}));
    var CommandString;
    (function (CommandString) {
        function value(value) {
            if (Types.isString(value)) {
                return value;
            }
            else {
                return value.value;
            }
        }
        CommandString.value = value;
    })(CommandString = exports.CommandString || (exports.CommandString = {}));
    var TaskGroup;
    (function (TaskGroup) {
        TaskGroup.Clean = 'clean';
        TaskGroup.Build = 'build';
        TaskGroup.Rebuild = 'rebuild';
        TaskGroup.Test = 'test';
        function is(value) {
            return value === TaskGroup.Clean || value === TaskGroup.Build || value === TaskGroup.Rebuild || value === TaskGroup.Test;
        }
        TaskGroup.is = is;
    })(TaskGroup = exports.TaskGroup || (exports.TaskGroup = {}));
    var TaskScope;
    (function (TaskScope) {
        TaskScope[TaskScope["Global"] = 1] = "Global";
        TaskScope[TaskScope["Workspace"] = 2] = "Workspace";
        TaskScope[TaskScope["Folder"] = 3] = "Folder";
    })(TaskScope = exports.TaskScope || (exports.TaskScope = {}));
    var TaskSourceKind;
    (function (TaskSourceKind) {
        TaskSourceKind.Workspace = 'workspace';
        TaskSourceKind.Extension = 'extension';
        TaskSourceKind.InMemory = 'inMemory';
    })(TaskSourceKind = exports.TaskSourceKind || (exports.TaskSourceKind = {}));
    var GroupType;
    (function (GroupType) {
        GroupType["default"] = "default";
        GroupType["user"] = "user";
    })(GroupType = exports.GroupType || (exports.GroupType = {}));
    var CustomTask;
    (function (CustomTask) {
        function is(value) {
            var candidate = value;
            return candidate && candidate.type === 'custom';
        }
        CustomTask.is = is;
        function getDefinition(task) {
            var type;
            if (task.command !== void 0) {
                type = task.command.runtime === RuntimeType.Shell ? 'shell' : 'process';
            }
            else {
                type = '$composite';
            }
            var result = {
                type: type,
                _key: task._id,
                id: task._id
            };
            return result;
        }
        CustomTask.getDefinition = getDefinition;
        function customizes(task) {
            if (task._source && task._source.customizes) {
                return task._source.customizes;
            }
            return undefined;
        }
        CustomTask.customizes = customizes;
    })(CustomTask = exports.CustomTask || (exports.CustomTask = {}));
    var ConfiguringTask;
    (function (ConfiguringTask) {
        function is(value) {
            var candidate = value;
            return candidate && candidate.configures && Types.isString(candidate.configures.type) && value.command === void 0;
        }
        ConfiguringTask.is = is;
    })(ConfiguringTask = exports.ConfiguringTask || (exports.ConfiguringTask = {}));
    var ContributedTask;
    (function (ContributedTask) {
        function is(value) {
            var candidate = value;
            return candidate && candidate.defines && Types.isString(candidate.defines.type) && candidate.command !== void 0;
        }
        ContributedTask.is = is;
    })(ContributedTask = exports.ContributedTask || (exports.ContributedTask = {}));
    var InMemoryTask;
    (function (InMemoryTask) {
        function is(value) {
            var candidate = value;
            return candidate && candidate._source && candidate._source.kind === TaskSourceKind.InMemory;
        }
        InMemoryTask.is = is;
    })(InMemoryTask = exports.InMemoryTask || (exports.InMemoryTask = {}));
    var Task;
    (function (Task) {
        function getRecentlyUsedKey(task) {
            if (InMemoryTask.is(task)) {
                return undefined;
            }
            if (CustomTask.is(task)) {
                var workspaceFolder = task._source.config.workspaceFolder;
                if (!workspaceFolder) {
                    return undefined;
                }
                var key = { type: 'custom', folder: workspaceFolder.uri.toString(), id: task.identifier };
                return JSON.stringify(key);
            }
            if (ContributedTask.is(task)) {
                var key = { type: 'contributed', scope: task._source.scope, id: task._id };
                if (task._source.scope === TaskScope.Folder && task._source.workspaceFolder) {
                    key.folder = task._source.workspaceFolder.uri.toString();
                }
                return JSON.stringify(key);
            }
            return undefined;
        }
        Task.getRecentlyUsedKey = getRecentlyUsedKey;
        function getMapKey(task) {
            if (CustomTask.is(task)) {
                var workspaceFolder = task._source.config.workspaceFolder;
                return workspaceFolder ? workspaceFolder.uri.toString() + "|" + task._id : task._id;
            }
            else if (ContributedTask.is(task)) {
                var workspaceFolder = task._source.workspaceFolder;
                return workspaceFolder
                    ? task._source.scope.toString() + "|" + workspaceFolder.uri.toString() + "|" + task._id
                    : task._source.scope.toString() + "|" + task._id;
            }
            else {
                return task._id;
            }
        }
        Task.getMapKey = getMapKey;
        function getWorkspaceFolder(task) {
            if (CustomTask.is(task)) {
                return task._source.config.workspaceFolder;
            }
            else if (ContributedTask.is(task)) {
                return task._source.workspaceFolder;
            }
            else {
                return undefined;
            }
        }
        Task.getWorkspaceFolder = getWorkspaceFolder;
        function clone(task) {
            return Objects.assign({}, task);
        }
        Task.clone = clone;
        function getTelemetryKind(task) {
            if (ContributedTask.is(task)) {
                return 'extension';
            }
            else if (CustomTask.is(task)) {
                if (task._source.customizes) {
                    return 'workspace>extension';
                }
                else {
                    return 'workspace';
                }
            }
            else if (InMemoryTask.is(task)) {
                return 'composite';
            }
            else {
                return 'unknown';
            }
        }
        Task.getTelemetryKind = getTelemetryKind;
        function matches(task, key, compareId) {
            if (compareId === void 0) { compareId = false; }
            if (key === void 0) {
                return false;
            }
            if (Types.isString(key)) {
                return key === task._label || key === task.identifier || (compareId && key === task._id);
            }
            var identifier = Task.getTaskDefinition(task, true);
            return identifier !== void 0 && identifier._key === key._key;
        }
        Task.matches = matches;
        function getQualifiedLabel(task) {
            var workspaceFolder = getWorkspaceFolder(task);
            if (workspaceFolder) {
                return task._label + " (" + workspaceFolder.name + ")";
            }
            else {
                return task._label;
            }
        }
        Task.getQualifiedLabel = getQualifiedLabel;
        function getTaskDefinition(task, useSource) {
            if (useSource === void 0) { useSource = false; }
            if (ContributedTask.is(task)) {
                return task.defines;
            }
            else if (CustomTask.is(task)) {
                if (useSource && task._source.customizes !== void 0) {
                    return task._source.customizes;
                }
                else {
                    return CustomTask.getDefinition(task);
                }
            }
            else {
                return undefined;
            }
        }
        Task.getTaskDefinition = getTaskDefinition;
        function getTaskExecution(task) {
            var result = {
                id: task._id,
                task: task
            };
            return result;
        }
        Task.getTaskExecution = getTaskExecution;
    })(Task = exports.Task || (exports.Task = {}));
    var ExecutionEngine;
    (function (ExecutionEngine) {
        ExecutionEngine[ExecutionEngine["Process"] = 1] = "Process";
        ExecutionEngine[ExecutionEngine["Terminal"] = 2] = "Terminal";
    })(ExecutionEngine = exports.ExecutionEngine || (exports.ExecutionEngine = {}));
    (function (ExecutionEngine) {
        ExecutionEngine._default = ExecutionEngine.Terminal;
    })(ExecutionEngine = exports.ExecutionEngine || (exports.ExecutionEngine = {}));
    var JsonSchemaVersion;
    (function (JsonSchemaVersion) {
        JsonSchemaVersion[JsonSchemaVersion["V0_1_0"] = 1] = "V0_1_0";
        JsonSchemaVersion[JsonSchemaVersion["V2_0_0"] = 2] = "V2_0_0";
    })(JsonSchemaVersion = exports.JsonSchemaVersion || (exports.JsonSchemaVersion = {}));
    var TaskSorter = /** @class */ (function () {
        function TaskSorter(workspaceFolders) {
            this._order = new Map();
            for (var i = 0; i < workspaceFolders.length; i++) {
                this._order.set(workspaceFolders[i].uri.toString(), i);
            }
        }
        TaskSorter.prototype.compare = function (a, b) {
            var aw = Task.getWorkspaceFolder(a);
            var bw = Task.getWorkspaceFolder(b);
            if (aw && bw) {
                var ai = this._order.get(aw.uri.toString());
                ai = ai === void 0 ? 0 : ai + 1;
                var bi = this._order.get(bw.uri.toString());
                bi = bi === void 0 ? 0 : bi + 1;
                if (ai === bi) {
                    return a._label.localeCompare(b._label);
                }
                else {
                    return ai - bi;
                }
            }
            else if (!aw && bw) {
                return -1;
            }
            else if (aw && !bw) {
                return +1;
            }
            else {
                return 0;
            }
        };
        return TaskSorter;
    }());
    exports.TaskSorter = TaskSorter;
    var TaskEventKind;
    (function (TaskEventKind) {
        TaskEventKind["Start"] = "start";
        TaskEventKind["ProcessStarted"] = "processStarted";
        TaskEventKind["Active"] = "active";
        TaskEventKind["Inactive"] = "inactive";
        TaskEventKind["Changed"] = "changed";
        TaskEventKind["Terminated"] = "terminated";
        TaskEventKind["ProcessEnded"] = "processEnded";
        TaskEventKind["End"] = "end";
    })(TaskEventKind = exports.TaskEventKind || (exports.TaskEventKind = {}));
    var TaskRunType;
    (function (TaskRunType) {
        TaskRunType["SingleRun"] = "singleRun";
        TaskRunType["Background"] = "background";
    })(TaskRunType = exports.TaskRunType || (exports.TaskRunType = {}));
    var TaskEvent;
    (function (TaskEvent) {
        function create(kind, task, processIdOrExitCode) {
            if (task) {
                var result = {
                    kind: kind,
                    taskId: task._id,
                    taskName: task.name,
                    runType: task.isBackground ? TaskRunType.Background : TaskRunType.SingleRun,
                    group: task.group,
                    processId: undefined,
                    exitCode: undefined,
                    __task: task,
                };
                if (kind === TaskEventKind.ProcessStarted) {
                    result.processId = processIdOrExitCode;
                }
                else if (kind === TaskEventKind.ProcessEnded) {
                    result.exitCode = processIdOrExitCode;
                }
                return Object.freeze(result);
            }
            else {
                return Object.freeze({ kind: TaskEventKind.Changed });
            }
        }
        TaskEvent.create = create;
    })(TaskEvent = exports.TaskEvent || (exports.TaskEvent = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[163/*vs/workbench/parts/terminal/common/terminal*/], __M([0/*require*/,1/*exports*/,42/*vs/platform/contextkey/common/contextkey*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, contextkey_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TERMINAL_PANEL_ID = 'workbench.panel.terminal';
    exports.TERMINAL_SERVICE_ID = 'terminalService';
    /** A context key that is set when there is at least one opened integrated terminal. */
    exports.KEYBINDING_CONTEXT_TERMINAL_IS_OPEN = new contextkey_1.RawContextKey('terminalIsOpen', false);
    /** A context key that is set when the integrated terminal has focus. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FOCUS = new contextkey_1.RawContextKey('terminalFocus', undefined);
    /** A context key that is set when the integrated terminal does not have focus. */
    exports.KEYBINDING_CONTEXT_TERMINAL_NOT_FOCUSED = exports.KEYBINDING_CONTEXT_TERMINAL_FOCUS.toNegated();
    /** A keybinding context key that is set when the integrated terminal has text selected. */
    exports.KEYBINDING_CONTEXT_TERMINAL_TEXT_SELECTED = new contextkey_1.RawContextKey('terminalTextSelected', undefined);
    /** A keybinding context key that is set when the integrated terminal does not have text selected. */
    exports.KEYBINDING_CONTEXT_TERMINAL_TEXT_NOT_SELECTED = exports.KEYBINDING_CONTEXT_TERMINAL_TEXT_SELECTED.toNegated();
    /**  A context key that is set when the find widget in integrated terminal is visible. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_VISIBLE = new contextkey_1.RawContextKey('terminalFindWidgetVisible', undefined);
    /**  A context key that is set when the find widget in integrated terminal is not visible. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_NOT_VISIBLE = exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_VISIBLE.toNegated();
    /**  A context key that is set when the find widget find input in integrated terminal is focused. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_FOCUSED = new contextkey_1.RawContextKey('terminalFindWidgetInputFocused', false);
    /**  A context key that is set when the find widget find input in integrated terminal is not focused. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_NOT_FOCUSED = exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_FOCUSED.toNegated();
    exports.IS_WORKSPACE_SHELL_ALLOWED_STORAGE_KEY = 'terminal.integrated.isWorkspaceShellAllowed';
    exports.NEVER_SUGGEST_SELECT_WINDOWS_SHELL_STORAGE_KEY = 'terminal.integrated.neverSuggestSelectWindowsShell';
    exports.NEVER_MEASURE_RENDER_TIME_STORAGE_KEY = 'terminal.integrated.neverMeasureRenderTime';
    // The creation of extension host terminals is delayed by this value (milliseconds). The purpose of
    // this delay is to allow the terminal instance to initialize correctly and have its ID set before
    // trying to create the corressponding object on the ext host.
    exports.EXT_HOST_CREATION_DELAY = 100;
    exports.ITerminalService = instantiation_1.createDecorator(exports.TERMINAL_SERVICE_ID);
    exports.TerminalCursorStyle = {
        BLOCK: 'block',
        LINE: 'line',
        UNDERLINE: 'underline'
    };
    exports.TERMINAL_CONFIG_SECTION = 'terminal.integrated';
    exports.DEFAULT_LETTER_SPACING = 0;
    exports.MINIMUM_LETTER_SPACING = -5;
    exports.DEFAULT_LINE_HEIGHT = 1.0;
    var Direction;
    (function (Direction) {
        Direction[Direction["Left"] = 0] = "Left";
        Direction[Direction["Right"] = 1] = "Right";
        Direction[Direction["Up"] = 2] = "Up";
        Direction[Direction["Down"] = 3] = "Down";
    })(Direction = exports.Direction || (exports.Direction = {}));
    var ProcessState;
    (function (ProcessState) {
        // The process has not been initialized yet.
        ProcessState[ProcessState["UNINITIALIZED"] = 0] = "UNINITIALIZED";
        // The process is currently launching, the process is marked as launching
        // for a short duration after being created and is helpful to indicate
        // whether the process died as a result of bad shell and args.
        ProcessState[ProcessState["LAUNCHING"] = 1] = "LAUNCHING";
        // The process is running normally.
        ProcessState[ProcessState["RUNNING"] = 2] = "RUNNING";
        // The process was killed during launch, likely as a result of bad shell and
        // args.
        ProcessState[ProcessState["KILLED_DURING_LAUNCH"] = 3] = "KILLED_DURING_LAUNCH";
        // The process was killed by the user (the event originated from VS Code).
        ProcessState[ProcessState["KILLED_BY_USER"] = 4] = "KILLED_BY_USER";
        // The process was killed by itself, for example the shell crashed or `exit`
        // was run.
        ProcessState[ProcessState["KILLED_BY_PROCESS"] = 5] = "KILLED_BY_PROCESS";
    })(ProcessState = exports.ProcessState || (exports.ProcessState = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[164/*vs/workbench/parts/terminal/node/terminalEnvironment*/], __M([0/*require*/,1/*exports*/,37/*os*/,16/*vs/base/common/paths*/,10/*vs/base/common/platform*/,65/*vs/platform/node/package*/]), function (require, exports, os, paths, platform, package_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This module contains utility functions related to the environment, cwd and paths.
     */
    function mergeEnvironments(parent, other) {
        if (!other) {
            return;
        }
        // On Windows apply the new values ignoring case, while still retaining
        // the case of the original key.
        if (platform.isWindows) {
            for (var configKey in other) {
                var actualKey = configKey;
                for (var envKey in parent) {
                    if (configKey.toLowerCase() === envKey.toLowerCase()) {
                        actualKey = envKey;
                        break;
                    }
                }
                var value = other[configKey];
                _mergeEnvironmentValue(parent, actualKey, value);
            }
        }
        else {
            Object.keys(other).forEach(function (key) {
                var value = other[key];
                _mergeEnvironmentValue(parent, key, value);
            });
        }
    }
    exports.mergeEnvironments = mergeEnvironments;
    function _mergeEnvironmentValue(env, key, value) {
        if (typeof value === 'string') {
            env[key] = value;
        }
        else {
            delete env[key];
        }
    }
    function sanitizeEnvironment(env) {
        // Remove keys based on strings
        var keysToRemove = [
            'ELECTRON_ENABLE_STACK_DUMPING',
            'ELECTRON_ENABLE_LOGGING',
            'ELECTRON_NO_ASAR',
            'ELECTRON_NO_ATTACH_CONSOLE',
            'ELECTRON_RUN_AS_NODE',
            'GOOGLE_API_KEY',
            'VSCODE_CLI',
            'VSCODE_DEV',
            'VSCODE_IPC_HOOK',
            'VSCODE_LOGS',
            'VSCODE_NLS_CONFIG',
            'VSCODE_PORTABLE',
            'VSCODE_PID',
        ];
        keysToRemove.forEach(function (key) {
            if (env[key]) {
                delete env[key];
            }
        });
        // Remove keys based on regexp
        Object.keys(env).forEach(function (key) {
            if (key.search(/^VSCODE_NODE_CACHED_DATA_DIR_\d+$/) === 0) {
                delete env[key];
            }
        });
    }
    exports.sanitizeEnvironment = sanitizeEnvironment;
    function addTerminalEnvironmentKeys(env, locale) {
        env['TERM_PROGRAM'] = 'vscode';
        env['TERM_PROGRAM_VERSION'] = package_1.default.version;
        env['LANG'] = _getLangEnvVariable(locale);
    }
    exports.addTerminalEnvironmentKeys = addTerminalEnvironmentKeys;
    function resolveConfigurationVariables(configurationResolverService, env, lastActiveWorkspaceRoot) {
        Object.keys(env).forEach(function (key) {
            if (typeof env[key] === 'string') {
                env[key] = configurationResolverService.resolve(lastActiveWorkspaceRoot, env[key]);
            }
        });
        return env;
    }
    exports.resolveConfigurationVariables = resolveConfigurationVariables;
    function _getLangEnvVariable(locale) {
        var parts = locale ? locale.split('-') : [];
        var n = parts.length;
        if (n === 0) {
            // Fallback to en_US to prevent possible encoding issues.
            return 'en_US.UTF-8';
        }
        if (n === 1) {
            // app.getLocale can return just a language without a variant, fill in the variant for
            // supported languages as many shells expect a 2-part locale.
            var languageVariants = {
                de: 'DE',
                en: 'US',
                es: 'ES',
                fi: 'FI',
                fr: 'FR',
                it: 'IT',
                ja: 'JP',
                ko: 'KR',
                pl: 'PL',
                ru: 'RU',
                zh: 'CN'
            };
            if (parts[0] in languageVariants) {
                parts.push(languageVariants[parts[0]]);
            }
        }
        else {
            // Ensure the variant is uppercase
            parts[1] = parts[1].toUpperCase();
        }
        return parts.join('_') + '.UTF-8';
    }
    function getCwd(shell, root, configHelper) {
        if (shell.cwd) {
            return shell.cwd;
        }
        var cwd;
        // TODO: Handle non-existent customCwd
        if (!shell.ignoreConfigurationCwd) {
            // Evaluate custom cwd first
            var customCwd = configHelper.config.cwd;
            if (customCwd) {
                if (paths.isAbsolute(customCwd)) {
                    cwd = customCwd;
                }
                else if (root) {
                    cwd = paths.normalize(paths.join(root.fsPath, customCwd));
                }
            }
        }
        // If there was no custom cwd or it was relative with no workspace
        if (!cwd) {
            cwd = root ? root.fsPath : os.homedir();
        }
        return _sanitizeCwd(cwd);
    }
    exports.getCwd = getCwd;
    function _sanitizeCwd(cwd) {
        // Make the drive letter uppercase on Windows (see #9448)
        if (platform.platform === platform.Platform.Windows && cwd && cwd[1] === ':') {
            return cwd[0].toUpperCase() + cwd.substr(1);
        }
        return cwd;
    }
    /**
     * Adds quotes to a path if it contains whitespaces
     */
    function preparePathForTerminal(path) {
        if (platform.isWindows) {
            if (/\s+/.test(path)) {
                return "\"" + path + "\"";
            }
            return path;
        }
        path = path.replace(/(%5C|\\)/g, '\\\\');
        var charsToEscape = [
            ' ', '\'', '"', '?', ':', ';', '!', '*', '(', ')', '{', '}', '[', ']'
        ];
        for (var i = 0; i < path.length; i++) {
            var indexOfChar = charsToEscape.indexOf(path.charAt(i));
            if (indexOfChar >= 0) {
                path = path.substring(0, i) + "\\" + path.charAt(i) + path.substring(i + 1);
                i++; // Skip char due to escape char being added
            }
        }
        return path;
    }
    exports.preparePathForTerminal = preparePathForTerminal;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[165/*vs/workbench/parts/terminal/node/terminalProcess*/], __M([0/*require*/,1/*exports*/,37/*os*/,22/*path*/,237/*node-pty*/,3/*vs/base/common/event*/]), function (require, exports, os, path, pty, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TerminalProcess = /** @class */ (function () {
        function TerminalProcess(shellLaunchConfig, cwd, cols, rows, env) {
            var _this = this;
            this._currentTitle = '';
            this._onProcessData = new event_1.Emitter();
            this._onProcessExit = new event_1.Emitter();
            this._onProcessIdReady = new event_1.Emitter();
            this._onProcessTitleChanged = new event_1.Emitter();
            var shellName;
            if (os.platform() === 'win32') {
                shellName = path.basename(shellLaunchConfig.executable);
            }
            else {
                // Using 'xterm-256color' here helps ensure that the majority of Linux distributions will use a
                // color prompt as defined in the default ~/.bashrc file.
                shellName = 'xterm-256color';
            }
            var options = {
                name: shellName,
                cwd: cwd,
                env: env,
                cols: cols,
                rows: rows
            };
            this._ptyProcess = pty.spawn(shellLaunchConfig.executable, shellLaunchConfig.args, options);
            this._ptyProcess.on('data', function (data) {
                _this._onProcessData.fire(data);
                if (_this._closeTimeout) {
                    clearTimeout(_this._closeTimeout);
                    _this._queueProcessExit();
                }
            });
            this._ptyProcess.on('exit', function (code) {
                _this._exitCode = code;
                _this._queueProcessExit();
            });
            // TODO: We should no longer need to delay this since pty.spawn is sync
            setTimeout(function () {
                _this._sendProcessId();
            }, 500);
            this._setupTitlePolling();
        }
        Object.defineProperty(TerminalProcess.prototype, "onProcessData", {
            get: function () { return this._onProcessData.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerminalProcess.prototype, "onProcessExit", {
            get: function () { return this._onProcessExit.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerminalProcess.prototype, "onProcessIdReady", {
            get: function () { return this._onProcessIdReady.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerminalProcess.prototype, "onProcessTitleChanged", {
            get: function () { return this._onProcessTitleChanged.event; },
            enumerable: true,
            configurable: true
        });
        TerminalProcess.prototype.dispose = function () {
            this._onProcessData.dispose();
            this._onProcessExit.dispose();
            this._onProcessIdReady.dispose();
            this._onProcessTitleChanged.dispose();
        };
        TerminalProcess.prototype._setupTitlePolling = function () {
            var _this = this;
            this._sendProcessTitle();
            setInterval(function () {
                if (_this._currentTitle !== _this._ptyProcess.process) {
                    _this._sendProcessTitle();
                }
            }, 200);
        };
        // Allow any trailing data events to be sent before the exit event is sent.
        // See https://github.com/Tyriar/node-pty/issues/72
        TerminalProcess.prototype._queueProcessExit = function () {
            var _this = this;
            if (this._closeTimeout) {
                clearTimeout(this._closeTimeout);
            }
            this._closeTimeout = setTimeout(function () {
                _this._ptyProcess.kill();
                _this._onProcessExit.fire(_this._exitCode);
                _this.dispose();
            }, 250);
        };
        TerminalProcess.prototype._sendProcessId = function () {
            this._onProcessIdReady.fire(this._ptyProcess.pid);
        };
        TerminalProcess.prototype._sendProcessTitle = function () {
            this._currentTitle = this._ptyProcess.process;
            this._onProcessTitleChanged.fire(this._currentTitle);
        };
        TerminalProcess.prototype.shutdown = function () {
            this._queueProcessExit();
        };
        TerminalProcess.prototype.input = function (data) {
            this._ptyProcess.write(data);
        };
        TerminalProcess.prototype.resize = function (cols, rows) {
            // Ensure that cols and rows are always >= 1, this prevents a native
            // exception in winpty.
            this._ptyProcess.resize(Math.max(cols, 1), Math.max(rows, 1));
        };
        return TerminalProcess;
    }());
    exports.TerminalProcess = TerminalProcess;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[167/*vs/workbench/services/backup/common/backup*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IBackupFileService = instantiation_1.createDecorator('backupFileService');
    exports.BACKUP_FILE_RESOLVE_OPTIONS = { acceptTextOnly: true, encoding: 'utf8' };
    exports.BACKUP_FILE_UPDATE_OPTIONS = { encoding: 'utf8' };
});




















define(__m[168/*vs/workbench/common/editor/untitledEditorModel*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,161/*vs/workbench/common/editor/textEditorModel*/,67/*vs/editor/common/modes/modesRegistry*/,43/*vs/platform/files/common/files*/,55/*vs/editor/common/services/modeService*/,39/*vs/editor/common/services/modelService*/,3/*vs/base/common/event*/,12/*vs/base/common/async*/,167/*vs/workbench/services/backup/common/backup*/,123/*vs/editor/common/services/resourceConfiguration*/,122/*vs/editor/common/model/textModel*/]), function (require, exports, winjs_base_1, textEditorModel_1, modesRegistry_1, files_1, modeService_1, modelService_1, event_1, async_1, backup_1, resourceConfiguration_1, textModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var UntitledEditorModel = /** @class */ (function (_super) {
        __extends(UntitledEditorModel, _super);
        function UntitledEditorModel(modeId, resource, hasAssociatedFilePath, initialValue, preferredEncoding, modeService, modelService, backupFileService, configurationService) {
            var _this = _super.call(this, modelService, modeService) || this;
            _this.modeId = modeId;
            _this.resource = resource;
            _this.hasAssociatedFilePath = hasAssociatedFilePath;
            _this.initialValue = initialValue;
            _this.preferredEncoding = preferredEncoding;
            _this.backupFileService = backupFileService;
            _this.configurationService = configurationService;
            _this._onDidChangeContent = _this._register(new event_1.Emitter());
            _this._onDidChangeDirty = _this._register(new event_1.Emitter());
            _this._onDidChangeEncoding = _this._register(new event_1.Emitter());
            _this.dirty = false;
            _this.versionId = 0;
            _this.contentChangeEventScheduler = _this._register(new async_1.RunOnceScheduler(function () { return _this._onDidChangeContent.fire(); }, UntitledEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY));
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(UntitledEditorModel.prototype, "onDidChangeContent", {
            get: function () { return this._onDidChangeContent.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorModel.prototype, "onDidChangeDirty", {
            get: function () { return this._onDidChangeDirty.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorModel.prototype, "onDidChangeEncoding", {
            get: function () { return this._onDidChangeEncoding.event; },
            enumerable: true,
            configurable: true
        });
        UntitledEditorModel.prototype.getOrCreateMode = function (modeService, modeId, firstLineText) {
            if (!modeId || modeId === modesRegistry_1.PLAINTEXT_MODE_ID) {
                return modeService.getOrCreateModeByFilenameOrFirstLine(this.resource.fsPath, firstLineText); // lookup mode via resource path if the provided modeId is unspecific
            }
            return _super.prototype.getOrCreateMode.call(this, modeService, modeId, firstLineText);
        };
        UntitledEditorModel.prototype.registerListeners = function () {
            var _this = this;
            // Config Changes
            this._register(this.configurationService.onDidChangeConfiguration(function (e) { return _this.onConfigurationChange(); }));
        };
        UntitledEditorModel.prototype.onConfigurationChange = function () {
            var configuredEncoding = this.configurationService.getValue(this.resource, 'files.encoding');
            if (this.configuredEncoding !== configuredEncoding) {
                this.configuredEncoding = configuredEncoding;
                if (!this.preferredEncoding) {
                    this._onDidChangeEncoding.fire(); // do not fire event if we have a preferred encoding set
                }
            }
        };
        UntitledEditorModel.prototype.getVersionId = function () {
            return this.versionId;
        };
        UntitledEditorModel.prototype.getModeId = function () {
            if (this.textEditorModel) {
                return this.textEditorModel.getLanguageIdentifier().language;
            }
            return null;
        };
        UntitledEditorModel.prototype.getEncoding = function () {
            return this.preferredEncoding || this.configuredEncoding;
        };
        UntitledEditorModel.prototype.setEncoding = function (encoding) {
            var oldEncoding = this.getEncoding();
            this.preferredEncoding = encoding;
            // Emit if it changed
            if (oldEncoding !== this.preferredEncoding) {
                this._onDidChangeEncoding.fire();
            }
        };
        UntitledEditorModel.prototype.isDirty = function () {
            return this.dirty;
        };
        // {{SQL CARBON EDIT}}
        // make property public
        UntitledEditorModel.prototype.setDirty = function (dirty) {
            if (this.dirty === dirty) {
                return;
            }
            this.dirty = dirty;
            this._onDidChangeDirty.fire();
        };
        UntitledEditorModel.prototype.getResource = function () {
            return this.resource;
        };
        UntitledEditorModel.prototype.revert = function () {
            this.setDirty(false);
            // Handle content change event buffered
            this.contentChangeEventScheduler.schedule();
        };
        UntitledEditorModel.prototype.load = function () {
            var _this = this;
            // Check for backups first
            return this.backupFileService.loadBackupResource(this.resource).then(function (backupResource) {
                if (backupResource) {
                    return _this.backupFileService.resolveBackupContent(backupResource);
                }
                return null;
            }).then(function (backupTextBufferFactory) {
                var hasBackup = !!backupTextBufferFactory;
                // untitled associated to file path are dirty right away as well as untitled with content
                _this.setDirty(_this.hasAssociatedFilePath || hasBackup);
                var untitledContents;
                if (backupTextBufferFactory) {
                    untitledContents = backupTextBufferFactory;
                }
                else {
                    untitledContents = textModel_1.createTextBufferFactory(_this.initialValue || '');
                }
                return _this.doLoad(untitledContents).then(function (model) {
                    // Encoding
                    _this.configuredEncoding = _this.configurationService.getValue(_this.resource, 'files.encoding');
                    // Listen to content changes
                    _this._register(_this.textEditorModel.onDidChangeContent(function () { return _this.onModelContentChanged(); }));
                    // Listen to mode changes
                    _this._register(_this.textEditorModel.onDidChangeLanguage(function () { return _this.onConfigurationChange(); })); // mode change can have impact on config
                    return model;
                });
            });
        };
        UntitledEditorModel.prototype.doLoad = function (content) {
            var _this = this;
            // Create text editor model if not yet done
            if (!this.textEditorModel) {
                return this.createTextEditorModel(content, this.resource, this.modeId).then(function (model) { return _this; });
            }
            // Otherwise update
            else {
                this.updateTextEditorModel(content);
            }
            return winjs_base_1.TPromise.as(this);
        };
        UntitledEditorModel.prototype.onModelContentChanged = function () {
            this.versionId++;
            // mark the untitled editor as non-dirty once its content becomes empty and we do
            // not have an associated path set. we never want dirty indicator in that case.
            if (!this.hasAssociatedFilePath && this.textEditorModel.getLineCount() === 1 && this.textEditorModel.getLineContent(1) === '') {
                this.setDirty(false);
            }
            // turn dirty otherwise
            else {
                this.setDirty(true);
            }
            // Handle content change event buffered
            this.contentChangeEventScheduler.schedule();
        };
        UntitledEditorModel.prototype.isReadonly = function () {
            return false;
        };
        UntitledEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY = files_1.CONTENT_CHANGE_EVENT_BUFFER_DELAY;
        UntitledEditorModel = __decorate([
            __param(5, modeService_1.IModeService),
            __param(6, modelService_1.IModelService),
            __param(7, backup_1.IBackupFileService),
            __param(8, resourceConfiguration_1.ITextResourceConfigurationService)
        ], UntitledEditorModel);
        return UntitledEditorModel;
    }(textEditorModel_1.BaseTextEditorModel));
    exports.UntitledEditorModel = UntitledEditorModel;
});











define(__m[169/*vs/workbench/services/configuration/common/configurationModels*/], __M([0/*require*/,1/*exports*/,20/*vs/base/common/objects*/,30/*vs/platform/configuration/common/configuration*/,70/*vs/platform/configuration/common/configurationModels*/,31/*vs/platform/registry/common/platform*/,40/*vs/platform/configuration/common/configurationRegistry*/,21/*vs/base/common/map*/]), function (require, exports, objects_1, configuration_1, configurationModels_1, platform_1, configurationRegistry_1, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var WorkspaceConfigurationModelParser = /** @class */ (function (_super) {
        __extends(WorkspaceConfigurationModelParser, _super);
        function WorkspaceConfigurationModelParser(name) {
            var _this = _super.call(this, name) || this;
            _this._folders = [];
            _this._settingsModelParser = new FolderSettingsModelParser(name, [configurationRegistry_1.ConfigurationScope.WINDOW, configurationRegistry_1.ConfigurationScope.RESOURCE]);
            _this._launchModel = new configurationModels_1.ConfigurationModel();
            return _this;
        }
        Object.defineProperty(WorkspaceConfigurationModelParser.prototype, "folders", {
            get: function () {
                return this._folders;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspaceConfigurationModelParser.prototype, "settingsModel", {
            get: function () {
                return this._settingsModelParser.configurationModel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspaceConfigurationModelParser.prototype, "launchModel", {
            get: function () {
                return this._launchModel;
            },
            enumerable: true,
            configurable: true
        });
        WorkspaceConfigurationModelParser.prototype.reprocessWorkspaceSettings = function () {
            this._settingsModelParser.reprocess();
        };
        WorkspaceConfigurationModelParser.prototype.parseRaw = function (raw) {
            this._folders = (raw['folders'] || []);
            this._settingsModelParser.parse(raw['settings']);
            this._launchModel = this.createConfigurationModelFrom(raw, 'launch');
            return _super.prototype.parseRaw.call(this, raw);
        };
        WorkspaceConfigurationModelParser.prototype.createConfigurationModelFrom = function (raw, key) {
            var _this = this;
            var data = raw[key];
            if (data) {
                var contents = configuration_1.toValuesTree(data, function (message) { return console.error("Conflict in settings file " + _this._name + ": " + message); });
                var scopedContents = Object.create(null);
                scopedContents[key] = contents;
                var keys = Object.keys(data).map(function (k) { return key + "." + k; });
                return new configurationModels_1.ConfigurationModel(scopedContents, keys, []);
            }
            return new configurationModels_1.ConfigurationModel();
        };
        return WorkspaceConfigurationModelParser;
    }(configurationModels_1.ConfigurationModelParser));
    exports.WorkspaceConfigurationModelParser = WorkspaceConfigurationModelParser;
    var StandaloneConfigurationModelParser = /** @class */ (function (_super) {
        __extends(StandaloneConfigurationModelParser, _super);
        function StandaloneConfigurationModelParser(name, scope) {
            var _this = _super.call(this, name) || this;
            _this.scope = scope;
            return _this;
        }
        StandaloneConfigurationModelParser.prototype.parseRaw = function (raw) {
            var _this = this;
            var contents = configuration_1.toValuesTree(raw, function (message) { return console.error("Conflict in settings file " + _this._name + ": " + message); });
            var scopedContents = Object.create(null);
            scopedContents[this.scope] = contents;
            var keys = Object.keys(raw).map(function (key) { return _this.scope + "." + key; });
            return { contents: scopedContents, keys: keys, overrides: [] };
        };
        return StandaloneConfigurationModelParser;
    }(configurationModels_1.ConfigurationModelParser));
    exports.StandaloneConfigurationModelParser = StandaloneConfigurationModelParser;
    var FolderSettingsModelParser = /** @class */ (function (_super) {
        __extends(FolderSettingsModelParser, _super);
        function FolderSettingsModelParser(name, scopes) {
            var _this = _super.call(this, name) || this;
            _this.scopes = scopes;
            return _this;
        }
        FolderSettingsModelParser.prototype.parse = function (content) {
            this._raw = typeof content === 'string' ? this.parseContent(content) : content;
            this.parseWorkspaceSettings(this._raw);
        };
        Object.defineProperty(FolderSettingsModelParser.prototype, "configurationModel", {
            get: function () {
                return this._settingsModel || new configurationModels_1.ConfigurationModel();
            },
            enumerable: true,
            configurable: true
        });
        FolderSettingsModelParser.prototype.reprocess = function () {
            this.parse(this._raw);
        };
        FolderSettingsModelParser.prototype.parseWorkspaceSettings = function (rawSettings) {
            var configurationProperties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
            var rawWorkspaceSettings = this.filterByScope(rawSettings, configurationProperties, true);
            var configurationModel = this.parseRaw(rawWorkspaceSettings);
            this._settingsModel = new configurationModels_1.ConfigurationModel(configurationModel.contents, configurationModel.keys, configurationModel.overrides);
        };
        FolderSettingsModelParser.prototype.filterByScope = function (properties, configurationProperties, filterOverriddenProperties) {
            var result = {};
            for (var key in properties) {
                if (configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key) && filterOverriddenProperties) {
                    result[key] = this.filterByScope(properties[key], configurationProperties, false);
                }
                else {
                    var scope = this.getScope(key, configurationProperties);
                    if (this.scopes.indexOf(scope) !== -1) {
                        result[key] = properties[key];
                    }
                }
            }
            return result;
        };
        FolderSettingsModelParser.prototype.getScope = function (key, configurationProperties) {
            var propertySchema = configurationProperties[key];
            return propertySchema ? propertySchema.scope : configurationRegistry_1.ConfigurationScope.WINDOW;
        };
        return FolderSettingsModelParser;
    }(configurationModels_1.ConfigurationModelParser));
    exports.FolderSettingsModelParser = FolderSettingsModelParser;
    var Configuration = /** @class */ (function (_super) {
        __extends(Configuration, _super);
        function Configuration(defaults, user, workspaceConfiguration, folders, memoryConfiguration, memoryConfigurationByResource, _workspace) {
            var _this = _super.call(this, defaults, user, workspaceConfiguration, folders, memoryConfiguration, memoryConfigurationByResource) || this;
            _this._workspace = _workspace;
            return _this;
        }
        Configuration.prototype.getValue = function (key, overrides) {
            if (overrides === void 0) { overrides = {}; }
            return _super.prototype.getValue.call(this, key, overrides, this._workspace);
        };
        Configuration.prototype.inspect = function (key, overrides) {
            if (overrides === void 0) { overrides = {}; }
            return _super.prototype.inspect.call(this, key, overrides, this._workspace);
        };
        Configuration.prototype.keys = function () {
            return _super.prototype.keys.call(this, this._workspace);
        };
        Configuration.prototype.compareAndUpdateUserConfiguration = function (user) {
            var _a = configuration_1.compare(this.user, user), added = _a.added, updated = _a.updated, removed = _a.removed;
            var changedKeys = added.concat(updated, removed);
            if (changedKeys.length) {
                _super.prototype.updateUserConfiguration.call(this, user);
            }
            return new configurationModels_1.ConfigurationChangeEvent().change(changedKeys);
        };
        Configuration.prototype.compareAndUpdateWorkspaceConfiguration = function (workspaceConfiguration) {
            var _a = configuration_1.compare(this.workspace, workspaceConfiguration), added = _a.added, updated = _a.updated, removed = _a.removed;
            var changedKeys = added.concat(updated, removed);
            if (changedKeys.length) {
                _super.prototype.updateWorkspaceConfiguration.call(this, workspaceConfiguration);
            }
            return new configurationModels_1.ConfigurationChangeEvent().change(changedKeys);
        };
        Configuration.prototype.compareAndUpdateFolderConfiguration = function (resource, folderConfiguration) {
            var currentFolderConfiguration = this.folders.get(resource);
            if (currentFolderConfiguration) {
                var _a = configuration_1.compare(currentFolderConfiguration, folderConfiguration), added = _a.added, updated = _a.updated, removed = _a.removed;
                var changedKeys = added.concat(updated, removed);
                if (changedKeys.length) {
                    _super.prototype.updateFolderConfiguration.call(this, resource, folderConfiguration);
                }
                return new configurationModels_1.ConfigurationChangeEvent().change(changedKeys, resource);
            }
            else {
                _super.prototype.updateFolderConfiguration.call(this, resource, folderConfiguration);
                return new configurationModels_1.ConfigurationChangeEvent().change(folderConfiguration.keys, resource);
            }
        };
        Configuration.prototype.compareAndDeleteFolderConfiguration = function (folder) {
            if (this._workspace && this._workspace.folders.length > 0 && this._workspace.folders[0].uri.toString() === folder.toString()) {
                // Do not remove workspace configuration
                return new configurationModels_1.ConfigurationChangeEvent();
            }
            var keys = this.folders.get(folder).keys;
            _super.prototype.deleteFolderConfiguration.call(this, folder);
            return new configurationModels_1.ConfigurationChangeEvent().change(keys, folder);
        };
        Configuration.prototype.compare = function (other) {
            var _this = this;
            var result = [];
            var _loop_1 = function (key) {
                if (!objects_1.equals(this_1.getValue(key), other.getValue(key))
                    || (this_1._workspace && this_1._workspace.folders.some(function (folder) { return !objects_1.equals(_this.getValue(key, { resource: folder.uri }), other.getValue(key, { resource: folder.uri })); }))) {
                    result.push(key);
                }
            };
            var this_1 = this;
            for (var _i = 0, _a = this.allKeys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _loop_1(key);
            }
            return result;
        };
        Configuration.prototype.allKeys = function () {
            return _super.prototype.allKeys.call(this, this._workspace);
        };
        return Configuration;
    }(configurationModels_1.Configuration));
    exports.Configuration = Configuration;
    var AllKeysConfigurationChangeEvent = /** @class */ (function (_super) {
        __extends(AllKeysConfigurationChangeEvent, _super);
        function AllKeysConfigurationChangeEvent(_configuration, source, sourceConfig) {
            var _this = _super.call(this) || this;
            _this._configuration = _configuration;
            _this.source = source;
            _this.sourceConfig = sourceConfig;
            _this._changedConfiguration = null;
            return _this;
        }
        Object.defineProperty(AllKeysConfigurationChangeEvent.prototype, "changedConfiguration", {
            get: function () {
                if (!this._changedConfiguration) {
                    this._changedConfiguration = new configurationModels_1.ConfigurationModel();
                    this.updateKeys(this._changedConfiguration, this.affectedKeys);
                }
                return this._changedConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AllKeysConfigurationChangeEvent.prototype, "changedConfigurationByResource", {
            get: function () {
                return new map_1.ResourceMap();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AllKeysConfigurationChangeEvent.prototype, "affectedKeys", {
            get: function () {
                return this._configuration.allKeys();
            },
            enumerable: true,
            configurable: true
        });
        AllKeysConfigurationChangeEvent.prototype.affectsConfiguration = function (config, resource) {
            return this.doesConfigurationContains(this.changedConfiguration, config);
        };
        return AllKeysConfigurationChangeEvent;
    }(configurationModels_1.AbstractConfigurationChangeEvent));
    exports.AllKeysConfigurationChangeEvent = AllKeysConfigurationChangeEvent;
    var WorkspaceConfigurationChangeEvent = /** @class */ (function () {
        function WorkspaceConfigurationChangeEvent(configurationChangeEvent, workspace) {
            this.configurationChangeEvent = configurationChangeEvent;
            this.workspace = workspace;
        }
        Object.defineProperty(WorkspaceConfigurationChangeEvent.prototype, "changedConfiguration", {
            get: function () {
                return this.configurationChangeEvent.changedConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspaceConfigurationChangeEvent.prototype, "changedConfigurationByResource", {
            get: function () {
                return this.configurationChangeEvent.changedConfigurationByResource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspaceConfigurationChangeEvent.prototype, "affectedKeys", {
            get: function () {
                return this.configurationChangeEvent.affectedKeys;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspaceConfigurationChangeEvent.prototype, "source", {
            get: function () {
                return this.configurationChangeEvent.source;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspaceConfigurationChangeEvent.prototype, "sourceConfig", {
            get: function () {
                return this.configurationChangeEvent.sourceConfig;
            },
            enumerable: true,
            configurable: true
        });
        WorkspaceConfigurationChangeEvent.prototype.affectsConfiguration = function (config, resource) {
            if (this.configurationChangeEvent.affectsConfiguration(config, resource)) {
                return true;
            }
            if (resource && this.workspace) {
                var workspaceFolder = this.workspace.getFolder(resource);
                if (workspaceFolder) {
                    return this.configurationChangeEvent.affectsConfiguration(config, workspaceFolder.uri);
                }
            }
            return false;
        };
        return WorkspaceConfigurationChangeEvent;
    }());
    exports.WorkspaceConfigurationChangeEvent = WorkspaceConfigurationChangeEvent;
});

define(__m[170/*vs/workbench/api/node/extHostConfiguration*/], __M([0/*require*/,1/*exports*/,20/*vs/base/common/objects*/,4/*vs/base/common/uri*/,3/*vs/base/common/event*/,5/*vs/workbench/api/node/extHostTypes*/,30/*vs/platform/configuration/common/configuration*/,70/*vs/platform/configuration/common/configurationModels*/,169/*vs/workbench/services/configuration/common/configurationModels*/,21/*vs/base/common/map*/,40/*vs/platform/configuration/common/configurationRegistry*/,18/*vs/base/common/types*/]), function (require, exports, objects_1, uri_1, event_1, extHostTypes_1, configuration_1, configurationModels_1, configurationModels_2, map_1, configurationRegistry_1, types_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function lookUp(tree, key) {
        if (key) {
            var parts = key.split('.');
            var node = tree;
            for (var i = 0; node && i < parts.length; i++) {
                node = node[parts[i]];
            }
            return node;
        }
    }
    var ExtHostConfiguration = /** @class */ (function () {
        function ExtHostConfiguration(proxy, extHostWorkspace, data) {
            this._onDidChangeConfiguration = new event_1.Emitter();
            this._proxy = proxy;
            this._extHostWorkspace = extHostWorkspace;
            this._configuration = ExtHostConfiguration.parse(data);
            this._configurationScopes = data.configurationScopes;
        }
        Object.defineProperty(ExtHostConfiguration.prototype, "onDidChangeConfiguration", {
            get: function () {
                return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostConfiguration.prototype.$acceptConfigurationChanged = function (data, eventData) {
            this._configuration = ExtHostConfiguration.parse(data);
            this._onDidChangeConfiguration.fire(this._toConfigurationChangeEvent(eventData));
        };
        ExtHostConfiguration.prototype.getConfiguration = function (section, resource, extensionId) {
            var _this = this;
            var config = this._toReadonlyValue(section
                ? lookUp(this._configuration.getValue(null, { resource: resource }, this._extHostWorkspace.workspace), section)
                : this._configuration.getValue(null, { resource: resource }, this._extHostWorkspace.workspace));
            if (section) {
                this._validateConfigurationAccess(section, resource, extensionId);
            }
            function parseConfigurationTarget(arg) {
                if (arg === void 0 || arg === null) {
                    return null;
                }
                if (typeof arg === 'boolean') {
                    return arg ? configuration_1.ConfigurationTarget.USER : configuration_1.ConfigurationTarget.WORKSPACE;
                }
                switch (arg) {
                    case extHostTypes_1.ConfigurationTarget.Global: return configuration_1.ConfigurationTarget.USER;
                    case extHostTypes_1.ConfigurationTarget.Workspace: return configuration_1.ConfigurationTarget.WORKSPACE;
                    case extHostTypes_1.ConfigurationTarget.WorkspaceFolder: return configuration_1.ConfigurationTarget.WORKSPACE_FOLDER;
                }
            }
            var result = {
                has: function (key) {
                    return typeof lookUp(config, key) !== 'undefined';
                },
                get: function (key, defaultValue) {
                    _this._validateConfigurationAccess(section ? section + "." + key : key, resource, extensionId);
                    var result = lookUp(config, key);
                    if (typeof result === 'undefined') {
                        result = defaultValue;
                    }
                    else {
                        var clonedConfig_1 = void 0;
                        var cloneOnWriteProxy_1 = function (target, accessor) {
                            var clonedTarget = void 0;
                            var cloneTarget = function () {
                                clonedConfig_1 = clonedConfig_1 ? clonedConfig_1 : objects_1.deepClone(config);
                                clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig_1, accessor);
                            };
                            return types_1.isObject(target) ?
                                new Proxy(target, {
                                    get: function (target, property) {
                                        if (typeof property === 'string' && property.toLowerCase() === 'tojson') {
                                            cloneTarget();
                                            return function () { return clonedTarget; };
                                        }
                                        if (clonedConfig_1) {
                                            clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig_1, accessor);
                                            return clonedTarget[property];
                                        }
                                        var result = target[property];
                                        if (typeof property === 'string') {
                                            return cloneOnWriteProxy_1(result, accessor + "." + property);
                                        }
                                        return result;
                                    },
                                    set: function (_target, property, value) {
                                        cloneTarget();
                                        clonedTarget[property] = value;
                                        return true;
                                    },
                                    deleteProperty: function (_target, property) {
                                        cloneTarget();
                                        delete clonedTarget[property];
                                        return true;
                                    },
                                    defineProperty: function (_target, property, descriptor) {
                                        cloneTarget();
                                        Object.defineProperty(clonedTarget, property, descriptor);
                                        return true;
                                    }
                                }) : target;
                        };
                        result = cloneOnWriteProxy_1(result, key);
                    }
                    return result;
                },
                update: function (key, value, arg) {
                    key = section ? section + "." + key : key;
                    var target = parseConfigurationTarget(arg);
                    if (value !== void 0) {
                        return _this._proxy.$updateConfigurationOption(target, key, value, resource);
                    }
                    else {
                        return _this._proxy.$removeConfigurationOption(target, key, resource);
                    }
                },
                inspect: function (key) {
                    key = section ? section + "." + key : key;
                    var config = objects_1.deepClone(_this._configuration.inspect(key, { resource: resource }, _this._extHostWorkspace.workspace));
                    if (config) {
                        return {
                            key: key,
                            defaultValue: config.default,
                            globalValue: config.user,
                            workspaceValue: config.workspace,
                            workspaceFolderValue: config.workspaceFolder
                        };
                    }
                    return undefined;
                }
            };
            if (typeof config === 'object') {
                objects_1.mixin(result, config, false);
            }
            return Object.freeze(result);
        };
        ExtHostConfiguration.prototype._toReadonlyValue = function (result) {
            var readonlyProxy = function (target) {
                return types_1.isObject(target) ?
                    new Proxy(target, {
                        get: function (target, property) { return readonlyProxy(target[property]); },
                        set: function (_target, property, _value) { throw new Error("TypeError: Cannot assign to read only property '" + property + "' of object"); },
                        deleteProperty: function (_target, property) { throw new Error("TypeError: Cannot delete read only property '" + property + "' of object"); },
                        defineProperty: function (_target, property) { throw new Error("TypeError: Cannot define property '" + property + "' for a readonly object"); },
                        setPrototypeOf: function (_target) { throw new Error("TypeError: Cannot set prototype for a readonly object"); },
                        isExtensible: function () { return false; },
                        preventExtensions: function () { return true; }
                    }) : target;
            };
            return readonlyProxy(result);
        };
        ExtHostConfiguration.prototype._validateConfigurationAccess = function (key, resource, extensionId) {
            var scope = configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key) ? configurationRegistry_1.ConfigurationScope.RESOURCE : this._configurationScopes[key];
            var extensionIdText = extensionId ? "[" + extensionId + "] " : '';
            if (configurationRegistry_1.ConfigurationScope.RESOURCE === scope) {
                if (resource === void 0) {
                    console.warn(extensionIdText + "Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '" + key + "', provide the URI of a resource or 'null' for any resource.");
                }
                return;
            }
            if (configurationRegistry_1.ConfigurationScope.WINDOW === scope) {
                if (resource) {
                    console.warn(extensionIdText + "Accessing a window scoped configuration for a resource is not expected. To associate '" + key + "' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.");
                }
                return;
            }
        };
        ExtHostConfiguration.prototype._toConfigurationChangeEvent = function (data) {
            var changedConfiguration = new configurationModels_1.ConfigurationModel(data.changedConfiguration.contents, data.changedConfiguration.keys, data.changedConfiguration.overrides);
            var changedConfigurationByResource = new map_1.ResourceMap();
            for (var _i = 0, _a = Object.keys(data.changedConfigurationByResource); _i < _a.length; _i++) {
                var key = _a[_i];
                var resource = uri_1.default.parse(key);
                var model = data.changedConfigurationByResource[key];
                changedConfigurationByResource.set(resource, new configurationModels_1.ConfigurationModel(model.contents, model.keys, model.overrides));
            }
            var event = new configurationModels_2.WorkspaceConfigurationChangeEvent(new configurationModels_1.ConfigurationChangeEvent(changedConfiguration, changedConfigurationByResource), this._extHostWorkspace.workspace);
            return Object.freeze({
                affectsConfiguration: function (section, resource) { return event.affectsConfiguration(section, resource); }
            });
        };
        ExtHostConfiguration.parse = function (data) {
            var defaultConfiguration = ExtHostConfiguration.parseConfigurationModel(data.defaults);
            var userConfiguration = ExtHostConfiguration.parseConfigurationModel(data.user);
            var workspaceConfiguration = ExtHostConfiguration.parseConfigurationModel(data.workspace);
            var folders = Object.keys(data.folders).reduce(function (result, key) {
                result.set(uri_1.default.parse(key), ExtHostConfiguration.parseConfigurationModel(data.folders[key]));
                return result;
            }, new map_1.ResourceMap());
            return new configurationModels_1.Configuration(defaultConfiguration, userConfiguration, workspaceConfiguration, folders, new configurationModels_1.ConfigurationModel(), new map_1.ResourceMap(), false);
        };
        ExtHostConfiguration.parseConfigurationModel = function (model) {
            return new configurationModels_1.ConfigurationModel(model.contents, model.keys, model.overrides).freeze();
        };
        return ExtHostConfiguration;
    }());
    exports.ExtHostConfiguration = ExtHostConfiguration;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[171/*vs/workbench/services/editor/common/editorService*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IEditorService = instantiation_1.createDecorator('editorService');
    exports.ACTIVE_GROUP = -1;
    exports.SIDE_GROUP = -2;
});

define(__m[172/*vs/workbench/services/extensions/common/extensions*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IExtensionService = instantiation_1.createDecorator('extensionService');
    var ActivationTimes = /** @class */ (function () {
        function ActivationTimes(startup, codeLoadingTime, activateCallTime, activateResolvedTime, activationEvent) {
            this.startup = startup;
            this.codeLoadingTime = codeLoadingTime;
            this.activateCallTime = activateCallTime;
            this.activateResolvedTime = activateResolvedTime;
            this.activationEvent = activationEvent;
        }
        return ActivationTimes;
    }());
    exports.ActivationTimes = ActivationTimes;
    var ExtensionPointContribution = /** @class */ (function () {
        function ExtensionPointContribution(description, value) {
            this.description = description;
            this.value = value;
        }
        return ExtensionPointContribution;
    }());
    exports.ExtensionPointContribution = ExtensionPointContribution;
});

define(__m[173/*vs/workbench/services/extensions/node/extensionDescriptionRegistry*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var hasOwnProperty = Object.hasOwnProperty;
    var ExtensionDescriptionRegistry = /** @class */ (function () {
        function ExtensionDescriptionRegistry(extensionDescriptions) {
            this._extensionsMap = {};
            this._extensionsArr = [];
            this._activationMap = {};
            for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                var extensionDescription = extensionDescriptions[i];
                if (hasOwnProperty.call(this._extensionsMap, extensionDescription.id)) {
                    // No overwriting allowed!
                    console.error('Extension `' + extensionDescription.id + '` is already registered');
                    continue;
                }
                this._extensionsMap[extensionDescription.id] = extensionDescription;
                this._extensionsArr.push(extensionDescription);
                if (Array.isArray(extensionDescription.activationEvents)) {
                    for (var j = 0, lenJ = extensionDescription.activationEvents.length; j < lenJ; j++) {
                        var activationEvent = extensionDescription.activationEvents[j];
                        // TODO@joao: there's no easy way to contribute this
                        if (activationEvent === 'onUri') {
                            activationEvent = "onUri:" + extensionDescription.id;
                        }
                        this._activationMap[activationEvent] = this._activationMap[activationEvent] || [];
                        this._activationMap[activationEvent].push(extensionDescription);
                    }
                }
            }
        }
        ExtensionDescriptionRegistry.prototype.containsActivationEvent = function (activationEvent) {
            return hasOwnProperty.call(this._activationMap, activationEvent);
        };
        ExtensionDescriptionRegistry.prototype.getExtensionDescriptionsForActivationEvent = function (activationEvent) {
            if (!hasOwnProperty.call(this._activationMap, activationEvent)) {
                return [];
            }
            return this._activationMap[activationEvent].slice(0);
        };
        ExtensionDescriptionRegistry.prototype.getAllExtensionDescriptions = function () {
            return this._extensionsArr.slice(0);
        };
        ExtensionDescriptionRegistry.prototype.getExtensionDescription = function (extensionId) {
            if (!hasOwnProperty.call(this._extensionsMap, extensionId)) {
                return null;
            }
            return this._extensionsMap[extensionId];
        };
        return ExtensionDescriptionRegistry;
    }());
    exports.ExtensionDescriptionRegistry = ExtensionDescriptionRegistry;
});

define(__m[174/*vs/workbench/services/extensions/node/lazyPromise*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,14/*vs/base/common/errors*/]), function (require, exports, winjs_base_1, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var LazyPromise = /** @class */ (function () {
        function LazyPromise(onCancel) {
            this._onCancel = onCancel;
            this._actual = null;
            this._actualOk = null;
            this._actualErr = null;
            this._hasValue = false;
            this._value = null;
            this._hasErr = false;
            this._err = null;
            this._isCanceled = false;
        }
        LazyPromise.prototype._ensureActual = function () {
            var _this = this;
            if (!this._actual) {
                this._actual = new winjs_base_1.TPromise(function (c, e) {
                    _this._actualOk = c;
                    _this._actualErr = e;
                }, this._onCancel);
                if (this._hasValue) {
                    this._actualOk(this._value);
                }
                if (this._hasErr) {
                    this._actualErr(this._err);
                }
            }
            return this._actual;
        };
        LazyPromise.prototype.resolveOk = function (value) {
            if (this._isCanceled || this._hasErr) {
                return;
            }
            this._hasValue = true;
            this._value = value;
            if (this._actual) {
                this._actualOk(value);
            }
        };
        LazyPromise.prototype.resolveErr = function (err) {
            if (this._isCanceled || this._hasValue) {
                return;
            }
            this._hasErr = true;
            this._err = err;
            if (this._actual) {
                this._actualErr(err);
            }
            else {
                // If nobody's listening at this point, it is safe to assume they never will,
                // since resolving this promise is always "async"
                errors_1.onUnexpectedError(err);
            }
        };
        LazyPromise.prototype.then = function (success, error) {
            if (this._isCanceled) {
                return;
            }
            return this._ensureActual().then(success, error);
        };
        LazyPromise.prototype.done = function (success, error) {
            if (this._isCanceled) {
                return;
            }
            this._ensureActual().done(success, error);
        };
        LazyPromise.prototype.cancel = function () {
            if (this._hasValue || this._hasErr) {
                return;
            }
            this._isCanceled = true;
            if (this._actual) {
                this._actual.cancel();
            }
            else {
                this._onCancel();
            }
        };
        return LazyPromise;
    }());
    exports.LazyPromise = LazyPromise;
});

define(__m[79/*vs/workbench/services/extensions/node/proxyIdentifier*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProxyIdentifier = /** @class */ (function () {
        function ProxyIdentifier(isMain, id) {
            this.isMain = isMain;
            this.id = id;
        }
        return ProxyIdentifier;
    }());
    exports.ProxyIdentifier = ProxyIdentifier;
    /**
     * Using `isFancy` indicates that arguments or results of type `URI` or `RegExp`
     * will be serialized/deserialized automatically, but this has a performance cost,
     * as each argument/result must be visited.
     */
    function createMainContextProxyIdentifier(identifier) {
        return new ProxyIdentifier(true, 'm' + identifier);
    }
    exports.createMainContextProxyIdentifier = createMainContextProxyIdentifier;
    function createExtHostContextProxyIdentifier(identifier) {
        return new ProxyIdentifier(false, 'e' + identifier);
    }
    exports.createExtHostContextProxyIdentifier = createExtHostContextProxyIdentifier;
});

define(__m[11/*sql/workbench/api/node/sqlExtHost.protocol*/], __M([0/*require*/,1/*exports*/,79/*vs/workbench/services/extensions/node/proxyIdentifier*/]), function (require, exports, proxyIdentifier_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostAccountManagementShape = /** @class */ (function () {
        function ExtHostAccountManagementShape() {
        }
        ExtHostAccountManagementShape.prototype.$autoOAuthCancelled = function (handle) { throw ni(); };
        ExtHostAccountManagementShape.prototype.$clear = function (handle, accountKey) { throw ni(); };
        ExtHostAccountManagementShape.prototype.$getSecurityToken = function (account, resource) { throw ni(); };
        ExtHostAccountManagementShape.prototype.$initialize = function (handle, restoredAccounts) { throw ni(); };
        ExtHostAccountManagementShape.prototype.$prompt = function (handle) { throw ni(); };
        ExtHostAccountManagementShape.prototype.$refresh = function (handle, account) { throw ni(); };
        ExtHostAccountManagementShape.prototype.$accountsChanged = function (handle, accounts) { throw ni(); };
        return ExtHostAccountManagementShape;
    }());
    exports.ExtHostAccountManagementShape = ExtHostAccountManagementShape;
    var ExtHostConnectionManagementShape = /** @class */ (function () {
        function ExtHostConnectionManagementShape() {
        }
        ExtHostConnectionManagementShape.prototype.$onConnectionOpened = function (handleId, connection) { throw ni; };
        return ExtHostConnectionManagementShape;
    }());
    exports.ExtHostConnectionManagementShape = ExtHostConnectionManagementShape;
    var ExtHostDataProtocolShape = /** @class */ (function () {
        function ExtHostDataProtocolShape() {
        }
        /**
         * Establish a connection to a data source using the provided ConnectionInfo instance.
         */
        ExtHostDataProtocolShape.prototype.$connect = function (handle, connectionUri, connection) { throw ni(); };
        /**
         * Disconnect from a data source using the provided connectionUri string.
         */
        ExtHostDataProtocolShape.prototype.$disconnect = function (handle, connectionUri) { throw ni(); };
        /**
         * Cancel a connection to a data source using the provided connectionUri string.
         */
        ExtHostDataProtocolShape.prototype.$cancelConnect = function (handle, connectionUri) { throw ni(); };
        /**
         * Change the database for the connection.
         */
        ExtHostDataProtocolShape.prototype.$changeDatabase = function (handle, connectionUri, newDatabase) { throw ni(); };
        /**
         * List databases for a data source using the provided connectionUri string.
         * @param handle the handle to use when looking up a provider
         * @param connectionUri URI identifying a connected resource
         */
        ExtHostDataProtocolShape.prototype.$listDatabases = function (handle, connectionUri) { throw ni(); };
        /**
         * Get the connection string for the connection specified by connectionUri
         * @param handle the handle to use when looking up a provider
         * @param connectionUri URI identifying a connected resource
         */
        ExtHostDataProtocolShape.prototype.$getConnectionString = function (handle, connectionUri, includePassword) { throw ni(); };
        /**
         * Serialize connection string
         * @param handle the handle to use when looking up a provider
         * @param connectionString the connection string to serialize
         */
        ExtHostDataProtocolShape.prototype.$buildConnectionInfo = function (handle, connectionString) { throw ni(); };
        /**
         * Notifies all listeners on the Extension Host side that a language change occurred
         * for a dataprotocol language. The sub-flavor is the specific implementation used for query
         * and other events
         * @param params information on what URI was changed and the new language
         */
        ExtHostDataProtocolShape.prototype.$languageFlavorChanged = function (params) { throw ni(); };
        /**
         * Callback when a connection request has completed
         */
        ExtHostDataProtocolShape.prototype.$onConnectComplete = function (handle, connectionInfoSummary) { throw ni(); };
        /**
         * Callback when a IntelliSense cache has been built
         */
        ExtHostDataProtocolShape.prototype.$onIntelliSenseCacheComplete = function (handle, connectionUri) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$getServerCapabilities = function (handle, client) { throw ni(); };
        /**
         * Metadata service methods
         *
         */
        ExtHostDataProtocolShape.prototype.$getMetadata = function (handle, connectionUri) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$getDatabases = function (handle, connectionUri) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$getTableInfo = function (handle, connectionUri, metadata) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$getViewInfo = function (handle, connectionUri, metadata) { throw ni(); };
        /**
         * Object Explorer
         */
        ExtHostDataProtocolShape.prototype.$createObjectExplorerSession = function (handle, connInfo) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$expandObjectExplorerNode = function (handle, nodeInfo) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$refreshObjectExplorerNode = function (handle, nodeInfo) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$closeObjectExplorerSession = function (handle, closeSessionInfo) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$findNodes = function (handle, findNodesInfo) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$createObjectExplorerNodeProviderSession = function (handle, sessionInfo) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$handleSessionClose = function (handle, closeSessionInfo) { throw ni(); };
        /**
         * Tasks
         */
        ExtHostDataProtocolShape.prototype.$getAllTasks = function (handle, listTasksParams) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$cancelTask = function (handle, cancelTaskParams) { throw ni(); };
        /**
         * Scripting methods
         */
        ExtHostDataProtocolShape.prototype.$scriptAsOperation = function (handle, connectionUri, operation, metadata, paramDetails) { throw ni(); };
        /**
         * Cancels the currently running query for a URI
         */
        ExtHostDataProtocolShape.prototype.$cancelQuery = function (handle, ownerUri) { throw ni(); };
        /**
         * Runs a query for a text selection inside a document
         */
        ExtHostDataProtocolShape.prototype.$runQuery = function (handle, ownerUri, selection, runOptions) { throw ni(); };
        /**
         * Runs the current SQL statement query for a text document
         */
        ExtHostDataProtocolShape.prototype.$runQueryStatement = function (handle, ownerUri, line, column) { throw ni(); };
        /**
         * Runs a query for a provided query
         */
        ExtHostDataProtocolShape.prototype.$runQueryString = function (handle, ownerUri, queryString) { throw ni(); };
        /**
         * Runs a query for a provided query and returns result
         */
        ExtHostDataProtocolShape.prototype.$runQueryAndReturn = function (handle, ownerUri, queryString) { throw ni(); };
        /**
         * Parses a T-SQL string without actually executing it
         */
        ExtHostDataProtocolShape.prototype.$parseSyntax = function (handle, ownerUri, query) { throw ni(); };
        /**
         * Gets a subset of rows in a result set in order to display in the UI
         */
        ExtHostDataProtocolShape.prototype.$getQueryRows = function (handle, rowData) { throw ni(); };
        /**
         * Disposes the cached information regarding a query
         */
        ExtHostDataProtocolShape.prototype.$disposeQuery = function (handle, ownerUri) { throw ni(); };
        /**
         * Refreshes the IntelliSense cache
         */
        ExtHostDataProtocolShape.prototype.$rebuildIntelliSenseCache = function (handle, ownerUri) { throw ni(); };
        /**
         * Callback when a query has completed
         */
        ExtHostDataProtocolShape.prototype.$onQueryComplete = function (handle, result) { throw ni(); };
        /**
         * Callback when a batch has started. This enables the UI to display when batch execution has started
         */
        ExtHostDataProtocolShape.prototype.$onBatchStart = function (handle, batchInfo) { throw ni(); };
        /**
         * Callback when a batch is complete. This includes updated information on result sets, time to execute, and
         * other relevant batch information
         */
        ExtHostDataProtocolShape.prototype.$onBatchComplete = function (handle, batchInfo) { throw ni(); };
        /**
         * Callback when a result set has been returned from query execution and can be displayed
         */
        ExtHostDataProtocolShape.prototype.$onResultSetAvailable = function (handle, resultSetInfo) { throw ni(); };
        /**
         * Callback when a result set has been returned from query execution and can be displayed
         */
        ExtHostDataProtocolShape.prototype.$onResultSetUpdate = function (handle, resultSetInfo) { throw ni(); };
        /**
         * Callback when a message generated during query execution is issued
         */
        ExtHostDataProtocolShape.prototype.$onQueryMessage = function (handle, message) { throw ni(); };
        /**
         * Requests saving of the results from a result set into a specific format (CSV, JSON, Excel)
         */
        ExtHostDataProtocolShape.prototype.$saveResults = function (handle, requestParams) { throw ni(); };
        /**
         * Commits all pending edits in an edit session
         */
        ExtHostDataProtocolShape.prototype.$commitEdit = function (handle, ownerUri) { throw ni(); };
        /**
         * Creates a new row in the edit session
         */
        ExtHostDataProtocolShape.prototype.$createRow = function (handle, ownerUri) { throw ni(); };
        /**
         * Marks the selected row for deletion in the edit session
         */
        ExtHostDataProtocolShape.prototype.$deleteRow = function (handle, ownerUri, rowId) { throw ni(); };
        /**
         * Initializes a new edit data session for the requested table/view
         */
        ExtHostDataProtocolShape.prototype.$initializeEdit = function (handle, ownerUri, schemaName, objectName, objectType, rowLimit, queryString) { throw ni(); };
        /**
         * Reverts any pending changes for the requested cell and returns the original value
         */
        ExtHostDataProtocolShape.prototype.$revertCell = function (handle, ownerUri, rowId, columnId) { throw ni(); };
        /**
         * Reverts any pending changes for the requested row
         */
        ExtHostDataProtocolShape.prototype.$revertRow = function (handle, ownerUri, rowId) { throw ni(); };
        /**
         * Updates a cell value in the requested row. Returns if there are any corrections to the value
         */
        ExtHostDataProtocolShape.prototype.$updateCell = function (handle, ownerUri, rowId, columId, newValue) { throw ni(); };
        /**
         * Gets a subset of rows in a result set, merging pending edit changes in order to display in the UI
         */
        ExtHostDataProtocolShape.prototype.$getEditRows = function (handle, rowData) { throw ni(); };
        /**
         * Diposes an initialized edit session and cleans up pending edits
         */
        ExtHostDataProtocolShape.prototype.$disposeEdit = function (handle, ownerUri) { throw ni(); };
        /**
         * Create a new database on the provided connection
         */
        ExtHostDataProtocolShape.prototype.$createDatabase = function (handle, connectionUri, database) { throw ni(); };
        /**
         * Get the default database prototype
         */
        ExtHostDataProtocolShape.prototype.$getDefaultDatabaseInfo = function (handle, connectionUri) { throw ni(); };
        /**
         * Get the database info
         */
        ExtHostDataProtocolShape.prototype.$getDatabaseInfo = function (handle, connectionUri) { throw ni(); };
        /**
         * Create a new login on the provided connection
         */
        ExtHostDataProtocolShape.prototype.$createLogin = function (handle, connectionUri, login) { throw ni(); };
        /**
         * Backup a database
         */
        ExtHostDataProtocolShape.prototype.$backup = function (handle, connectionUri, backupInfo, taskExecutionMode) { throw ni(); };
        /**
         * Get the extended database prototype
         */
        ExtHostDataProtocolShape.prototype.$getBackupConfigInfo = function (handle, connectionUri) { throw ni(); };
        /**
         * Restores a database
         */
        ExtHostDataProtocolShape.prototype.$restore = function (handle, connectionUri, restoreInfo) { throw ni(); };
        /**
         * Gets a plan for restoring a database
         */
        ExtHostDataProtocolShape.prototype.$getRestorePlan = function (handle, connectionUri, restoreInfo) { throw ni(); };
        /**
         * Cancels a plan
         */
        ExtHostDataProtocolShape.prototype.$cancelRestorePlan = function (handle, connectionUri, restoreInfo) { throw ni(); };
        /**
         * Gets restore config Info
         */
        ExtHostDataProtocolShape.prototype.$getRestoreConfigInfo = function (handle, connectionUri) { throw ni(); };
        /**
         * Open a file browser
         */
        ExtHostDataProtocolShape.prototype.$openFileBrowser = function (handle, ownerUri, expandPath, fileFilters, changeFilter) { throw ni(); };
        /**
         * Expand a folder node
         */
        ExtHostDataProtocolShape.prototype.$expandFolderNode = function (handle, ownerUri, expandPath) { throw ni(); };
        /**
         * Validate selected file paths
         */
        ExtHostDataProtocolShape.prototype.$validateFilePaths = function (handle, ownerUri, serviceType, selectedFiles) { throw ni(); };
        /**
         * Close file browser
         */
        ExtHostDataProtocolShape.prototype.$closeFileBrowser = function (handle, ownerUri) { throw ni(); };
        /**
         * Profiler Provider methods
         */
        /**
         * Create a profiler session
         */
        ExtHostDataProtocolShape.prototype.$createSession = function (handle, sessionId, createStatement, template) { throw ni(); };
        /**
         * Start a profiler session
         */
        ExtHostDataProtocolShape.prototype.$startSession = function (handle, sessionId, sessionName) { throw ni(); };
        /**
         * Stop a profiler session
         */
        ExtHostDataProtocolShape.prototype.$stopSession = function (handle, sessionId) { throw ni(); };
        /**
         * Pause a profiler session
         */
        ExtHostDataProtocolShape.prototype.$pauseSession = function (handle, sessionId) { throw ni(); };
        /**
         * Get list of running XEvent sessions on the profiler session's target server
         */
        ExtHostDataProtocolShape.prototype.$getXEventSessions = function (handle, sessionId) { throw ni(); };
        /**
         * Disconnect a profiler session
         */
        ExtHostDataProtocolShape.prototype.$disconnectSession = function (handle, sessionId) { throw ni(); };
        /**
         * Get Agent Job list
         */
        ExtHostDataProtocolShape.prototype.$getJobs = function (handle, ownerUri) { throw ni(); };
        /**
         * Get a Agent Job's history
         */
        ExtHostDataProtocolShape.prototype.$getJobHistory = function (handle, ownerUri, jobID, jobName) { throw ni(); };
        /**
         * Run an action on a Job
         */
        ExtHostDataProtocolShape.prototype.$jobAction = function (handle, ownerUri, jobName, action) { throw ni(); };
        /**
         * Deletes a job
         */
        ExtHostDataProtocolShape.prototype.$deleteJob = function (handle, ownerUri, job) { throw ni(); };
        /**
         * Deletes a job step
         */
        ExtHostDataProtocolShape.prototype.$deleteJobStep = function (handle, ownerUri, step) { throw ni(); };
        /**
         * Get Agent Alerts list
         */
        ExtHostDataProtocolShape.prototype.$getAlerts = function (handle, connectionUri) { throw ni(); };
        /**
         * Deletes  an alert
         */
        ExtHostDataProtocolShape.prototype.$deleteAlert = function (handle, connectionUri, alert) { throw ni(); };
        /**
         * Get Agent Oeprators list
         */
        ExtHostDataProtocolShape.prototype.$getOperators = function (handle, connectionUri) { throw ni(); };
        /**
         * Deletes  an operator
         */
        ExtHostDataProtocolShape.prototype.$deleteOperator = function (handle, connectionUri, operator) { throw ni(); };
        /**
         * Get Agent Proxies list
         */
        ExtHostDataProtocolShape.prototype.$getProxies = function (handle, connectionUri) { throw ni(); };
        /**
         * Deletes  a proxy
         */
        ExtHostDataProtocolShape.prototype.$deleteProxy = function (handle, connectionUri, proxy) { throw ni(); };
        /**
         * Get Agent Credentials list
         */
        ExtHostDataProtocolShape.prototype.$getCredentials = function (handle, connectionUri) { throw ni(); };
        /**
         * DacFx export bacpac
         */
        ExtHostDataProtocolShape.prototype.$exportBacpac = function (handle, databaseName, packageFilePath, ownerUri, taskExecutionMode) { throw ni(); };
        /**
         * DacFx import bacpac
         */
        ExtHostDataProtocolShape.prototype.$importBacpac = function (handle, packageFilePath, databaseName, ownerUri, taskExecutionMode) { throw ni(); };
        /**
         * DacFx extract dacpac
         */
        ExtHostDataProtocolShape.prototype.$extractDacpac = function (handle, databaseName, packageFilePath, applicationName, applicationVersion, ownerUri, taskExecutionMode) { throw ni(); };
        /**
         * DacFx deploy dacpac
         */
        ExtHostDataProtocolShape.prototype.$deployDacpac = function (handle, packageFilePath, databaseName, upgradeExisting, ownerUri, taskExecutionMode) { throw ni(); };
        /**
         * DacFx generate deploy script
         */
        ExtHostDataProtocolShape.prototype.$generateDeployScript = function (handle, packageFilePath, databaseName, scriptFilePath, ownerUri, taskExecutionMode) { throw ni(); };
        /**
         * DacFx generate deploy plan
         */
        ExtHostDataProtocolShape.prototype.$generateDeployPlan = function (handle, packageFilePath, databaseName, ownerUri, taskExecutionMode) { throw ni(); };
        return ExtHostDataProtocolShape;
    }());
    exports.ExtHostDataProtocolShape = ExtHostDataProtocolShape;
    /**
     * ResourceProvider extension host class.
     */
    var ExtHostResourceProviderShape = /** @class */ (function () {
        function ExtHostResourceProviderShape() {
        }
        /**
         * Create a firewall rule
         */
        ExtHostResourceProviderShape.prototype.$createFirewallRule = function (handle, account, firewallRuleInfo) { throw ni(); };
        /**
         * Handle firewall rule
         */
        ExtHostResourceProviderShape.prototype.$handleFirewallRule = function (handle, errorCode, errorMessage, connectionTypeId) { throw ni(); };
        return ExtHostResourceProviderShape;
    }());
    exports.ExtHostResourceProviderShape = ExtHostResourceProviderShape;
    /**
     * Credential Management extension host class.
     */
    var ExtHostCredentialManagementShape = /** @class */ (function () {
        function ExtHostCredentialManagementShape() {
        }
        ExtHostCredentialManagementShape.prototype.$saveCredential = function (credentialId, password) { throw ni(); };
        ExtHostCredentialManagementShape.prototype.$readCredential = function (credentialId) { throw ni(); };
        ExtHostCredentialManagementShape.prototype.$deleteCredential = function (credentialId) { throw ni(); };
        return ExtHostCredentialManagementShape;
    }());
    exports.ExtHostCredentialManagementShape = ExtHostCredentialManagementShape;
    /**
     * Serialization provider extension host class.
     */
    var ExtHostSerializationProviderShape = /** @class */ (function () {
        function ExtHostSerializationProviderShape() {
        }
        ExtHostSerializationProviderShape.prototype.$saveAs = function (saveFormat, savePath, results, appendToFile) { throw ni(); };
        return ExtHostSerializationProviderShape;
    }());
    exports.ExtHostSerializationProviderShape = ExtHostSerializationProviderShape;
    function ni() { return new Error('Not implemented'); }
    // --- proxy identifiers
    exports.SqlMainContext = {
        // SQL entries
        MainThreadAccountManagement: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadAccountManagement'),
        MainThreadConnectionManagement: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadConnectionManagement'),
        MainThreadCredentialManagement: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadCredentialManagement'),
        MainThreadDataProtocol: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDataProtocol'),
        MainThreadObjectExplorer: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadObjectExplorer'),
        MainThreadBackgroundTaskManagement: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadBackgroundTaskManagement'),
        MainThreadSerializationProvider: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadSerializationProvider'),
        MainThreadResourceProvider: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadResourceProvider'),
        MainThreadModalDialog: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadModalDialog'),
        MainThreadTasks: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTasks'),
        MainThreadDashboardWebview: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDashboardWebview'),
        MainThreadModelView: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadModelView'),
        MainThreadDashboard: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDashboard'),
        MainThreadModelViewDialog: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadModelViewDialog'),
        MainThreadQueryEditor: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadQueryEditor'),
        MainThreadNotebook: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadNotebook'),
        MainThreadNotebookDocumentsAndEditors: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadNotebookDocumentsAndEditors'),
        MainThreadExtensionManagement: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadExtensionManagement')
    };
    exports.SqlExtHostContext = {
        ExtHostAccountManagement: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostAccountManagement'),
        ExtHostConnectionManagement: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostConnectionManagement'),
        ExtHostCredentialManagement: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostCredentialManagement'),
        ExtHostDataProtocol: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDataProtocol'),
        ExtHostObjectExplorer: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostObjectExplorer'),
        ExtHostSerializationProvider: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostSerializationProvider'),
        ExtHostResourceProvider: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostResourceProvider'),
        ExtHostModalDialogs: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostModalDialogs'),
        ExtHostTasks: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostTasks'),
        ExtHostBackgroundTaskManagement: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostBackgroundTaskManagement'),
        ExtHostDashboardWebviews: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDashboardWebviews'),
        ExtHostModelView: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostModelView'),
        ExtHostModelViewTreeViews: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostModelViewTreeViews'),
        ExtHostDashboard: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDashboard'),
        ExtHostModelViewDialog: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostModelViewDialog'),
        ExtHostQueryEditor: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostQueryEditor'),
        ExtHostNotebook: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostNotebook'),
        ExtHostNotebookDocumentsAndEditors: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostNotebookDocumentsAndEditors'),
        ExtHostExtensionManagement: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostExtensionManagement')
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[177/*sql/workbench/api/node/extHostAccountManagement*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,5/*vs/workbench/api/node/extHostTypes*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/,28/*sql/workbench/api/common/sqlExtHostTypes*/,3/*vs/base/common/event*/]), function (require, exports, winjs_base_1, extHostTypes_1, sqlExtHost_protocol_1, sqlExtHostTypes_1, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostAccountManagement = /** @class */ (function (_super) {
        __extends(ExtHostAccountManagement, _super);
        function ExtHostAccountManagement(mainContext) {
            var _this = _super.call(this) || this;
            _this._handlePool = 0;
            _this._providers = {};
            _this._accounts = {};
            _this._onDidChangeAccounts = new event_1.Emitter();
            _this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadAccountManagement);
            return _this;
        }
        // PUBLIC METHODS //////////////////////////////////////////////////////
        // - MAIN THREAD AVAILABLE METHODS /////////////////////////////////////
        ExtHostAccountManagement.prototype.$clear = function (handle, accountKey) {
            return this._withProvider(handle, function (provider) { return provider.clear(accountKey); });
        };
        ExtHostAccountManagement.prototype.$initialize = function (handle, restoredAccounts) {
            return this._withProvider(handle, function (provider) { return provider.initialize(restoredAccounts); });
        };
        ExtHostAccountManagement.prototype.$prompt = function (handle) {
            return this._withProvider(handle, function (provider) { return provider.prompt(); });
        };
        ExtHostAccountManagement.prototype.$refresh = function (handle, account) {
            return this._withProvider(handle, function (provider) { return provider.refresh(account); });
        };
        ExtHostAccountManagement.prototype.$autoOAuthCancelled = function (handle) {
            return this._withProvider(handle, function (provider) { return provider.autoOAuthCancelled(); });
        };
        // - EXTENSION HOST AVAILABLE METHODS //////////////////////////////////
        ExtHostAccountManagement.prototype.$beginAutoOAuthDeviceCode = function (providerId, title, message, userCode, uri) {
            return this._proxy.$beginAutoOAuthDeviceCode(providerId, title, message, userCode, uri);
        };
        ExtHostAccountManagement.prototype.$endAutoOAuthDeviceCode = function () {
            this._proxy.$endAutoOAuthDeviceCode();
        };
        ExtHostAccountManagement.prototype.$accountUpdated = function (updatedAccount) {
            this._proxy.$accountUpdated(updatedAccount);
        };
        ExtHostAccountManagement.prototype.$getAllAccounts = function () {
            var _this = this;
            if (Object.keys(this._providers).length === 0) {
                throw new Error('No account providers registered.');
            }
            this._accounts = {};
            var resultAccounts = [];
            var promises = [];
            var _loop_1 = function (providerKey) {
                var providerHandle = parseInt(providerKey);
                var provider = this_1._providers[providerHandle];
                promises.push(this_1._proxy.$getAccountsForProvider(provider.metadata.id).then(function (accounts) {
                    _this._accounts[providerHandle] = accounts;
                    resultAccounts.push.apply(resultAccounts, accounts);
                }));
            };
            var this_1 = this;
            for (var providerKey in this._providers) {
                _loop_1(providerKey);
            }
            return Promise.all(promises).then(function () { return resultAccounts; });
        };
        ExtHostAccountManagement.prototype.$getSecurityToken = function (account, resource) {
            var _this = this;
            if (resource === undefined) {
                resource = sqlExtHostTypes_1.AzureResource.ResourceManagement;
            }
            return this.$getAllAccounts().then(function () {
                for (var handle in _this._accounts) {
                    var providerHandle = parseInt(handle);
                    if (_this._accounts[handle].findIndex(function (acct) { return acct.key.accountId === account.key.accountId; }) !== -1) {
                        return _this._withProvider(providerHandle, function (provider) { return provider.getSecurityToken(account, resource); });
                    }
                }
                throw new Error("Account " + account.key.accountId + " not found.");
            });
        };
        Object.defineProperty(ExtHostAccountManagement.prototype, "onDidChangeAccounts", {
            get: function () {
                return this._onDidChangeAccounts.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostAccountManagement.prototype.$accountsChanged = function (handle, accounts) {
            return this._onDidChangeAccounts.fire({ accounts: accounts });
        };
        ExtHostAccountManagement.prototype.$registerAccountProvider = function (providerMetadata, provider) {
            var self = this;
            // Look for any account providers that have the same provider ID
            var matchingProviderIndex = Object.values(this._providers).findIndex(function (provider) {
                return provider.metadata.id === providerMetadata.id;
            });
            if (matchingProviderIndex >= 0) {
                throw new Error("Account Provider with ID '" + providerMetadata.id + "' has already been registered");
            }
            // Create the handle for the provider
            var handle = this._nextHandle();
            this._providers[handle] = {
                metadata: providerMetadata,
                provider: provider
            };
            // Register the provider in the main thread via the proxy
            this._proxy.$registerAccountProvider(providerMetadata, handle);
            // Return a disposable to cleanup the provider
            return new extHostTypes_1.Disposable(function () {
                delete self._providers[handle];
                self._proxy.$unregisterAccountProvider(handle);
            });
        };
        /**
         * This method is for testing only, it is not exposed via the shape.
         * @return {number} Number of providers that are currently registered
         */
        ExtHostAccountManagement.prototype.getProviderCount = function () {
            return Object.keys(this._providers).length;
        };
        // PRIVATE METHODS /////////////////////////////////////////////////////
        ExtHostAccountManagement.prototype._nextHandle = function () {
            return this._handlePool++;
        };
        ExtHostAccountManagement.prototype._withProvider = function (handle, callback) {
            var provider = this._providers[handle];
            if (provider === undefined) {
                return winjs_base_1.TPromise.wrapError(new Error("Provider " + handle + " not found."));
            }
            return callback(provider.provider);
        };
        return ExtHostAccountManagement;
    }(sqlExtHost_protocol_1.ExtHostAccountManagementShape));
    exports.ExtHostAccountManagement = ExtHostAccountManagement;
});

define(__m[178/*sql/workbench/api/node/extHostBackgroundTaskManagement*/], __M([0/*require*/,1/*exports*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/,3/*vs/base/common/event*/,44/*vs/base/common/uuid*/]), function (require, exports, sqlExtHost_protocol_1, event_1, uuid_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TaskStatus;
    (function (TaskStatus) {
        TaskStatus[TaskStatus["NotStarted"] = 0] = "NotStarted";
        TaskStatus[TaskStatus["InProgress"] = 1] = "InProgress";
        TaskStatus[TaskStatus["Succeeded"] = 2] = "Succeeded";
        TaskStatus[TaskStatus["SucceededWithWarning"] = 3] = "SucceededWithWarning";
        TaskStatus[TaskStatus["Failed"] = 4] = "Failed";
        TaskStatus[TaskStatus["Canceled"] = 5] = "Canceled";
        TaskStatus[TaskStatus["Canceling"] = 6] = "Canceling";
    })(TaskStatus = exports.TaskStatus || (exports.TaskStatus = {}));
    var ExtBackgroundOperation = /** @class */ (function () {
        function ExtBackgroundOperation(_id, mainContext) {
            this._id = _id;
            this._onCanceled = new event_1.Emitter();
            this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadBackgroundTaskManagement);
        }
        ExtBackgroundOperation.prototype.updateStatus = function (status, message) {
            this._proxy.$updateTask({
                message: message,
                status: status,
                taskId: this.id
            });
        };
        Object.defineProperty(ExtBackgroundOperation.prototype, "onCanceled", {
            get: function () {
                return this._onCanceled.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtBackgroundOperation.prototype.cancel = function () {
            this._onCanceled.fire();
        };
        Object.defineProperty(ExtBackgroundOperation.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        return ExtBackgroundOperation;
    }());
    exports.ExtBackgroundOperation = ExtBackgroundOperation;
    var ExtHostBackgroundTaskManagement = /** @class */ (function () {
        function ExtHostBackgroundTaskManagement(mainContext) {
            this._handlers = new Map();
            this._operations = new Map();
            this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadBackgroundTaskManagement);
            this._mainContext = mainContext;
        }
        ExtHostBackgroundTaskManagement.prototype.$onTaskRegistered = function (operationId) {
            var extOperationInfo = new ExtBackgroundOperation(operationId, this._mainContext);
            this._operations.set(operationId, extOperationInfo);
            var operationInfo = this._handlers.get(operationId);
            if (operationInfo) {
                operationInfo.operation(extOperationInfo);
            }
        };
        ExtHostBackgroundTaskManagement.prototype.$onTaskCanceled = function (operationId) {
            var operation = this._operations.get(operationId);
            if (operation) {
                operation.cancel();
            }
        };
        ExtHostBackgroundTaskManagement.prototype.$registerTask = function (operationInfo) {
            var operationId = operationInfo.operationId || "OperationId" + uuid_1.generateUuid();
            if (this._handlers.has(operationId)) {
                throw new Error("operation '" + operationId + "' already exists");
            }
            this._handlers.set(operationId, operationInfo);
            var taskInfo = {
                databaseName: undefined,
                serverName: undefined,
                description: operationInfo.description,
                isCancelable: operationInfo.isCancelable,
                name: operationInfo.displayName,
                providerName: undefined,
                //by the extension
                taskExecutionMode: 0,
                taskId: operationId,
                status: TaskStatus.NotStarted,
                connection: operationInfo.connection
            };
            this._proxy.$registerTask(taskInfo);
        };
        ExtHostBackgroundTaskManagement.prototype.$removeTask = function (operationId) {
            if (this._handlers.has(operationId)) {
                this._handlers.delete(operationId);
            }
        };
        return ExtHostBackgroundTaskManagement;
    }());
    exports.ExtHostBackgroundTaskManagement = ExtHostBackgroundTaskManagement;
});











define(__m[179/*sql/workbench/api/node/extHostConnectionManagement*/], __M([0/*require*/,1/*exports*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/]), function (require, exports, sqlExtHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostConnectionManagement = /** @class */ (function (_super) {
        __extends(ExtHostConnectionManagement, _super);
        function ExtHostConnectionManagement(mainContext) {
            var _this = _super.call(this) || this;
            _this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadConnectionManagement);
            return _this;
        }
        ExtHostConnectionManagement.prototype.$getActiveConnections = function () {
            return this._proxy.$getActiveConnections();
        };
        ExtHostConnectionManagement.prototype.$getCurrentConnection = function () {
            return this._proxy.$getCurrentConnection();
        };
        ExtHostConnectionManagement.prototype.$getCredentials = function (connectionId) {
            return this._proxy.$getCredentials(connectionId);
        };
        ExtHostConnectionManagement.prototype.$getServerInfo = function (connectionId) {
            return this._proxy.$getServerInfo(connectionId);
        };
        ExtHostConnectionManagement.prototype.$openConnectionDialog = function (providers, initialConnectionProfile, connectionCompletionOptions) {
            return this._proxy.$openConnectionDialog(providers, initialConnectionProfile, connectionCompletionOptions);
        };
        ExtHostConnectionManagement.prototype.$listDatabases = function (connectionId) {
            return this._proxy.$listDatabases(connectionId);
        };
        ExtHostConnectionManagement.prototype.$getConnectionString = function (connectionId, includePassword) {
            return this._proxy.$getConnectionString(connectionId, includePassword);
        };
        ExtHostConnectionManagement.prototype.$getUriForConnection = function (connectionId) {
            return this._proxy.$getUriForConnection(connectionId);
        };
        ExtHostConnectionManagement.prototype.$connect = function (connectionProfile) {
            return this._proxy.$connect(connectionProfile);
        };
        return ExtHostConnectionManagement;
    }(sqlExtHost_protocol_1.ExtHostConnectionManagementShape));
    exports.ExtHostConnectionManagement = ExtHostConnectionManagement;
});











define(__m[180/*sql/workbench/api/node/extHostCredentialManagement*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/,5/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, winjs_base_1, sqlExtHost_protocol_1, extHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var CredentialAdapter = /** @class */ (function () {
        function CredentialAdapter(provider) {
            this.provider = provider;
        }
        CredentialAdapter.prototype.saveCredential = function (credentialId, password) {
            return this.provider.saveCredential(credentialId, password);
        };
        CredentialAdapter.prototype.readCredential = function (credentialId) {
            return this.provider.readCredential(credentialId);
        };
        CredentialAdapter.prototype.deleteCredential = function (credentialId) {
            return this.provider.deleteCredential(credentialId);
        };
        return CredentialAdapter;
    }());
    var ExtHostCredentialManagement = /** @class */ (function (_super) {
        __extends(ExtHostCredentialManagement, _super);
        function ExtHostCredentialManagement(mainContext) {
            var _this = _super.call(this) || this;
            // MEMBER VARIABLES ////////////////////////////////////////////////////
            _this._adapter = Object.create(null);
            _this._handlePool = 0;
            var self = _this;
            _this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadCredentialManagement);
            // Create a promise to resolve when a credential provider has been registered.
            // HACK: this gives us a deferred promise
            _this._registrationPromise = new Promise(function (resolve) { self._registrationPromiseResolve = resolve; });
            return _this;
        }
        // PUBLIC METHODS //////////////////////////////////////////////////////
        ExtHostCredentialManagement.prototype.$registerCredentialProvider = function (provider) {
            // Store the credential provider
            provider.handle = this._nextHandle();
            this._adapter[provider.handle] = new CredentialAdapter(provider);
            // Register the credential provider with the main thread
            this._proxy.$registerCredentialProvider(provider.handle);
            // Resolve the credential provider registration promise
            this._registrationPromiseResolve();
            return this._createDisposable(provider.handle);
        };
        ExtHostCredentialManagement.prototype.$getCredentialProvider = function (namespaceId) {
            var self = this;
            if (!namespaceId) {
                return winjs_base_1.TPromise.wrapError(new Error('A namespace must be provided when retrieving a credential provider'));
            }
            // When the registration promise has finished successfully,
            return this._registrationPromise.then(function () {
                return self._withAdapter(0, CredentialAdapter, function (adapter) { return self._createNamespacedCredentialProvider(namespaceId, adapter); });
            });
        };
        ExtHostCredentialManagement.prototype.$saveCredential = function (credentialId, password) {
            return this._withAdapter(0, CredentialAdapter, function (adapter) { return adapter.saveCredential(credentialId, password); });
        };
        ExtHostCredentialManagement.prototype.$readCredential = function (credentialId) {
            return this._withAdapter(0, CredentialAdapter, function (adapter) { return adapter.readCredential(credentialId); });
        };
        ExtHostCredentialManagement.prototype.$deleteCredential = function (credentialId) {
            return this._withAdapter(0, CredentialAdapter, function (adapter) { return adapter.deleteCredential(credentialId); });
        };
        /**
         * Helper method for tests. Not exposed via shape.
         * @return {number} Number of providers registered
         */
        ExtHostCredentialManagement.prototype.getProviderCount = function () {
            return Object.keys(this._adapter).length;
        };
        // PRIVATE HELPERS /////////////////////////////////////////////////////
        ExtHostCredentialManagement._getNamespacedCredentialId = function (namespaceId, credentialId) {
            return namespaceId + "|" + credentialId;
        };
        ExtHostCredentialManagement.prototype._createNamespacedCredentialProvider = function (namespaceId, adapter) {
            // Create a provider that wraps the methods in a namespace
            var provider = {
                handle: adapter.provider.handle,
                deleteCredential: function (credentialId) {
                    var namespacedId = ExtHostCredentialManagement._getNamespacedCredentialId(namespaceId, credentialId);
                    return adapter.provider.deleteCredential(namespacedId);
                },
                readCredential: function (credentialId) {
                    var namespacedId = ExtHostCredentialManagement._getNamespacedCredentialId(namespaceId, credentialId);
                    return adapter.provider.readCredential(namespacedId);
                },
                saveCredential: function (credentialId, credential) {
                    var namespacedId = ExtHostCredentialManagement._getNamespacedCredentialId(namespaceId, credentialId);
                    return adapter.provider.saveCredential(namespacedId, credential);
                }
            };
            return Promise.resolve(provider);
        };
        ExtHostCredentialManagement.prototype._createDisposable = function (handle) {
            var _this = this;
            return new extHostTypes_1.Disposable(function () {
                delete _this._adapter[handle];
                _this._proxy.$unregisterCredentialProvider(handle);
            });
        };
        ExtHostCredentialManagement.prototype._nextHandle = function () {
            return this._handlePool++;
        };
        ExtHostCredentialManagement.prototype._withAdapter = function (handle, ctor, callback) {
            var adapter = this._adapter[handle];
            if (!(adapter instanceof ctor)) {
                return winjs_base_1.TPromise.wrapError(new Error('no adapter found'));
            }
            return callback(adapter);
        };
        return ExtHostCredentialManagement;
    }(sqlExtHost_protocol_1.ExtHostCredentialManagementShape));
    exports.ExtHostCredentialManagement = ExtHostCredentialManagement;
});

define(__m[181/*sql/workbench/api/node/extHostDashboard*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/]), function (require, exports, event_1, sqlExtHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDashboard = /** @class */ (function () {
        function ExtHostDashboard(mainContext) {
            this._onDidOpenDashboard = new event_1.Emitter();
            this.onDidOpenDashboard = this._onDidOpenDashboard.event;
            this._onDidChangeToDashboard = new event_1.Emitter();
            this.onDidChangeToDashboard = this._onDidChangeToDashboard.event;
            this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadDashboard);
        }
        ExtHostDashboard.prototype.$onDidOpenDashboard = function (dashboard) {
            this._onDidOpenDashboard.fire(dashboard);
        };
        ExtHostDashboard.prototype.$onDidChangeToDashboard = function (dashboard) {
            this._onDidChangeToDashboard.fire(dashboard);
        };
        return ExtHostDashboard;
    }());
    exports.ExtHostDashboard = ExtHostDashboard;
});

define(__m[182/*sql/workbench/api/node/extHostDashboardWebview*/], __M([0/*require*/,1/*exports*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/,3/*vs/base/common/event*/,20/*vs/base/common/objects*/]), function (require, exports, sqlExtHost_protocol_1, event_1, objects_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDashboardWebview = /** @class */ (function () {
        function ExtHostDashboardWebview(_proxy, _handle, _connection, _serverInfo) {
            this._proxy = _proxy;
            this._handle = _handle;
            this._connection = _connection;
            this._serverInfo = _serverInfo;
            this.onMessageEmitter = new event_1.Emitter();
            this.onClosedEmitter = new event_1.Emitter();
        }
        ExtHostDashboardWebview.prototype.postMessage = function (message) {
            return this._proxy.$sendMessage(this._handle, message);
        };
        Object.defineProperty(ExtHostDashboardWebview.prototype, "onMessage", {
            get: function () {
                return this.onMessageEmitter.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDashboardWebview.prototype, "onClosed", {
            get: function () {
                return this.onClosedEmitter.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDashboardWebview.prototype, "connection", {
            get: function () {
                return objects_1.deepClone(this._connection);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDashboardWebview.prototype, "serverInfo", {
            get: function () {
                return objects_1.deepClone(this._serverInfo);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDashboardWebview.prototype, "html", {
            get: function () {
                return this._html;
            },
            set: function (value) {
                if (this._html !== value) {
                    this._html = value;
                    this._proxy.$setHtml(this._handle, value);
                }
            },
            enumerable: true,
            configurable: true
        });
        return ExtHostDashboardWebview;
    }());
    var ExtHostDashboardWebviews = /** @class */ (function () {
        function ExtHostDashboardWebviews(mainContext) {
            this._webviews = new Map();
            this._handlers = new Map();
            this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadDashboardWebview);
        }
        ExtHostDashboardWebviews.prototype.$onMessage = function (handle, message) {
            var webview = this._webviews.get(handle);
            webview.onMessageEmitter.fire(message);
        };
        ExtHostDashboardWebviews.prototype.$onClosed = function (handle) {
            var webview = this._webviews.get(handle);
            webview.onClosedEmitter.fire();
            this._webviews.delete(handle);
        };
        ExtHostDashboardWebviews.prototype.$registerProvider = function (widgetId, handler) {
            this._handlers.set(widgetId, handler);
            this._proxy.$registerProvider(widgetId);
        };
        ExtHostDashboardWebviews.prototype.$registerWidget = function (handle, id, connection, serverInfo) {
            var webview = new ExtHostDashboardWebview(this._proxy, handle, connection, serverInfo);
            this._webviews.set(handle, webview);
            this._handlers.get(id)(webview);
        };
        return ExtHostDashboardWebviews;
    }());
    exports.ExtHostDashboardWebviews = ExtHostDashboardWebviews;
});











define(__m[183/*sql/workbench/api/node/extHostDataProtocol*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,5/*vs/workbench/api/node/extHostTypes*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/,28/*sql/workbench/api/common/sqlExtHostTypes*/,2/*vs/base/common/winjs.base*/]), function (require, exports, event_1, extHostTypes_1, sqlExtHost_protocol_1, sqlExtHostTypes_1, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDataProtocol = /** @class */ (function (_super) {
        __extends(ExtHostDataProtocol, _super);
        function ExtHostDataProtocol(mainContext) {
            var _this = _super.call(this) || this;
            _this._onDidChangeLanguageFlavor = new event_1.Emitter();
            _this.onDidChangeLanguageFlavor = _this._onDidChangeLanguageFlavor.event;
            _this._adapter = new Map();
            _this._providersByType = new Map();
            _this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadDataProtocol);
            return _this;
        }
        ExtHostDataProtocol.prototype._createDisposable = function (handle) {
            var _this = this;
            return new extHostTypes_1.Disposable(function () {
                _this._adapter.delete(handle);
                _this._proxy.$unregisterProvider(handle);
            });
        };
        ExtHostDataProtocol.prototype._nextHandle = function () {
            return ExtHostDataProtocol._handlePool++;
        };
        ExtHostDataProtocol.prototype._resolveProvider = function (handle) {
            var provider = this._adapter.get(handle);
            if (provider) {
                return provider;
            }
            else {
                throw new Error("Unfound provider " + handle);
            }
        };
        ExtHostDataProtocol.prototype.registerProvider = function (provider, providerType) {
            provider.handle = this._nextHandle();
            this._adapter.set(provider.handle, provider);
            var providersForType = this._providersByType.get(providerType);
            if (!providersForType) {
                providersForType = [provider];
            }
            else {
                providersForType.push(provider);
            }
            this._providersByType.set(providerType, providersForType);
            return this._createDisposable(provider.handle);
        };
        ExtHostDataProtocol.prototype.getProvider = function (providerId, providerType) {
            var providersForType = this._providersByType.get(providerType);
            if (!providersForType) {
                return undefined;
            }
            return providersForType.find(function (provider) { return provider.providerId === providerId; });
        };
        ExtHostDataProtocol.prototype.getProvidersByType = function (providerType) {
            var providersForType = this._providersByType.get(providerType);
            return (providersForType || []);
        };
        ExtHostDataProtocol.prototype.$registerConnectionProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.ConnectionProvider);
            this._proxy.$registerConnectionProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerBackupProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.BackupProvider);
            this._proxy.$registerBackupProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerRestoreProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.RestoreProvider);
            this._proxy.$registerRestoreProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerScriptingProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.ScriptingProvider);
            this._proxy.$registerScriptingProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerQueryProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.QueryProvider);
            this._proxy.$registerQueryProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerMetadataProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.MetadataProvider);
            this._proxy.$registerMetadataProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerTaskServicesProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.TaskServicesProvider);
            this._proxy.$registerTaskServicesProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerFileBrowserProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.FileBrowserProvider);
            this._proxy.$registerFileBrowserProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerObjectExplorerProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.ObjectExplorerProvider);
            this._proxy.$registerObjectExplorerProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerObjectExplorerNodeProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.ObjectExplorerNodeProvider);
            this._proxy.$registerObjectExplorerNodeProvider(provider.providerId, provider.supportedProviderId, provider.group, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerProfilerProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.ProfilerProvider);
            this._proxy.$registerProfilerProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerAdminServicesProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.AdminServicesProvider);
            this._proxy.$registerAdminServicesProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerAgentServiceProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.AgentServicesProvider);
            this._proxy.$registerAgentServicesProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerCapabilitiesServiceProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.CapabilitiesProvider);
            this._proxy.$registerCapabilitiesServiceProvider(provider.providerId, provider.handle);
            return rt;
        };
        ExtHostDataProtocol.prototype.$registerDacFxServiceProvider = function (provider) {
            var rt = this.registerProvider(provider, sqlExtHostTypes_1.DataProviderType.DacFxServicesProvider);
            this._proxy.$registerDacFxServicesProvider(provider.providerId, provider.handle);
            return rt;
        };
        // Capabilities Discovery handlers
        ExtHostDataProtocol.prototype.$getServerCapabilities = function (handle, client) {
            return this._resolveProvider(handle).getServerCapabilities(client);
        };
        // Connection Management handlers
        ExtHostDataProtocol.prototype.$connect = function (handle, connectionUri, connection) {
            return this._resolveProvider(handle).connect(connectionUri, connection);
        };
        ExtHostDataProtocol.prototype.$disconnect = function (handle, connectionUri) {
            return this._resolveProvider(handle).disconnect(connectionUri);
        };
        ExtHostDataProtocol.prototype.$cancelConnect = function (handle, connectionUri) {
            return this._resolveProvider(handle).cancelConnect(connectionUri);
        };
        ExtHostDataProtocol.prototype.$changeDatabase = function (handle, connectionUri, newDatabase) {
            return this._resolveProvider(handle).changeDatabase(connectionUri, newDatabase);
        };
        ExtHostDataProtocol.prototype.$listDatabases = function (handle, connectionUri) {
            return this._resolveProvider(handle).listDatabases(connectionUri);
        };
        ExtHostDataProtocol.prototype.$getConnectionString = function (handle, connectionUri, includePassword) {
            return this._resolveProvider(handle).getConnectionString(connectionUri, includePassword);
        };
        ExtHostDataProtocol.prototype.$buildConnectionInfo = function (handle, connectionString) {
            var provider = this._resolveProvider(handle);
            if (provider.buildConnectionInfo) {
                return provider.buildConnectionInfo(connectionString);
            }
            else {
                return winjs_base_1.TPromise.as(undefined);
            }
        };
        ExtHostDataProtocol.prototype.$rebuildIntelliSenseCache = function (handle, connectionUri) {
            return this._resolveProvider(handle).rebuildIntelliSenseCache(connectionUri);
        };
        ExtHostDataProtocol.prototype.$onConnectComplete = function (handle, connectionInfoSummary) {
            this._proxy.$onConnectionComplete(handle, connectionInfoSummary);
        };
        ExtHostDataProtocol.prototype.$onIntelliSenseCacheComplete = function (handle, connectionUri) {
            this._proxy.$onIntelliSenseCacheComplete(handle, connectionUri);
        };
        ExtHostDataProtocol.prototype.$onConnectionChanged = function (handle, changedConnInfo) {
            this._proxy.$onConnectionChangeNotification(handle, changedConnInfo);
        };
        // Protocol-wide Event Handlers
        ExtHostDataProtocol.prototype.$languageFlavorChanged = function (params) {
            this._onDidChangeLanguageFlavor.fire(params);
        };
        // Query Management handlers
        ExtHostDataProtocol.prototype.$cancelQuery = function (handle, ownerUri) {
            return this._resolveProvider(handle).cancelQuery(ownerUri);
        };
        ExtHostDataProtocol.prototype.$runQuery = function (handle, ownerUri, selection, runOptions) {
            return this._resolveProvider(handle).runQuery(ownerUri, selection, runOptions);
        };
        ExtHostDataProtocol.prototype.$runQueryStatement = function (handle, ownerUri, line, column) {
            return this._resolveProvider(handle).runQueryStatement(ownerUri, line, column);
        };
        ExtHostDataProtocol.prototype.$runQueryString = function (handle, ownerUri, queryString) {
            return this._resolveProvider(handle).runQueryString(ownerUri, queryString);
        };
        ExtHostDataProtocol.prototype.$runQueryAndReturn = function (handle, ownerUri, queryString) {
            return this._resolveProvider(handle).runQueryAndReturn(ownerUri, queryString);
        };
        ExtHostDataProtocol.prototype.$parseSyntax = function (handle, ownerUri, query) {
            return this._resolveProvider(handle).parseSyntax(ownerUri, query);
        };
        ExtHostDataProtocol.prototype.$getQueryRows = function (handle, rowData) {
            return this._resolveProvider(handle).getQueryRows(rowData);
        };
        ExtHostDataProtocol.prototype.$disposeQuery = function (handle, ownerUri) {
            return this._resolveProvider(handle).disposeQuery(ownerUri);
        };
        ExtHostDataProtocol.prototype.$onQueryComplete = function (handle, result) {
            this._proxy.$onQueryComplete(handle, result);
        };
        ExtHostDataProtocol.prototype.$onBatchStart = function (handle, batchInfo) {
            this._proxy.$onBatchStart(handle, batchInfo);
        };
        ExtHostDataProtocol.prototype.$onBatchComplete = function (handle, batchInfo) {
            this._proxy.$onBatchComplete(handle, batchInfo);
        };
        ExtHostDataProtocol.prototype.$onResultSetAvailable = function (handle, resultSetInfo) {
            this._proxy.$onResultSetAvailable(handle, resultSetInfo);
        };
        ExtHostDataProtocol.prototype.$onResultSetUpdated = function (handle, resultSetInfo) {
            this._proxy.$onResultSetUpdated(handle, resultSetInfo);
        };
        ExtHostDataProtocol.prototype.$onQueryMessage = function (handle, message) {
            this._proxy.$onQueryMessage(handle, message);
        };
        ExtHostDataProtocol.prototype.$saveResults = function (handle, requestParams) {
            return this._resolveProvider(handle).saveResults(requestParams);
        };
        // Edit Data handlers
        ExtHostDataProtocol.prototype.$commitEdit = function (handle, ownerUri) {
            return this._resolveProvider(handle).commitEdit(ownerUri);
        };
        ExtHostDataProtocol.prototype.$createRow = function (handle, ownerUri) {
            return this._resolveProvider(handle).createRow(ownerUri);
        };
        ExtHostDataProtocol.prototype.$deleteRow = function (handle, ownerUri, rowId) {
            return this._resolveProvider(handle).deleteRow(ownerUri, rowId);
        };
        ExtHostDataProtocol.prototype.$disposeEdit = function (handle, ownerUri) {
            return this._resolveProvider(handle).disposeEdit(ownerUri);
        };
        ExtHostDataProtocol.prototype.$initializeEdit = function (handle, ownerUri, schemaName, objectName, objectType, rowLimit, queryString) {
            return this._resolveProvider(handle).initializeEdit(ownerUri, schemaName, objectName, objectType, rowLimit, queryString);
        };
        ExtHostDataProtocol.prototype.$revertCell = function (handle, ownerUri, rowId, columnId) {
            return this._resolveProvider(handle).revertCell(ownerUri, rowId, columnId);
        };
        ExtHostDataProtocol.prototype.$revertRow = function (handle, ownerUri, rowId) {
            return this._resolveProvider(handle).revertRow(ownerUri, rowId);
        };
        ExtHostDataProtocol.prototype.$updateCell = function (handle, ownerUri, rowId, columnId, newValue) {
            return this._resolveProvider(handle).updateCell(ownerUri, rowId, columnId, newValue);
        };
        ExtHostDataProtocol.prototype.$getEditRows = function (handle, rowData) {
            return this._resolveProvider(handle).getEditRows(rowData);
        };
        ExtHostDataProtocol.prototype.$onEditSessionReady = function (handle, ownerUri, success, message) {
            this._proxy.$onEditSessionReady(handle, ownerUri, success, message);
        };
        // Metadata handlers
        ExtHostDataProtocol.prototype.$getMetadata = function (handle, connectionUri) {
            return this._resolveProvider(handle).getMetadata(connectionUri);
        };
        ExtHostDataProtocol.prototype.$getDatabases = function (handle, connectionUri) {
            return this._resolveProvider(handle).getDatabases(connectionUri);
        };
        ExtHostDataProtocol.prototype.$getTableInfo = function (handle, connectionUri, metadata) {
            return this._resolveProvider(handle).getTableInfo(connectionUri, metadata);
        };
        ExtHostDataProtocol.prototype.$getViewInfo = function (handle, connectionUri, metadata) {
            return this._resolveProvider(handle).getViewInfo(connectionUri, metadata);
        };
        // Object Explorer Service
        ExtHostDataProtocol.prototype.$createObjectExplorerSession = function (handle, connInfo) {
            return this._resolveProvider(handle).createNewSession(connInfo);
        };
        ExtHostDataProtocol.prototype.$createObjectExplorerNodeProviderSession = function (handle, session) {
            return this._resolveProvider(handle).handleSessionOpen(session);
        };
        ExtHostDataProtocol.prototype.$expandObjectExplorerNode = function (handle, nodeInfo) {
            return this._resolveProvider(handle).expandNode(nodeInfo);
        };
        ExtHostDataProtocol.prototype.$refreshObjectExplorerNode = function (handle, nodeInfo) {
            return this._resolveProvider(handle).refreshNode(nodeInfo);
        };
        ExtHostDataProtocol.prototype.$closeObjectExplorerSession = function (handle, closeSessionInfo) {
            return this._resolveProvider(handle).closeSession(closeSessionInfo);
        };
        ExtHostDataProtocol.prototype.$handleSessionClose = function (handle, closeSessionInfo) {
            return this._resolveProvider(handle).handleSessionClose(closeSessionInfo);
        };
        ExtHostDataProtocol.prototype.$findNodes = function (handle, findNodesInfo) {
            return this._resolveProvider(handle).findNodes(findNodesInfo);
        };
        ExtHostDataProtocol.prototype.$onObjectExplorerSessionCreated = function (handle, response) {
            this._proxy.$onObjectExplorerSessionCreated(handle, response);
        };
        ExtHostDataProtocol.prototype.$onObjectExplorerSessionDisconnected = function (handle, response) {
            this._proxy.$onObjectExplorerSessionDisconnected(handle, response);
        };
        ExtHostDataProtocol.prototype.$onObjectExplorerNodeExpanded = function (providerId, response) {
            this._proxy.$onObjectExplorerNodeExpanded(providerId, response);
        };
        // Task Service
        ExtHostDataProtocol.prototype.$getAllTasks = function (handle, listTasksParams) {
            return this._resolveProvider(handle).getAllTasks(listTasksParams);
        };
        ExtHostDataProtocol.prototype.$cancelTask = function (handle, cancelTaskParams) {
            return this._resolveProvider(handle).cancelTask(cancelTaskParams);
        };
        ExtHostDataProtocol.prototype.$onTaskStatusChanged = function (handle, response) {
            this._proxy.$onTaskStatusChanged(handle, response);
        };
        ExtHostDataProtocol.prototype.$onTaskCreated = function (handle, response) {
            this._proxy.$onTaskCreated(handle, response);
        };
        // Scripting handlers
        ExtHostDataProtocol.prototype.$scriptAsOperation = function (handle, connectionUri, operation, metadata, paramDetails) {
            return this._resolveProvider(handle).scriptAsOperation(connectionUri, operation, metadata, paramDetails);
        };
        ExtHostDataProtocol.prototype.$onScriptingComplete = function (handle, scriptingCompleteResult) {
            this._proxy.$onScriptingComplete(handle, scriptingCompleteResult);
        };
        /**
         * Create a new database on the provided connection
         */
        ExtHostDataProtocol.prototype.$createDatabase = function (handle, connectionUri, database) {
            return this._resolveProvider(handle).createDatabase(connectionUri, database);
        };
        /**
         * Create a new database on the provided connection
         */
        ExtHostDataProtocol.prototype.$getDefaultDatabaseInfo = function (handle, connectionUri) {
            return this._resolveProvider(handle).getDefaultDatabaseInfo(connectionUri);
        };
        /**
         * Get the info on a database
         */
        ExtHostDataProtocol.prototype.$getDatabaseInfo = function (handle, connectionUri) {
            return this._resolveProvider(handle).getDatabaseInfo(connectionUri);
        };
        /**
         * Create a new login on the provided connection
         */
        ExtHostDataProtocol.prototype.$createLogin = function (handle, connectionUri, login) {
            return this._resolveProvider(handle).createLogin(connectionUri, login);
        };
        /**
         * Backup a database
         */
        ExtHostDataProtocol.prototype.$backup = function (handle, connectionUri, backupInfo, taskExecutionMode) {
            return this._resolveProvider(handle).backup(connectionUri, backupInfo, taskExecutionMode);
        };
        /**
        * Create a new database on the provided connection
        */
        ExtHostDataProtocol.prototype.$getBackupConfigInfo = function (handle, connectionUri) {
            return this._resolveProvider(handle).getBackupConfigInfo(connectionUri);
        };
        /**
         * Restores a database
         */
        ExtHostDataProtocol.prototype.$restore = function (handle, connectionUri, restoreInfo) {
            return this._resolveProvider(handle).restore(connectionUri, restoreInfo);
        };
        /**
         * Gets a plan for restoring a database
         */
        ExtHostDataProtocol.prototype.$getRestorePlan = function (handle, connectionUri, restoreInfo) {
            return this._resolveProvider(handle).getRestorePlan(connectionUri, restoreInfo);
        };
        /**
         * cancels a restore plan
         */
        ExtHostDataProtocol.prototype.$cancelRestorePlan = function (handle, connectionUri, restoreInfo) {
            return this._resolveProvider(handle).cancelRestorePlan(connectionUri, restoreInfo);
        };
        /**
         * Gets restore config Info
         */
        ExtHostDataProtocol.prototype.$getRestoreConfigInfo = function (handle, connectionUri) {
            return this._resolveProvider(handle).getRestoreConfigInfo(connectionUri);
        };
        /**
         * Open a file browser
         */
        ExtHostDataProtocol.prototype.$openFileBrowser = function (handle, ownerUri, expandPath, fileFilters, changeFilter) {
            return this._resolveProvider(handle).openFileBrowser(ownerUri, expandPath, fileFilters, changeFilter);
        };
        /**
         * Send event when opening browser is complete
         */
        ExtHostDataProtocol.prototype.$onFileBrowserOpened = function (handle, response) {
            this._proxy.$onFileBrowserOpened(handle, response);
        };
        /**
         * Expand a folder node
         */
        ExtHostDataProtocol.prototype.$expandFolderNode = function (handle, ownerUri, expandPath) {
            return this._resolveProvider(handle).expandFolderNode(ownerUri, expandPath);
        };
        /**
         * Send event when expansion is complete
         */
        ExtHostDataProtocol.prototype.$onFolderNodeExpanded = function (handle, response) {
            this._proxy.$onFolderNodeExpanded(handle, response);
        };
        /**
         * Validate selected file path
         */
        ExtHostDataProtocol.prototype.$validateFilePaths = function (handle, ownerUri, serviceType, selectedFiles) {
            return this._resolveProvider(handle).validateFilePaths(ownerUri, serviceType, selectedFiles);
        };
        /**
         * Send event when validation is complete
         */
        ExtHostDataProtocol.prototype.$onFilePathsValidated = function (handle, response) {
            this._proxy.$onFilePathsValidated(handle, response);
        };
        /**
         * Close file browser
         */
        ExtHostDataProtocol.prototype.$closeFileBrowser = function (handle, ownerUri) {
            return this._resolveProvider(handle).closeFileBrowser(ownerUri);
        };
        /**
         * Profiler Provider methods
         */
        /**
         * Create a new profiler session
         */
        ExtHostDataProtocol.prototype.$createSession = function (handle, sessionId, createStatement, template) {
            return this._resolveProvider(handle).createSession(sessionId, createStatement, template);
        };
        /**
         * Start a profiler session
         */
        ExtHostDataProtocol.prototype.$startSession = function (handle, sessionId, sessionName) {
            return this._resolveProvider(handle).startSession(sessionId, sessionName);
        };
        /**
         * Stop a profiler session
         */
        ExtHostDataProtocol.prototype.$stopSession = function (handle, sessionId) {
            return this._resolveProvider(handle).stopSession(sessionId);
        };
        /**
         * Pause a profiler session
         */
        ExtHostDataProtocol.prototype.$pauseSession = function (handle, sessionId) {
            return this._resolveProvider(handle).pauseSession(sessionId);
        };
        /**
         * Disconnect a profiler session
         */
        ExtHostDataProtocol.prototype.$disconnectSession = function (handle, sessionId) {
            return this._resolveProvider(handle).disconnectSession(sessionId);
        };
        /**
         * Get list of running XEvent sessions on the session's target server
         */
        ExtHostDataProtocol.prototype.$getXEventSessions = function (handle, sessionId) {
            return this._resolveProvider(handle).getXEventSessions(sessionId);
        };
        /**
         * Profiler session events available notification
         */
        ExtHostDataProtocol.prototype.$onSessionEventsAvailable = function (handle, response) {
            this._proxy.$onSessionEventsAvailable(handle, response);
        };
        /**
         * Profiler session stopped unexpectedly notification
         */
        ExtHostDataProtocol.prototype.$onSessionStopped = function (handle, response) {
            this._proxy.$onSessionStopped(handle, response);
        };
        /**
         * Profiler session created notification
         */
        ExtHostDataProtocol.prototype.$onProfilerSessionCreated = function (handle, response) {
            this._proxy.$onProfilerSessionCreated(handle, response);
        };
        /**
         * Agent Job Provider methods
         */
        /**
         * Get Agent Job list
         */
        ExtHostDataProtocol.prototype.$getJobs = function (handle, ownerUri) {
            return this._resolveProvider(handle).getJobs(ownerUri);
        };
        /**
         * Get a Agent Job's history
         */
        ExtHostDataProtocol.prototype.$getJobHistory = function (handle, ownerUri, jobID, jobName) {
            return this._resolveProvider(handle).getJobHistory(ownerUri, jobID, jobName);
        };
        /**
         * Run an action on a job
         */
        ExtHostDataProtocol.prototype.$jobAction = function (handle, ownerUri, jobName, action) {
            return this._resolveProvider(handle).jobAction(ownerUri, jobName, action);
        };
        /**
         * Deletes a job
         */
        ExtHostDataProtocol.prototype.$deleteJob = function (handle, ownerUri, job) {
            throw this._resolveProvider(handle).deleteJob(ownerUri, job);
        };
        /**
         * Deletes a job step
         */
        ExtHostDataProtocol.prototype.$deleteJobStep = function (handle, ownerUri, step) {
            throw this._resolveProvider(handle).deleteJobStep(ownerUri, step);
        };
        /**
         * Get Agent Alerts list
         */
        ExtHostDataProtocol.prototype.$getAlerts = function (handle, ownerUri) {
            return this._resolveProvider(handle).getAlerts(ownerUri);
        };
        /**
         * Deletes an alert
         */
        ExtHostDataProtocol.prototype.$deleteAlert = function (handle, ownerUri, alert) {
            return this._resolveProvider(handle).deleteAlert(ownerUri, alert);
        };
        /**
         * Get Agent Oeprators list
         */
        ExtHostDataProtocol.prototype.$getOperators = function (handle, ownerUri) {
            return this._resolveProvider(handle).getOperators(ownerUri);
        };
        /**
         * Deletes an operator
         */
        ExtHostDataProtocol.prototype.$deleteOperator = function (handle, ownerUri, operator) {
            return this._resolveProvider(handle).deleteOperator(ownerUri, operator);
        };
        /**
         * Get Agent Proxies list
         */
        ExtHostDataProtocol.prototype.$getProxies = function (handle, ownerUri) {
            return this._resolveProvider(handle).getProxies(ownerUri);
        };
        /**
         * Deletes a proxy
         */
        ExtHostDataProtocol.prototype.$deleteProxy = function (handle, ownerUri, proxy) {
            return this._resolveProvider(handle).deleteProxy(ownerUri, proxy);
        };
        /**
         * Gets Agent Credentials from server
         */
        ExtHostDataProtocol.prototype.$getCredentials = function (handle, ownerUri) {
            return this._resolveProvider(handle).getCredentials(ownerUri);
        };
        /**
         * SQL Agent job data update notification
         */
        ExtHostDataProtocol.prototype.$onJobDataUpdated = function (handle) {
            this._proxy.$onJobDataUpdated(handle);
        };
        ExtHostDataProtocol._handlePool = 0;
        return ExtHostDataProtocol;
    }(sqlExtHost_protocol_1.ExtHostDataProtocolShape));
    exports.ExtHostDataProtocol = ExtHostDataProtocol;
});

define(__m[184/*sql/workbench/api/node/extHostExtensionManagement*/], __M([0/*require*/,1/*exports*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/]), function (require, exports, sqlExtHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostExtensionManagement = /** @class */ (function () {
        function ExtHostExtensionManagement(_mainContext) {
            this._proxy = _mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadExtensionManagement);
        }
        ExtHostExtensionManagement.prototype.$install = function (vsixPath) {
            return this._proxy.$install(vsixPath);
        };
        return ExtHostExtensionManagement;
    }());
    exports.ExtHostExtensionManagement = ExtHostExtensionManagement;
});

define(__m[185/*sql/workbench/api/node/extHostModalDialog*/], __M([0/*require*/,1/*exports*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/,3/*vs/base/common/event*/]), function (require, exports, sqlExtHost_protocol_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDialog = /** @class */ (function () {
        function ExtHostDialog(_proxy, _handle) {
            this._proxy = _proxy;
            this._handle = _handle;
            this.onMessageEmitter = new event_1.Emitter();
            this.onClosedEmitter = new event_1.Emitter();
        }
        Object.defineProperty(ExtHostDialog.prototype, "title", {
            get: function () {
                return this._title;
            },
            set: function (value) {
                if (this._title !== value) {
                    this._title = value;
                    this._proxy.$setTitle(this._handle, value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDialog.prototype, "html", {
            get: function () {
                return this._html;
            },
            set: function (value) {
                if (this._html !== value) {
                    this._html = value;
                    this._proxy.$setHtml(this._handle, value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDialog.prototype, "okTitle", {
            get: function () {
                return this._okTitle;
            },
            set: function (value) {
                this._okTitle = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDialog.prototype, "closeTitle", {
            get: function () {
                return this._closeTitle;
            },
            set: function (value) {
                this._closeTitle = value;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostDialog.prototype.open = function () {
            this._proxy.$show(this._handle);
        };
        ExtHostDialog.prototype.close = function () {
            this._proxy.$disposeDialog(this._handle);
        };
        ExtHostDialog.prototype.postMessage = function (message) {
            return this._proxy.$sendMessage(this._handle, message);
        };
        Object.defineProperty(ExtHostDialog.prototype, "onMessage", {
            get: function () {
                return this.onMessageEmitter.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDialog.prototype, "onClosed", {
            get: function () {
                return this.onClosedEmitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return ExtHostDialog;
    }());
    var ExtHostModalDialogs = /** @class */ (function () {
        function ExtHostModalDialogs(mainContext) {
            this._webviews = new Map();
            this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadModalDialog);
        }
        ExtHostModalDialogs.prototype.createDialog = function (title) {
            console.log(title);
            var handle = ExtHostModalDialogs._handlePool++;
            this._proxy.$createDialog(handle);
            var webview = new ExtHostDialog(this._proxy, handle);
            this._webviews.set(handle, webview);
            webview.title = title;
            //webview.options = options;
            //this._proxy.$show(handle);
            return webview;
        };
        ExtHostModalDialogs.prototype.$onMessage = function (handle, message) {
            var webview = this._webviews.get(handle);
            webview.onMessageEmitter.fire(message);
        };
        ExtHostModalDialogs.prototype.$onClosed = function (handle) {
            var webview = this._webviews.get(handle);
            webview.onClosedEmitter.fire();
        };
        ExtHostModalDialogs._handlePool = 0;
        return ExtHostModalDialogs;
    }());
    exports.ExtHostModalDialogs = ExtHostModalDialogs;
});














































define(__m[186/*sql/workbench/api/node/extHostModelView*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,20/*vs/base/common/objects*/,88/*vs/nls!sql/workbench/api/node/extHostModelView*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/,28/*sql/workbench/api/common/sqlExtHostTypes*/]), function (require, exports, event_1, objects_1, nls, sqlExtHost_protocol_1, sqlExtHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ModelBuilderImpl = /** @class */ (function () {
        function ModelBuilderImpl(_proxy, _handle, _mainContext, _extHostModelViewTree, _extensionLocation) {
            this._proxy = _proxy;
            this._handle = _handle;
            this._mainContext = _mainContext;
            this._extHostModelViewTree = _extHostModelViewTree;
            this._extensionLocation = _extensionLocation;
            this._componentBuilders = new Map();
            this.nextComponentId = 0;
        }
        ModelBuilderImpl.prototype.navContainer = function () {
            var id = this.getNextComponentId();
            var container = new GenericContainerBuilder(this._proxy, this._handle, sqlExtHostTypes_1.ModelComponentTypes.NavContainer, id);
            this._componentBuilders.set(id, container);
            return container;
        };
        ModelBuilderImpl.prototype.divContainer = function () {
            var id = this.getNextComponentId();
            var container = new DivContainerBuilder(this._proxy, this._handle, sqlExtHostTypes_1.ModelComponentTypes.DivContainer, id);
            this._componentBuilders.set(id, container);
            return container;
        };
        ModelBuilderImpl.prototype.flexContainer = function () {
            var id = this.getNextComponentId();
            var container = new GenericContainerBuilder(this._proxy, this._handle, sqlExtHostTypes_1.ModelComponentTypes.FlexContainer, id);
            this._componentBuilders.set(id, container);
            return container;
        };
        ModelBuilderImpl.prototype.formContainer = function () {
            var id = this.getNextComponentId();
            var container = new FormContainerBuilder(this._proxy, this._handle, sqlExtHostTypes_1.ModelComponentTypes.Form, id, this);
            this._componentBuilders.set(id, container);
            return container;
        };
        ModelBuilderImpl.prototype.toolbarContainer = function () {
            var id = this.getNextComponentId();
            var container = new ToolbarContainerBuilder(this._proxy, this._handle, sqlExtHostTypes_1.ModelComponentTypes.Toolbar, id);
            this._componentBuilders.set(id, container);
            return container;
        };
        ModelBuilderImpl.prototype.groupContainer = function () {
            var id = this.getNextComponentId();
            var container = new GenericContainerBuilder(this._proxy, this._handle, sqlExtHostTypes_1.ModelComponentTypes.Group, id);
            this._componentBuilders.set(id, container);
            return container;
        };
        ModelBuilderImpl.prototype.card = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new CardWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.tree = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new TreeComponentWrapper(this._extHostModelViewTree, this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.inputBox = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new InputBoxWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.text = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new TextComponentWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.radioButton = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new RadioButtonWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.checkBox = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new CheckBoxWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.webView = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new WebViewWrapper(this._proxy, this._handle, id, this._extensionLocation), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.editor = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new EditorWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.button = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new ButtonWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.dropDown = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new DropDownWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.listBox = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new ListBoxWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.table = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new TableComponentWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.declarativeTable = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new DeclarativeTableWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.dashboardWidget = function (widgetId) {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new ComponentWrapper(this._proxy, this._handle, sqlExtHostTypes_1.ModelComponentTypes.DashboardWidget, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.dashboardWebview = function (webviewId) {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new ComponentWrapper(this._proxy, this._handle, sqlExtHostTypes_1.ModelComponentTypes.DashboardWebview, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.loadingComponent = function () {
            var id = this.getNextComponentId();
            var builder = new LoadingComponentBuilder(new LoadingComponentWrapper(this._proxy, this._handle, id));
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.fileBrowserTree = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new FileBrowserTreeComponentWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.dom = function () {
            var id = this.getNextComponentId();
            var builder = this.getComponentBuilder(new DomComponentWrapper(this._proxy, this._handle, id), id);
            this._componentBuilders.set(id, builder);
            return builder;
        };
        ModelBuilderImpl.prototype.getComponentBuilder = function (component, id) {
            var componentBuilder = new ComponentBuilderImpl(component);
            this._componentBuilders.set(id, componentBuilder);
            return componentBuilder;
        };
        ModelBuilderImpl.prototype.handleEvent = function (componentId, eventArgs) {
            var eventHandler = this._componentBuilders.get(componentId);
            if (eventHandler) {
                eventHandler.handleEvent(eventArgs);
            }
        };
        ModelBuilderImpl.prototype.runCustomValidations = function (componentId) {
            var component = this._componentBuilders.get(componentId).componentWrapper();
            return component.runCustomValidations();
        };
        ModelBuilderImpl.prototype.getNextComponentId = function () {
            return "component" + this._handle + "_" + this.nextComponentId++;
        };
        return ModelBuilderImpl;
    }());
    var ComponentBuilderImpl = /** @class */ (function () {
        function ComponentBuilderImpl(_component) {
            this._component = _component;
            _component.registerEvent();
        }
        ComponentBuilderImpl.prototype.component = function () {
            return this._component;
        };
        ComponentBuilderImpl.prototype.componentWrapper = function () {
            return this._component;
        };
        ComponentBuilderImpl.prototype.withProperties = function (properties) {
            // Keep any properties that may have been set during initial object construction
            this._component.properties = Object.assign({}, this._component.properties, properties);
            return this;
        };
        ComponentBuilderImpl.prototype.withValidation = function (validation) {
            this._component.customValidations.push(validation);
            return this;
        };
        ComponentBuilderImpl.prototype.handleEvent = function (eventArgs) {
            this._component.onEvent(eventArgs);
        };
        return ComponentBuilderImpl;
    }());
    var ContainerBuilderImpl = /** @class */ (function (_super) {
        __extends(ContainerBuilderImpl, _super);
        function ContainerBuilderImpl(componentWrapper) {
            return _super.call(this, componentWrapper) || this;
        }
        ContainerBuilderImpl.prototype.withLayout = function (layout) {
            this._component.layout = layout;
            return this;
        };
        ContainerBuilderImpl.prototype.withItems = function (components, itemLayout) {
            this._component.itemConfigs = components.map(function (item) {
                var componentWrapper = item;
                return new InternalItemConfig(componentWrapper, itemLayout);
            });
            return this;
        };
        return ContainerBuilderImpl;
    }(ComponentBuilderImpl));
    var GenericContainerBuilder = /** @class */ (function (_super) {
        __extends(GenericContainerBuilder, _super);
        function GenericContainerBuilder(proxy, handle, type, id) {
            return _super.call(this, new ComponentWrapper(proxy, handle, type, id)) || this;
        }
        return GenericContainerBuilder;
    }(ContainerBuilderImpl));
    var DivContainerBuilder = /** @class */ (function (_super) {
        __extends(DivContainerBuilder, _super);
        function DivContainerBuilder(proxy, handle, type, id) {
            return _super.call(this, new DivContainerWrapper(proxy, handle, type, id)) || this;
        }
        return DivContainerBuilder;
    }(ContainerBuilderImpl));
    var FormContainerBuilder = /** @class */ (function (_super) {
        __extends(FormContainerBuilder, _super);
        function FormContainerBuilder(proxy, handle, type, id, _builder) {
            var _this = _super.call(this, proxy, handle, type, id) || this;
            _this._builder = _builder;
            return _this;
        }
        FormContainerBuilder.prototype.withFormItems = function (components, itemLayout) {
            this.addFormItems(components, itemLayout);
            return this;
        };
        FormContainerBuilder.prototype.convertToItemConfig = function (formComponent, itemLayout) {
            var componentWrapper = formComponent.component;
            if (formComponent.required && componentWrapper) {
                componentWrapper.required = true;
            }
            var actions = undefined;
            if (formComponent.actions) {
                actions = formComponent.actions.map(function (action) {
                    var actionComponentWrapper = action;
                    return actionComponentWrapper.id;
                });
            }
            return new InternalItemConfig(componentWrapper, Object.assign({}, itemLayout, {
                title: formComponent.title,
                actions: actions,
                isFormComponent: true,
                required: componentWrapper.required
            }));
        };
        FormContainerBuilder.prototype.addComponentActions = function (formComponent, itemLayout) {
            var _this = this;
            if (formComponent.actions) {
                formComponent.actions.forEach(function (component) {
                    var componentWrapper = component;
                    _this._component.addItem(componentWrapper, itemLayout);
                });
            }
        };
        FormContainerBuilder.prototype.removeComponentActions = function (formComponent) {
            var _this = this;
            if (formComponent.actions) {
                formComponent.actions.forEach(function (component) {
                    var componentWrapper = component;
                    _this._component.removeItem(componentWrapper);
                });
            }
        };
        FormContainerBuilder.prototype.addFormItems = function (formComponents, itemLayout) {
            var _this = this;
            formComponents.forEach(function (formComponent) {
                _this.addFormItem(formComponent, itemLayout);
            });
        };
        FormContainerBuilder.prototype.addFormItem = function (formComponent, itemLayout) {
            this.insertFormItem(formComponent, undefined, itemLayout);
        };
        FormContainerBuilder.prototype.insertFormItem = function (formComponent, index, itemLayout) {
            var _this = this;
            var componentGroup = formComponent;
            if (componentGroup && componentGroup.components !== undefined) {
                var labelComponent = this._builder.text().component();
                labelComponent.value = componentGroup.title;
                this._component.addItem(labelComponent, { isGroupLabel: true }, index);
                var componentIndex_1 = index ? index + 1 : undefined;
                componentGroup.components.forEach(function (component) {
                    var layout = component.layout || itemLayout;
                    var itemConfig = _this.convertToItemConfig(component, layout);
                    itemConfig.config.isInGroup = true;
                    _this._component.insertItem(component.component, componentIndex_1, itemConfig.config);
                    if (componentIndex_1) {
                        componentIndex_1++;
                    }
                    _this.addComponentActions(component, layout);
                });
            }
            else {
                formComponent = formComponent;
                var itemImpl = this.convertToItemConfig(formComponent, itemLayout);
                this._component.addItem(formComponent.component, itemImpl.config, index);
                this.addComponentActions(formComponent, itemLayout);
            }
        };
        FormContainerBuilder.prototype.removeFormItem = function (formComponent) {
            var _this = this;
            var componentGroup = formComponent;
            var result = false;
            if (componentGroup && componentGroup.components !== undefined) {
                var firstComponent_1 = componentGroup.components[0];
                var index = this._component.itemConfigs.findIndex(function (x) { return x.component.id === firstComponent_1.component.id; });
                if (index) {
                    result = this._component.removeItemAt(index - 1);
                }
                componentGroup.components.forEach(function (element) {
                    _this.removeComponentActions(element);
                    _this._component.removeItem(element.component);
                });
            }
            else {
                formComponent = formComponent;
                if (formComponent) {
                    result = this._component.removeItem(formComponent.component);
                    this.removeComponentActions(formComponent);
                }
            }
            return result;
        };
        return FormContainerBuilder;
    }(GenericContainerBuilder));
    var ToolbarContainerBuilder = /** @class */ (function (_super) {
        __extends(ToolbarContainerBuilder, _super);
        function ToolbarContainerBuilder() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ToolbarContainerBuilder.prototype.withToolbarItems = function (components) {
            var _this = this;
            this._component.itemConfigs = components.map(function (item) {
                return _this.convertToItemConfig(item);
            });
            return this;
        };
        ToolbarContainerBuilder.prototype.convertToItemConfig = function (toolbarComponent) {
            var componentWrapper = toolbarComponent.component;
            return new InternalItemConfig(componentWrapper, {
                title: toolbarComponent.title
            });
        };
        ToolbarContainerBuilder.prototype.addToolbarItems = function (toolbarComponent) {
            var _this = this;
            toolbarComponent.forEach(function (toolbarComponent) {
                _this.addToolbarItem(toolbarComponent);
            });
        };
        ToolbarContainerBuilder.prototype.addToolbarItem = function (toolbarComponent) {
            var itemImpl = this.convertToItemConfig(toolbarComponent);
            this._component.addItem(toolbarComponent.component, itemImpl.config);
        };
        return ToolbarContainerBuilder;
    }(GenericContainerBuilder));
    var LoadingComponentBuilder = /** @class */ (function (_super) {
        __extends(LoadingComponentBuilder, _super);
        function LoadingComponentBuilder() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LoadingComponentBuilder.prototype.withItem = function (component) {
            this.component().component = component;
            return this;
        };
        return LoadingComponentBuilder;
    }(ComponentBuilderImpl));
    var InternalItemConfig = /** @class */ (function () {
        function InternalItemConfig(_component, config) {
            this._component = _component;
            this.config = config;
        }
        InternalItemConfig.prototype.toIItemConfig = function () {
            return {
                config: this.config,
                componentShape: this._component.toComponentShape()
            };
        };
        Object.defineProperty(InternalItemConfig.prototype, "component", {
            get: function () {
                return this._component;
            },
            enumerable: true,
            configurable: true
        });
        return InternalItemConfig;
    }());
    var ComponentWrapper = /** @class */ (function () {
        function ComponentWrapper(_proxy, _handle, _type, _id) {
            this._proxy = _proxy;
            this._handle = _handle;
            this._type = _type;
            this._id = _id;
            this.properties = {};
            this.customValidations = [];
            this._valid = true;
            this._onValidityChangedEmitter = new event_1.Emitter();
            this.onValidityChanged = this._onValidityChangedEmitter.event;
            this._onErrorEmitter = new event_1.Emitter();
            this.onError = this._onErrorEmitter.event;
            this._emitterMap = new Map();
            this.properties = {};
            this.itemConfigs = [];
        }
        Object.defineProperty(ComponentWrapper.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentWrapper.prototype, "type", {
            get: function () {
                return this._type;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentWrapper.prototype, "items", {
            get: function () {
                return this.itemConfigs.map(function (itemConfig) { return itemConfig.component; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentWrapper.prototype, "enabled", {
            get: function () {
                var isEnabled = this.properties['enabled'];
                return (isEnabled === undefined) ? true : isEnabled;
            },
            set: function (value) {
                this.setProperty('enabled', value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentWrapper.prototype, "height", {
            get: function () {
                return this.properties['height'];
            },
            set: function (v) {
                this.setProperty('height', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentWrapper.prototype, "width", {
            get: function () {
                return this.properties['width'];
            },
            set: function (v) {
                this.setProperty('width', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentWrapper.prototype, "required", {
            get: function () {
                return this.properties['required'];
            },
            set: function (v) {
                this.setProperty('required', v);
            },
            enumerable: true,
            configurable: true
        });
        ComponentWrapper.prototype.toComponentShape = function () {
            return {
                id: this.id,
                type: this.type,
                layout: this.layout,
                properties: this.properties,
                itemConfigs: this.itemConfigs ? this.itemConfigs.map(function (item) { return item.toIItemConfig(); }) : undefined
            };
        };
        ComponentWrapper.prototype.clearItems = function () {
            this.itemConfigs = [];
            return this._proxy.$clearContainer(this._handle, this.id);
        };
        ComponentWrapper.prototype.addItems = function (items, itemLayout) {
            for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                var item = items_1[_i];
                this.addItem(item, itemLayout);
            }
        };
        ComponentWrapper.prototype.removeItemAt = function (index) {
            if (index >= 0 && index < this.itemConfigs.length) {
                var itemConfig = this.itemConfigs[index];
                this._proxy.$removeFromContainer(this._handle, this.id, itemConfig.toIItemConfig());
                this.itemConfigs.splice(index, 1);
                return true;
            }
            return false;
        };
        ComponentWrapper.prototype.removeItem = function (item) {
            var index = this.itemConfigs.findIndex(function (c) { return c.component.id === item.id; });
            if (index >= 0 && index < this.itemConfigs.length) {
                return this.removeItemAt(index);
            }
            return false;
        };
        ComponentWrapper.prototype.insertItem = function (item, index, itemLayout) {
            this.addItem(item, itemLayout, index);
        };
        ComponentWrapper.prototype.addItem = function (item, itemLayout, index) {
            var _this = this;
            var itemImpl = item;
            if (!itemImpl) {
                throw new Error(nls.localize(0, null));
            }
            var config = new InternalItemConfig(itemImpl, itemLayout);
            if (index !== undefined && index >= 0 && index < this.items.length) {
                this.itemConfigs.splice(index, 0, config);
            }
            else if (!index) {
                this.itemConfigs.push(config);
            }
            else {
                throw new Error(nls.localize(1, null));
            }
            this._proxy.$addToContainer(this._handle, this.id, config.toIItemConfig(), index).then(undefined, function (err) { return _this.handleError(err); });
        };
        ComponentWrapper.prototype.setLayout = function (layout) {
            return this._proxy.$setLayout(this._handle, this.id, layout);
        };
        ComponentWrapper.prototype.updateProperties = function (properties) {
            this.properties = Object.assign(this.properties, properties);
            return this.notifyPropertyChanged();
        };
        ComponentWrapper.prototype.updateProperty = function (key, value) {
            return this.setProperty(key, value);
        };
        ComponentWrapper.prototype.notifyPropertyChanged = function () {
            return this._proxy.$setProperties(this._handle, this._id, this.properties);
        };
        ComponentWrapper.prototype.registerEvent = function () {
            return this._proxy.$registerEvent(this._handle, this._id).then(function () { return true; });
        };
        ComponentWrapper.prototype.onEvent = function (eventArgs) {
            if (eventArgs && eventArgs.eventType === sqlExtHostTypes_1.ComponentEventType.PropertiesChanged) {
                this.properties = eventArgs.args;
            }
            else if (eventArgs && eventArgs.eventType === sqlExtHostTypes_1.ComponentEventType.validityChanged) {
                this._valid = eventArgs.args;
                this._onValidityChangedEmitter.fire(this._valid);
            }
            else if (eventArgs) {
                var emitter = this._emitterMap.get(eventArgs.eventType);
                if (emitter) {
                    emitter.fire(eventArgs.args);
                }
            }
        };
        ComponentWrapper.prototype.setDataProvider = function () {
            return this._proxy.$setDataProvider(this._handle, this._id);
        };
        ComponentWrapper.prototype.setProperty = function (key, value) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (!this.properties[key] || this.properties[key] !== value) {
                        // Only notify the front end if a value has been updated
                        this.properties[key] = value;
                        return [2 /*return*/, this.notifyPropertyChanged()];
                    }
                    return [2 /*return*/, Promise.resolve()];
                });
            });
        };
        ComponentWrapper.prototype.handleError = function (err) {
            this._onErrorEmitter.fire(err);
        };
        ComponentWrapper.prototype.runCustomValidations = function () {
            var _this = this;
            var isValid = true;
            try {
                this.customValidations.forEach(function (validation) {
                    if (!validation(_this)) {
                        isValid = false;
                    }
                });
            }
            catch (e) {
                isValid = false;
            }
            return isValid;
        };
        ComponentWrapper.prototype.validate = function () {
            return this._proxy.$validate(this._handle, this._id);
        };
        Object.defineProperty(ComponentWrapper.prototype, "valid", {
            get: function () {
                return this._valid;
            },
            enumerable: true,
            configurable: true
        });
        return ComponentWrapper;
    }());
    var ContainerWrapper = /** @class */ (function (_super) {
        __extends(ContainerWrapper, _super);
        function ContainerWrapper(proxy, handle, type, id) {
            return _super.call(this, proxy, handle, type, id) || this;
        }
        return ContainerWrapper;
    }(ComponentWrapper));
    var CardWrapper = /** @class */ (function (_super) {
        __extends(CardWrapper, _super);
        function CardWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.Card, id) || this;
            _this.properties = {};
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onDidClick, new event_1.Emitter());
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onDidClick, new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(CardWrapper.prototype, "label", {
            get: function () {
                return this.properties['label'];
            },
            set: function (l) {
                this.setProperty('label', l);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CardWrapper.prototype, "value", {
            get: function () {
                return this.properties['value'];
            },
            set: function (v) {
                this.setProperty('value', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CardWrapper.prototype, "selected", {
            get: function () {
                return this.properties['selected'];
            },
            set: function (v) {
                this.setProperty('selected', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CardWrapper.prototype, "cardType", {
            get: function () {
                return this.properties['cardType'];
            },
            set: function (v) {
                this.setProperty('cardType', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CardWrapper.prototype, "actions", {
            get: function () {
                return this.properties['actions'];
            },
            set: function (a) {
                this.setProperty('actions', a);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CardWrapper.prototype, "iconPath", {
            get: function () {
                return this.properties['iconPath'];
            },
            set: function (v) {
                this.setProperty('iconPath', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CardWrapper.prototype, "iconHeight", {
            get: function () {
                return this.properties['iconHeight'];
            },
            set: function (v) {
                this.setProperty('iconHeight', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CardWrapper.prototype, "iconWidth", {
            get: function () {
                return this.properties['iconWidth'];
            },
            set: function (v) {
                this.setProperty('iconWidth', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CardWrapper.prototype, "onDidActionClick", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onDidClick);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CardWrapper.prototype, "onCardSelectedChanged", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onDidClick);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return CardWrapper;
    }(ComponentWrapper));
    var InputBoxWrapper = /** @class */ (function (_super) {
        __extends(InputBoxWrapper, _super);
        function InputBoxWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.InputBox, id) || this;
            _this.properties = {};
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onDidChange, new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(InputBoxWrapper.prototype, "value", {
            get: function () {
                return this.properties['value'];
            },
            set: function (v) {
                this.setProperty('value', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBoxWrapper.prototype, "ariaLabel", {
            get: function () {
                return this.properties['ariaLabel'];
            },
            set: function (v) {
                this.setProperty('ariaLabel', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBoxWrapper.prototype, "placeHolder", {
            get: function () {
                return this.properties['placeHolder'];
            },
            set: function (v) {
                this.setProperty('placeHolder', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBoxWrapper.prototype, "rows", {
            get: function () {
                return this.properties['rows'];
            },
            set: function (v) {
                this.setProperty('rows', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBoxWrapper.prototype, "min", {
            get: function () {
                return this.properties['min'];
            },
            set: function (v) {
                this.setProperty('min', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBoxWrapper.prototype, "max", {
            get: function () {
                return this.properties['max'];
            },
            set: function (v) {
                this.setProperty('max', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBoxWrapper.prototype, "columns", {
            get: function () {
                return this.properties['columns'];
            },
            set: function (v) {
                this.setProperty('columns', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBoxWrapper.prototype, "multiline", {
            get: function () {
                return this.properties['multiline'];
            },
            set: function (v) {
                this.setProperty('multiline', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBoxWrapper.prototype, "inputType", {
            get: function () {
                return this.properties['inputType'];
            },
            set: function (v) {
                this.setProperty('inputType', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBoxWrapper.prototype, "onTextChanged", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onDidChange);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return InputBoxWrapper;
    }(ComponentWrapper));
    var CheckBoxWrapper = /** @class */ (function (_super) {
        __extends(CheckBoxWrapper, _super);
        function CheckBoxWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.CheckBox, id) || this;
            _this.properties = {};
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onDidChange, new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(CheckBoxWrapper.prototype, "checked", {
            get: function () {
                return this.properties['checked'];
            },
            set: function (v) {
                this.setProperty('checked', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CheckBoxWrapper.prototype, "label", {
            get: function () {
                return this.properties['label'];
            },
            set: function (v) {
                this.setProperty('label', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CheckBoxWrapper.prototype, "onChanged", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onDidChange);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return CheckBoxWrapper;
    }(ComponentWrapper));
    var WebViewWrapper = /** @class */ (function (_super) {
        __extends(WebViewWrapper, _super);
        function WebViewWrapper(proxy, handle, id, _extensionLocation) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.WebView, id) || this;
            _this._extensionLocation = _extensionLocation;
            _this.properties = {
                'extensionLocation': _this._extensionLocation
            };
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onMessage, new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(WebViewWrapper.prototype, "message", {
            get: function () {
                return this.properties['message'];
            },
            set: function (v) {
                this.setProperty('message', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WebViewWrapper.prototype, "html", {
            get: function () {
                return this.properties['html'];
            },
            set: function (html) {
                this.setProperty('html', html);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WebViewWrapper.prototype, "onMessage", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onMessage);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WebViewWrapper.prototype, "options", {
            get: function () {
                return this.properties['options'];
            },
            set: function (o) {
                this.setProperty('options', o);
            },
            enumerable: true,
            configurable: true
        });
        return WebViewWrapper;
    }(ComponentWrapper));
    var DomComponentWrapper = /** @class */ (function (_super) {
        __extends(DomComponentWrapper, _super);
        function DomComponentWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.Dom, id) || this;
            _this.properties = {};
            return _this;
        }
        Object.defineProperty(DomComponentWrapper.prototype, "html", {
            get: function () {
                return this.properties['html'];
            },
            set: function (html) {
                this.setProperty('html', html);
            },
            enumerable: true,
            configurable: true
        });
        return DomComponentWrapper;
    }(ComponentWrapper));
    var EditorWrapper = /** @class */ (function (_super) {
        __extends(EditorWrapper, _super);
        function EditorWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.Editor, id) || this;
            _this.properties = {};
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onDidChange, new event_1.Emitter());
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onComponentCreated, new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(EditorWrapper.prototype, "content", {
            get: function () {
                return this.properties['content'];
            },
            set: function (v) {
                this.setProperty('content', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorWrapper.prototype, "languageMode", {
            get: function () {
                return this.properties['languageMode'];
            },
            set: function (v) {
                this.setProperty('languageMode', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorWrapper.prototype, "editorUri", {
            get: function () {
                return this.properties['editorUri'];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorWrapper.prototype, "isAutoResizable", {
            get: function () {
                return this.properties['isAutoResizable'];
            },
            set: function (v) {
                this.setProperty('isAutoResizable', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorWrapper.prototype, "minimumHeight", {
            get: function () {
                return this.properties['minimumHeight'];
            },
            set: function (v) {
                this.setProperty('minimumHeight', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorWrapper.prototype, "onContentChanged", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onDidChange);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorWrapper.prototype, "onEditorCreated", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onComponentCreated);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return EditorWrapper;
    }(ComponentWrapper));
    var RadioButtonWrapper = /** @class */ (function (_super) {
        __extends(RadioButtonWrapper, _super);
        function RadioButtonWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.RadioButton, id) || this;
            _this.properties = {};
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onDidClick, new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(RadioButtonWrapper.prototype, "name", {
            get: function () {
                return this.properties['name'];
            },
            set: function (v) {
                this.setProperty('name', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RadioButtonWrapper.prototype, "label", {
            get: function () {
                return this.properties['label'];
            },
            set: function (v) {
                this.setProperty('label', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RadioButtonWrapper.prototype, "value", {
            get: function () {
                return this.properties['value'];
            },
            set: function (v) {
                this.setProperty('value', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RadioButtonWrapper.prototype, "checked", {
            get: function () {
                return this.properties['checked'];
            },
            set: function (v) {
                this.setProperty('checked', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RadioButtonWrapper.prototype, "onDidClick", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onDidClick);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return RadioButtonWrapper;
    }(ComponentWrapper));
    var TextComponentWrapper = /** @class */ (function (_super) {
        __extends(TextComponentWrapper, _super);
        function TextComponentWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.Text, id) || this;
            _this.properties = {};
            return _this;
        }
        Object.defineProperty(TextComponentWrapper.prototype, "value", {
            get: function () {
                return this.properties['value'];
            },
            set: function (v) {
                this.setProperty('value', v);
            },
            enumerable: true,
            configurable: true
        });
        return TextComponentWrapper;
    }(ComponentWrapper));
    var TableComponentWrapper = /** @class */ (function (_super) {
        __extends(TableComponentWrapper, _super);
        function TableComponentWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.Table, id) || this;
            _this.properties = {};
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onSelectedRowChanged, new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(TableComponentWrapper.prototype, "data", {
            get: function () {
                return this.properties['data'];
            },
            set: function (v) {
                this.setProperty('data', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponentWrapper.prototype, "columns", {
            get: function () {
                return this.properties['columns'];
            },
            set: function (v) {
                this.setProperty('columns', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponentWrapper.prototype, "fontSize", {
            get: function () {
                return this.properties['fontSize'];
            },
            set: function (size) {
                this.setProperty('fontSize', size);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponentWrapper.prototype, "selectedRows", {
            get: function () {
                return this.properties['selectedRows'];
            },
            set: function (v) {
                this.setProperty('selectedRows', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponentWrapper.prototype, "onRowSelected", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onSelectedRowChanged);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return TableComponentWrapper;
    }(ComponentWrapper));
    var DropDownWrapper = /** @class */ (function (_super) {
        __extends(DropDownWrapper, _super);
        function DropDownWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.DropDown, id) || this;
            _this.properties = {};
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onDidChange, new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(DropDownWrapper.prototype, "value", {
            get: function () {
                var val = this.properties['value'];
                if (!val && this.values && this.values.length > 0) {
                    val = this.values[0];
                }
                return val;
            },
            set: function (v) {
                this.setProperty('value', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DropDownWrapper.prototype, "values", {
            get: function () {
                return this.properties['values'];
            },
            set: function (v) {
                this.setProperty('values', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DropDownWrapper.prototype, "editable", {
            get: function () {
                return this.properties['editable'];
            },
            set: function (v) {
                this.setProperty('editable', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DropDownWrapper.prototype, "onValueChanged", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onDidChange);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return DropDownWrapper;
    }(ComponentWrapper));
    var DeclarativeTableWrapper = /** @class */ (function (_super) {
        __extends(DeclarativeTableWrapper, _super);
        function DeclarativeTableWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.DeclarativeTable, id) || this;
            _this.properties = {};
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onDidChange, new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(DeclarativeTableWrapper.prototype, "data", {
            get: function () {
                return this.properties['data'];
            },
            set: function (v) {
                this.setProperty('data', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeclarativeTableWrapper.prototype, "columns", {
            get: function () {
                return this.properties['columns'];
            },
            set: function (v) {
                this.setProperty('columns', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeclarativeTableWrapper.prototype, "onDataChanged", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onDidChange);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return DeclarativeTableWrapper;
    }(ComponentWrapper));
    var ListBoxWrapper = /** @class */ (function (_super) {
        __extends(ListBoxWrapper, _super);
        function ListBoxWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.ListBox, id) || this;
            _this.properties = {};
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onSelectedRowChanged, new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(ListBoxWrapper.prototype, "selectedRow", {
            get: function () {
                return this.properties['selectedRow'];
            },
            set: function (v) {
                this.setProperty('selectedRow', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListBoxWrapper.prototype, "values", {
            get: function () {
                return this.properties['values'];
            },
            set: function (v) {
                this.setProperty('values', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListBoxWrapper.prototype, "onRowSelected", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onSelectedRowChanged);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return ListBoxWrapper;
    }(ComponentWrapper));
    var ButtonWrapper = /** @class */ (function (_super) {
        __extends(ButtonWrapper, _super);
        function ButtonWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.Button, id) || this;
            _this.properties = {};
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onDidClick, new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(ButtonWrapper.prototype, "label", {
            get: function () {
                return this.properties['label'];
            },
            set: function (v) {
                this.setProperty('label', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonWrapper.prototype, "iconPath", {
            get: function () {
                return this.properties['iconPath'];
            },
            set: function (v) {
                this.setProperty('iconPath', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonWrapper.prototype, "title", {
            get: function () {
                return this.properties['title'];
            },
            set: function (v) {
                this.setProperty('title', v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonWrapper.prototype, "onDidClick", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onDidClick);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return ButtonWrapper;
    }(ComponentWrapper));
    var LoadingComponentWrapper = /** @class */ (function (_super) {
        __extends(LoadingComponentWrapper, _super);
        function LoadingComponentWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.LoadingComponent, id) || this;
            _this.properties = {};
            _this.loading = true;
            return _this;
        }
        Object.defineProperty(LoadingComponentWrapper.prototype, "loading", {
            get: function () {
                return this.properties['loading'];
            },
            set: function (value) {
                this.setProperty('loading', value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LoadingComponentWrapper.prototype, "component", {
            get: function () {
                return this.items[0];
            },
            set: function (value) {
                this.addItem(value);
            },
            enumerable: true,
            configurable: true
        });
        return LoadingComponentWrapper;
    }(ComponentWrapper));
    var FileBrowserTreeComponentWrapper = /** @class */ (function (_super) {
        __extends(FileBrowserTreeComponentWrapper, _super);
        function FileBrowserTreeComponentWrapper(proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.FileBrowserTree, id) || this;
            _this.properties = {};
            _this._emitterMap.set(sqlExtHostTypes_1.ComponentEventType.onDidChange, new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(FileBrowserTreeComponentWrapper.prototype, "ownerUri", {
            get: function () {
                return this.properties['ownerUri'];
            },
            set: function (value) {
                this.setProperty('ownerUri', value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileBrowserTreeComponentWrapper.prototype, "onDidChange", {
            get: function () {
                var emitter = this._emitterMap.get(sqlExtHostTypes_1.ComponentEventType.onDidChange);
                return emitter && emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return FileBrowserTreeComponentWrapper;
    }(ComponentWrapper));
    var DivContainerWrapper = /** @class */ (function (_super) {
        __extends(DivContainerWrapper, _super);
        function DivContainerWrapper() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(DivContainerWrapper.prototype, "overflowY", {
            get: function () {
                return this.properties['overflowY'];
            },
            set: function (value) {
                this.setProperty('overflowY', value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DivContainerWrapper.prototype, "yOffsetChange", {
            get: function () {
                return this.properties['yOffsetChange'];
            },
            set: function (value) {
                this.setProperty('yOffsetChange', value);
            },
            enumerable: true,
            configurable: true
        });
        return DivContainerWrapper;
    }(ComponentWrapper));
    var TreeComponentWrapper = /** @class */ (function (_super) {
        __extends(TreeComponentWrapper, _super);
        function TreeComponentWrapper(_extHostModelViewTree, proxy, handle, id) {
            var _this = _super.call(this, proxy, handle, sqlExtHostTypes_1.ModelComponentTypes.TreeComponent, id) || this;
            _this._extHostModelViewTree = _extHostModelViewTree;
            _this.properties = {};
            return _this;
        }
        TreeComponentWrapper.prototype.registerDataProvider = function (dataProvider) {
            this.setDataProvider();
            return this._extHostModelViewTree.$createTreeView(this._handle, this.id, { treeDataProvider: dataProvider });
        };
        Object.defineProperty(TreeComponentWrapper.prototype, "withCheckbox", {
            get: function () {
                return this.properties['withCheckbox'];
            },
            set: function (v) {
                this.setProperty('withCheckbox', v);
            },
            enumerable: true,
            configurable: true
        });
        return TreeComponentWrapper;
    }(ComponentWrapper));
    var ModelViewImpl = /** @class */ (function () {
        function ModelViewImpl(_proxy, _handle, _connection, _serverInfo, mainContext, _extHostModelViewTree, _extensionLocation) {
            this._proxy = _proxy;
            this._handle = _handle;
            this._connection = _connection;
            this._serverInfo = _serverInfo;
            this.mainContext = mainContext;
            this._extHostModelViewTree = _extHostModelViewTree;
            this._extensionLocation = _extensionLocation;
            this.onClosedEmitter = new event_1.Emitter();
            this._onValidityChangedEmitter = new event_1.Emitter();
            this.onValidityChanged = this._onValidityChangedEmitter.event;
            this._modelBuilder = new ModelBuilderImpl(this._proxy, this._handle, this.mainContext, this._extHostModelViewTree, _extensionLocation);
        }
        Object.defineProperty(ModelViewImpl.prototype, "onClosed", {
            get: function () {
                return this.onClosedEmitter.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelViewImpl.prototype, "connection", {
            get: function () {
                return objects_1.deepClone(this._connection);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelViewImpl.prototype, "serverInfo", {
            get: function () {
                return objects_1.deepClone(this._serverInfo);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelViewImpl.prototype, "modelBuilder", {
            get: function () {
                return this._modelBuilder;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelViewImpl.prototype, "valid", {
            get: function () {
                return this._component.valid;
            },
            enumerable: true,
            configurable: true
        });
        ModelViewImpl.prototype.handleEvent = function (componentId, eventArgs) {
            this._modelBuilder.handleEvent(componentId, eventArgs);
        };
        ModelViewImpl.prototype.initializeModel = function (component) {
            var _this = this;
            component.onValidityChanged(function (valid) { return _this._onValidityChangedEmitter.fire(valid); });
            this._component = component;
            var componentImpl = component;
            if (!componentImpl) {
                return Promise.reject(nls.localize(2, null));
            }
            return this._proxy.$initializeModel(this._handle, componentImpl.toComponentShape());
        };
        ModelViewImpl.prototype.validate = function () {
            return this._proxy.$validate(this._handle, this._component.id);
        };
        ModelViewImpl.prototype.runCustomValidations = function (componentId) {
            return this._modelBuilder.runCustomValidations(componentId);
        };
        return ModelViewImpl;
    }());
    var ExtHostModelView = /** @class */ (function () {
        function ExtHostModelView(_mainContext, _extHostModelViewTree) {
            this._mainContext = _mainContext;
            this._extHostModelViewTree = _extHostModelViewTree;
            this._modelViews = new Map();
            this._handlers = new Map();
            this._handlerToExtensionPath = new Map();
            this._proxy = _mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadModelView);
        }
        ExtHostModelView.prototype.$onClosed = function (handle) {
            var view = this._modelViews.get(handle);
            view.onClosedEmitter.fire();
            this._modelViews.delete(handle);
        };
        ExtHostModelView.prototype.$registerProvider = function (widgetId, handler, extensionLocation) {
            this._handlers.set(widgetId, handler);
            this._handlerToExtensionPath.set(widgetId, extensionLocation);
            this._proxy.$registerProvider(widgetId);
        };
        ExtHostModelView.prototype.$registerWidget = function (handle, id, connection, serverInfo) {
            var extensionLocation = this._handlerToExtensionPath.get(id);
            var view = new ModelViewImpl(this._proxy, handle, connection, serverInfo, this._mainContext, this._extHostModelViewTree, extensionLocation);
            this._modelViews.set(handle, view);
            this._handlers.get(id)(view);
        };
        ExtHostModelView.prototype.$handleEvent = function (handle, componentId, eventArgs) {
            var view = this._modelViews.get(handle);
            if (view) {
                view.handleEvent(componentId, eventArgs);
            }
        };
        ExtHostModelView.prototype.$runCustomValidations = function (handle, componentId) {
            var view = this._modelViews.get(handle);
            return Promise.resolve(view.runCustomValidations(componentId));
        };
        return ExtHostModelView;
    }());
    exports.ExtHostModelView = ExtHostModelView;
});











define(__m[187/*sql/workbench/api/node/extHostModelViewDialog*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,91/*vs/nls!sql/workbench/api/node/extHostModelViewDialog*/,44/*vs/base/common/uuid*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/]), function (require, exports, event_1, nls, uuid_1, sqlExtHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var DONE_LABEL = nls.localize(0, null);
    var CANCEL_LABEL = nls.localize(1, null);
    var GENERATE_SCRIPT_LABEL = nls.localize(2, null);
    var NEXT_LABEL = nls.localize(3, null);
    var PREVIOUS_LABEL = nls.localize(4, null);
    var ModelViewPanelImpl = /** @class */ (function () {
        function ModelViewPanelImpl(_viewType, _extHostModelViewDialog, _extHostModelView, _extensionLocation) {
            var _this = this;
            this._viewType = _viewType;
            this._extHostModelViewDialog = _extHostModelViewDialog;
            this._extHostModelView = _extHostModelView;
            this._extensionLocation = _extensionLocation;
            this._valid = true;
            this._onValidityChanged = this._extHostModelViewDialog.getValidityChangedEvent(this);
            this._onValidityChanged(function (valid) { return _this._valid = valid; });
        }
        ModelViewPanelImpl.prototype.registerContent = function (handler) {
            var _this = this;
            if (!this._modelViewId) {
                var viewId = this._viewType + this._handle;
                this.setModelViewId(viewId);
                this._extHostModelView.$registerProvider(viewId, function (modelView) {
                    _this._modelView = modelView;
                    handler(modelView);
                }, this._extensionLocation);
            }
        };
        Object.defineProperty(ModelViewPanelImpl.prototype, "handle", {
            set: function (value) {
                this._handle = value;
            },
            enumerable: true,
            configurable: true
        });
        ModelViewPanelImpl.prototype.setModelViewId = function (value) {
            this._modelViewId = value;
        };
        Object.defineProperty(ModelViewPanelImpl.prototype, "modelView", {
            get: function () {
                return this._modelView;
            },
            set: function (value) {
                this._modelView = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelViewPanelImpl.prototype, "valid", {
            get: function () {
                return this._valid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelViewPanelImpl.prototype, "onValidityChanged", {
            get: function () {
                return this._onValidityChanged;
            },
            enumerable: true,
            configurable: true
        });
        return ModelViewPanelImpl;
    }());
    var ModelViewEditorImpl = /** @class */ (function (_super) {
        __extends(ModelViewEditorImpl, _super);
        function ModelViewEditorImpl(extHostModelViewDialog, extHostModelView, extensionLocation, _proxy, _title, _options) {
            var _this = _super.call(this, 'modelViewEditor', extHostModelViewDialog, extHostModelView, extensionLocation) || this;
            _this._proxy = _proxy;
            _this._title = _title;
            _this._options = _options;
            _this._isDirty = false;
            return _this;
        }
        ModelViewEditorImpl.prototype.openEditor = function (position) {
            return this._proxy.$openEditor(this.handle, this._modelViewId, this._title, this._options, position);
        };
        Object.defineProperty(ModelViewEditorImpl.prototype, "isDirty", {
            get: function () {
                return this._isDirty;
            },
            set: function (value) {
                this._isDirty = value;
                this._proxy.$setDirty(this.handle, value);
            },
            enumerable: true,
            configurable: true
        });
        ModelViewEditorImpl.prototype.registerSaveHandler = function (handler) {
            this._saveHandler = handler;
        };
        ModelViewEditorImpl.prototype.handleSave = function () {
            if (this._saveHandler) {
                return Promise.resolve(this._saveHandler());
            }
            else {
                return Promise.resolve(true);
            }
        };
        return ModelViewEditorImpl;
    }(ModelViewPanelImpl));
    var DialogImpl = /** @class */ (function (_super) {
        __extends(DialogImpl, _super);
        function DialogImpl(extHostModelViewDialog, extHostModelView, extHostTaskManagement, extensionLocation) {
            var _this = _super.call(this, 'modelViewDialog', extHostModelViewDialog, extHostModelView, extensionLocation) || this;
            _this.okButton = _this._extHostModelViewDialog.createButton(DONE_LABEL);
            _this.cancelButton = _this._extHostModelViewDialog.createButton(CANCEL_LABEL);
            _this._operationHandler = new BackgroundOperationHandler('dialog', extHostTaskManagement);
            _this.okButton.onClick(function () {
                _this._operationHandler.createOperation();
            });
            return _this;
        }
        DialogImpl.prototype.registerOperation = function (operationInfo) {
            this._operationHandler.registerOperation(operationInfo);
        };
        DialogImpl.prototype.setModelViewId = function (value) {
            _super.prototype.setModelViewId.call(this, value);
            this.content = value;
        };
        Object.defineProperty(DialogImpl.prototype, "message", {
            get: function () {
                return this._message;
            },
            set: function (value) {
                this._message = value;
                this._extHostModelViewDialog.updateDialogContent(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DialogImpl.prototype, "dialogName", {
            get: function () {
                return this._dialogName;
            },
            set: function (value) {
                this._dialogName = value;
            },
            enumerable: true,
            configurable: true
        });
        DialogImpl.prototype.registerCloseValidator = function (validator) {
            this._closeValidator = validator;
        };
        DialogImpl.prototype.validateClose = function () {
            if (this._closeValidator) {
                return Promise.resolve(this._closeValidator());
            }
            else {
                return Promise.resolve(true);
            }
        };
        return DialogImpl;
    }(ModelViewPanelImpl));
    var TabImpl = /** @class */ (function (_super) {
        __extends(TabImpl, _super);
        function TabImpl(extHostModelViewDialog, extHostModelView, extensionLocation) {
            return _super.call(this, 'modelViewDialogTab', extHostModelViewDialog, extHostModelView, extensionLocation) || this;
        }
        TabImpl.prototype.setModelViewId = function (value) {
            _super.prototype.setModelViewId.call(this, value);
            this.content = value;
        };
        return TabImpl;
    }(ModelViewPanelImpl));
    var ButtonImpl = /** @class */ (function () {
        function ButtonImpl(_extHostModelViewDialog) {
            this._extHostModelViewDialog = _extHostModelViewDialog;
            this._onClick = new event_1.Emitter();
            this.onClick = this._onClick.event;
            this._enabled = true;
            this._hidden = false;
        }
        Object.defineProperty(ButtonImpl.prototype, "label", {
            get: function () {
                return this._label;
            },
            set: function (label) {
                this._label = label;
                this._extHostModelViewDialog.updateButton(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonImpl.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (enabled) {
                this._enabled = enabled;
                this._extHostModelViewDialog.updateButton(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonImpl.prototype, "hidden", {
            get: function () {
                return this._hidden;
            },
            set: function (hidden) {
                this._hidden = hidden;
                this._extHostModelViewDialog.updateButton(this);
            },
            enumerable: true,
            configurable: true
        });
        ButtonImpl.prototype.getOnClickCallback = function () {
            var _this = this;
            return function () { return _this._onClick.fire(); };
        };
        return ButtonImpl;
    }());
    var BackgroundOperationHandler = /** @class */ (function () {
        function BackgroundOperationHandler(_name, _extHostTaskManagement) {
            this._name = _name;
            this._extHostTaskManagement = _extHostTaskManagement;
        }
        BackgroundOperationHandler.prototype.createOperation = function () {
            if (!this._operationInfo) {
                return;
            }
            if (!this._operationInfo.operationId) {
                var uniqueId = uuid_1.generateUuid();
                this._operationInfo.operationId = 'OperationId' + uniqueId + this._name;
            }
            if (this._operationInfo.operation) {
                this._extHostTaskManagement.$registerTask(this._operationInfo);
            }
        };
        BackgroundOperationHandler.prototype.registerOperation = function (operationInfo) {
            this._operationInfo = operationInfo;
        };
        return BackgroundOperationHandler;
    }());
    var WizardPageImpl = /** @class */ (function (_super) {
        __extends(WizardPageImpl, _super);
        function WizardPageImpl(title, extHostModelViewDialog, extHostModelView, extensionLocation) {
            var _this = _super.call(this, 'modelViewWizardPage', extHostModelViewDialog, extHostModelView, extensionLocation) || this;
            _this.title = title;
            _this._enabled = true;
            return _this;
        }
        Object.defineProperty(WizardPageImpl.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (enabled) {
                this._enabled = enabled;
                this._extHostModelViewDialog.updateWizardPage(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardPageImpl.prototype, "content", {
            get: function () {
                return this._modelViewId;
            },
            set: function (content) {
                this._modelViewId = content;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardPageImpl.prototype, "description", {
            get: function () {
                return this._description;
            },
            set: function (description) {
                this._description = description;
                this._extHostModelViewDialog.updateWizardPage(this);
            },
            enumerable: true,
            configurable: true
        });
        return WizardPageImpl;
    }(ModelViewPanelImpl));
    var WizardPageInfoEventType;
    (function (WizardPageInfoEventType) {
        WizardPageInfoEventType[WizardPageInfoEventType["PageChanged"] = 0] = "PageChanged";
        WizardPageInfoEventType[WizardPageInfoEventType["PageAddedOrRemoved"] = 1] = "PageAddedOrRemoved";
    })(WizardPageInfoEventType = exports.WizardPageInfoEventType || (exports.WizardPageInfoEventType = {}));
    var WizardImpl = /** @class */ (function () {
        function WizardImpl(title, _extHostModelViewDialog, extHostTaskManagement) {
            var _this = this;
            this.title = title;
            this._extHostModelViewDialog = _extHostModelViewDialog;
            this._currentPage = undefined;
            this.pages = [];
            this._pageChangedEmitter = new event_1.Emitter();
            this.onPageChanged = this._pageChangedEmitter.event;
            this._displayPageTitles = true;
            this.doneButton = this._extHostModelViewDialog.createButton(DONE_LABEL);
            this.cancelButton = this._extHostModelViewDialog.createButton(CANCEL_LABEL);
            this.generateScriptButton = this._extHostModelViewDialog.createButton(GENERATE_SCRIPT_LABEL);
            this.nextButton = this._extHostModelViewDialog.createButton(NEXT_LABEL);
            this.backButton = this._extHostModelViewDialog.createButton(PREVIOUS_LABEL);
            this._extHostModelViewDialog.registerWizardPageInfoChangedCallback(this, function (info) { return _this.handlePageInfoChanged(info); });
            this._currentPage = 0;
            this.onPageChanged(function (info) { return _this._currentPage = info.newPage; });
            this._operationHandler = new BackgroundOperationHandler('wizard' + this.title, extHostTaskManagement);
            this.doneButton.onClick(function () {
                _this._operationHandler.createOperation();
            });
        }
        WizardImpl.prototype.registerOperation = function (operationInfo) {
            this._operationHandler.registerOperation(operationInfo);
        };
        Object.defineProperty(WizardImpl.prototype, "currentPage", {
            get: function () {
                return this._currentPage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardImpl.prototype, "message", {
            get: function () {
                return this._message;
            },
            set: function (value) {
                this._message = value;
                this._extHostModelViewDialog.updateWizard(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardImpl.prototype, "displayPageTitles", {
            get: function () {
                return this._displayPageTitles;
            },
            set: function (value) {
                this._displayPageTitles = value;
                this._extHostModelViewDialog.updateWizard(this);
            },
            enumerable: true,
            configurable: true
        });
        WizardImpl.prototype.addPage = function (page, index) {
            var _this = this;
            return this._extHostModelViewDialog.updateWizardPage(page).then(function () {
                _this._extHostModelViewDialog.addPage(_this, page, index);
            });
        };
        WizardImpl.prototype.removePage = function (index) {
            return this._extHostModelViewDialog.removePage(this, index);
        };
        WizardImpl.prototype.setCurrentPage = function (index) {
            return this._extHostModelViewDialog.setWizardPage(this, index);
        };
        WizardImpl.prototype.open = function () {
            return this._extHostModelViewDialog.openWizard(this);
        };
        WizardImpl.prototype.close = function () {
            return this._extHostModelViewDialog.closeWizard(this);
        };
        WizardImpl.prototype.registerNavigationValidator = function (validator) {
            this._navigationValidator = validator;
        };
        WizardImpl.prototype.validateNavigation = function (info) {
            if (this._navigationValidator) {
                return Promise.resolve(this._navigationValidator(info));
            }
            else {
                return Promise.resolve(true);
            }
        };
        WizardImpl.prototype.handlePageInfoChanged = function (info) {
            this._currentPage = info.pageChangeInfo.newPage;
            if (info.eventType === WizardPageInfoEventType.PageAddedOrRemoved) {
                this.pages = info.pages;
            }
            else if (info.eventType === WizardPageInfoEventType.PageChanged) {
                this._pageChangedEmitter.fire(info.pageChangeInfo);
            }
        };
        return WizardImpl;
    }());
    var ExtHostModelViewDialog = /** @class */ (function () {
        function ExtHostModelViewDialog(mainContext, _extHostModelView, _extHostTaskManagement) {
            this._extHostModelView = _extHostModelView;
            this._extHostTaskManagement = _extHostTaskManagement;
            this._objectHandles = new Map();
            this._objectsByHandle = new Map();
            this._validityEmitters = new Map();
            this._pageInfoChangedCallbacks = new Map();
            this._onClickCallbacks = new Map();
            this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadModelViewDialog);
        }
        ExtHostModelViewDialog.getNewHandle = function () {
            var handle = ExtHostModelViewDialog._currentHandle;
            ExtHostModelViewDialog._currentHandle += 1;
            return handle;
        };
        ExtHostModelViewDialog.prototype.getHandle = function (item) {
            var handle = this._objectHandles.get(item);
            if (handle === undefined) {
                handle = ExtHostModelViewDialog.getNewHandle();
                this._objectHandles.set(item, handle);
                this._objectsByHandle.set(handle, item);
            }
            return handle;
        };
        ExtHostModelViewDialog.prototype.$onButtonClick = function (handle) {
            this._onClickCallbacks.get(handle)();
        };
        ExtHostModelViewDialog.prototype.$onPanelValidityChanged = function (handle, valid) {
            var emitter = this._validityEmitters.get(handle);
            if (emitter) {
                emitter.fire(valid);
            }
        };
        ExtHostModelViewDialog.prototype.$onWizardPageChanged = function (handle, info) {
            var callback = this._pageInfoChangedCallbacks.get(handle);
            if (callback) {
                callback({
                    eventType: WizardPageInfoEventType.PageChanged,
                    pageChangeInfo: info
                });
            }
        };
        ExtHostModelViewDialog.prototype.$updateWizardPageInfo = function (handle, pageHandles, currentPageIndex) {
            var _this = this;
            var callback = this._pageInfoChangedCallbacks.get(handle);
            if (callback) {
                var pages = pageHandles.map(function (pageHandle) { return _this._objectsByHandle.get(handle); });
                callback({
                    eventType: WizardPageInfoEventType.PageAddedOrRemoved,
                    pageChangeInfo: {
                        lastPage: undefined,
                        newPage: currentPageIndex
                    },
                    pages: pages
                });
            }
        };
        ExtHostModelViewDialog.prototype.$validateNavigation = function (handle, info) {
            var wizard = this._objectsByHandle.get(handle);
            return wizard.validateNavigation(info);
        };
        ExtHostModelViewDialog.prototype.$validateDialogClose = function (handle) {
            var dialog = this._objectsByHandle.get(handle);
            return dialog.validateClose();
        };
        ExtHostModelViewDialog.prototype.$handleSave = function (handle) {
            var editor = this._objectsByHandle.get(handle);
            return editor.handleSave();
        };
        ExtHostModelViewDialog.prototype.openDialog = function (dialog) {
            var handle = this.getHandle(dialog);
            this.updateDialogContent(dialog);
            dialog.dialogName ? this._proxy.$openDialog(handle, dialog.dialogName) :
                this._proxy.$openDialog(handle);
        };
        ExtHostModelViewDialog.prototype.closeDialog = function (dialog) {
            var handle = this.getHandle(dialog);
            this._proxy.$closeDialog(handle);
        };
        ExtHostModelViewDialog.prototype.createModelViewEditor = function (title, extensionLocation, options) {
            var editor = new ModelViewEditorImpl(this, this._extHostModelView, extensionLocation, this._proxy, title, options);
            editor.handle = this.getHandle(editor);
            return editor;
        };
        ExtHostModelViewDialog.prototype.updateDialogContent = function (dialog) {
            var _this = this;
            var handle = this.getHandle(dialog);
            var tabs = dialog.content;
            if (tabs && typeof tabs !== 'string') {
                tabs.forEach(function (tab) { return _this.updateTabContent(tab); });
            }
            if (dialog.customButtons) {
                dialog.customButtons.forEach(function (button) { return _this.updateButton(button); });
            }
            this.updateButton(dialog.okButton);
            this.updateButton(dialog.cancelButton);
            this._proxy.$setDialogDetails(handle, {
                title: dialog.title,
                okButton: this.getHandle(dialog.okButton),
                cancelButton: this.getHandle(dialog.cancelButton),
                content: dialog.content && typeof dialog.content !== 'string' ? dialog.content.map(function (tab) { return _this.getHandle(tab); }) : dialog.content,
                customButtons: dialog.customButtons ? dialog.customButtons.map(function (button) { return _this.getHandle(button); }) : undefined,
                message: dialog.message
            });
        };
        ExtHostModelViewDialog.prototype.updateTabContent = function (tab) {
            var handle = this.getHandle(tab);
            this._proxy.$setTabDetails(handle, {
                title: tab.title,
                content: tab.content
            });
        };
        ExtHostModelViewDialog.prototype.updateButton = function (button) {
            var handle = this.getHandle(button);
            this._proxy.$setButtonDetails(handle, {
                label: button.label,
                enabled: button.enabled,
                hidden: button.hidden
            });
        };
        ExtHostModelViewDialog.prototype.registerOnClickCallback = function (button, callback) {
            var handle = this.getHandle(button);
            this._onClickCallbacks.set(handle, callback);
        };
        ExtHostModelViewDialog.prototype.createDialog = function (title, dialogName, extensionLocation) {
            var dialog = new DialogImpl(this, this._extHostModelView, this._extHostTaskManagement, extensionLocation);
            if (dialogName) {
                dialog.dialogName = dialogName;
            }
            dialog.title = title;
            dialog.handle = this.getHandle(dialog);
            return dialog;
        };
        ExtHostModelViewDialog.prototype.createTab = function (title, extensionLocation) {
            var tab = new TabImpl(this, this._extHostModelView, extensionLocation);
            tab.title = title;
            tab.handle = this.getHandle(tab);
            return tab;
        };
        ExtHostModelViewDialog.prototype.createButton = function (label) {
            var button = new ButtonImpl(this);
            this.getHandle(button);
            this.registerOnClickCallback(button, button.getOnClickCallback());
            button.label = label;
            return button;
        };
        ExtHostModelViewDialog.prototype.getValidityChangedEvent = function (panel) {
            var handle = this.getHandle(panel);
            var emitter = this._validityEmitters.get(handle);
            if (!emitter) {
                emitter = new event_1.Emitter();
                this._validityEmitters.set(handle, emitter);
            }
            return emitter.event;
        };
        ExtHostModelViewDialog.prototype.registerWizardPageInfoChangedCallback = function (wizard, callback) {
            var handle = this.getHandle(wizard);
            this._pageInfoChangedCallbacks.set(handle, callback);
        };
        ExtHostModelViewDialog.prototype.createWizardPage = function (title, extensionLocation) {
            var page = new WizardPageImpl(title, this, this._extHostModelView, extensionLocation);
            page.handle = this.getHandle(page);
            return page;
        };
        ExtHostModelViewDialog.prototype.createWizard = function (title) {
            var wizard = new WizardImpl(title, this, this._extHostTaskManagement);
            this.getHandle(wizard);
            return wizard;
        };
        ExtHostModelViewDialog.prototype.updateWizardPage = function (page) {
            var _this = this;
            var handle = this.getHandle(page);
            if (page.customButtons) {
                page.customButtons.forEach(function (button) { return _this.updateButton(button); });
            }
            return this._proxy.$setWizardPageDetails(handle, {
                content: page.content,
                customButtons: page.customButtons ? page.customButtons.map(function (button) { return _this.getHandle(button); }) : undefined,
                enabled: page.enabled,
                title: page.title,
                description: page.description
            });
        };
        ExtHostModelViewDialog.prototype.updateWizard = function (wizard) {
            var _this = this;
            var handle = this.getHandle(wizard);
            wizard.pages.forEach(function (page) { return _this.updateWizardPage(page); });
            this.updateButton(wizard.backButton);
            this.updateButton(wizard.cancelButton);
            this.updateButton(wizard.generateScriptButton);
            this.updateButton(wizard.doneButton);
            this.updateButton(wizard.nextButton);
            if (wizard.customButtons) {
                wizard.customButtons.forEach(function (button) { return _this.updateButton(button); });
            }
            return this._proxy.$setWizardDetails(handle, {
                title: wizard.title,
                pages: wizard.pages.map(function (page) { return _this.getHandle(page); }),
                currentPage: wizard.currentPage,
                backButton: this.getHandle(wizard.backButton),
                cancelButton: this.getHandle(wizard.cancelButton),
                generateScriptButton: this.getHandle(wizard.generateScriptButton),
                doneButton: this.getHandle(wizard.doneButton),
                nextButton: this.getHandle(wizard.nextButton),
                customButtons: wizard.customButtons ? wizard.customButtons.map(function (button) { return _this.getHandle(button); }) : undefined,
                message: wizard.message,
                displayPageTitles: wizard.displayPageTitles
            });
        };
        ExtHostModelViewDialog.prototype.addPage = function (wizard, page, pageIndex) {
            return this._proxy.$addWizardPage(this.getHandle(wizard), this.getHandle(page), pageIndex);
        };
        ExtHostModelViewDialog.prototype.removePage = function (wizard, pageIndex) {
            return this._proxy.$removeWizardPage(this.getHandle(wizard), pageIndex);
        };
        ExtHostModelViewDialog.prototype.setWizardPage = function (wizard, pageIndex) {
            return this._proxy.$setWizardPage(this.getHandle(wizard), pageIndex);
        };
        ExtHostModelViewDialog.prototype.openWizard = function (wizard) {
            var handle = this.getHandle(wizard);
            this.updateWizard(wizard);
            return this._proxy.$openWizard(handle);
        };
        ExtHostModelViewDialog.prototype.closeWizard = function (wizard) {
            var handle = this.getHandle(wizard);
            return this._proxy.$closeWizard(handle);
        };
        ExtHostModelViewDialog._currentHandle = 0;
        return ExtHostModelViewDialog;
    }());
    exports.ExtHostModelViewDialog = ExtHostModelViewDialog;
});











define(__m[188/*sql/workbench/api/node/extHostModelViewTree*/], __M([0/*require*/,1/*exports*/,92/*vs/nls!sql/workbench/api/node/extHostModelViewTree*/,2/*vs/base/common/winjs.base*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/,12/*vs/base/common/async*/,77/*vs/workbench/api/node/extHostTreeViews*/,3/*vs/base/common/event*/]), function (require, exports, nls_1, winjs_base_1, sqlExtHost_protocol_1, async_1, vsTreeExt, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostModelViewTreeViews = /** @class */ (function () {
        function ExtHostModelViewTreeViews(_mainContext) {
            this._mainContext = _mainContext;
            this.treeViews = new Map();
            this._proxy = this._mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadModelView);
        }
        ExtHostModelViewTreeViews.prototype.$createTreeView = function (handle, componentId, options) {
            var _this = this;
            if (!options || !options.treeDataProvider) {
                throw new Error('Options with treeDataProvider is mandatory');
            }
            var treeView = this.createExtHostTreeViewer(handle, componentId, options.treeDataProvider);
            return {
                dispose: function () {
                    _this.treeViews.delete(componentId);
                    treeView.dispose();
                },
                onNodeCheckedChanged: treeView.NodeCheckedChanged,
                onDidChangeSelection: treeView.ChangeSelection
            };
        };
        ExtHostModelViewTreeViews.prototype.$getChildren = function (treeViewId, treeItemHandle) {
            var treeView = this.treeViews.get(treeViewId);
            if (!treeView) {
                return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize(0, null, treeViewId)));
            }
            return treeView.getChildren(treeItemHandle);
        };
        ExtHostModelViewTreeViews.prototype.$onNodeCheckedChanged = function (treeViewId, treeItemHandle, checked) {
            var treeView = this.treeViews.get(treeViewId);
            if (treeView) {
                treeView.onNodeCheckedChanged(treeItemHandle, checked);
            }
        };
        ExtHostModelViewTreeViews.prototype.$onNodeSelected = function (treeViewId, handles) {
            var treeView = this.treeViews.get(treeViewId);
            if (treeView) {
                treeView.onNodeSelectedChanged(handles);
            }
        };
        ExtHostModelViewTreeViews.prototype.$setExpanded = function (treeViewId, treeItemHandle, expanded) {
        };
        ExtHostModelViewTreeViews.prototype.$setSelection = function (treeViewId, treeItemHandles) {
        };
        ExtHostModelViewTreeViews.prototype.$setVisible = function (treeViewId, visible) {
        };
        ExtHostModelViewTreeViews.prototype.createExtHostTreeViewer = function (handle, id, dataProvider) {
            var treeView = new ExtHostTreeView(handle, id, dataProvider, this._proxy, undefined);
            this.treeViews.set(handle + "-" + id, treeView);
            return treeView;
        };
        return ExtHostModelViewTreeViews;
    }());
    exports.ExtHostModelViewTreeViews = ExtHostModelViewTreeViews;
    var ExtHostTreeView = /** @class */ (function (_super) {
        __extends(ExtHostTreeView, _super);
        function ExtHostTreeView(handle, componentId, componentDataProvider, modelViewProxy, commands) {
            var _this = _super.call(this, componentId, componentDataProvider, undefined, commands, undefined) || this;
            _this.handle = handle;
            _this.componentId = componentId;
            _this.componentDataProvider = componentDataProvider;
            _this.modelViewProxy = modelViewProxy;
            _this._onNodeCheckedChanged = new event_1.Emitter();
            _this._onChangeSelection = new event_1.Emitter();
            _this.NodeCheckedChanged = _this._onNodeCheckedChanged.event;
            _this.ChangeSelection = _this._onChangeSelection.event;
            return _this;
        }
        ExtHostTreeView.prototype.onNodeCheckedChanged = function (parentHandle, checked) {
            var parentElement = parentHandle ? this.getExtensionElement(parentHandle) : void 0;
            if (parentHandle && !parentElement) {
                console.error("No tree item with id '" + parentHandle + "' found.");
            }
            this._onNodeCheckedChanged.fire({ element: parentElement, checked: checked });
        };
        ExtHostTreeView.prototype.onNodeSelectedChanged = function (parentHandles) {
            var _this = this;
            if (parentHandles) {
                var nodes = parentHandles.map(function (parentHandle) {
                    return parentHandle ? _this.getExtensionElement(parentHandle) : void 0;
                });
                this._onChangeSelection.fire({ selection: nodes });
            }
        };
        ExtHostTreeView.prototype.reveal = function (element, options) {
            var _this = this;
            if (typeof this.componentDataProvider.getParent !== 'function') {
                return winjs_base_1.TPromise.wrapError(new Error("Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method"));
            }
            var i;
            return this.resolveUnknownParentChain(element)
                .then(function (parentChain) { return _this.resolveTreeNode(element, parentChain[parentChain.length - 1])
                .then(function (treeNode) { return i; }); });
        };
        ExtHostTreeView.prototype.refreshElements = function (elements) {
            var hasRoot = elements.some(function (element) { return !element; });
            if (hasRoot) {
                this.clearAll(); // clear cache
                this.modelViewProxy.$refreshDataProvider(this.handle, this.componentId);
            }
            else {
                var handlesToRefresh = this.getHandlesToRefresh(elements);
                if (handlesToRefresh.length) {
                    this.refreshHandles(handlesToRefresh);
                }
            }
        };
        ExtHostTreeView.prototype.refreshHandles = function (itemHandles) {
            var _this = this;
            var itemsToRefresh = {};
            return winjs_base_1.TPromise.join(itemHandles.map(function (treeItemHandle) {
                return _this.refreshNode(treeItemHandle)
                    .then(function (node) {
                    if (node) {
                        itemsToRefresh[treeItemHandle] = node.item;
                    }
                });
            }))
                .then(function () { return Object.keys(itemsToRefresh).length ? _this.modelViewProxy.$refreshDataProvider(_this.handle, _this.componentId, itemsToRefresh) : null; });
        };
        ExtHostTreeView.prototype.refreshNode = function (treeItemHandle) {
            var _this = this;
            var extElement = this.getExtensionElement(treeItemHandle);
            var existing = this.nodes.get(extElement);
            //this.clearChildren(extElement); // clear children cache
            return async_1.asWinJsPromise(function () { return _this.componentDataProvider.getTreeItem(extElement); })
                .then(function (extTreeItem) {
                if (extTreeItem) {
                    var newNode = _this.createTreeNode(extElement, extTreeItem, existing.parent);
                    _this.updateNodeCache(extElement, newNode, existing, existing.parent);
                    return newNode;
                }
                return null;
            });
        };
        ExtHostTreeView.prototype.createTreeItem = function (element, extensionTreeItem, parent) {
            var item = _super.prototype.createTreeItem.call(this, element, extensionTreeItem, parent);
            item = Object.assign({}, item, { checked: extensionTreeItem.checked, enabled: extensionTreeItem.enabled });
            return item;
        };
        return ExtHostTreeView;
    }(vsTreeExt.ExtHostTreeView));
    exports.ExtHostTreeView = ExtHostTreeView;
});




































define(__m[189/*sql/workbench/api/node/extHostNotebook*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,5/*vs/workbench/api/node/extHostTypes*/,93/*vs/nls!sql/workbench/api/node/extHostNotebook*/,4/*vs/base/common/uri*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/,28/*sql/workbench/api/common/sqlExtHostTypes*/]), function (require, exports, winjs_base_1, extHostTypes_1, nls_1, uri_1, sqlExtHost_protocol_1, sqlExtHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostNotebook = /** @class */ (function () {
        // Notebook URI to manager lookup.
        function ExtHostNotebook(_mainContext) {
            this._adapters = new Map();
            this._proxy = _mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadNotebook);
        }
        //#region APIs called by main thread
        ExtHostNotebook.prototype.$getNotebookManager = function (providerHandle, notebookUri) {
            return __awaiter(this, void 0, void 0, function () {
                var uri, uriString, adapter;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            uri = uri_1.default.revive(notebookUri);
                            uriString = uri.toString();
                            adapter = this.findManagerForUri(uriString);
                            if (!!adapter) return [3 /*break*/, 2];
                            return [4 /*yield*/, this._withProvider(providerHandle, function (provider) {
                                    return _this.createManager(provider, uri);
                                })];
                        case 1:
                            adapter = _a.sent();
                            _a.label = 2;
                        case 2: return [2 /*return*/, {
                                handle: adapter.handle,
                                hasContentManager: !!adapter.contentManager,
                                hasServerManager: !!adapter.serverManager
                            }];
                    }
                });
            });
        };
        ExtHostNotebook.prototype.$handleNotebookClosed = function (notebookUri) {
            var uri = uri_1.default.revive(notebookUri);
            var uriString = uri.toString();
            var manager = this.findManagerForUri(uriString);
            if (manager) {
                manager.provider.handleNotebookClosed(uri);
                // Note: deliberately not removing handle.
            }
        };
        ExtHostNotebook.prototype.$doStartServer = function (managerHandle) {
            return this._withServerManager(managerHandle, function (serverManager) { return serverManager.startServer(); });
        };
        ExtHostNotebook.prototype.$doStopServer = function (managerHandle) {
            return this._withServerManager(managerHandle, function (serverManager) { return serverManager.stopServer(); });
        };
        ExtHostNotebook.prototype.$getNotebookContents = function (managerHandle, notebookUri) {
            return this._withContentManager(managerHandle, function (contentManager) { return contentManager.getNotebookContents(uri_1.default.revive(notebookUri)); });
        };
        ExtHostNotebook.prototype.$save = function (managerHandle, notebookUri, notebook) {
            return this._withContentManager(managerHandle, function (contentManager) { return contentManager.save(uri_1.default.revive(notebookUri), notebook); });
        };
        ExtHostNotebook.prototype.$refreshSpecs = function (managerHandle) {
            var _this = this;
            return this._withSessionManager(managerHandle, function (sessionManager) { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, sessionManager.ready];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, sessionManager.specs];
                    }
                });
            }); });
        };
        ExtHostNotebook.prototype.$startNewSession = function (managerHandle, options) {
            var _this = this;
            return this._withSessionManager(managerHandle, function (sessionManager) { return __awaiter(_this, void 0, void 0, function () {
                var session, sessionId, kernelDetails, details;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, sessionManager.startNew(options)];
                        case 1:
                            session = _a.sent();
                            sessionId = this._addNewAdapter(session);
                            kernelDetails = undefined;
                            if (session.kernel) {
                                kernelDetails = this.saveKernel(session.kernel);
                            }
                            details = {
                                sessionId: sessionId,
                                id: session.id,
                                path: session.path,
                                name: session.name,
                                type: session.type,
                                status: session.status,
                                canChangeKernels: session.canChangeKernels,
                                kernelDetails: kernelDetails
                            };
                            return [2 /*return*/, details];
                    }
                });
            }); });
        };
        ExtHostNotebook.prototype.saveKernel = function (kernel) {
            var kernelId = this._addNewAdapter(kernel);
            var kernelDetails = {
                kernelId: kernelId,
                id: kernel.id,
                info: kernel.info,
                name: kernel.name,
                supportsIntellisense: kernel.supportsIntellisense
            };
            return kernelDetails;
        };
        ExtHostNotebook.prototype.$shutdownSession = function (managerHandle, sessionId) {
            var _this = this;
            return this._withSessionManager(managerHandle, function (sessionManager) { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, sessionManager.shutdown(sessionId)];
                });
            }); });
        };
        ExtHostNotebook.prototype.$changeKernel = function (sessionId, kernelInfo) {
            var _this = this;
            var session = this._getAdapter(sessionId);
            return session.changeKernel(kernelInfo).then(function (kernel) { return _this.saveKernel(kernel); });
        };
        ExtHostNotebook.prototype.$configureKernel = function (sessionId, kernelInfo) {
            var session = this._getAdapter(sessionId);
            return session.configureKernel(kernelInfo).then(function () { return null; });
        };
        ExtHostNotebook.prototype.$configureConnection = function (sessionId, connection) {
            var session = this._getAdapter(sessionId);
            return session.configureConnection(connection).then(function () { return null; });
        };
        ExtHostNotebook.prototype.$getKernelReadyStatus = function (kernelId) {
            var kernel = this._getAdapter(kernelId);
            return kernel.ready.then(function (success) { return kernel.info; });
        };
        ExtHostNotebook.prototype.$getKernelSpec = function (kernelId) {
            var kernel = this._getAdapter(kernelId);
            return kernel.getSpec();
        };
        ExtHostNotebook.prototype.$requestComplete = function (kernelId, content) {
            var kernel = this._getAdapter(kernelId);
            return kernel.requestComplete(content);
        };
        ExtHostNotebook.prototype.$requestExecute = function (kernelId, content, disposeOnDone) {
            var kernel = this._getAdapter(kernelId);
            var future = kernel.requestExecute(content, disposeOnDone);
            var futureId = this._addNewAdapter(future);
            this.hookFutureDone(futureId, future);
            this.hookFutureMessages(futureId, future);
            return Promise.resolve({
                futureId: futureId,
                msg: future.msg
            });
        };
        ExtHostNotebook.prototype.hookFutureDone = function (futureId, future) {
            var _this = this;
            future.done.then(function (success) {
                return _this._proxy.$onFutureDone(futureId, { succeeded: true, message: success, rejectReason: undefined });
            }, function (err) {
                var rejectReason;
                if (typeof err === 'string') {
                    rejectReason = err;
                }
                else if (err instanceof Error && typeof err.message === 'string') {
                    rejectReason = err.message;
                }
                else {
                    rejectReason = err;
                }
                return _this._proxy.$onFutureDone(futureId, { succeeded: false, message: undefined, rejectReason: rejectReason });
            });
        };
        ExtHostNotebook.prototype.hookFutureMessages = function (futureId, future) {
            var _this = this;
            future.setReplyHandler({ handle: function (msg) { return _this._proxy.$onFutureMessage(futureId, sqlExtHostTypes_1.FutureMessageType.Reply, msg); } });
            future.setStdInHandler({ handle: function (msg) { return _this._proxy.$onFutureMessage(futureId, sqlExtHostTypes_1.FutureMessageType.StdIn, msg); } });
            future.setIOPubHandler({ handle: function (msg) { return _this._proxy.$onFutureMessage(futureId, sqlExtHostTypes_1.FutureMessageType.IOPub, msg); } });
        };
        ExtHostNotebook.prototype.$interruptKernel = function (kernelId) {
            var kernel = this._getAdapter(kernelId);
            return kernel.interrupt();
        };
        ExtHostNotebook.prototype.$sendInputReply = function (futureId, content) {
            var future = this._getAdapter(futureId);
            return future.sendInputReply(content);
        };
        ExtHostNotebook.prototype.$disposeFuture = function (futureId) {
            var future = this._getAdapter(futureId);
            future.dispose();
        };
        //#endregion
        //#region APIs called by extensions
        ExtHostNotebook.prototype.registerNotebookProvider = function (provider) {
            if (!provider || !provider.providerId) {
                throw new Error(nls_1.localize(0, null));
            }
            var handle = this._addNewAdapter(provider);
            this._proxy.$registerNotebookProvider(provider.providerId, handle);
            return this._createDisposable(handle);
        };
        //#endregion
        //#region private methods
        ExtHostNotebook.prototype.getAdapters = function (ctor) {
            var matchingAdapters = [];
            this._adapters.forEach(function (a) {
                if (a instanceof ctor) {
                    matchingAdapters.push(a);
                }
            });
            return matchingAdapters;
        };
        ExtHostNotebook.prototype.findManagerForUri = function (uriString) {
            for (var _i = 0, _a = this.getAdapters(NotebookManagerAdapter); _i < _a.length; _i++) {
                var manager = _a[_i];
                if (manager.uriString === uriString) {
                    return manager;
                }
            }
            return undefined;
        };
        ExtHostNotebook.prototype.createManager = function (provider, notebookUri) {
            return __awaiter(this, void 0, void 0, function () {
                var manager, uriString, adapter;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, provider.getNotebookManager(notebookUri)];
                        case 1:
                            manager = _a.sent();
                            uriString = notebookUri.toString();
                            adapter = new NotebookManagerAdapter(provider, manager, uriString);
                            adapter.handle = this._addNewAdapter(adapter);
                            return [2 /*return*/, adapter];
                    }
                });
            });
        };
        ExtHostNotebook.prototype._createDisposable = function (handle) {
            var _this = this;
            return new extHostTypes_1.Disposable(function () {
                _this._adapters.delete(handle);
                _this._proxy.$unregisterNotebookProvider(handle);
            });
        };
        ExtHostNotebook.prototype._nextHandle = function () {
            return ExtHostNotebook._handlePool++;
        };
        ExtHostNotebook.prototype._withProvider = function (handle, callback) {
            var provider = this._adapters.get(handle);
            if (provider === undefined) {
                return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize(1, null)));
            }
            return winjs_base_1.TPromise.wrap(callback(provider));
        };
        ExtHostNotebook.prototype._withNotebookManager = function (handle, callback) {
            var manager = this._adapters.get(handle);
            if (manager === undefined) {
                return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize(2, null)));
            }
            return winjs_base_1.TPromise.wrap(callback(manager));
        };
        ExtHostNotebook.prototype._withServerManager = function (handle, callback) {
            return this._withNotebookManager(handle, function (notebookManager) {
                var serverManager = notebookManager.serverManager;
                if (!serverManager) {
                    return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize(3, null, notebookManager.uriString)));
                }
                return callback(serverManager);
            });
        };
        ExtHostNotebook.prototype._withContentManager = function (handle, callback) {
            return this._withNotebookManager(handle, function (notebookManager) {
                var contentManager = notebookManager.contentManager;
                if (!contentManager) {
                    return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize(4, null, notebookManager.uriString)));
                }
                return callback(contentManager);
            });
        };
        ExtHostNotebook.prototype._withSessionManager = function (handle, callback) {
            return this._withNotebookManager(handle, function (notebookManager) {
                var sessionManager = notebookManager.sessionManager;
                if (!sessionManager) {
                    return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize(5, null, notebookManager.uriString)));
                }
                return callback(sessionManager);
            });
        };
        ExtHostNotebook.prototype._addNewAdapter = function (adapter) {
            var handle = this._nextHandle();
            this._adapters.set(handle, adapter);
            return handle;
        };
        ExtHostNotebook.prototype._getAdapter = function (id) {
            var adapter = this._adapters.get(id);
            if (adapter === undefined) {
                throw new Error('No adapter found');
            }
            return adapter;
        };
        ExtHostNotebook._handlePool = 0;
        return ExtHostNotebook;
    }());
    exports.ExtHostNotebook = ExtHostNotebook;
    var NotebookManagerAdapter = /** @class */ (function () {
        function NotebookManagerAdapter(provider, manager, uriString) {
            this.provider = provider;
            this.manager = manager;
            this.uriString = uriString;
        }
        Object.defineProperty(NotebookManagerAdapter.prototype, "contentManager", {
            get: function () {
                return this.manager.contentManager;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NotebookManagerAdapter.prototype, "sessionManager", {
            get: function () {
                return this.manager.sessionManager;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NotebookManagerAdapter.prototype, "serverManager", {
            get: function () {
                return this.manager.serverManager;
            },
            enumerable: true,
            configurable: true
        });
        return NotebookManagerAdapter;
    }());
});

define(__m[190/*sql/workbench/api/node/extHostObjectExplorer*/], __M([0/*require*/,1/*exports*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/]), function (require, exports, sqlExtHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostObjectExplorer = /** @class */ (function () {
        function ExtHostObjectExplorer(mainContext) {
            this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadObjectExplorer);
        }
        ExtHostObjectExplorer.prototype.$getNode = function (connectionId, nodePath) {
            var _this = this;
            return this._proxy.$getNode(connectionId, nodePath).then(function (nodeInfo) { return nodeInfo === undefined ? undefined : new ExtHostObjectExplorerNode(nodeInfo, connectionId, _this._proxy); });
        };
        ExtHostObjectExplorer.prototype.$getActiveConnectionNodes = function () {
            var _this = this;
            return this._proxy.$getActiveConnectionNodes().then(function (results) { return results.map(function (result) { return new ExtHostObjectExplorerNode(result.nodeInfo, result.connectionId, _this._proxy); }); });
        };
        ExtHostObjectExplorer.prototype.$findNodes = function (connectionId, type, schema, name, database, parentObjectNames) {
            var _this = this;
            return this._proxy.$findNodes(connectionId, type, schema, name, database, parentObjectNames).then(function (results) { return results.map(function (result) { return new ExtHostObjectExplorerNode(result, connectionId, _this._proxy); }); });
        };
        ExtHostObjectExplorer.prototype.$getNodeActions = function (connectionId, nodePath) {
            return this._proxy.$getNodeActions(connectionId, nodePath);
        };
        ExtHostObjectExplorer.prototype.$getSessionConnectionProfile = function (sessionId) {
            return this._proxy.$getSessionConnectionProfile(sessionId);
        };
        return ExtHostObjectExplorer;
    }());
    exports.ExtHostObjectExplorer = ExtHostObjectExplorer;
    var ExtHostObjectExplorerNode = /** @class */ (function () {
        function ExtHostObjectExplorerNode(nodeInfo, connectionId, _proxy) {
            this._proxy = _proxy;
            this.getDetailsFromInfo(nodeInfo);
            this.connectionId = connectionId;
        }
        ExtHostObjectExplorerNode.prototype.isExpanded = function () {
            return this._proxy.$isExpanded(this.connectionId, this.nodePath);
        };
        ExtHostObjectExplorerNode.prototype.setExpandedState = function (expandedState) {
            return this._proxy.$setExpandedState(this.connectionId, this.nodePath, expandedState);
        };
        ExtHostObjectExplorerNode.prototype.setSelected = function (selected, clearOtherSelections) {
            if (clearOtherSelections === void 0) { clearOtherSelections = undefined; }
            return this._proxy.$setSelected(this.connectionId, this.nodePath, selected, clearOtherSelections);
        };
        ExtHostObjectExplorerNode.prototype.getChildren = function () {
            var _this = this;
            return this._proxy.$getChildren(this.connectionId, this.nodePath).then(function (children) { return children.map(function (nodeInfo) { return new ExtHostObjectExplorerNode(nodeInfo, _this.connectionId, _this._proxy); }); });
        };
        ExtHostObjectExplorerNode.prototype.getParent = function () {
            var _this = this;
            var parentPathEndIndex = this.nodePath.lastIndexOf('/');
            if (parentPathEndIndex === -1) {
                return Promise.resolve(undefined);
            }
            return this._proxy.$getNode(this.connectionId, this.nodePath.slice(0, parentPathEndIndex)).then(function (nodeInfo) { return nodeInfo ? new ExtHostObjectExplorerNode(nodeInfo, _this.connectionId, _this._proxy) : undefined; });
        };
        ExtHostObjectExplorerNode.prototype.refresh = function () {
            var _this = this;
            return this._proxy.$refresh(this.connectionId, this.nodePath).then(function (nodeInfo) { return _this.getDetailsFromInfo(nodeInfo); });
        };
        ExtHostObjectExplorerNode.prototype.getDetailsFromInfo = function (nodeInfo) {
            var _this = this;
            Object.entries(nodeInfo).forEach(function (_a) {
                var key = _a[0], value = _a[1];
                return _this[key] = value;
            });
        };
        return ExtHostObjectExplorerNode;
    }());
});

define(__m[191/*sql/workbench/api/node/extHostQueryEditor*/], __M([0/*require*/,1/*exports*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/]), function (require, exports, sqlExtHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostQueryEditor = /** @class */ (function () {
        function ExtHostQueryEditor(mainContext) {
            this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadQueryEditor);
        }
        ExtHostQueryEditor.prototype.$connect = function (fileUri, connectionId) {
            return this._proxy.$connect(fileUri, connectionId);
        };
        ExtHostQueryEditor.prototype.$runQuery = function (fileUri) {
            return this._proxy.$runQuery(fileUri);
        };
        return ExtHostQueryEditor;
    }());
    exports.ExtHostQueryEditor = ExtHostQueryEditor;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[192/*sql/workbench/api/node/extHostResourceProvider*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,5/*vs/workbench/api/node/extHostTypes*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/]), function (require, exports, winjs_base_1, extHostTypes_1, sqlExtHost_protocol_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostResourceProvider = /** @class */ (function (_super) {
        __extends(ExtHostResourceProvider, _super);
        function ExtHostResourceProvider(mainContext) {
            var _this = _super.call(this) || this;
            _this._handlePool = 0;
            _this._providers = {};
            _this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadResourceProvider);
            return _this;
        }
        // PUBLIC METHODS //////////////////////////////////////////////////////
        // - MAIN THREAD AVAILABLE METHODS /////////////////////////////////////
        ExtHostResourceProvider.prototype.$createFirewallRule = function (handle, account, firewallRuleInfo) {
            return this._withProvider(handle, function (provider) { return provider.createFirewallRule(account, firewallRuleInfo); });
        };
        ExtHostResourceProvider.prototype.$handleFirewallRule = function (handle, errorCode, errorMessage, connectionTypeId) {
            return this._withProvider(handle, function (provider) { return provider.handleFirewallRule(errorCode, errorMessage, connectionTypeId); });
        };
        // - EXTENSION HOST AVAILABLE METHODS //////////////////////////////////
        ExtHostResourceProvider.prototype.$registerResourceProvider = function (providerMetadata, provider) {
            var self = this;
            // Look for any account providers that have the same provider ID
            var matchingProviderIndex = Object.values(this._providers).findIndex(function (provider) {
                return provider.metadata.id === providerMetadata.id;
            });
            if (matchingProviderIndex >= 0) {
                throw new Error("Resource Provider with ID '" + providerMetadata.id + "' has already been registered");
            }
            // Create the handle for the provider
            var handle = this._nextHandle();
            this._providers[handle] = {
                metadata: providerMetadata,
                provider: provider
            };
            // Register the provider in the main thread via the proxy
            this._proxy.$registerResourceProvider(providerMetadata, handle);
            // Return a disposable to cleanup the provider
            return new extHostTypes_1.Disposable(function () {
                delete self._providers[handle];
                self._proxy.$unregisterResourceProvider(handle);
            });
        };
        /**
         * This method is for testing only, it is not exposed via the shape.
         * @return {number} Number of providers that are currently registered
         */
        ExtHostResourceProvider.prototype.getProviderCount = function () {
            return Object.keys(this._providers).length;
        };
        // PRIVATE METHODS /////////////////////////////////////////////////////
        ExtHostResourceProvider.prototype._nextHandle = function () {
            return this._handlePool++;
        };
        ExtHostResourceProvider.prototype._withProvider = function (handle, callback) {
            var provider = this._providers[handle];
            if (provider === undefined) {
                return winjs_base_1.TPromise.wrapError(new Error("Provider " + handle + " not found."));
            }
            return callback(provider.provider);
        };
        return ExtHostResourceProvider;
    }(sqlExtHost_protocol_1.ExtHostResourceProviderShape));
    exports.ExtHostResourceProvider = ExtHostResourceProvider;
});











define(__m[193/*sql/workbench/api/node/extHostSerializationProvider*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/,5/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, winjs_base_1, sqlExtHost_protocol_1, extHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SerializationAdapter = /** @class */ (function () {
        function SerializationAdapter(provider) {
            this._provider = provider;
        }
        SerializationAdapter.prototype.saveAs = function (saveFormat, savePath, results, appendToFile) {
            return this._provider.saveAs(saveFormat, savePath, results, appendToFile);
        };
        return SerializationAdapter;
    }());
    var ExtHostSerializationProvider = /** @class */ (function (_super) {
        __extends(ExtHostSerializationProvider, _super);
        function ExtHostSerializationProvider(mainContext) {
            var _this = _super.call(this) || this;
            _this._adapter = Object.create(null);
            _this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadSerializationProvider);
            return _this;
        }
        ExtHostSerializationProvider.prototype._createDisposable = function (handle) {
            var _this = this;
            return new extHostTypes_1.Disposable(function () {
                delete _this._adapter[handle];
                _this._proxy.$unregisterSerializationProvider(handle);
            });
        };
        ExtHostSerializationProvider.prototype._nextHandle = function () {
            return ExtHostSerializationProvider._handlePool++;
        };
        ExtHostSerializationProvider.prototype._withAdapter = function (handle, ctor, callback) {
            var adapter = this._adapter[handle];
            if (!(adapter instanceof ctor)) {
                return winjs_base_1.TPromise.wrapError(new Error('no adapter found'));
            }
            return callback(adapter);
        };
        ExtHostSerializationProvider.prototype.$registerSerializationProvider = function (provider) {
            provider.handle = this._nextHandle();
            this._adapter[provider.handle] = new SerializationAdapter(provider);
            this._proxy.$registerSerializationProvider(provider.handle);
            return this._createDisposable(provider.handle);
        };
        ExtHostSerializationProvider.prototype.$saveAs = function (saveFormat, savePath, results, appendToFile) {
            return this._withAdapter(0, SerializationAdapter, function (adapter) { return adapter.saveAs(saveFormat, savePath, results, appendToFile); });
        };
        ExtHostSerializationProvider._handlePool = 0;
        return ExtHostSerializationProvider;
    }(sqlExtHost_protocol_1.ExtHostSerializationProviderShape));
    exports.ExtHostSerializationProvider = ExtHostSerializationProvider;
});

define(__m[194/*sql/workbench/api/node/extHostTasks*/], __M([0/*require*/,1/*exports*/,18/*vs/base/common/types*/,5/*vs/workbench/api/node/extHostTypes*/,2/*vs/base/common/winjs.base*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/]), function (require, exports, types_1, extHostTypes, winjs_base_1, sqlExtHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostTasks = /** @class */ (function () {
        function ExtHostTasks(mainContext, logService) {
            this.logService = logService;
            this._tasks = new Map();
            this._proxy = mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadTasks);
        }
        ExtHostTasks.prototype.registerTask = function (id, callback, thisArg, description) {
            var _this = this;
            this.logService.trace('ExtHostTasks#registerTask', id);
            if (!id.trim().length) {
                throw new Error('invalid id');
            }
            if (this._tasks.has(id)) {
                throw new Error("task '" + id + "' already exists");
            }
            this._tasks.set(id, { callback: callback, thisArg: thisArg, description: description });
            this._proxy.$registerTask(id);
            return new extHostTypes.Disposable(function () {
                if (_this._tasks.delete(id)) {
                    _this._proxy.$unregisterTask(id);
                }
            });
        };
        ExtHostTasks.prototype.$executeContributedTask = function (id) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var command = this._tasks.get(id);
            if (!command) {
                return winjs_base_1.TPromise.wrapError(new Error("Contributed task '" + id + "' does not exist."));
            }
            var callback = command.callback, thisArg = command.thisArg, description = command.description;
            if (description) {
                for (var i = 0; i < description.args.length; i++) {
                    try {
                        types_1.validateConstraint(args[i], description.args[i].constraint);
                    }
                    catch (err) {
                        return winjs_base_1.TPromise.wrapError(new Error("Running the contributed task:'" + id + "' failed. Illegal argument '" + description.args[i].name + "' - " + description.args[i].description));
                    }
                }
            }
            try {
                var result = callback.apply(thisArg, args);
                return winjs_base_1.TPromise.as(result);
            }
            catch (err) {
                // console.log(err);
                // try {
                // 	console.log(toErrorMessage(err));
                // } catch (err) {
                // 	//
                // }
                return winjs_base_1.TPromise.wrapError(new Error("Running the contributed task:'" + id + "' failed."));
            }
        };
        ExtHostTasks.prototype.$getContributedTaskHandlerDescriptions = function () {
            throw new Error('Method not implemented.');
        };
        return ExtHostTasks;
    }());
    exports.ExtHostTasks = ExtHostTasks;
});

define(__m[6/*vs/workbench/api/node/extHost.protocol*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,79/*vs/workbench/services/extensions/node/proxyIdentifier*/]), function (require, exports, uri_1, proxyIdentifier_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextEditorRevealType;
    (function (TextEditorRevealType) {
        TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
        TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
        TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
    })(TextEditorRevealType = exports.TextEditorRevealType || (exports.TextEditorRevealType = {}));
    var ObjectIdentifier;
    (function (ObjectIdentifier) {
        ObjectIdentifier.name = '$ident';
        function mixin(obj, id) {
            Object.defineProperty(obj, ObjectIdentifier.name, { value: id, enumerable: true });
            return obj;
        }
        ObjectIdentifier.mixin = mixin;
        function of(obj) {
            return obj[ObjectIdentifier.name];
        }
        ObjectIdentifier.of = of;
    })(ObjectIdentifier = exports.ObjectIdentifier || (exports.ObjectIdentifier = {}));
    var IdObject = /** @class */ (function () {
        function IdObject() {
        }
        IdObject.mixin = function (object) {
            object._id = IdObject._n++;
            return object;
        };
        IdObject._n = 0;
        return IdObject;
    }());
    exports.IdObject = IdObject;
    function reviveWorkspaceEditDto(data) {
        if (data && data.edits) {
            for (var _i = 0, _a = data.edits; _i < _a.length; _i++) {
                var edit = _a[_i];
                if (typeof edit.resource === 'object') {
                    edit.resource = uri_1.default.revive(edit.resource);
                }
                else {
                    edit.newUri = uri_1.default.revive(edit.newUri);
                    edit.oldUri = uri_1.default.revive(edit.oldUri);
                }
            }
        }
        return data;
    }
    exports.reviveWorkspaceEditDto = reviveWorkspaceEditDto;
    // --- proxy identifiers
    exports.MainContext = {
        MainThreadCommands: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadCommands'),
        MainThreadComments: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadComments'),
        MainThreadConfiguration: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadConfiguration'),
        // {{SQL CARBON EDIT}}
        // MainThreadDebugService: createMainId<MainThreadDebugServiceShape>('MainThreadDebugService'),
        MainThreadDecorations: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDecorations'),
        MainThreadDiagnostics: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDiagnostics'),
        MainThreadDialogs: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDiaglogs'),
        MainThreadDocuments: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDocuments'),
        MainThreadDocumentContentProviders: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDocumentContentProviders'),
        MainThreadTextEditors: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTextEditors'),
        MainThreadErrors: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadErrors'),
        MainThreadTreeViews: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTreeViews'),
        MainThreadLanguageFeatures: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadLanguageFeatures'),
        MainThreadLanguages: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadLanguages'),
        MainThreadMessageService: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadMessageService'),
        MainThreadOutputService: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadOutputService'),
        MainThreadProgress: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadProgress'),
        MainThreadQuickOpen: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadQuickOpen'),
        MainThreadStatusBar: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadStatusBar'),
        MainThreadStorage: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadStorage'),
        MainThreadTelemetry: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTelemetry'),
        MainThreadTerminalService: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTerminalService'),
        MainThreadWebviews: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadWebviews'),
        MainThreadUrls: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadUrls'),
        MainThreadWorkspace: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadWorkspace'),
        MainThreadFileSystem: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadFileSystem'),
        MainThreadExtensionService: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadExtensionService'),
        MainThreadSCM: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadSCM'),
        MainThreadSearch: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadSearch'),
        MainThreadTask: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTask'),
        MainThreadWindow: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadWindow'),
    };
    exports.ExtHostContext = {
        ExtHostCommands: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostCommands'),
        ExtHostConfiguration: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostConfiguration'),
        ExtHostDiagnostics: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDiagnostics'),
        // {{SQL CARBON EDIT}}
        // ExtHostDebugService: createExtId<ExtHostDebugServiceShape>('ExtHostDebugService'),
        ExtHostDecorations: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDecorations'),
        ExtHostDocumentsAndEditors: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDocumentsAndEditors'),
        ExtHostDocuments: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDocuments'),
        ExtHostDocumentContentProviders: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDocumentContentProviders'),
        ExtHostDocumentSaveParticipant: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDocumentSaveParticipant'),
        ExtHostEditors: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostEditors'),
        ExtHostTreeViews: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostTreeViews'),
        ExtHostFileSystem: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostFileSystem'),
        ExtHostFileSystemEventService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostFileSystemEventService'),
        ExtHostHeapService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostHeapMonitor'),
        ExtHostLanguageFeatures: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostLanguageFeatures'),
        ExtHostQuickOpen: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostQuickOpen'),
        ExtHostExtensionService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostExtensionService'),
        ExtHostLogService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostLogService'),
        ExtHostTerminalService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostTerminalService'),
        ExtHostSCM: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostSCM'),
        ExtHostSearch: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostSearch'),
        ExtHostTask: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostTask'),
        ExtHostWorkspace: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostWorkspace'),
        ExtHostWindow: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostWindow'),
        ExtHostWebviews: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostWebviews'),
        ExtHostProgress: proxyIdentifier_1.createMainContextProxyIdentifier('ExtHostProgress'),
        ExtHostComments: proxyIdentifier_1.createMainContextProxyIdentifier('ExtHostComments'),
        ExtHostUrls: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostUrls')
    };
});

define(__m[196/*vs/workbench/api/node/extHostDecorations*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,6/*vs/workbench/api/node/extHost.protocol*/,2/*vs/base/common/winjs.base*/,5/*vs/workbench/api/node/extHostTypes*/,12/*vs/base/common/async*/]), function (require, exports, uri_1, extHost_protocol_1, winjs_base_1, extHostTypes_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDecorations = /** @class */ (function () {
        function ExtHostDecorations(mainContext) {
            this._provider = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDecorations);
        }
        ExtHostDecorations.prototype.registerDecorationProvider = function (provider, label) {
            var _this = this;
            var handle = ExtHostDecorations._handlePool++;
            this._provider.set(handle, provider);
            this._proxy.$registerDecorationProvider(handle, label);
            var listener = provider.onDidChangeDecorations(function (e) {
                _this._proxy.$onDidChange(handle, !e ? null : Array.isArray(e) ? e : [e]);
            });
            return new extHostTypes_1.Disposable(function () {
                listener.dispose();
                _this._proxy.$unregisterDecorationProvider(handle);
                _this._provider.delete(handle);
            });
        };
        ExtHostDecorations.prototype.$provideDecorations = function (requests) {
            var _this = this;
            var result = Object.create(null);
            return winjs_base_1.TPromise.join(requests.map(function (request) {
                var handle = request.handle, uri = request.uri, id = request.id;
                var provider = _this._provider.get(handle);
                if (!provider) {
                    // might have been unregistered in the meantime
                    return void 0;
                }
                return async_1.asWinJsPromise(function (token) { return provider.provideDecoration(uri_1.default.revive(uri), token); }).then(function (data) {
                    result[id] = data && [data.priority, data.bubble, data.title, data.abbreviation, data.color, data.source];
                }, function (err) {
                    console.error(err);
                });
            })).then(function () {
                return result;
            });
        };
        ExtHostDecorations._handlePool = 0;
        return ExtHostDecorations;
    }());
    exports.ExtHostDecorations = ExtHostDecorations;
});

define(__m[197/*vs/workbench/api/node/extHostDialogs*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,6/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, uri_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDialogs = /** @class */ (function () {
        function ExtHostDialogs(mainContext) {
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDialogs);
        }
        ExtHostDialogs.prototype.showOpenDialog = function (options) {
            return this._proxy.$showOpenDialog(options).then(function (filepaths) {
                return filepaths && filepaths.map(uri_1.default.file);
            });
        };
        ExtHostDialogs.prototype.showSaveDialog = function (options) {
            return this._proxy.$showSaveDialog(options).then(function (filepath) {
                return filepath && uri_1.default.file(filepath);
            });
        };
        return ExtHostDialogs;
    }());
    exports.ExtHostDialogs = ExtHostDialogs;
});

define(__m[198/*vs/workbench/api/node/extHostDocumentContentProviders*/], __M([0/*require*/,1/*exports*/,14/*vs/base/common/errors*/,4/*vs/base/common/uri*/,5/*vs/workbench/api/node/extHostTypes*/,2/*vs/base/common/winjs.base*/,12/*vs/base/common/async*/,6/*vs/workbench/api/node/extHost.protocol*/,23/*vs/base/common/network*/]), function (require, exports, errors_1, uri_1, extHostTypes_1, winjs_base_1, async_1, extHost_protocol_1, network_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDocumentContentProvider = /** @class */ (function () {
        function ExtHostDocumentContentProvider(mainContext, _documentsAndEditors, _logService) {
            this._documentsAndEditors = _documentsAndEditors;
            this._logService = _logService;
            this._documentContentProviders = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDocumentContentProviders);
        }
        ExtHostDocumentContentProvider.prototype.dispose = function () {
            // todo@joh
        };
        ExtHostDocumentContentProvider.prototype.registerTextDocumentContentProvider = function (scheme, provider) {
            var _this = this;
            // todo@remote
            // check with scheme from fs-providers!
            if (scheme === network_1.Schemas.file || scheme === network_1.Schemas.untitled) {
                throw new Error("scheme '" + scheme + "' already registered");
            }
            var handle = ExtHostDocumentContentProvider._handlePool++;
            this._documentContentProviders.set(handle, provider);
            this._proxy.$registerTextContentProvider(handle, scheme);
            var subscription;
            if (typeof provider.onDidChange === 'function') {
                subscription = provider.onDidChange(function (uri) {
                    if (uri.scheme !== scheme) {
                        _this._logService.warn("Provider for scheme '" + scheme + "' is firing event for schema '" + uri.scheme + "' which will be IGNORED");
                        return;
                    }
                    if (_this._documentsAndEditors.getDocument(uri.toString())) {
                        _this.$provideTextDocumentContent(handle, uri).then(function (value) {
                            var document = _this._documentsAndEditors.getDocument(uri.toString());
                            if (!document) {
                                // disposed in the meantime
                                return;
                            }
                            // create lines and compare
                            var lines = value.split(/\r\n|\r|\n/);
                            // broadcast event when content changed
                            if (!document.equalLines(lines)) {
                                return _this._proxy.$onVirtualDocumentChange(uri, value);
                            }
                        }, errors_1.onUnexpectedError);
                    }
                });
            }
            return new extHostTypes_1.Disposable(function () {
                if (_this._documentContentProviders.delete(handle)) {
                    _this._proxy.$unregisterTextContentProvider(handle);
                }
                if (subscription) {
                    subscription.dispose();
                    subscription = undefined;
                }
            });
        };
        ExtHostDocumentContentProvider.prototype.$provideTextDocumentContent = function (handle, uri) {
            var provider = this._documentContentProviders.get(handle);
            if (!provider) {
                return winjs_base_1.TPromise.wrapError(new Error("unsupported uri-scheme: " + uri.scheme));
            }
            return async_1.asWinJsPromise(function (token) { return provider.provideTextDocumentContent(uri_1.default.revive(uri), token); });
        };
        ExtHostDocumentContentProvider._handlePool = 0;
        return ExtHostDocumentContentProvider;
    }());
    exports.ExtHostDocumentContentProvider = ExtHostDocumentContentProvider;
});

define(__m[199/*vs/workbench/api/node/extHostFileSystem*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,6/*vs/workbench/api/node/extHost.protocol*/,43/*vs/platform/files/common/files*/,9/*vs/base/common/lifecycle*/,12/*vs/base/common/async*/,21/*vs/base/common/map*/,5/*vs/workbench/api/node/extHostTypes*/,23/*vs/base/common/network*/]), function (require, exports, uri_1, extHost_protocol_1, files, lifecycle_1, async_1, map_1, extHostTypes_1, network_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var FsLinkProvider = /** @class */ (function () {
        function FsLinkProvider() {
            this._schemes = new Set();
        }
        FsLinkProvider.prototype.add = function (scheme) {
            this._regex = undefined;
            this._schemes.add(scheme);
        };
        FsLinkProvider.prototype.delete = function (scheme) {
            if (this._schemes.delete(scheme)) {
                this._regex = undefined;
            }
        };
        FsLinkProvider.prototype.provideDocumentLinks = function (document) {
            if (this._schemes.size === 0) {
                return undefined;
            }
            if (!this._regex) {
                this._regex = new RegExp("(" + (map_1.values(this._schemes).join('|')) + "):[^\\s]+", 'gi');
            }
            var result = [];
            var max = Math.min(document.lineCount, 2500);
            for (var line = 0; line < max; line++) {
                this._regex.lastIndex = 0;
                var textLine = document.lineAt(line);
                var m = void 0;
                while (m = this._regex.exec(textLine.text)) {
                    var target = uri_1.default.parse(m[0]);
                    if (target.path[0] !== '/') {
                        continue;
                    }
                    var range = new extHostTypes_1.Range(line, this._regex.lastIndex - m[0].length, line, this._regex.lastIndex);
                    result.push({ target: target, range: range });
                }
            }
            return result;
        };
        return FsLinkProvider;
    }());
    var ExtHostFileSystem = /** @class */ (function () {
        function ExtHostFileSystem(mainContext, extHostLanguageFeatures) {
            this._linkProvider = new FsLinkProvider();
            this._fsProvider = new Map();
            this._usedSchemes = new Set();
            this._watches = new Map();
            this._handlePool = 0;
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadFileSystem);
            this._usedSchemes.add(network_1.Schemas.file);
            this._usedSchemes.add(network_1.Schemas.untitled);
            this._usedSchemes.add(network_1.Schemas.vscode);
            this._usedSchemes.add(network_1.Schemas.inMemory);
            this._usedSchemes.add(network_1.Schemas.internal);
            this._usedSchemes.add(network_1.Schemas.http);
            this._usedSchemes.add(network_1.Schemas.https);
            this._usedSchemes.add(network_1.Schemas.mailto);
            this._usedSchemes.add(network_1.Schemas.data);
            extHostLanguageFeatures.registerDocumentLinkProvider('*', this._linkProvider);
        }
        ExtHostFileSystem.prototype.registerFileSystemProvider = function (scheme, provider, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (this._usedSchemes.has(scheme)) {
                throw new Error("a provider for the scheme '" + scheme + "' is already registered");
            }
            var handle = this._handlePool++;
            this._linkProvider.add(scheme);
            this._usedSchemes.add(scheme);
            this._fsProvider.set(handle, provider);
            var capabilites = files.FileSystemProviderCapabilities.FileReadWrite;
            if (options.isCaseSensitive) {
                capabilites += files.FileSystemProviderCapabilities.PathCaseSensitive;
            }
            if (options.isReadonly) {
                capabilites += files.FileSystemProviderCapabilities.Readonly;
            }
            if (typeof provider.copy === 'function') {
                capabilites += files.FileSystemProviderCapabilities.FileFolderCopy;
            }
            this._proxy.$registerFileSystemProvider(handle, scheme, capabilites);
            var subscription = provider.onDidChangeFile(function (event) {
                var mapped = [];
                for (var _i = 0, event_1 = event; _i < event_1.length; _i++) {
                    var e = event_1[_i];
                    var resource = e.uri, type = e.type;
                    if (resource.scheme !== scheme) {
                        // dropping events for wrong scheme
                        continue;
                    }
                    var newType = void 0;
                    switch (type) {
                        case extHostTypes_1.FileChangeType.Changed:
                            newType = files.FileChangeType.UPDATED;
                            break;
                        case extHostTypes_1.FileChangeType.Created:
                            newType = files.FileChangeType.ADDED;
                            break;
                        case extHostTypes_1.FileChangeType.Deleted:
                            newType = files.FileChangeType.DELETED;
                            break;
                    }
                    mapped.push({ resource: resource, type: newType });
                }
                _this._proxy.$onFileSystemChange(handle, mapped);
            });
            return lifecycle_1.toDisposable(function () {
                subscription.dispose();
                _this._linkProvider.delete(scheme);
                _this._usedSchemes.delete(scheme);
                _this._fsProvider.delete(handle);
                _this._proxy.$unregisterProvider(handle);
            });
        };
        ExtHostFileSystem._asIStat = function (stat) {
            var type = stat.type, ctime = stat.ctime, mtime = stat.mtime, size = stat.size;
            return { type: type, ctime: ctime, mtime: mtime, size: size };
        };
        ExtHostFileSystem.prototype.$stat = function (handle, resource) {
            var _this = this;
            return async_1.asWinJsPromise(function () { return _this._fsProvider.get(handle).stat(uri_1.default.revive(resource)); }).then(ExtHostFileSystem._asIStat);
        };
        ExtHostFileSystem.prototype.$readdir = function (handle, resource) {
            var _this = this;
            return async_1.asWinJsPromise(function () { return _this._fsProvider.get(handle).readDirectory(uri_1.default.revive(resource)); });
        };
        ExtHostFileSystem.prototype.$readFile = function (handle, resource) {
            var _this = this;
            return async_1.asWinJsPromise(function () {
                return _this._fsProvider.get(handle).readFile(uri_1.default.revive(resource));
            }).then(function (data) {
                return Buffer.isBuffer(data) ? data.toString('base64') : Buffer.from(data.buffer, data.byteOffset, data.byteLength).toString('base64');
            });
        };
        ExtHostFileSystem.prototype.$writeFile = function (handle, resource, base64Content, opts) {
            var _this = this;
            return async_1.asWinJsPromise(function () { return _this._fsProvider.get(handle).writeFile(uri_1.default.revive(resource), Buffer.from(base64Content, 'base64'), opts); });
        };
        ExtHostFileSystem.prototype.$delete = function (handle, resource, opts) {
            var _this = this;
            return async_1.asWinJsPromise(function () { return _this._fsProvider.get(handle).delete(uri_1.default.revive(resource), opts); });
        };
        ExtHostFileSystem.prototype.$rename = function (handle, oldUri, newUri, opts) {
            var _this = this;
            return async_1.asWinJsPromise(function () { return _this._fsProvider.get(handle).rename(uri_1.default.revive(oldUri), uri_1.default.revive(newUri), opts); });
        };
        ExtHostFileSystem.prototype.$copy = function (handle, oldUri, newUri, opts) {
            var _this = this;
            return async_1.asWinJsPromise(function () { return _this._fsProvider.get(handle).copy(uri_1.default.revive(oldUri), uri_1.default.revive(newUri), opts); });
        };
        ExtHostFileSystem.prototype.$mkdir = function (handle, resource) {
            var _this = this;
            return async_1.asWinJsPromise(function () { return _this._fsProvider.get(handle).createDirectory(uri_1.default.revive(resource)); });
        };
        ExtHostFileSystem.prototype.$watch = function (handle, session, resource, opts) {
            var _this = this;
            async_1.asWinJsPromise(function () {
                var subscription = _this._fsProvider.get(handle).watch(uri_1.default.revive(resource), opts);
                _this._watches.set(session, subscription);
            });
        };
        ExtHostFileSystem.prototype.$unwatch = function (session) {
            var subscription = this._watches.get(session);
            if (subscription) {
                subscription.dispose();
                this._watches.delete(session);
            }
        };
        return ExtHostFileSystem;
    }());
    exports.ExtHostFileSystem = ExtHostFileSystem;
});

define(__m[200/*vs/workbench/api/node/extHostLanguages*/], __M([0/*require*/,1/*exports*/,6/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostLanguages = /** @class */ (function () {
        function ExtHostLanguages(mainContext) {
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadLanguages);
        }
        ExtHostLanguages.prototype.getLanguages = function () {
            return this._proxy.$getLanguages();
        };
        return ExtHostLanguages;
    }());
    exports.ExtHostLanguages = ExtHostLanguages;
});

define(__m[201/*vs/workbench/api/node/extHostMessageService*/], __M([0/*require*/,1/*exports*/,6/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function isMessageItem(item) {
        return item && item.title;
    }
    var ExtHostMessageService = /** @class */ (function () {
        function ExtHostMessageService(mainContext) {
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadMessageService);
        }
        ExtHostMessageService.prototype.showMessage = function (extension, severity, message, optionsOrFirstItem, rest) {
            var options = { extension: extension };
            var items;
            if (typeof optionsOrFirstItem === 'string' || isMessageItem(optionsOrFirstItem)) {
                items = [optionsOrFirstItem].concat(rest);
            }
            else {
                options.modal = optionsOrFirstItem && optionsOrFirstItem.modal;
                items = rest;
            }
            var commands = [];
            for (var handle = 0; handle < items.length; handle++) {
                var command = items[handle];
                if (typeof command === 'string') {
                    commands.push({ title: command, handle: handle, isCloseAffordance: false });
                }
                else if (typeof command === 'object') {
                    var title = command.title, isCloseAffordance = command.isCloseAffordance;
                    commands.push({ title: title, isCloseAffordance: isCloseAffordance, handle: handle });
                }
                else {
                    console.warn('Invalid message item:', command);
                }
            }
            return this._proxy.$showMessage(severity, message, options, commands).then(function (handle) {
                if (typeof handle === 'number') {
                    return items[handle];
                }
                return undefined;
            });
        };
        return ExtHostMessageService;
    }());
    exports.ExtHostMessageService = ExtHostMessageService;
});

define(__m[202/*vs/workbench/api/node/extHostOutputService*/], __M([0/*require*/,1/*exports*/,6/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostOutputChannel = /** @class */ (function () {
        function ExtHostOutputChannel(name, proxy) {
            this._name = name;
            this._id = 'extension-output-#' + (ExtHostOutputChannel._idPool++);
            this._proxy = proxy;
        }
        Object.defineProperty(ExtHostOutputChannel.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostOutputChannel.prototype.dispose = function () {
            var _this = this;
            if (!this._disposed) {
                this._proxy.$dispose(this._id, this._name).then(function () {
                    _this._disposed = true;
                });
            }
        };
        ExtHostOutputChannel.prototype.append = function (value) {
            this.validate();
            this._proxy.$append(this._id, this._name, value);
        };
        ExtHostOutputChannel.prototype.appendLine = function (value) {
            this.validate();
            this.append(value + '\n');
        };
        ExtHostOutputChannel.prototype.clear = function () {
            this.validate();
            this._proxy.$clear(this._id, this._name);
        };
        ExtHostOutputChannel.prototype.show = function (columnOrPreserveFocus, preserveFocus) {
            this.validate();
            if (typeof columnOrPreserveFocus === 'boolean') {
                preserveFocus = columnOrPreserveFocus;
            }
            this._proxy.$reveal(this._id, this._name, preserveFocus);
        };
        ExtHostOutputChannel.prototype.hide = function () {
            this.validate();
            this._proxy.$close(this._id);
        };
        ExtHostOutputChannel.prototype.validate = function () {
            if (this._disposed) {
                throw new Error('Channel has been closed');
            }
        };
        ExtHostOutputChannel._idPool = 1;
        return ExtHostOutputChannel;
    }());
    exports.ExtHostOutputChannel = ExtHostOutputChannel;
    var ExtHostOutputService = /** @class */ (function () {
        function ExtHostOutputService(mainContext) {
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadOutputService);
        }
        ExtHostOutputService.prototype.createOutputChannel = function (name) {
            name = name.trim();
            if (!name) {
                throw new Error('illegal argument `name`. must not be falsy');
            }
            else {
                return new ExtHostOutputChannel(name, this._proxy);
            }
        };
        return ExtHostOutputService;
    }());
    exports.ExtHostOutputService = ExtHostOutputService;
});











define(__m[203/*vs/workbench/api/node/extHostQuickOpen*/], __M([0/*require*/,1/*exports*/,12/*vs/base/common/async*/,29/*vs/base/common/cancellation*/,3/*vs/base/common/event*/,9/*vs/base/common/lifecycle*/,2/*vs/base/common/winjs.base*/,6/*vs/workbench/api/node/extHost.protocol*/,4/*vs/base/common/uri*/,5/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, async_1, cancellation_1, event_1, lifecycle_1, winjs_base_1, extHost_protocol_1, uri_1, extHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostQuickOpen = /** @class */ (function () {
        function ExtHostQuickOpen(mainContext, workspace, commands) {
            this._sessions = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadQuickOpen);
            this._workspace = workspace;
            this._commands = commands;
        }
        ExtHostQuickOpen.prototype.showQuickPick = function (itemsOrItemsPromise, options, token) {
            var _this = this;
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            // clear state from last invocation
            this._onDidSelectItem = undefined;
            var itemsPromise = winjs_base_1.TPromise.wrap(itemsOrItemsPromise);
            var quickPickWidget = this._proxy.$show({
                placeHolder: options && options.placeHolder,
                matchOnDescription: options && options.matchOnDescription,
                matchOnDetail: options && options.matchOnDetail,
                ignoreFocusLost: options && options.ignoreFocusOut,
                canPickMany: options && options.canPickMany
            });
            var promise = winjs_base_1.TPromise.any([quickPickWidget, itemsPromise]).then(function (values) {
                if (values.key === '0') {
                    return undefined;
                }
                return itemsPromise.then(function (items) {
                    var pickItems = [];
                    for (var handle = 0; handle < items.length; handle++) {
                        var item = items[handle];
                        var label = void 0;
                        var description = void 0;
                        var detail = void 0;
                        var picked = void 0;
                        if (typeof item === 'string') {
                            label = item;
                        }
                        else {
                            label = item.label;
                            description = item.description;
                            detail = item.detail;
                            picked = item.picked;
                        }
                        pickItems.push({
                            label: label,
                            description: description,
                            handle: handle,
                            detail: detail,
                            picked: picked
                        });
                    }
                    // handle selection changes
                    if (options && typeof options.onDidSelectItem === 'function') {
                        _this._onDidSelectItem = function (handle) {
                            options.onDidSelectItem(items[handle]);
                        };
                    }
                    // show items
                    _this._proxy.$setItems(pickItems);
                    return quickPickWidget.then(function (handle) {
                        if (typeof handle === 'number') {
                            return items[handle];
                        }
                        else if (Array.isArray(handle)) {
                            return handle.map(function (h) { return items[h]; });
                        }
                        return undefined;
                    });
                }, function (err) {
                    _this._proxy.$setError(err);
                    return winjs_base_1.TPromise.wrapError(err);
                });
            });
            return async_1.wireCancellationToken(token, promise, true);
        };
        ExtHostQuickOpen.prototype.$onItemSelected = function (handle) {
            if (this._onDidSelectItem) {
                this._onDidSelectItem(handle);
            }
        };
        // ---- input
        ExtHostQuickOpen.prototype.showInput = function (options, token) {
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            // global validate fn used in callback below
            this._validateInput = options && options.validateInput;
            var promise = this._proxy.$input(options, typeof this._validateInput === 'function');
            return async_1.wireCancellationToken(token, promise, true);
        };
        ExtHostQuickOpen.prototype.$validateInput = function (input) {
            var _this = this;
            if (this._validateInput) {
                return async_1.asWinJsPromise(function (_) { return _this._validateInput(input); });
            }
            return undefined;
        };
        // ---- workspace folder picker
        ExtHostQuickOpen.prototype.showWorkspaceFolderPick = function (options, token) {
            var _this = this;
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            return this._commands.executeCommand('_workbench.pickWorkspaceFolder', [options]).then(function (selectedFolder) {
                if (!selectedFolder) {
                    return undefined;
                }
                return _this._workspace.getWorkspaceFolders().filter(function (folder) { return folder.uri.toString() === selectedFolder.uri.toString(); })[0];
            });
        };
        // ---- QuickInput
        ExtHostQuickOpen.prototype.createQuickPick = function (extensionId) {
            var _this = this;
            var session = new ExtHostQuickPick(this._proxy, extensionId, function () { return _this._sessions.delete(session._id); });
            this._sessions.set(session._id, session);
            return session;
        };
        ExtHostQuickOpen.prototype.createInputBox = function (extensionId) {
            var _this = this;
            var session = new ExtHostInputBox(this._proxy, extensionId, function () { return _this._sessions.delete(session._id); });
            this._sessions.set(session._id, session);
            return session;
        };
        ExtHostQuickOpen.prototype.$onDidChangeValue = function (sessionId, value) {
            var session = this._sessions.get(sessionId);
            if (session) {
                session._fireDidChangeValue(value);
            }
        };
        ExtHostQuickOpen.prototype.$onDidAccept = function (sessionId) {
            var session = this._sessions.get(sessionId);
            if (session) {
                session._fireDidAccept();
            }
        };
        ExtHostQuickOpen.prototype.$onDidChangeActive = function (sessionId, handles) {
            var session = this._sessions.get(sessionId);
            if (session instanceof ExtHostQuickPick) {
                session._fireDidChangeActive(handles);
            }
        };
        ExtHostQuickOpen.prototype.$onDidChangeSelection = function (sessionId, handles) {
            var session = this._sessions.get(sessionId);
            if (session instanceof ExtHostQuickPick) {
                session._fireDidChangeSelection(handles);
            }
        };
        ExtHostQuickOpen.prototype.$onDidTriggerButton = function (sessionId, handle) {
            var session = this._sessions.get(sessionId);
            if (session) {
                session._fireDidTriggerButton(handle);
            }
        };
        ExtHostQuickOpen.prototype.$onDidHide = function (sessionId) {
            var session = this._sessions.get(sessionId);
            if (session) {
                session._fireDidHide();
            }
        };
        return ExtHostQuickOpen;
    }());
    exports.ExtHostQuickOpen = ExtHostQuickOpen;
    var ExtHostQuickInput = /** @class */ (function () {
        function ExtHostQuickInput(_proxy, _extensionId, _onDidDispose) {
            this._proxy = _proxy;
            this._extensionId = _extensionId;
            this._onDidDispose = _onDidDispose;
            this._id = ExtHostQuickPick._nextId++;
            this._visible = false;
            this._enabled = true;
            this._busy = false;
            this._ignoreFocusOut = true;
            this._value = '';
            this._buttons = [];
            this._handlesToButtons = new Map();
            this._onDidAcceptEmitter = new event_1.Emitter();
            this._onDidChangeValueEmitter = new event_1.Emitter();
            this._onDidTriggerButtonEmitter = new event_1.Emitter();
            this._onDidHideEmitter = new event_1.Emitter();
            this._pendingUpdate = { id: this._id };
            this._disposed = false;
            this._disposables = [
                this._onDidTriggerButtonEmitter,
                this._onDidHideEmitter,
                this._onDidAcceptEmitter,
                this._onDidChangeValueEmitter
            ];
            this.onDidChangeValue = this._onDidChangeValueEmitter.event;
            this.onDidAccept = this._onDidAcceptEmitter.event;
            this.onDidTriggerButton = this._onDidTriggerButtonEmitter.event;
            this.onDidHide = this._onDidHideEmitter.event;
        }
        Object.defineProperty(ExtHostQuickInput.prototype, "title", {
            get: function () {
                return this._title;
            },
            set: function (title) {
                this._title = title;
                this.update({ title: title });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "step", {
            get: function () {
                return this._steps;
            },
            set: function (step) {
                this._steps = step;
                this.update({ step: step });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "totalSteps", {
            get: function () {
                return this._totalSteps;
            },
            set: function (totalSteps) {
                this._totalSteps = totalSteps;
                this.update({ totalSteps: totalSteps });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (enabled) {
                this._enabled = enabled;
                this.update({ enabled: enabled });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "busy", {
            get: function () {
                return this._busy;
            },
            set: function (busy) {
                this._busy = busy;
                this.update({ busy: busy });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "ignoreFocusOut", {
            get: function () {
                return this._ignoreFocusOut;
            },
            set: function (ignoreFocusOut) {
                this._ignoreFocusOut = ignoreFocusOut;
                this.update({ ignoreFocusOut: ignoreFocusOut });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
                this.update({ value: value });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "placeholder", {
            get: function () {
                return this._placeholder;
            },
            set: function (placeholder) {
                this._placeholder = placeholder;
                this.update({ placeholder: placeholder });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "buttons", {
            get: function () {
                return this._buttons;
            },
            set: function (buttons) {
                var _this = this;
                this._buttons = buttons.slice();
                this._handlesToButtons.clear();
                buttons.forEach(function (button, i) {
                    var handle = button === extHostTypes_1.QuickInputButtons.Back ? -1 : i;
                    _this._handlesToButtons.set(handle, button);
                });
                this.update({
                    buttons: buttons.map(function (button, i) { return ({
                        iconPath: getIconUris(button.iconPath),
                        tooltip: button.tooltip,
                        handle: button === extHostTypes_1.QuickInputButtons.Back ? -1 : i,
                    }); })
                });
            },
            enumerable: true,
            configurable: true
        });
        ExtHostQuickInput.prototype.show = function () {
            this._visible = true;
            this.update({ visible: true });
        };
        ExtHostQuickInput.prototype.hide = function () {
            this._visible = false;
            this.update({ visible: false });
        };
        ExtHostQuickInput.prototype._fireDidAccept = function () {
            this._onDidAcceptEmitter.fire();
        };
        ExtHostQuickInput.prototype._fireDidChangeValue = function (value) {
            this._value = value;
            this._onDidChangeValueEmitter.fire(value);
        };
        ExtHostQuickInput.prototype._fireDidTriggerButton = function (handle) {
            var button = this._handlesToButtons.get(handle);
            this._onDidTriggerButtonEmitter.fire(button);
        };
        ExtHostQuickInput.prototype._fireDidHide = function () {
            this._onDidHideEmitter.fire();
        };
        ExtHostQuickInput.prototype.dispose = function () {
            if (this._disposed) {
                return;
            }
            this._disposed = true;
            this._fireDidHide();
            this._disposables = lifecycle_1.dispose(this._disposables);
            if (this._updateTimeout) {
                clearTimeout(this._updateTimeout);
                this._updateTimeout = undefined;
            }
            this._onDidDispose();
            this._proxy.$dispose(this._id);
        };
        ExtHostQuickInput.prototype.update = function (properties) {
            var _this = this;
            if (this._disposed) {
                return;
            }
            for (var _i = 0, _a = Object.keys(properties); _i < _a.length; _i++) {
                var key = _a[_i];
                var value = properties[key];
                this._pendingUpdate[key] = value === undefined ? null : value;
            }
            if ('visible' in this._pendingUpdate) {
                if (this._updateTimeout) {
                    clearTimeout(this._updateTimeout);
                    this._updateTimeout = undefined;
                }
                this.dispatchUpdate();
            }
            else if (this._visible && !this._updateTimeout) {
                // Defer the update so that multiple changes to setters dont cause a redraw each
                this._updateTimeout = setTimeout(function () {
                    _this._updateTimeout = undefined;
                    _this.dispatchUpdate();
                }, 0);
            }
        };
        ExtHostQuickInput.prototype.dispatchUpdate = function () {
            this._proxy.$createOrUpdate(this._pendingUpdate);
            this._pendingUpdate = { id: this._id };
        };
        ExtHostQuickInput._nextId = 1;
        return ExtHostQuickInput;
    }());
    function getIconUris(iconPath) {
        var light = getLightIconUri(iconPath);
        return { dark: getDarkIconUri(iconPath) || light, light: light };
    }
    function getLightIconUri(iconPath) {
        if (iconPath && !(iconPath instanceof extHostTypes_1.ThemeIcon)) {
            if (typeof iconPath === 'string'
                || iconPath instanceof uri_1.default) {
                return getIconUri(iconPath);
            }
            return getIconUri(iconPath['light']);
        }
        return undefined;
    }
    function getDarkIconUri(iconPath) {
        if (iconPath && !(iconPath instanceof extHostTypes_1.ThemeIcon) && iconPath['dark']) {
            return getIconUri(iconPath['dark']);
        }
        return undefined;
    }
    function getIconUri(iconPath) {
        if (iconPath instanceof uri_1.default) {
            return iconPath;
        }
        return uri_1.default.file(iconPath);
    }
    var ExtHostQuickPick = /** @class */ (function (_super) {
        __extends(ExtHostQuickPick, _super);
        function ExtHostQuickPick(proxy, extensionId, onDispose) {
            var _this = _super.call(this, proxy, extensionId, onDispose) || this;
            _this._items = [];
            _this._handlesToItems = new Map();
            _this._itemsToHandles = new Map();
            _this._canSelectMany = false;
            _this._matchOnDescription = true;
            _this._matchOnDetail = true;
            _this._activeItems = [];
            _this._onDidChangeActiveEmitter = new event_1.Emitter();
            _this._selectedItems = [];
            _this._onDidChangeSelectionEmitter = new event_1.Emitter();
            _this.onDidChangeActive = _this._onDidChangeActiveEmitter.event;
            _this.onDidChangeSelection = _this._onDidChangeSelectionEmitter.event;
            _this._disposables.push(_this._onDidChangeActiveEmitter, _this._onDidChangeSelectionEmitter);
            _this.update({ type: 'quickPick' });
            return _this;
        }
        Object.defineProperty(ExtHostQuickPick.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (items) {
                var _this = this;
                this._items = items.slice();
                this._handlesToItems.clear();
                this._itemsToHandles.clear();
                items.forEach(function (item, i) {
                    _this._handlesToItems.set(i, item);
                    _this._itemsToHandles.set(item, i);
                });
                this.update({
                    items: items.map(function (item, i) { return ({
                        label: item.label,
                        description: item.description,
                        handle: i,
                        detail: item.detail,
                        picked: item.picked
                    }); })
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickPick.prototype, "canSelectMany", {
            get: function () {
                return this._canSelectMany;
            },
            set: function (canSelectMany) {
                this._canSelectMany = canSelectMany;
                this.update({ canSelectMany: canSelectMany });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickPick.prototype, "matchOnDescription", {
            get: function () {
                return this._matchOnDescription;
            },
            set: function (matchOnDescription) {
                this._matchOnDescription = matchOnDescription;
                this.update({ matchOnDescription: matchOnDescription });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickPick.prototype, "matchOnDetail", {
            get: function () {
                return this._matchOnDetail;
            },
            set: function (matchOnDetail) {
                this._matchOnDetail = matchOnDetail;
                this.update({ matchOnDetail: matchOnDetail });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickPick.prototype, "activeItems", {
            get: function () {
                return this._activeItems;
            },
            set: function (activeItems) {
                var _this = this;
                this._activeItems = activeItems.filter(function (item) { return _this._itemsToHandles.has(item); });
                this.update({ activeItems: this._activeItems.map(function (item) { return _this._itemsToHandles.get(item); }) });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickPick.prototype, "selectedItems", {
            get: function () {
                return this._selectedItems;
            },
            set: function (selectedItems) {
                var _this = this;
                this._selectedItems = selectedItems.filter(function (item) { return _this._itemsToHandles.has(item); });
                this.update({ selectedItems: this._selectedItems.map(function (item) { return _this._itemsToHandles.get(item); }) });
            },
            enumerable: true,
            configurable: true
        });
        ExtHostQuickPick.prototype._fireDidChangeActive = function (handles) {
            var _this = this;
            var items = handles.map(function (handle) { return _this._handlesToItems.get(handle); });
            this._activeItems = items;
            this._onDidChangeActiveEmitter.fire(items);
        };
        ExtHostQuickPick.prototype._fireDidChangeSelection = function (handles) {
            var _this = this;
            var items = handles.map(function (handle) { return _this._handlesToItems.get(handle); });
            this._selectedItems = items;
            this._onDidChangeSelectionEmitter.fire(items);
        };
        return ExtHostQuickPick;
    }(ExtHostQuickInput));
    var ExtHostInputBox = /** @class */ (function (_super) {
        __extends(ExtHostInputBox, _super);
        function ExtHostInputBox(proxy, extensionId, onDispose) {
            var _this = _super.call(this, proxy, extensionId, onDispose) || this;
            _this.update({ type: 'inputBox' });
            return _this;
        }
        Object.defineProperty(ExtHostInputBox.prototype, "password", {
            get: function () {
                return this._password;
            },
            set: function (password) {
                this._password = password;
                this.update({ password: password });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostInputBox.prototype, "prompt", {
            get: function () {
                return this._prompt;
            },
            set: function (prompt) {
                this._prompt = prompt;
                this.update({ prompt: prompt });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostInputBox.prototype, "validationMessage", {
            get: function () {
                return this._validationMessage;
            },
            set: function (validationMessage) {
                this._validationMessage = validationMessage;
                this.update({ validationMessage: validationMessage });
            },
            enumerable: true,
            configurable: true
        });
        return ExtHostInputBox;
    }(ExtHostQuickInput));
});










define(__m[204/*vs/workbench/api/node/extHostSCM*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,2/*vs/base/common/winjs.base*/,3/*vs/base/common/event*/,52/*vs/base/common/decorators*/,9/*vs/base/common/lifecycle*/,12/*vs/base/common/async*/,6/*vs/workbench/api/node/extHost.protocol*/,13/*vs/base/common/arrays*/,75/*vs/base/common/comparers*/,38/*vs/platform/log/common/log*/]), function (require, exports, uri_1, winjs_base_1, event_1, decorators_1, lifecycle_1, async_1, extHost_protocol_1, arrays_1, comparers_1, log_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getIconPath(decorations) {
        if (!decorations) {
            return undefined;
        }
        else if (typeof decorations.iconPath === 'string') {
            return uri_1.default.file(decorations.iconPath).toString();
        }
        else if (decorations.iconPath) {
            return "" + decorations.iconPath;
        }
        return undefined;
    }
    function compareResourceThemableDecorations(a, b) {
        if (!a.iconPath && !b.iconPath) {
            return 0;
        }
        else if (!a.iconPath) {
            return -1;
        }
        else if (!b.iconPath) {
            return 1;
        }
        var aPath = typeof a.iconPath === 'string' ? a.iconPath : a.iconPath.fsPath;
        var bPath = typeof b.iconPath === 'string' ? b.iconPath : b.iconPath.fsPath;
        return comparers_1.comparePaths(aPath, bPath);
    }
    function compareResourceStatesDecorations(a, b) {
        var result = 0;
        if (a.strikeThrough !== b.strikeThrough) {
            return a.strikeThrough ? 1 : -1;
        }
        if (a.faded !== b.faded) {
            return a.faded ? 1 : -1;
        }
        if (a.tooltip !== b.tooltip) {
            return (a.tooltip || '').localeCompare(b.tooltip);
        }
        result = compareResourceThemableDecorations(a, b);
        if (result !== 0) {
            return result;
        }
        if (a.light && b.light) {
            result = compareResourceThemableDecorations(a.light, b.light);
        }
        else if (a.light) {
            return 1;
        }
        else if (b.light) {
            return -1;
        }
        if (result !== 0) {
            return result;
        }
        if (a.dark && b.dark) {
            result = compareResourceThemableDecorations(a.dark, b.dark);
        }
        else if (a.dark) {
            return 1;
        }
        else if (b.dark) {
            return -1;
        }
        return result;
    }
    function compareResourceStates(a, b) {
        var result = comparers_1.comparePaths(a.resourceUri.fsPath, b.resourceUri.fsPath, true);
        if (result !== 0) {
            return result;
        }
        if (a.decorations && b.decorations) {
            result = compareResourceStatesDecorations(a.decorations, b.decorations);
        }
        else if (a.decorations) {
            return 1;
        }
        else if (b.decorations) {
            return -1;
        }
        return result;
    }
    var ExtHostSCMInputBox = /** @class */ (function () {
        function ExtHostSCMInputBox(_extension, _proxy, _sourceControlHandle) {
            this._extension = _extension;
            this._proxy = _proxy;
            this._sourceControlHandle = _sourceControlHandle;
            this._value = '';
            this._onDidChange = new event_1.Emitter();
            this._placeholder = '';
            // noop
        }
        Object.defineProperty(ExtHostSCMInputBox.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._proxy.$setInputBoxValue(this._sourceControlHandle, value);
                this.updateValue(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSCMInputBox.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSCMInputBox.prototype, "placeholder", {
            get: function () {
                return this._placeholder;
            },
            set: function (placeholder) {
                this._proxy.$setInputBoxPlaceholder(this._sourceControlHandle, placeholder);
                this._placeholder = placeholder;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSCMInputBox.prototype, "validateInput", {
            get: function () {
                if (!this._extension.enableProposedApi) {
                    throw new Error("[" + this._extension.id + "]: Proposed API is only available when running out of dev or with the following command line switch: --enable-proposed-api " + this._extension.id);
                }
                return this._validateInput;
            },
            set: function (fn) {
                if (!this._extension.enableProposedApi) {
                    throw new Error("[" + this._extension.id + "]: Proposed API is only available when running out of dev or with the following command line switch: --enable-proposed-api " + this._extension.id);
                }
                if (fn && typeof fn !== 'function') {
                    console.warn('Invalid SCM input box validation function');
                    return;
                }
                this._validateInput = fn;
                this._proxy.$setValidationProviderIsEnabled(this._sourceControlHandle, !!fn);
            },
            enumerable: true,
            configurable: true
        });
        ExtHostSCMInputBox.prototype.$onInputBoxValueChange = function (value) {
            this.updateValue(value);
        };
        ExtHostSCMInputBox.prototype.updateValue = function (value) {
            this._value = value;
            this._onDidChange.fire(value);
        };
        return ExtHostSCMInputBox;
    }());
    exports.ExtHostSCMInputBox = ExtHostSCMInputBox;
    var ExtHostSourceControlResourceGroup = /** @class */ (function () {
        function ExtHostSourceControlResourceGroup(_proxy, _commands, _sourceControlHandle, _id, _label) {
            this._proxy = _proxy;
            this._commands = _commands;
            this._sourceControlHandle = _sourceControlHandle;
            this._id = _id;
            this._label = _label;
            this._resourceHandlePool = 0;
            this._resourceStates = [];
            this._resourceStatesMap = new Map();
            this._resourceStatesCommandsMap = new Map();
            this._onDidUpdateResourceStates = new event_1.Emitter();
            this.onDidUpdateResourceStates = this._onDidUpdateResourceStates.event;
            this._onDidDispose = new event_1.Emitter();
            this.onDidDispose = this._onDidDispose.event;
            this._handlesSnapshot = [];
            this._resourceSnapshot = [];
            this._hideWhenEmpty = undefined;
            this.handle = ExtHostSourceControlResourceGroup._handlePool++;
            this._disposables = [];
            this._proxy.$registerGroup(_sourceControlHandle, this.handle, _id, _label);
        }
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "id", {
            get: function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "label", {
            get: function () { return this._label; },
            set: function (label) {
                this._label = label;
                this._proxy.$updateGroupLabel(this._sourceControlHandle, this.handle, label);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "hideWhenEmpty", {
            get: function () { return this._hideWhenEmpty; },
            set: function (hideWhenEmpty) {
                this._hideWhenEmpty = hideWhenEmpty;
                this._proxy.$updateGroup(this._sourceControlHandle, this.handle, { hideWhenEmpty: hideWhenEmpty });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "resourceStates", {
            get: function () { return this._resourceStates.slice(); },
            set: function (resources) {
                this._resourceStates = resources.slice();
                this._onDidUpdateResourceStates.fire();
            },
            enumerable: true,
            configurable: true
        });
        ExtHostSourceControlResourceGroup.prototype.getResourceState = function (handle) {
            return this._resourceStatesMap.get(handle);
        };
        ExtHostSourceControlResourceGroup.prototype.$executeResourceCommand = function (handle) {
            var _this = this;
            var command = this._resourceStatesCommandsMap.get(handle);
            if (!command) {
                return winjs_base_1.TPromise.as(null);
            }
            return async_1.asWinJsPromise(function (_) {
                var _a;
                return (_a = _this._commands).executeCommand.apply(_a, [command.command].concat(command.arguments));
            });
        };
        ExtHostSourceControlResourceGroup.prototype._takeResourceStateSnapshot = function () {
            var _this = this;
            var _a;
            var snapshot = this._resourceStates.slice().sort(compareResourceStates);
            var diffs = arrays_1.sortedDiff(this._resourceSnapshot, snapshot, compareResourceStates);
            var splices = diffs.map(function (diff) {
                var toInsert = diff.toInsert.map(function (r) {
                    var handle = _this._resourceHandlePool++;
                    _this._resourceStatesMap.set(handle, r);
                    var sourceUri = r.resourceUri;
                    var iconPath = getIconPath(r.decorations);
                    var lightIconPath = r.decorations && getIconPath(r.decorations.light) || iconPath;
                    var darkIconPath = r.decorations && getIconPath(r.decorations.dark) || iconPath;
                    var icons = [];
                    if (r.command) {
                        _this._resourceStatesCommandsMap.set(handle, r.command);
                    }
                    if (lightIconPath || darkIconPath) {
                        icons.push(lightIconPath);
                    }
                    if (darkIconPath !== lightIconPath) {
                        icons.push(darkIconPath);
                    }
                    var tooltip = (r.decorations && r.decorations.tooltip) || '';
                    var strikeThrough = r.decorations && !!r.decorations.strikeThrough;
                    var faded = r.decorations && !!r.decorations.faded;
                    var source = r.decorations && r.decorations.source || undefined;
                    var letter = r.decorations && r.decorations.letter || undefined;
                    var color = r.decorations && r.decorations.color || undefined;
                    var rawResource = [handle, sourceUri, icons, tooltip, strikeThrough, faded, source, letter, color];
                    return { rawResource: rawResource, handle: handle };
                });
                return { start: diff.start, deleteCount: diff.deleteCount, toInsert: toInsert };
            });
            var rawResourceSplices = splices
                .map(function (_a) {
                var start = _a.start, deleteCount = _a.deleteCount, toInsert = _a.toInsert;
                return [start, deleteCount, toInsert.map(function (i) { return i.rawResource; })];
            });
            var reverseSplices = splices.reverse();
            for (var _i = 0, reverseSplices_1 = reverseSplices; _i < reverseSplices_1.length; _i++) {
                var _b = reverseSplices_1[_i], start = _b.start, deleteCount = _b.deleteCount, toInsert = _b.toInsert;
                var handles = toInsert.map(function (i) { return i.handle; });
                var handlesToDelete = (_a = this._handlesSnapshot).splice.apply(_a, [start, deleteCount].concat(handles));
                for (var _c = 0, handlesToDelete_1 = handlesToDelete; _c < handlesToDelete_1.length; _c++) {
                    var handle = handlesToDelete_1[_c];
                    this._resourceStatesMap.delete(handle);
                    this._resourceStatesCommandsMap.delete(handle);
                }
            }
            this._resourceSnapshot = snapshot;
            return rawResourceSplices;
        };
        ExtHostSourceControlResourceGroup.prototype.dispose = function () {
            this._proxy.$unregisterGroup(this._sourceControlHandle, this.handle);
            this._disposables = lifecycle_1.dispose(this._disposables);
            this._onDidDispose.fire();
        };
        ExtHostSourceControlResourceGroup._handlePool = 0;
        return ExtHostSourceControlResourceGroup;
    }());
    var ExtHostSourceControl = /** @class */ (function () {
        function ExtHostSourceControl(_extension, _proxy, _commands, _id, _label, _rootUri) {
            this._proxy = _proxy;
            this._commands = _commands;
            this._id = _id;
            this._label = _label;
            this._rootUri = _rootUri;
            this._groups = new Map();
            this._count = undefined;
            this._quickDiffProvider = undefined;
            this._commitTemplate = undefined;
            this._acceptInputCommand = undefined;
            this._statusBarCommands = undefined;
            this.handle = ExtHostSourceControl._handlePool++;
            this.updatedResourceGroups = new Set();
            this._inputBox = new ExtHostSCMInputBox(_extension, this._proxy, this.handle);
            this._proxy.$registerSourceControl(this.handle, _id, _label, _rootUri);
        }
        Object.defineProperty(ExtHostSourceControl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "rootUri", {
            get: function () {
                return this._rootUri;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "inputBox", {
            get: function () { return this._inputBox; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "count", {
            get: function () {
                return this._count;
            },
            set: function (count) {
                this._count = count;
                this._proxy.$updateSourceControl(this.handle, { count: count });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "quickDiffProvider", {
            get: function () {
                return this._quickDiffProvider;
            },
            set: function (quickDiffProvider) {
                this._quickDiffProvider = quickDiffProvider;
                this._proxy.$updateSourceControl(this.handle, { hasQuickDiffProvider: !!quickDiffProvider });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "commitTemplate", {
            get: function () {
                return this._commitTemplate;
            },
            set: function (commitTemplate) {
                this._commitTemplate = commitTemplate;
                this._proxy.$updateSourceControl(this.handle, { commitTemplate: commitTemplate });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "acceptInputCommand", {
            get: function () {
                return this._acceptInputCommand;
            },
            set: function (acceptInputCommand) {
                this._acceptInputCommand = acceptInputCommand;
                var internal = this._commands.converter.toInternal(acceptInputCommand);
                this._proxy.$updateSourceControl(this.handle, { acceptInputCommand: internal });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "statusBarCommands", {
            get: function () {
                return this._statusBarCommands;
            },
            set: function (statusBarCommands) {
                var _this = this;
                this._statusBarCommands = statusBarCommands;
                var internal = (statusBarCommands || []).map(function (c) { return _this._commands.converter.toInternal(c); });
                this._proxy.$updateSourceControl(this.handle, { statusBarCommands: internal });
            },
            enumerable: true,
            configurable: true
        });
        ExtHostSourceControl.prototype.createResourceGroup = function (id, label) {
            var _this = this;
            var group = new ExtHostSourceControlResourceGroup(this._proxy, this._commands, this.handle, id, label);
            var updateListener = group.onDidUpdateResourceStates(function () {
                _this.updatedResourceGroups.add(group);
                _this.eventuallyUpdateResourceStates();
            });
            event_1.once(group.onDidDispose)(function () {
                _this.updatedResourceGroups.delete(group);
                updateListener.dispose();
                _this._groups.delete(group.handle);
            });
            this._groups.set(group.handle, group);
            return group;
        };
        ExtHostSourceControl.prototype.eventuallyUpdateResourceStates = function () {
            var splices = [];
            this.updatedResourceGroups.forEach(function (group) {
                var snapshot = group._takeResourceStateSnapshot();
                if (snapshot.length === 0) {
                    return;
                }
                splices.push([group.handle, snapshot]);
            });
            if (splices.length > 0) {
                this._proxy.$spliceResourceStates(this.handle, splices);
            }
            this.updatedResourceGroups.clear();
        };
        ExtHostSourceControl.prototype.getResourceGroup = function (handle) {
            return this._groups.get(handle);
        };
        ExtHostSourceControl.prototype.dispose = function () {
            this._groups.forEach(function (group) { return group.dispose(); });
            this._proxy.$unregisterSourceControl(this.handle);
        };
        ExtHostSourceControl._handlePool = 0;
        __decorate([
            decorators_1.debounce(100)
        ], ExtHostSourceControl.prototype, "eventuallyUpdateResourceStates", null);
        return ExtHostSourceControl;
    }());
    var ExtHostSCM = /** @class */ (function () {
        function ExtHostSCM(mainContext, _commands, logService) {
            var _this = this;
            this._commands = _commands;
            this.logService = logService;
            this._sourceControls = new Map();
            this._sourceControlsByExtension = new Map();
            this._onDidChangeActiveProvider = new event_1.Emitter();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadSCM);
            _commands.registerArgumentProcessor({
                processArgument: function (arg) {
                    if (arg && arg.$mid === 3) {
                        var sourceControl = _this._sourceControls.get(arg.sourceControlHandle);
                        if (!sourceControl) {
                            return arg;
                        }
                        var group = sourceControl.getResourceGroup(arg.groupHandle);
                        if (!group) {
                            return arg;
                        }
                        return group.getResourceState(arg.handle);
                    }
                    else if (arg && arg.$mid === 4) {
                        var sourceControl = _this._sourceControls.get(arg.sourceControlHandle);
                        if (!sourceControl) {
                            return arg;
                        }
                        return sourceControl.getResourceGroup(arg.groupHandle);
                    }
                    else if (arg && arg.$mid === 5) {
                        var sourceControl = _this._sourceControls.get(arg.handle);
                        if (!sourceControl) {
                            return arg;
                        }
                        return sourceControl;
                    }
                    return arg;
                }
            });
        }
        Object.defineProperty(ExtHostSCM.prototype, "onDidChangeActiveProvider", {
            get: function () { return this._onDidChangeActiveProvider.event; },
            enumerable: true,
            configurable: true
        });
        ExtHostSCM.prototype.createSourceControl = function (extension, id, label, rootUri) {
            this.logService.trace('ExtHostSCM#createSourceControl', extension.id, id, label, rootUri);
            var handle = ExtHostSCM._handlePool++;
            var sourceControl = new ExtHostSourceControl(extension, this._proxy, this._commands, id, label, rootUri);
            this._sourceControls.set(handle, sourceControl);
            var sourceControls = this._sourceControlsByExtension.get(extension.id) || [];
            sourceControls.push(sourceControl);
            this._sourceControlsByExtension.set(extension.id, sourceControls);
            return sourceControl;
        };
        // Deprecated
        ExtHostSCM.prototype.getLastInputBox = function (extension) {
            this.logService.trace('ExtHostSCM#getLastInputBox', extension.id);
            var sourceControls = this._sourceControlsByExtension.get(extension.id);
            var sourceControl = sourceControls && sourceControls[sourceControls.length - 1];
            var inputBox = sourceControl && sourceControl.inputBox;
            return inputBox;
        };
        ExtHostSCM.prototype.$provideOriginalResource = function (sourceControlHandle, uriComponents) {
            var uri = uri_1.default.revive(uriComponents);
            this.logService.trace('ExtHostSCM#$provideOriginalResource', sourceControlHandle, uri.toString());
            var sourceControl = this._sourceControls.get(sourceControlHandle);
            if (!sourceControl || !sourceControl.quickDiffProvider) {
                return winjs_base_1.TPromise.as(null);
            }
            return async_1.asWinJsPromise(function (token) { return sourceControl.quickDiffProvider.provideOriginalResource(uri, token); });
        };
        ExtHostSCM.prototype.$onInputBoxValueChange = function (sourceControlHandle, value) {
            this.logService.trace('ExtHostSCM#$onInputBoxValueChange', sourceControlHandle);
            var sourceControl = this._sourceControls.get(sourceControlHandle);
            if (!sourceControl) {
                return winjs_base_1.TPromise.as(null);
            }
            sourceControl.inputBox.$onInputBoxValueChange(value);
            return winjs_base_1.TPromise.as(null);
        };
        ExtHostSCM.prototype.$executeResourceCommand = function (sourceControlHandle, groupHandle, handle) {
            this.logService.trace('ExtHostSCM#$executeResourceCommand', sourceControlHandle, groupHandle, handle);
            var sourceControl = this._sourceControls.get(sourceControlHandle);
            if (!sourceControl) {
                return winjs_base_1.TPromise.as(null);
            }
            var group = sourceControl.getResourceGroup(groupHandle);
            if (!group) {
                return winjs_base_1.TPromise.as(null);
            }
            return group.$executeResourceCommand(handle);
        };
        ExtHostSCM.prototype.$validateInput = function (sourceControlHandle, value, cursorPosition) {
            this.logService.trace('ExtHostSCM#$validateInput', sourceControlHandle);
            var sourceControl = this._sourceControls.get(sourceControlHandle);
            if (!sourceControl) {
                return winjs_base_1.TPromise.as(undefined);
            }
            if (!sourceControl.inputBox.validateInput) {
                return winjs_base_1.TPromise.as(undefined);
            }
            return async_1.asWinJsPromise(function (_) { return Promise.resolve(sourceControl.inputBox.validateInput(value, cursorPosition)); }).then(function (result) {
                if (!result) {
                    return winjs_base_1.TPromise.as(undefined);
                }
                return winjs_base_1.TPromise.as([result.message, result.type]);
            });
        };
        ExtHostSCM._handlePool = 0;
        ExtHostSCM = __decorate([
            __param(2, log_1.ILogService)
        ], ExtHostSCM);
        return ExtHostSCM;
    }());
    exports.ExtHostSCM = ExtHostSCM;
});









define(__m[205/*vs/workbench/api/node/extHostSearch*/], __M([0/*require*/,1/*exports*/,22/*path*/,29/*vs/base/common/cancellation*/,80/*vs/base/common/errorMessage*/,33/*vs/base/common/glob*/,26/*vs/base/common/resources*/,4/*vs/base/common/uri*/,2/*vs/base/common/winjs.base*/,68/*vs/base/node/extfs*/,6/*vs/workbench/api/node/extHost.protocol*/,9/*vs/base/common/lifecycle*/,152/*vs/workbench/api/node/extHostSearch.fileIndex*/]), function (require, exports, path, cancellation_1, errorMessage_1, glob, resources, uri_1, winjs_base_1, extfs, extHost_protocol_1, lifecycle_1, extHostSearch_fileIndex_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostSearch = /** @class */ (function () {
        function ExtHostSearch(mainContext, _schemeTransformer, _extfs) {
            if (_extfs === void 0) { _extfs = extfs; }
            this._schemeTransformer = _schemeTransformer;
            this._extfs = _extfs;
            this._fileSearchProvider = new Map();
            this._textSearchProvider = new Map();
            this._fileIndexProvider = new Map();
            this._handlePool = 0;
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadSearch);
            this._fileSearchManager = new FileSearchManager();
            this._fileIndexSearchManager = new extHostSearch_fileIndex_1.FileIndexSearchManager();
        }
        ExtHostSearch.prototype._transformScheme = function (scheme) {
            if (this._schemeTransformer) {
                return this._schemeTransformer.transformOutgoing(scheme);
            }
            return scheme;
        };
        ExtHostSearch.prototype.registerFileSearchProvider = function (scheme, provider) {
            var _this = this;
            var handle = this._handlePool++;
            this._fileSearchProvider.set(handle, provider);
            this._proxy.$registerFileSearchProvider(handle, this._transformScheme(scheme));
            return lifecycle_1.toDisposable(function () {
                _this._fileSearchProvider.delete(handle);
                _this._proxy.$unregisterProvider(handle);
            });
        };
        ExtHostSearch.prototype.registerTextSearchProvider = function (scheme, provider) {
            var _this = this;
            var handle = this._handlePool++;
            this._textSearchProvider.set(handle, provider);
            this._proxy.$registerTextSearchProvider(handle, this._transformScheme(scheme));
            return lifecycle_1.toDisposable(function () {
                _this._textSearchProvider.delete(handle);
                _this._proxy.$unregisterProvider(handle);
            });
        };
        ExtHostSearch.prototype.registerFileIndexProvider = function (scheme, provider) {
            var _this = this;
            var handle = this._handlePool++;
            this._fileIndexProvider.set(handle, provider);
            this._proxy.$registerFileIndexProvider(handle, this._transformScheme(scheme));
            return lifecycle_1.toDisposable(function () {
                _this._fileSearchProvider.delete(handle);
                _this._proxy.$unregisterProvider(handle); // TODO@roblou - unregisterFileIndexProvider
            });
        };
        ExtHostSearch.prototype.$provideFileSearchResults = function (handle, session, rawQuery) {
            var _this = this;
            var provider = this._fileSearchProvider.get(handle);
            var query = reviveQuery(rawQuery);
            if (provider) {
                return this._fileSearchManager.fileSearch(query, provider, function (batch) {
                    _this._proxy.$handleFileMatch(handle, session, batch.map(function (p) { return p.resource; }));
                });
            }
            else {
                var indexProvider = this._fileIndexProvider.get(handle);
                if (indexProvider) {
                    return this._fileIndexSearchManager.fileSearch(query, indexProvider, function (batch) {
                        _this._proxy.$handleFileMatch(handle, session, batch.map(function (p) { return p.resource; }));
                    });
                }
                else {
                    throw new Error('something went wrong');
                }
            }
        };
        ExtHostSearch.prototype.$clearCache = function (cacheKey) {
            // Actually called once per provider.
            // Only relevant to file index search.
            return this._fileIndexSearchManager.clearCache(cacheKey);
        };
        ExtHostSearch.prototype.$provideTextSearchResults = function (handle, session, pattern, rawQuery) {
            var _this = this;
            var provider = this._textSearchProvider.get(handle);
            if (!provider.provideTextSearchResults) {
                return winjs_base_1.TPromise.as(undefined);
            }
            var query = reviveQuery(rawQuery);
            var engine = new TextSearchEngine(pattern, query, provider, this._extfs);
            return engine.search(function (progress) { return _this._proxy.$handleTextMatch(handle, session, progress); });
        };
        return ExtHostSearch;
    }());
    exports.ExtHostSearch = ExtHostSearch;
    function reviveQuery(rawQuery) {
        return __assign({}, rawQuery, {
            folderQueries: rawQuery.folderQueries && rawQuery.folderQueries.map(reviveFolderQuery),
            extraFileResources: rawQuery.extraFileResources && rawQuery.extraFileResources.map(function (components) { return uri_1.default.revive(components); })
        });
    }
    function reviveFolderQuery(rawFolderQuery) {
        return __assign({}, rawFolderQuery, { folder: uri_1.default.revive(rawFolderQuery.folder) });
    }
    var TextSearchResultsCollector = /** @class */ (function () {
        function TextSearchResultsCollector(_onResult) {
            var _this = this;
            this._onResult = _onResult;
            this._batchedCollector = new BatchedCollector(512, function (items) { return _this.sendItems(items); });
        }
        TextSearchResultsCollector.prototype.add = function (data, folderIdx) {
            // Collects TextSearchResults into IInternalFileMatches and collates using BatchedCollector.
            // This is efficient for ripgrep which sends results back one file at a time. It wouldn't be efficient for other search
            // providers that send results in random order. We could do this step afterwards instead.
            if (this._currentFileMatch && (this._currentFolderIdx !== folderIdx || resources.isEqual(this._currentUri, data.uri))) {
                this.pushToCollector();
                this._currentFileMatch = null;
            }
            if (!this._currentFileMatch) {
                this._currentFileMatch = {
                    resource: data.uri,
                    lineMatches: []
                };
            }
            // TODO@roblou - line text is sent for every match
            var matchRange = data.preview.match;
            this._currentFileMatch.lineMatches.push({
                lineNumber: data.range.start.line,
                preview: data.preview.text,
                offsetAndLengths: [[matchRange.start.character, matchRange.end.character - matchRange.start.character]]
            });
        };
        TextSearchResultsCollector.prototype.pushToCollector = function () {
            var size = this._currentFileMatch ?
                this._currentFileMatch.lineMatches.reduce(function (acc, match) { return acc + match.offsetAndLengths.length; }, 0) :
                0;
            this._batchedCollector.addItem(this._currentFileMatch, size);
        };
        TextSearchResultsCollector.prototype.flush = function () {
            this.pushToCollector();
            this._batchedCollector.flush();
        };
        TextSearchResultsCollector.prototype.sendItems = function (items) {
            this._onResult(items);
        };
        return TextSearchResultsCollector;
    }());
    /**
     * Collects items that have a size - before the cumulative size of collected items reaches START_BATCH_AFTER_COUNT, the callback is called for every
     * set of items collected.
     * But after that point, the callback is called with batches of maxBatchSize.
     * If the batch isn't filled within some time, the callback is also called.
     */
    var BatchedCollector = /** @class */ (function () {
        function BatchedCollector(maxBatchSize, cb) {
            this.maxBatchSize = maxBatchSize;
            this.cb = cb;
            this.totalNumberCompleted = 0;
            this.batch = [];
            this.batchSize = 0;
        }
        BatchedCollector.prototype.addItem = function (item, size) {
            if (!item) {
                return;
            }
            this.addItemToBatch(item, size);
        };
        BatchedCollector.prototype.addItems = function (items, size) {
            if (!items) {
                return;
            }
            if (this.maxBatchSize > 0) {
                this.addItemsToBatch(items, size);
            }
            else {
                this.cb(items);
            }
        };
        BatchedCollector.prototype.addItemToBatch = function (item, size) {
            this.batch.push(item);
            this.batchSize += size;
            this.onUpdate();
        };
        BatchedCollector.prototype.addItemsToBatch = function (item, size) {
            this.batch = this.batch.concat(item);
            this.batchSize += size;
            this.onUpdate();
        };
        BatchedCollector.prototype.onUpdate = function () {
            var _this = this;
            if (this.totalNumberCompleted < BatchedCollector.START_BATCH_AFTER_COUNT) {
                // Flush because we aren't batching yet
                this.flush();
            }
            else if (this.batchSize >= this.maxBatchSize) {
                // Flush because the batch is full
                this.flush();
            }
            else if (!this.timeoutHandle) {
                // No timeout running, start a timeout to flush
                this.timeoutHandle = setTimeout(function () {
                    _this.flush();
                }, BatchedCollector.TIMEOUT);
            }
        };
        BatchedCollector.prototype.flush = function () {
            if (this.batchSize) {
                this.totalNumberCompleted += this.batchSize;
                this.cb(this.batch);
                this.batch = [];
                this.batchSize = 0;
                if (this.timeoutHandle) {
                    clearTimeout(this.timeoutHandle);
                    this.timeoutHandle = 0;
                }
            }
        };
        BatchedCollector.TIMEOUT = 4000;
        // After START_BATCH_AFTER_COUNT items have been collected, stop flushing on timeout
        BatchedCollector.START_BATCH_AFTER_COUNT = 50;
        return BatchedCollector;
    }());
    var TextSearchEngine = /** @class */ (function () {
        function TextSearchEngine(pattern, config, provider, _extfs) {
            this.pattern = pattern;
            this.config = config;
            this.provider = provider;
            this._extfs = _extfs;
            this.activeCancellationTokens = new Set();
            this.resultCount = 0;
        }
        TextSearchEngine.prototype.cancel = function () {
            this.isCanceled = true;
            this.activeCancellationTokens.forEach(function (t) { return t.cancel(); });
            this.activeCancellationTokens = new Set();
        };
        TextSearchEngine.prototype.search = function (onProgress) {
            var _this = this;
            var folderQueries = this.config.folderQueries;
            return new winjs_base_1.TPromise(function (resolve, reject) {
                _this.collector = new TextSearchResultsCollector(onProgress);
                var onResult = function (match, folderIdx) {
                    if (_this.isCanceled) {
                        return;
                    }
                    if (_this.resultCount >= _this.config.maxResults) {
                        _this.isLimitHit = true;
                        _this.cancel();
                    }
                    if (!_this.isLimitHit) {
                        _this.resultCount++;
                        _this.collector.add(match, folderIdx);
                    }
                };
                // For each root folder
                winjs_base_1.TPromise.join(folderQueries.map(function (fq, i) {
                    return _this.searchInFolder(fq, function (r) { return onResult(r, i); });
                })).then(function () {
                    _this.collector.flush();
                    resolve({ limitHit: _this.isLimitHit });
                }, function (errs) {
                    var errMsg = errs
                        .map(function (err) { return errorMessage_1.toErrorMessage(err); })
                        .filter(function (msg) { return !!msg; })[0];
                    reject(new Error(errMsg));
                });
            });
        };
        TextSearchEngine.prototype.searchInFolder = function (folderQuery, onResult) {
            var _this = this;
            var cancellation = new cancellation_1.CancellationTokenSource();
            return new winjs_base_1.TPromise(function (resolve, reject) {
                var queryTester = new extHostSearch_fileIndex_1.QueryGlobTester(_this.config, folderQuery);
                var testingPs = [];
                var progress = {
                    report: function (result) {
                        var hasSibling = folderQuery.folder.scheme === 'file' && glob.hasSiblingPromiseFn(function () {
                            return _this.readdir(path.dirname(result.uri.fsPath));
                        });
                        var relativePath = path.relative(folderQuery.folder.fsPath, result.uri.fsPath);
                        testingPs.push(queryTester.includedInQuery(relativePath, path.basename(relativePath), hasSibling)
                            .then(function (included) {
                            if (included) {
                                onResult(result);
                            }
                        }));
                    }
                };
                var searchOptions = _this.getSearchOptionsForFolder(folderQuery);
                new winjs_base_1.TPromise(function (resolve) { return process.nextTick(resolve); })
                    .then(function () {
                    _this.activeCancellationTokens.add(cancellation);
                    return _this.provider.provideTextSearchResults(patternInfoToQuery(_this.pattern), searchOptions, progress, cancellation.token);
                })
                    .then(function () {
                    _this.activeCancellationTokens.delete(cancellation);
                    return winjs_base_1.TPromise.join(testingPs);
                })
                    .then(function () {
                    cancellation.dispose();
                    resolve(null);
                }, function (err) {
                    cancellation.dispose();
                    reject(err);
                });
            });
        };
        TextSearchEngine.prototype.readdir = function (dirname) {
            var _this = this;
            return new winjs_base_1.TPromise(function (resolve, reject) {
                _this._extfs.readdir(dirname, function (err, files) {
                    if (err) {
                        return reject(err);
                    }
                    resolve(files);
                });
            });
        };
        TextSearchEngine.prototype.getSearchOptionsForFolder = function (fq) {
            var includes = extHostSearch_fileIndex_1.resolvePatternsForProvider(this.config.includePattern, fq.includePattern);
            var excludes = extHostSearch_fileIndex_1.resolvePatternsForProvider(this.config.excludePattern, fq.excludePattern);
            return {
                folder: uri_1.default.from(fq.folder),
                excludes: excludes,
                includes: includes,
                useIgnoreFiles: !this.config.disregardIgnoreFiles,
                followSymlinks: !this.config.ignoreSymlinks,
                encoding: this.config.fileEncoding,
                maxFileSize: this.config.maxFileSize,
                maxResults: this.config.maxResults
            };
        };
        return TextSearchEngine;
    }());
    function patternInfoToQuery(patternInfo) {
        return {
            isCaseSensitive: patternInfo.isCaseSensitive || false,
            isRegExp: patternInfo.isRegExp || false,
            isWordMatch: patternInfo.isWordMatch || false,
            pattern: patternInfo.pattern
        };
    }
    var FileSearchEngine = /** @class */ (function () {
        function FileSearchEngine(config, provider) {
            this.config = config;
            this.provider = provider;
            this.filePattern = config.filePattern;
            this.includePattern = config.includePattern && glob.parse(config.includePattern);
            this.maxResults = config.maxResults || null;
            this.exists = config.exists;
            this.resultCount = 0;
            this.isLimitHit = false;
            this.activeCancellationTokens = new Set();
            this.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);
        }
        FileSearchEngine.prototype.cancel = function () {
            this.isCanceled = true;
            this.activeCancellationTokens.forEach(function (t) { return t.cancel(); });
            this.activeCancellationTokens = new Set();
        };
        FileSearchEngine.prototype.search = function (_onResult) {
            var _this = this;
            var folderQueries = this.config.folderQueries;
            return new winjs_base_1.TPromise(function (resolve, reject) {
                var onResult = function (match) {
                    _this.resultCount++;
                    _onResult(match);
                };
                // Support that the file pattern is a full path to a file that exists
                if (_this.isCanceled) {
                    return resolve({ limitHit: _this.isLimitHit });
                }
                // For each extra file
                if (_this.config.extraFileResources) {
                    _this.config.extraFileResources
                        .forEach(function (extraFile) {
                        var extraFileStr = extraFile.toString(); // ?
                        var basename = path.basename(extraFileStr);
                        if (_this.globalExcludePattern && _this.globalExcludePattern(extraFileStr, basename)) {
                            return; // excluded
                        }
                        // File: Check for match on file pattern and include pattern
                        _this.matchFile(onResult, { base: extraFile, basename: basename });
                    });
                }
                // For each root folder
                winjs_base_1.TPromise.join(folderQueries.map(function (fq) {
                    return _this.searchInFolder(fq, onResult);
                })).then(function () {
                    resolve({ limitHit: _this.isLimitHit });
                }, function (errs) {
                    var errMsg = errs
                        .map(function (err) { return errorMessage_1.toErrorMessage(err); })
                        .filter(function (msg) { return !!msg; })[0];
                    reject(new Error(errMsg));
                });
            });
        };
        FileSearchEngine.prototype.searchInFolder = function (fq, onResult) {
            var _this = this;
            var cancellation = new cancellation_1.CancellationTokenSource();
            return new winjs_base_1.TPromise(function (resolve, reject) {
                var options = _this.getSearchOptionsForFolder(fq);
                var tree = _this.initDirectoryTree();
                var queryTester = new extHostSearch_fileIndex_1.QueryGlobTester(_this.config, fq);
                var noSiblingsClauses = !queryTester.hasSiblingExcludeClauses();
                new winjs_base_1.TPromise(function (_resolve) { return process.nextTick(_resolve); })
                    .then(function () {
                    _this.activeCancellationTokens.add(cancellation);
                    return _this.provider.provideFileSearchResults({
                        pattern: _this.config.filePattern || ''
                    }, options, cancellation.token);
                })
                    .then(function (results) {
                    if (_this.isCanceled) {
                        return;
                    }
                    if (results) {
                        results.forEach(function (result) {
                            var relativePath = path.relative(fq.folder.fsPath, result.fsPath);
                            if (noSiblingsClauses) {
                                var basename = path.basename(result.fsPath);
                                _this.matchFile(onResult, { base: fq.folder, relativePath: relativePath, basename: basename });
                                return;
                            }
                            // TODO: Optimize siblings clauses with ripgrep here.
                            _this.addDirectoryEntries(tree, fq.folder, relativePath, onResult);
                        });
                    }
                    _this.activeCancellationTokens.delete(cancellation);
                    if (_this.isCanceled) {
                        return null;
                    }
                    _this.matchDirectoryTree(tree, queryTester, onResult);
                    return null;
                }).then(function () {
                    cancellation.dispose();
                    resolve(null);
                }, function (err) {
                    cancellation.dispose();
                    reject(err);
                });
            });
        };
        FileSearchEngine.prototype.getSearchOptionsForFolder = function (fq) {
            var includes = extHostSearch_fileIndex_1.resolvePatternsForProvider(this.config.includePattern, fq.includePattern);
            var excludes = extHostSearch_fileIndex_1.resolvePatternsForProvider(this.config.excludePattern, fq.excludePattern);
            return {
                folder: fq.folder,
                excludes: excludes,
                includes: includes,
                useIgnoreFiles: !this.config.disregardIgnoreFiles,
                followSymlinks: !this.config.ignoreSymlinks,
                maxResults: this.config.maxResults
            };
        };
        FileSearchEngine.prototype.initDirectoryTree = function () {
            var tree = {
                rootEntries: [],
                pathToEntries: Object.create(null)
            };
            tree.pathToEntries['.'] = tree.rootEntries;
            return tree;
        };
        FileSearchEngine.prototype.addDirectoryEntries = function (_a, base, relativeFile, onResult) {
            var pathToEntries = _a.pathToEntries;
            // Support relative paths to files from a root resource (ignores excludes)
            if (relativeFile === this.filePattern) {
                var basename = path.basename(this.filePattern);
                this.matchFile(onResult, { base: base, relativePath: this.filePattern, basename: basename });
            }
            function add(relativePath) {
                var basename = path.basename(relativePath);
                var dirname = path.dirname(relativePath);
                var entries = pathToEntries[dirname];
                if (!entries) {
                    entries = pathToEntries[dirname] = [];
                    add(dirname);
                }
                entries.push({
                    base: base,
                    relativePath: relativePath,
                    basename: basename
                });
            }
            add(relativeFile);
        };
        FileSearchEngine.prototype.matchDirectoryTree = function (_a, queryTester, onResult) {
            var rootEntries = _a.rootEntries, pathToEntries = _a.pathToEntries;
            var self = this;
            var filePattern = this.filePattern;
            function matchDirectory(entries) {
                var hasSibling = glob.hasSiblingFn(function () { return entries.map(function (entry) { return entry.basename; }); });
                for (var i = 0, n = entries.length; i < n; i++) {
                    var entry = entries[i];
                    var relativePath = entry.relativePath, basename = entry.basename;
                    // Check exclude pattern
                    // If the user searches for the exact file name, we adjust the glob matching
                    // to ignore filtering by siblings because the user seems to know what she
                    // is searching for and we want to include the result in that case anyway
                    if (!queryTester.includedInQuerySync(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {
                        continue;
                    }
                    var sub = pathToEntries[relativePath];
                    if (sub) {
                        matchDirectory(sub);
                    }
                    else {
                        if (relativePath === filePattern) {
                            continue; // ignore file if its path matches with the file pattern because that is already matched above
                        }
                        self.matchFile(onResult, entry);
                    }
                    if (self.isLimitHit) {
                        break;
                    }
                }
            }
            matchDirectory(rootEntries);
        };
        FileSearchEngine.prototype.matchFile = function (onResult, candidate) {
            if (!this.includePattern || this.includePattern(candidate.relativePath, candidate.basename)) {
                if (this.exists || (this.maxResults && this.resultCount >= this.maxResults)) {
                    this.isLimitHit = true;
                    this.cancel();
                }
                if (!this.isLimitHit) {
                    onResult(candidate);
                }
            }
        };
        return FileSearchEngine;
    }());
    var FileSearchManager = /** @class */ (function () {
        function FileSearchManager() {
        }
        FileSearchManager.prototype.fileSearch = function (config, provider, onBatch) {
            var _this = this;
            var searchP;
            return new winjs_base_1.TPromise(function (c, e) {
                var engine = new FileSearchEngine(config, provider);
                var onInternalResult = function (batch) {
                    onBatch(batch.map(function (m) { return _this.rawMatchToSearchItem(m); }));
                };
                searchP = _this.doSearch(engine, FileSearchManager.BATCH_SIZE, onInternalResult).then(function (result) {
                    c({
                        limitHit: result.limitHit
                    });
                }, e);
            }, function () {
                if (searchP) {
                    searchP.cancel();
                }
            });
        };
        FileSearchManager.prototype.rawMatchToSearchItem = function (match) {
            if (match.relativePath) {
                return {
                    resource: resources.joinPath(match.base, match.relativePath)
                };
            }
            else {
                // extraFileResources
                return {
                    resource: match.base
                };
            }
        };
        FileSearchManager.prototype.doSearch = function (engine, batchSize, onResultBatch) {
            return new winjs_base_1.TPromise(function (c, e) {
                var _onResult = function (match) {
                    if (match) {
                        batch.push(match);
                        if (batchSize > 0 && batch.length >= batchSize) {
                            onResultBatch(batch);
                            batch = [];
                        }
                    }
                };
                var batch = [];
                engine.search(_onResult).then(function (result) {
                    if (batch.length) {
                        onResultBatch(batch);
                    }
                    c(result);
                }, function (error) {
                    if (batch.length) {
                        onResultBatch(batch);
                    }
                    e(error);
                });
            }, function () {
                engine.cancel();
            });
        };
        FileSearchManager.BATCH_SIZE = 512;
        return FileSearchManager;
    }());
});

define(__m[206/*vs/workbench/api/node/extHostStatusBar*/], __M([0/*require*/,1/*exports*/,143/*vs/platform/statusbar/common/statusbar*/,5/*vs/workbench/api/node/extHostTypes*/,6/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, statusbar_1, extHostTypes_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostStatusBarEntry = /** @class */ (function () {
        function ExtHostStatusBarEntry(proxy, extensionId, alignment, priority) {
            if (alignment === void 0) { alignment = extHostTypes_1.StatusBarAlignment.Left; }
            this._id = ExtHostStatusBarEntry.ID_GEN++;
            this._proxy = proxy;
            this._alignment = alignment;
            this._priority = priority;
            this._extensionId = extensionId;
        }
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "alignment", {
            get: function () {
                return this._alignment;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "priority", {
            get: function () {
                return this._priority;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "text", {
            get: function () {
                return this._text;
            },
            set: function (text) {
                this._text = text;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "tooltip", {
            get: function () {
                return this._tooltip;
            },
            set: function (tooltip) {
                this._tooltip = tooltip;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                this._color = color;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "command", {
            get: function () {
                return this._command;
            },
            set: function (command) {
                this._command = command;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        ExtHostStatusBarEntry.prototype.show = function () {
            this._visible = true;
            this.update();
        };
        ExtHostStatusBarEntry.prototype.hide = function () {
            clearTimeout(this._timeoutHandle);
            this._visible = false;
            this._proxy.$dispose(this.id);
        };
        ExtHostStatusBarEntry.prototype.update = function () {
            var _this = this;
            if (this._disposed || !this._visible) {
                return;
            }
            clearTimeout(this._timeoutHandle);
            // Defer the update so that multiple changes to setters dont cause a redraw each
            this._timeoutHandle = setTimeout(function () {
                _this._timeoutHandle = undefined;
                // Set to status bar
                _this._proxy.$setEntry(_this.id, _this._extensionId, _this.text, _this.tooltip, _this.command, _this.color, _this._alignment === extHostTypes_1.StatusBarAlignment.Left ? statusbar_1.StatusbarAlignment.LEFT : statusbar_1.StatusbarAlignment.RIGHT, _this._priority);
            }, 0);
        };
        ExtHostStatusBarEntry.prototype.dispose = function () {
            this.hide();
            this._disposed = true;
        };
        ExtHostStatusBarEntry.ID_GEN = 0;
        return ExtHostStatusBarEntry;
    }());
    exports.ExtHostStatusBarEntry = ExtHostStatusBarEntry;
    var StatusBarMessage = /** @class */ (function () {
        function StatusBarMessage(statusBar) {
            this._messages = [];
            this._item = statusBar.createStatusBarEntry(void 0, extHostTypes_1.StatusBarAlignment.Left, Number.MIN_VALUE);
        }
        StatusBarMessage.prototype.dispose = function () {
            this._messages.length = 0;
            this._item.dispose();
        };
        StatusBarMessage.prototype.setMessage = function (message) {
            var _this = this;
            var data = { message: message }; // use object to not confuse equal strings
            this._messages.unshift(data);
            this._update();
            return new extHostTypes_1.Disposable(function () {
                var idx = _this._messages.indexOf(data);
                if (idx >= 0) {
                    _this._messages.splice(idx, 1);
                    _this._update();
                }
            });
        };
        StatusBarMessage.prototype._update = function () {
            if (this._messages.length > 0) {
                this._item.text = this._messages[0].message;
                this._item.show();
            }
            else {
                this._item.hide();
            }
        };
        return StatusBarMessage;
    }());
    var ExtHostStatusBar = /** @class */ (function () {
        function ExtHostStatusBar(mainContext) {
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadStatusBar);
            this._statusMessage = new StatusBarMessage(this);
        }
        ExtHostStatusBar.prototype.createStatusBarEntry = function (extensionId, alignment, priority) {
            return new ExtHostStatusBarEntry(this._proxy, extensionId, alignment, priority);
        };
        ExtHostStatusBar.prototype.setStatusBarMessage = function (text, timeoutOrThenable) {
            var d = this._statusMessage.setMessage(text);
            var handle;
            if (typeof timeoutOrThenable === 'number') {
                handle = setTimeout(function () { return d.dispose(); }, timeoutOrThenable);
            }
            else if (typeof timeoutOrThenable !== 'undefined') {
                timeoutOrThenable.then(function () { return d.dispose(); }, function () { return d.dispose(); });
            }
            return new extHostTypes_1.Disposable(function () {
                d.dispose();
                clearTimeout(handle);
            });
        };
        return ExtHostStatusBar;
    }());
    exports.ExtHostStatusBar = ExtHostStatusBar;
});

define(__m[207/*vs/workbench/api/node/extHostStorage*/], __M([0/*require*/,1/*exports*/,6/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostStorage = /** @class */ (function () {
        function ExtHostStorage(mainContext) {
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadStorage);
        }
        ExtHostStorage.prototype.getValue = function (shared, key, defaultValue) {
            return this._proxy.$getValue(shared, key).then(function (value) { return value || defaultValue; });
        };
        ExtHostStorage.prototype.setValue = function (shared, key, value) {
            return this._proxy.$setValue(shared, key, value);
        };
        return ExtHostStorage;
    }());
    exports.ExtHostStorage = ExtHostStorage;
});

define(__m[208/*vs/workbench/api/node/extHostTask*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,110/*vs/nls!vs/workbench/api/node/extHostTask*/,2/*vs/base/common/winjs.base*/,20/*vs/base/common/objects*/,12/*vs/base/common/async*/,3/*vs/base/common/event*/,162/*vs/workbench/parts/tasks/common/tasks*/,6/*vs/workbench/api/node/extHost.protocol*/,5/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, uri_1, nls, winjs_base_1, Objects, async_1, event_1, tasks, extHost_protocol_1, types) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /*
    namespace ProblemPattern {
        export function from(value: vscode.ProblemPattern | vscode.MultiLineProblemPattern): Problems.ProblemPattern | Problems.MultiLineProblemPattern {
            if (value === void 0 || value === null) {
                return undefined;
            }
            if (Array.isArray(value)) {
                let result: Problems.ProblemPattern[] = [];
                for (let pattern of value) {
                    let converted = fromSingle(pattern);
                    if (!converted) {
                        return undefined;
                    }
                    result.push(converted);
                }
                return result;
            } else {
                return fromSingle(value);
            }
        }
    
        function copyProperty(target: Problems.ProblemPattern, source: vscode.ProblemPattern, tk: keyof Problems.ProblemPattern) {
            let sk: keyof vscode.ProblemPattern = tk;
            let value = source[sk];
            if (typeof value === 'number') {
                target[tk] = value;
            }
        }
    
        function getValue(value: number, defaultValue: number): number {
            if (value !== void 0 && value === null) {
                return value;
            }
            return defaultValue;
        }
    
        function fromSingle(problemPattern: vscode.ProblemPattern): Problems.ProblemPattern {
            if (problemPattern === void 0 || problemPattern === null || !(problemPattern.regexp instanceof RegExp)) {
                return undefined;
            }
            let result: Problems.ProblemPattern = {
                regexp: problemPattern.regexp
            };
            copyProperty(result, problemPattern, 'file');
            copyProperty(result, problemPattern, 'location');
            copyProperty(result, problemPattern, 'line');
            copyProperty(result, problemPattern, 'character');
            copyProperty(result, problemPattern, 'endLine');
            copyProperty(result, problemPattern, 'endCharacter');
            copyProperty(result, problemPattern, 'severity');
            copyProperty(result, problemPattern, 'code');
            copyProperty(result, problemPattern, 'message');
            if (problemPattern.loop === true || problemPattern.loop === false) {
                result.loop = problemPattern.loop;
            }
            if (result.location) {
                result.file = getValue(result.file, 1);
                result.message = getValue(result.message, 0);
            } else {
                result.file = getValue(result.file, 1);
                result.line = getValue(result.line, 2);
                result.character = getValue(result.character, 3);
                result.message = getValue(result.message, 0);
            }
            return result;
        }
    }
    
    namespace ApplyTo {
        export function from(value: vscode.ApplyToKind): Problems.ApplyToKind {
            if (value === void 0 || value === null) {
                return Problems.ApplyToKind.allDocuments;
            }
            switch (value) {
                case types.ApplyToKind.OpenDocuments:
                    return Problems.ApplyToKind.openDocuments;
                case types.ApplyToKind.ClosedDocuments:
                    return Problems.ApplyToKind.closedDocuments;
            }
            return Problems.ApplyToKind.allDocuments;
        }
    }
    
    namespace FileLocation {
        export function from(value: vscode.FileLocationKind | string): { kind: Problems.FileLocationKind; prefix?: string } {
            if (value === void 0 || value === null) {
                return { kind: Problems.FileLocationKind.Auto };
            }
            if (typeof value === 'string') {
                return { kind: Problems.FileLocationKind.Relative, prefix: value };
            }
            switch (value) {
                case types.FileLocationKind.Absolute:
                    return { kind: Problems.FileLocationKind.Absolute };
                case types.FileLocationKind.Relative:
                    return { kind: Problems.FileLocationKind.Relative, prefix: '${workspaceFolder}' };
            }
            return { kind: Problems.FileLocationKind.Auto };
        }
    }
    
    namespace WatchingPattern {
        export function from(value: RegExp | vscode.BackgroundPattern): Problems.WatchingPattern {
            if (value === void 0 || value === null) {
                return undefined;
            }
            if (value instanceof RegExp) {
                return { regexp: value };
            }
            if (!(value.regexp instanceof RegExp)) {
                return undefined;
            }
            let result: Problems.WatchingPattern = {
                regexp: value.regexp
            };
            if (typeof value.file === 'number') {
                result.file = value.file;
            }
            return result;
        }
    }
    
    namespace BackgroundMonitor {
        export function from(value: vscode.BackgroundMonitor): Problems.WatchingMatcher {
            if (value === void 0 || value === null) {
                return undefined;
            }
            let result: Problems.WatchingMatcher = {
                activeOnStart: !!value.activeOnStart,
                beginsPattern: WatchingPattern.from(value.beginsPattern),
                endsPattern: WatchingPattern.from(value.endsPattern)
            };
            return result;
        }
    }
    
    namespace ProblemMatcher {
        export function from(values: (string | vscode.ProblemMatcher)[]): (string | Problems.ProblemMatcher)[] {
            if (values === void 0 || values === null) {
                return undefined;
            }
            let result: (string | Problems.ProblemMatcher)[] = [];
            for (let value of values) {
                let converted = typeof value === 'string' ? value : fromSingle(value);
                if (converted) {
                    result.push(converted);
                }
            }
            return result;
        }
    
        function fromSingle(problemMatcher: vscode.ProblemMatcher): Problems.ProblemMatcher {
            if (problemMatcher === void 0 || problemMatcher === null) {
                return undefined;
            }
    
            let location = FileLocation.from(problemMatcher.fileLocation);
            let result: Problems.ProblemMatcher = {
                owner: typeof problemMatcher.owner === 'string' ? problemMatcher.owner : UUID.generateUuid(),
                applyTo: ApplyTo.from(problemMatcher.applyTo),
                fileLocation: location.kind,
                filePrefix: location.prefix,
                pattern: ProblemPattern.from(problemMatcher.pattern),
                severity: fromDiagnosticSeverity(problemMatcher.severity),
            };
            return result;
        }
    }
    */
    var TaskRevealKind;
    (function (TaskRevealKind) {
        function from(value) {
            if (value === void 0 || value === null) {
                return tasks.RevealKind.Always;
            }
            switch (value) {
                case types.TaskRevealKind.Silent:
                    return tasks.RevealKind.Silent;
                case types.TaskRevealKind.Never:
                    return tasks.RevealKind.Never;
            }
            return tasks.RevealKind.Always;
        }
        TaskRevealKind.from = from;
    })(TaskRevealKind || (TaskRevealKind = {}));
    var TaskPanelKind;
    (function (TaskPanelKind) {
        function from(value) {
            if (value === void 0 || value === null) {
                return tasks.PanelKind.Shared;
            }
            switch (value) {
                case types.TaskPanelKind.Dedicated:
                    return tasks.PanelKind.Dedicated;
                case types.TaskPanelKind.New:
                    return tasks.PanelKind.New;
                default:
                    return tasks.PanelKind.Shared;
            }
        }
        TaskPanelKind.from = from;
    })(TaskPanelKind || (TaskPanelKind = {}));
    var PresentationOptions;
    (function (PresentationOptions) {
        function from(value) {
            if (value === void 0 || value === null) {
                return { reveal: tasks.RevealKind.Always, echo: true, focus: false, panel: tasks.PanelKind.Shared, showReuseMessage: true };
            }
            return {
                reveal: TaskRevealKind.from(value.reveal),
                echo: value.echo === void 0 ? true : !!value.echo,
                focus: !!value.focus,
                panel: TaskPanelKind.from(value.panel),
                showReuseMessage: value.showReuseMessage === void 0 ? true : !!value.showReuseMessage
            };
        }
        PresentationOptions.from = from;
    })(PresentationOptions || (PresentationOptions = {}));
    var Strings;
    (function (Strings) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                var element = value_1[_i];
                if (typeof element !== 'string') {
                    return [];
                }
            }
            return value;
        }
        Strings.from = from;
    })(Strings || (Strings = {}));
    var CommandOptions;
    (function (CommandOptions) {
        function isShellConfiguration(value) {
            return value && typeof value.executable === 'string';
        }
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            var result = {};
            if (typeof value.cwd === 'string') {
                result.cwd = value.cwd;
            }
            if (value.env) {
                result.env = Object.create(null);
                Object.keys(value.env).forEach(function (key) {
                    var envValue = value.env[key];
                    if (typeof envValue === 'string') {
                        result.env[key] = envValue;
                    }
                });
            }
            if (isShellConfiguration(value)) {
                result.shell = ShellConfiguration.from(value);
            }
            return result;
        }
        CommandOptions.from = from;
    })(CommandOptions || (CommandOptions = {}));
    var ShellQuoteOptions;
    (function (ShellQuoteOptions) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return {
                escape: value.escape,
                strong: value.strong,
                weak: value.strong
            };
        }
        ShellQuoteOptions.from = from;
    })(ShellQuoteOptions || (ShellQuoteOptions = {}));
    var ShellConfiguration;
    (function (ShellConfiguration) {
        function from(value) {
            if (value === void 0 || value === null || !value.executable) {
                return undefined;
            }
            var result = {
                executable: value.executable,
                args: Strings.from(value.shellArgs),
                quoting: ShellQuoteOptions.from(value.quotes)
            };
            return result;
        }
        ShellConfiguration.from = from;
    })(ShellConfiguration || (ShellConfiguration = {}));
    var ShellString;
    (function (ShellString) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value.slice(0);
        }
        ShellString.from = from;
    })(ShellString || (ShellString = {}));
    var Tasks;
    (function (Tasks) {
        function from(tasks, rootFolder, extension) {
            if (tasks === void 0 || tasks === null) {
                return [];
            }
            var result = [];
            for (var _i = 0, tasks_1 = tasks; _i < tasks_1.length; _i++) {
                var task = tasks_1[_i];
                var converted = fromSingle(task, rootFolder, extension);
                if (converted) {
                    result.push(converted);
                }
            }
            return result;
        }
        Tasks.from = from;
        function fromSingle(task, rootFolder, extension) {
            if (typeof task.name !== 'string') {
                return undefined;
            }
            var command;
            var execution = task.execution;
            if (execution instanceof types.ProcessExecution) {
                command = getProcessCommand(execution);
            }
            else if (execution instanceof types.ShellExecution) {
                command = getShellCommand(execution);
            }
            else {
                return undefined;
            }
            if (command === void 0) {
                return undefined;
            }
            command.presentation = PresentationOptions.from(task.presentationOptions);
            var taskScope = task.scope;
            var workspaceFolder;
            var scope;
            // For backwards compatibility
            if (taskScope === void 0) {
                scope = tasks.TaskScope.Folder;
                workspaceFolder = rootFolder;
            }
            else if (taskScope === types.TaskScope.Global) {
                scope = tasks.TaskScope.Global;
            }
            else if (taskScope === types.TaskScope.Workspace) {
                scope = tasks.TaskScope.Workspace;
            }
            else {
                scope = tasks.TaskScope.Folder;
                workspaceFolder = taskScope;
            }
            var source = {
                kind: tasks.TaskSourceKind.Extension,
                label: typeof task.source === 'string' ? task.source : extension.name,
                extension: extension.id,
                scope: scope,
                workspaceFolder: undefined
            };
            // We can't transfer a workspace folder object from the extension host to main since they differ
            // in shape and we don't have backwards converting function. So transfer the URI and resolve the
            // workspace folder on the main side.
            source.__workspaceFolder = workspaceFolder ? workspaceFolder.uri : undefined;
            source.__definition = task.definition;
            var label = nls.localize(0, null, source.label, task.name);
            // The definition id will be prefix on the main side since we compute it there.
            var id = "" + extension.id;
            var result = {
                _id: id,
                _source: source,
                _label: label,
                type: task.definition.type,
                defines: undefined,
                name: task.name,
                identifier: label,
                group: task.group ? task.group.id : undefined,
                command: command,
                isBackground: !!task.isBackground,
                problemMatchers: task.problemMatchers.slice(),
                hasDefinedMatchers: task.hasDefinedMatchers
            };
            return result;
        }
        function getProcessCommand(value) {
            if (typeof value.process !== 'string') {
                return undefined;
            }
            var result = {
                name: value.process,
                args: Strings.from(value.args),
                runtime: tasks.RuntimeType.Process,
                suppressTaskName: true,
                presentation: undefined
            };
            if (value.options) {
                result.options = CommandOptions.from(value.options);
            }
            return result;
        }
        function getShellCommand(value) {
            if (value.args) {
                if (typeof value.command !== 'string' && typeof value.command.value !== 'string') {
                    return undefined;
                }
                var result = {
                    name: value.command,
                    args: ShellString.from(value.args),
                    runtime: tasks.RuntimeType.Shell,
                    presentation: undefined
                };
                if (value.options) {
                    result.options = CommandOptions.from(value.options);
                }
                return result;
            }
            else {
                if (typeof value.commandLine !== 'string') {
                    return undefined;
                }
                var result = {
                    name: value.commandLine,
                    runtime: tasks.RuntimeType.Shell,
                    presentation: undefined
                };
                if (value.options) {
                    result.options = CommandOptions.from(value.options);
                }
                return result;
            }
        }
    })(Tasks || (Tasks = {}));
    var TaskDefinitionDTO;
    (function (TaskDefinitionDTO) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        TaskDefinitionDTO.from = from;
        function to(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        TaskDefinitionDTO.to = to;
    })(TaskDefinitionDTO || (TaskDefinitionDTO = {}));
    var TaskPresentationOptionsDTO;
    (function (TaskPresentationOptionsDTO) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        TaskPresentationOptionsDTO.from = from;
        function to(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        TaskPresentationOptionsDTO.to = to;
    })(TaskPresentationOptionsDTO || (TaskPresentationOptionsDTO = {}));
    var ProcessExecutionOptionsDTO;
    (function (ProcessExecutionOptionsDTO) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        ProcessExecutionOptionsDTO.from = from;
        function to(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        ProcessExecutionOptionsDTO.to = to;
    })(ProcessExecutionOptionsDTO || (ProcessExecutionOptionsDTO = {}));
    var ProcessExecutionDTO;
    (function (ProcessExecutionDTO) {
        function is(value) {
            var candidate = value;
            return candidate && !!candidate.process;
        }
        ProcessExecutionDTO.is = is;
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            var result = {
                process: value.process,
                args: value.args
            };
            if (value.options) {
                result.options = ProcessExecutionOptionsDTO.from(value.options);
            }
            return result;
        }
        ProcessExecutionDTO.from = from;
        function to(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return new types.ProcessExecution(value.process, value.args, value.options);
        }
        ProcessExecutionDTO.to = to;
    })(ProcessExecutionDTO || (ProcessExecutionDTO = {}));
    var ShellExecutionOptionsDTO;
    (function (ShellExecutionOptionsDTO) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        ShellExecutionOptionsDTO.from = from;
        function to(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        ShellExecutionOptionsDTO.to = to;
    })(ShellExecutionOptionsDTO || (ShellExecutionOptionsDTO = {}));
    var ShellExecutionDTO;
    (function (ShellExecutionDTO) {
        function is(value) {
            var candidate = value;
            return candidate && (!!candidate.commandLine || !!candidate.command);
        }
        ShellExecutionDTO.is = is;
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            var result = {};
            if (value.commandLine !== void 0) {
                result.commandLine = value.commandLine;
            }
            else {
                result.command = value.command;
                result.args = value.args;
            }
            if (value.options) {
                result.options = ShellExecutionOptionsDTO.from(value.options);
            }
            return result;
        }
        ShellExecutionDTO.from = from;
        function to(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            if (value.commandLine) {
                return new types.ShellExecution(value.commandLine, value.options);
            }
            else {
                return new types.ShellExecution(value.command, value.args ? value.args : [], value.options);
            }
        }
        ShellExecutionDTO.to = to;
    })(ShellExecutionDTO || (ShellExecutionDTO = {}));
    var TaskHandleDTO;
    (function (TaskHandleDTO) {
        function from(value) {
            var folder;
            if (value.scope !== void 0 && typeof value.scope !== 'number') {
                folder = value.scope.uri;
            }
            return {
                id: value._id,
                workspaceFolder: folder
            };
        }
        TaskHandleDTO.from = from;
    })(TaskHandleDTO || (TaskHandleDTO = {}));
    var TaskDTO;
    (function (TaskDTO) {
        function from(value, extension) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            var execution;
            if (value.execution instanceof types.ProcessExecution) {
                execution = ProcessExecutionDTO.from(value.execution);
            }
            else if (value.execution instanceof types.ShellExecution) {
                execution = ShellExecutionDTO.from(value.execution);
            }
            var definition = TaskDefinitionDTO.from(value.definition);
            var scope;
            if (value.scope) {
                if (typeof value.scope === 'number') {
                    scope = value.scope;
                }
                else {
                    scope = value.scope.uri.toJSON();
                }
            }
            if (!definition || !scope) {
                return undefined;
            }
            var group = value.group ? value.group.id : undefined;
            var result = {
                _id: value._id,
                definition: definition,
                name: value.name,
                source: {
                    extensionId: extension.id,
                    label: value.source,
                    scope: scope
                },
                execution: execution,
                isBackground: value.isBackground,
                group: group,
                presentationOptions: TaskPresentationOptionsDTO.from(value.presentationOptions),
                problemMatchers: value.problemMatchers,
                hasDefinedMatchers: value.hasDefinedMatchers
            };
            return result;
        }
        TaskDTO.from = from;
        function to(value, workspace) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            var execution;
            if (ProcessExecutionDTO.is(value.execution)) {
                execution = ProcessExecutionDTO.to(value.execution);
            }
            else if (ShellExecutionDTO.is(value.execution)) {
                execution = ShellExecutionDTO.to(value.execution);
            }
            var definition = TaskDefinitionDTO.to(value.definition);
            var scope;
            if (value.source) {
                if (value.source.scope !== void 0) {
                    if (typeof value.source.scope === 'number') {
                        scope = value.source.scope;
                    }
                    else {
                        scope = workspace.resolveWorkspaceFolder(uri_1.default.revive(value.source.scope));
                    }
                }
                else {
                    scope = types.TaskScope.Workspace;
                }
            }
            if (!definition || !scope) {
                return undefined;
            }
            var result = new types.Task(definition, scope, value.name, value.source.label, execution, value.problemMatchers);
            if (value.isBackground !== void 0) {
                result.isBackground = value.isBackground;
            }
            if (value.group !== void 0) {
                result.group = types.TaskGroup.from(value.group);
            }
            if (value.presentationOptions) {
                result.presentationOptions = TaskPresentationOptionsDTO.to(value.presentationOptions);
            }
            if (value._id) {
                result._id = value._id;
            }
            return result;
        }
        TaskDTO.to = to;
    })(TaskDTO || (TaskDTO = {}));
    var TaskFilterDTO;
    (function (TaskFilterDTO) {
        function from(value) {
            return value;
        }
        TaskFilterDTO.from = from;
        function to(value) {
            if (!value) {
                return undefined;
            }
            return Objects.assign(Object.create(null), value);
        }
        TaskFilterDTO.to = to;
    })(TaskFilterDTO || (TaskFilterDTO = {}));
    var TaskExecutionImpl = /** @class */ (function () {
        function TaskExecutionImpl(_tasks, _id, _task) {
            this._tasks = _tasks;
            this._id = _id;
            this._task = _task;
        }
        Object.defineProperty(TaskExecutionImpl.prototype, "task", {
            get: function () {
                return this._task;
            },
            enumerable: true,
            configurable: true
        });
        TaskExecutionImpl.prototype.terminate = function () {
            this._tasks.terminateTask(this);
        };
        TaskExecutionImpl.prototype.fireDidStartProcess = function (value) {
        };
        TaskExecutionImpl.prototype.fireDidEndProcess = function (value) {
        };
        return TaskExecutionImpl;
    }());
    var TaskExecutionDTO;
    (function (TaskExecutionDTO) {
        function to(value, tasks) {
            return new TaskExecutionImpl(tasks, value.id, TaskDTO.to(value.task, tasks.extHostWorkspace));
        }
        TaskExecutionDTO.to = to;
        function from(value) {
            return {
                id: value._id,
                task: undefined
            };
        }
        TaskExecutionDTO.from = from;
    })(TaskExecutionDTO || (TaskExecutionDTO = {}));
    var ExtHostTask = /** @class */ (function () {
        function ExtHostTask(mainContext, workspaceService, editorService, configurationService) {
            this._onDidExecuteTask = new event_1.Emitter();
            this._onDidTerminateTask = new event_1.Emitter();
            this._onDidTaskProcessStarted = new event_1.Emitter();
            this._onDidTaskProcessEnded = new event_1.Emitter();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTask);
            this._workspaceService = workspaceService;
            this._editorService = editorService;
            this._configurationService = configurationService;
            this._handleCounter = 0;
            this._handlers = new Map();
            this._taskExecutions = new Map();
        }
        Object.defineProperty(ExtHostTask.prototype, "extHostWorkspace", {
            get: function () {
                return this._workspaceService;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTask.prototype.registerTaskProvider = function (extension, provider) {
            var _this = this;
            if (!provider) {
                return new types.Disposable(function () { });
            }
            var handle = this.nextHandle();
            this._handlers.set(handle, { provider: provider, extension: extension });
            this._proxy.$registerTaskProvider(handle);
            return new types.Disposable(function () {
                _this._handlers.delete(handle);
                _this._proxy.$unregisterTaskProvider(handle);
            });
        };
        ExtHostTask.prototype.registerTaskSystem = function (scheme, info) {
            this._proxy.$registerTaskSystem(scheme, info);
        };
        ExtHostTask.prototype.fetchTasks = function (filter) {
            var _this = this;
            return this._proxy.$fetchTasks(TaskFilterDTO.from(filter)).then(function (values) {
                var result = [];
                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                    var value = values_1[_i];
                    var task = TaskDTO.to(value, _this._workspaceService);
                    if (task) {
                        result.push(task);
                    }
                }
                return result;
            });
        };
        ExtHostTask.prototype.executeTask = function (extension, task) {
            var _this = this;
            var tTask = task;
            // We have a preserved ID. So the task didn't change.
            if (tTask._id !== void 0) {
                return this._proxy.$executeTask(TaskHandleDTO.from(tTask)).then(function (value) { return _this.getTaskExecution(value, task); });
            }
            else {
                var dto = TaskDTO.from(task, extension);
                if (dto === void 0) {
                    // {{ SQL CARBON EDIT }} - Add type assertion to fix build break
                    return Promise.reject(new Error('Task is not valid'));
                }
                return this._proxy.$executeTask(dto).then(function (value) { return _this.getTaskExecution(value, task); });
            }
        };
        Object.defineProperty(ExtHostTask.prototype, "taskExecutions", {
            get: function () {
                var result = [];
                this._taskExecutions.forEach(function (value) { return result.push(value); });
                return result;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTask.prototype.terminateTask = function (execution) {
            if (!(execution instanceof TaskExecutionImpl)) {
                throw new Error('No valid task execution provided');
            }
            return this._proxy.$terminateTask(execution._id);
        };
        Object.defineProperty(ExtHostTask.prototype, "onDidStartTask", {
            get: function () {
                return this._onDidExecuteTask.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTask.prototype.$onDidStartTask = function (execution) {
            this._onDidExecuteTask.fire({
                execution: this.getTaskExecution(execution)
            });
        };
        Object.defineProperty(ExtHostTask.prototype, "onDidEndTask", {
            get: function () {
                return this._onDidTerminateTask.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTask.prototype.$OnDidEndTask = function (execution) {
            var _execution = this.getTaskExecution(execution);
            this._taskExecutions.delete(execution.id);
            this._onDidTerminateTask.fire({
                execution: _execution
            });
        };
        Object.defineProperty(ExtHostTask.prototype, "onDidStartTaskProcess", {
            get: function () {
                return this._onDidTaskProcessStarted.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTask.prototype.$onDidStartTaskProcess = function (value) {
            var execution = this.getTaskExecution(value.id);
            if (execution) {
                this._onDidTaskProcessStarted.fire({
                    execution: execution,
                    processId: value.processId
                });
            }
        };
        Object.defineProperty(ExtHostTask.prototype, "onDidEndTaskProcess", {
            get: function () {
                return this._onDidTaskProcessEnded.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTask.prototype.$onDidEndTaskProcess = function (value) {
            var execution = this.getTaskExecution(value.id);
            if (execution) {
                this._onDidTaskProcessEnded.fire({
                    execution: execution,
                    exitCode: value.exitCode
                });
            }
        };
        ExtHostTask.prototype.$provideTasks = function (handle, validTypes) {
            var _this = this;
            var handler = this._handlers.get(handle);
            if (!handler) {
                return winjs_base_1.TPromise.wrapError(new Error('no handler found'));
            }
            return async_1.asWinJsPromise(function (token) { return handler.provider.provideTasks(token); }).then(function (value) {
                var sanitized = [];
                for (var _i = 0, value_2 = value; _i < value_2.length; _i++) {
                    var task = value_2[_i];
                    if (task.definition && validTypes[task.definition.type] === true) {
                        sanitized.push(task);
                    }
                    else {
                        sanitized.push(task);
                        console.warn("The task [" + task.source + ", " + task.name + "] uses an undefined task type. The task will be ignored in the future.");
                    }
                }
                var workspaceFolders = _this._workspaceService.getWorkspaceFolders();
                return {
                    tasks: Tasks.from(sanitized, workspaceFolders && workspaceFolders.length > 0 ? workspaceFolders[0] : undefined, handler.extension),
                    extension: handler.extension
                };
            });
        };
        // {{SQL CARBON EDIT}} disable debug related method
        ExtHostTask.prototype.$resolveVariables = function (uriComponents, variables) {
            // let uri: URI = URI.revive(uriComponents);
            // let result: { [key: string]: string; } = Object.create(null);
            // let workspaceFolder = this._workspaceService.resolveWorkspaceFolder(uri);
            // let resolver = new ExtHostVariableResolverService(this._workspaceService, this._editorService, this._configurationService);
            // let ws: IWorkspaceFolder = {
            // 	uri: workspaceFolder.uri,
            // 	name: workspaceFolder.name,
            // 	index: workspaceFolder.index,
            // 	toResource: () => {
            // 		throw new Error('Not implemented');
            // 	}
            // };
            // for (let variable of variables) {
            // 	result[variable] = resolver.resolve(ws, variable);
            // }
            // return result;
            return undefined;
        };
        ExtHostTask.prototype.nextHandle = function () {
            return this._handleCounter++;
        };
        ExtHostTask.prototype.getTaskExecution = function (execution, task) {
            if (typeof execution === 'string') {
                return this._taskExecutions.get(execution);
            }
            var result = this._taskExecutions.get(execution.id);
            if (result) {
                return result;
            }
            result = new TaskExecutionImpl(this, execution.id, task ? task : TaskDTO.to(execution.task, this._workspaceService));
            this._taskExecutions.set(execution.id, result);
            return result;
        };
        return ExtHostTask;
    }());
    exports.ExtHostTask = ExtHostTask;
});



















define(__m[209/*vs/workbench/api/node/extHostTerminalService*/], __M([0/*require*/,1/*exports*/,37/*os*/,10/*vs/base/common/platform*/,164/*vs/workbench/parts/terminal/node/terminalEnvironment*/,3/*vs/base/common/event*/,6/*vs/workbench/api/node/extHost.protocol*/,163/*vs/workbench/parts/terminal/common/terminal*/,165/*vs/workbench/parts/terminal/node/terminalProcess*/]), function (require, exports, os, platform, terminalEnvironment, event_1, extHost_protocol_1, terminal_1, terminalProcess_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RENDERER_NO_PROCESS_ID = -1;
    var BaseExtHostTerminal = /** @class */ (function () {
        function BaseExtHostTerminal(_proxy, id) {
            var _this = this;
            this._proxy = _proxy;
            this._disposed = false;
            this._queuedRequests = [];
            this._idPromise = new Promise(function (c) {
                if (id !== undefined) {
                    _this._id = id;
                    c(id);
                }
                else {
                    _this._idPromiseComplete = c;
                }
            });
        }
        BaseExtHostTerminal.prototype.dispose = function () {
            if (!this._disposed) {
                this._disposed = true;
                this._queueApiRequest(this._proxy.$dispose, []);
            }
        };
        BaseExtHostTerminal.prototype._checkDisposed = function () {
            if (this._disposed) {
                throw new Error('Terminal has already been disposed');
            }
        };
        BaseExtHostTerminal.prototype._queueApiRequest = function (callback, args) {
            var request = new ApiRequest(callback, args);
            if (!this._id) {
                this._queuedRequests.push(request);
                return;
            }
            request.run(this._proxy, this._id);
        };
        BaseExtHostTerminal.prototype._runQueuedRequests = function (id) {
            var _this = this;
            this._id = id;
            this._idPromiseComplete(id);
            this._queuedRequests.forEach(function (r) {
                r.run(_this._proxy, _this._id);
            });
            this._queuedRequests.length = 0;
        };
        return BaseExtHostTerminal;
    }());
    exports.BaseExtHostTerminal = BaseExtHostTerminal;
    var ExtHostTerminal = /** @class */ (function (_super) {
        __extends(ExtHostTerminal, _super);
        function ExtHostTerminal(proxy, _name, id, pid) {
            var _this = _super.call(this, proxy, id) || this;
            _this._name = _name;
            _this._onData = new event_1.Emitter();
            _this._pidPromise = new Promise(function (c) {
                if (pid === RENDERER_NO_PROCESS_ID) {
                    c(undefined);
                }
                else {
                    _this._pidPromiseComplete = c;
                }
            });
            return _this;
        }
        Object.defineProperty(ExtHostTerminal.prototype, "onDidWriteData", {
            get: function () {
                // Tell the main side to start sending data if it's not already
                this._proxy.$registerOnDataListener(this._id);
                return this._onData && this._onData.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTerminal.prototype.create = function (shellPath, shellArgs, cwd, env, waitOnExit) {
            var _this = this;
            this._proxy.$createTerminal(this._name, shellPath, shellArgs, cwd, env, waitOnExit).then(function (id) {
                _this._runQueuedRequests(id);
            });
        };
        Object.defineProperty(ExtHostTerminal.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminal.prototype, "processId", {
            get: function () {
                return this._pidPromise;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTerminal.prototype.sendText = function (text, addNewLine) {
            if (addNewLine === void 0) { addNewLine = true; }
            this._checkDisposed();
            this._queueApiRequest(this._proxy.$sendText, [text, addNewLine]);
        };
        ExtHostTerminal.prototype.show = function (preserveFocus) {
            this._checkDisposed();
            this._queueApiRequest(this._proxy.$show, [preserveFocus]);
        };
        ExtHostTerminal.prototype.hide = function () {
            this._checkDisposed();
            this._queueApiRequest(this._proxy.$hide, []);
        };
        ExtHostTerminal.prototype._setProcessId = function (processId) {
            // The event may fire 2 times when the panel is restored
            if (this._pidPromiseComplete) {
                this._pidPromiseComplete(processId);
                this._pidPromiseComplete = null;
            }
        };
        ExtHostTerminal.prototype._fireOnData = function (data) {
            this._onData.fire(data);
        };
        return ExtHostTerminal;
    }(BaseExtHostTerminal));
    exports.ExtHostTerminal = ExtHostTerminal;
    var ExtHostTerminalRenderer = /** @class */ (function (_super) {
        __extends(ExtHostTerminalRenderer, _super);
        function ExtHostTerminalRenderer(proxy, _name, _terminal) {
            var _this = _super.call(this, proxy) || this;
            _this._name = _name;
            _this._terminal = _terminal;
            _this._onInput = new event_1.Emitter();
            _this._onDidChangeMaximumDimensions = new event_1.Emitter();
            _this._proxy.$createTerminalRenderer(_this._name).then(function (id) {
                _this._runQueuedRequests(id);
                _this._terminal._runQueuedRequests(id);
            });
            return _this;
        }
        Object.defineProperty(ExtHostTerminalRenderer.prototype, "name", {
            get: function () { return this._name; },
            set: function (newName) {
                this._name = newName;
                this._checkDisposed();
                this._queueApiRequest(this._proxy.$terminalRendererSetName, [this._name]);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalRenderer.prototype, "onDidAcceptInput", {
            get: function () {
                this._checkDisposed();
                this._queueApiRequest(this._proxy.$terminalRendererRegisterOnInputListener, [this._id]);
                // Tell the main side to start sending data if it's not already
                // this._proxy.$terminalRendererRegisterOnDataListener(this._id);
                return this._onInput && this._onInput.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalRenderer.prototype, "dimensions", {
            get: function () { return this._dimensions; },
            set: function (dimensions) {
                this._checkDisposed();
                this._dimensions = dimensions;
                this._queueApiRequest(this._proxy.$terminalRendererSetDimensions, [dimensions]);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalRenderer.prototype, "maximumDimensions", {
            get: function () {
                if (!this._maximumDimensions) {
                    return undefined;
                }
                return {
                    rows: this._maximumDimensions.rows,
                    columns: this._maximumDimensions.columns
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalRenderer.prototype, "onDidChangeMaximumDimensions", {
            get: function () {
                return this._onDidChangeMaximumDimensions && this._onDidChangeMaximumDimensions.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalRenderer.prototype, "terminal", {
            get: function () {
                return this._terminal;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTerminalRenderer.prototype.write = function (data) {
            this._checkDisposed();
            this._queueApiRequest(this._proxy.$terminalRendererWrite, [data]);
        };
        ExtHostTerminalRenderer.prototype._fireOnInput = function (data) {
            this._onInput.fire(data);
        };
        ExtHostTerminalRenderer.prototype._setMaximumDimensions = function (columns, rows) {
            if (this._maximumDimensions && this._maximumDimensions.columns === columns && this._maximumDimensions.rows === rows) {
                return;
            }
            this._maximumDimensions = { columns: columns, rows: rows };
            this._onDidChangeMaximumDimensions.fire(this.maximumDimensions);
        };
        return ExtHostTerminalRenderer;
    }(BaseExtHostTerminal));
    exports.ExtHostTerminalRenderer = ExtHostTerminalRenderer;
    var ExtHostTerminalService = /** @class */ (function () {
        function ExtHostTerminalService(mainContext, _extHostConfiguration, _logService) {
            this._extHostConfiguration = _extHostConfiguration;
            this._logService = _logService;
            this._terminals = [];
            this._terminalProcesses = {};
            this._terminalRenderers = [];
            this._onDidCloseTerminal = new event_1.Emitter();
            this._onDidOpenTerminal = new event_1.Emitter();
            this._onDidChangeActiveTerminal = new event_1.Emitter();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTerminalService);
        }
        Object.defineProperty(ExtHostTerminalService.prototype, "activeTerminal", {
            get: function () { return this._activeTerminal; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalService.prototype, "terminals", {
            get: function () { return this._terminals; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalService.prototype, "onDidCloseTerminal", {
            get: function () { return this._onDidCloseTerminal && this._onDidCloseTerminal.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalService.prototype, "onDidOpenTerminal", {
            get: function () { return this._onDidOpenTerminal && this._onDidOpenTerminal.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalService.prototype, "onDidChangeActiveTerminal", {
            get: function () { return this._onDidChangeActiveTerminal && this._onDidChangeActiveTerminal.event; },
            enumerable: true,
            configurable: true
        });
        ExtHostTerminalService.prototype.createTerminal = function (name, shellPath, shellArgs) {
            var terminal = new ExtHostTerminal(this._proxy, name);
            terminal.create(shellPath, shellArgs);
            this._terminals.push(terminal);
            return terminal;
        };
        ExtHostTerminalService.prototype.createTerminalFromOptions = function (options) {
            var terminal = new ExtHostTerminal(this._proxy, options.name);
            terminal.create(options.shellPath, options.shellArgs, options.cwd, options.env /*, options.waitOnExit*/);
            this._terminals.push(terminal);
            return terminal;
        };
        ExtHostTerminalService.prototype.createTerminalRenderer = function (name) {
            var terminal = new ExtHostTerminal(this._proxy, name);
            terminal._setProcessId(undefined);
            this._terminals.push(terminal);
            var renderer = new ExtHostTerminalRenderer(this._proxy, name, terminal);
            this._terminalRenderers.push(renderer);
            return renderer;
        };
        ExtHostTerminalService.prototype.$acceptActiveTerminalChanged = function (id) {
            var _this = this;
            var original = this._activeTerminal;
            if (id === null) {
                this._activeTerminal = undefined;
                if (original !== this._activeTerminal) {
                    this._onDidChangeActiveTerminal.fire(this._activeTerminal);
                }
            }
            this._performTerminalIdAction(id, function (terminal) {
                if (terminal) {
                    _this._activeTerminal = terminal;
                    if (original !== _this._activeTerminal) {
                        _this._onDidChangeActiveTerminal.fire(_this._activeTerminal);
                    }
                }
            });
        };
        ExtHostTerminalService.prototype.$acceptTerminalProcessData = function (id, data) {
            // TODO: Queue requests, currently the first 100ms of data may get missed
            var terminal = this._getTerminalById(id);
            if (terminal) {
                terminal._fireOnData(data);
            }
        };
        ExtHostTerminalService.prototype.$acceptTerminalRendererDimensions = function (id, cols, rows) {
            var renderer = this._getTerminalRendererById(id);
            if (renderer) {
                renderer._setMaximumDimensions(cols, rows);
            }
        };
        ExtHostTerminalService.prototype.$acceptTerminalRendererInput = function (id, data) {
            var renderer = this._getTerminalRendererById(id);
            if (renderer) {
                renderer._fireOnInput(data);
            }
        };
        ExtHostTerminalService.prototype.$acceptTerminalClosed = function (id) {
            var index = this._getTerminalObjectIndexById(this.terminals, id);
            if (index === null) {
                return;
            }
            var terminal = this._terminals.splice(index, 1)[0];
            this._onDidCloseTerminal.fire(terminal);
        };
        ExtHostTerminalService.prototype.$acceptTerminalOpened = function (id, name) {
            var index = this._getTerminalObjectIndexById(this._terminals, id);
            if (index !== null) {
                // The terminal has already been created (via createTerminal*), only fire the event
                this._onDidOpenTerminal.fire(this.terminals[index]);
                return;
            }
            var renderer = this._getTerminalRendererById(id);
            var terminal = new ExtHostTerminal(this._proxy, name, id, renderer ? RENDERER_NO_PROCESS_ID : undefined);
            this._terminals.push(terminal);
            this._onDidOpenTerminal.fire(terminal);
        };
        ExtHostTerminalService.prototype.$acceptTerminalProcessId = function (id, processId) {
            this._performTerminalIdAction(id, function (terminal) { return terminal._setProcessId(processId); });
        };
        ExtHostTerminalService.prototype._performTerminalIdAction = function (id, callback) {
            var _this = this;
            var terminal = this._getTerminalById(id);
            if (terminal) {
                callback(terminal);
            }
            else {
                // Retry one more time in case the terminal has not yet been initialized.
                setTimeout(function () {
                    terminal = _this._getTerminalById(id);
                    if (terminal) {
                        callback(terminal);
                    }
                }, terminal_1.EXT_HOST_CREATION_DELAY);
            }
        };
        ExtHostTerminalService.prototype.$createProcess = function (id, shellLaunchConfig, cols, rows) {
            // TODO: This function duplicates a lot of TerminalProcessManager.createProcess, ideally
            // they would be merged into a single implementation.
            var _this = this;
            var terminalConfig = this._extHostConfiguration.getConfiguration('terminal.integrated');
            if (!shellLaunchConfig.executable) {
                // TODO: This duplicates some of TerminalConfigHelper.mergeDefaultShellPathAndArgs and should be merged
                // this._configHelper.mergeDefaultShellPathAndArgs(shellLaunchConfig);
                var platformKey = platform.isWindows ? 'windows' : platform.isMacintosh ? 'osx' : 'linux';
                var shellConfigValue = terminalConfig.get("shell." + platformKey);
                var shellArgsConfigValue = terminalConfig.get("shellArgs." + platformKey);
                shellLaunchConfig.executable = shellConfigValue;
                shellLaunchConfig.args = shellArgsConfigValue;
            }
            // TODO: Base the cwd on the last active workspace root
            // const lastActiveWorkspaceRootUri = this._historyService.getLastActiveWorkspaceRoot('file');
            // this.initialCwd = terminalEnvironment.getCwd(shellLaunchConfig, lastActiveWorkspaceRootUri, this._configHelper);
            var initialCwd = os.homedir();
            // TODO: Pull in and resolve config settings
            // // Resolve env vars from config and shell
            // const lastActiveWorkspaceRoot = this._workspaceContextService.getWorkspaceFolder(lastActiveWorkspaceRootUri);
            // const platformKey = platform.isWindows ? 'windows' : (platform.isMacintosh ? 'osx' : 'linux');
            // const envFromConfig = terminalEnvironment.resolveConfigurationVariables(this._configurationResolverService, { ...this._configHelper.config.env[platformKey] }, lastActiveWorkspaceRoot);
            // const envFromShell = terminalEnvironment.resolveConfigurationVariables(this._configurationResolverService, { ...shellLaunchConfig.env }, lastActiveWorkspaceRoot);
            // Merge process env with the env from config
            var env = __assign({}, process.env);
            // terminalEnvironment.mergeEnvironments(env, envFromConfig);
            terminalEnvironment.mergeEnvironments(env, shellLaunchConfig.env);
            // Continue env initialization, merging in the env from the launch
            // config and adding keys that are needed to create the process
            var locale = terminalConfig.get('setLocaleVariables') ? platform.locale : undefined;
            terminalEnvironment.addTerminalEnvironmentKeys(env, locale);
            // Fork the process and listen for messages
            this._logService.debug("Terminal process launching on ext host", shellLaunchConfig, initialCwd, cols, rows, env);
            this._terminalProcesses[id] = new terminalProcess_1.TerminalProcess(shellLaunchConfig, initialCwd, cols, rows, env);
            this._terminalProcesses[id].onProcessIdReady(function (pid) { return _this._proxy.$sendProcessPid(id, pid); });
            this._terminalProcesses[id].onProcessTitleChanged(function (title) { return _this._proxy.$sendProcessTitle(id, title); });
            this._terminalProcesses[id].onProcessData(function (data) { return _this._proxy.$sendProcessData(id, data); });
            this._terminalProcesses[id].onProcessExit(function (exitCode) { return _this._onProcessExit(id, exitCode); });
        };
        ExtHostTerminalService.prototype.$acceptProcessInput = function (id, data) {
            this._terminalProcesses[id].input(data);
        };
        ExtHostTerminalService.prototype.$acceptProcessResize = function (id, cols, rows) {
            try {
                this._terminalProcesses[id].resize(cols, rows);
            }
            catch (error) {
                // We tried to write to a closed pipe / channel.
                if (error.code !== 'EPIPE' && error.code !== 'ERR_IPC_CHANNEL_CLOSED') {
                    throw (error);
                }
            }
        };
        ExtHostTerminalService.prototype.$acceptProcessShutdown = function (id) {
            this._terminalProcesses[id].shutdown();
        };
        ExtHostTerminalService.prototype._onProcessExit = function (id, exitCode) {
            // Remove listeners
            this._terminalProcesses[id].dispose();
            // Remove process reference
            delete this._terminalProcesses[id];
            // Send exit event to main side
            this._proxy.$sendProcessExit(id, exitCode);
        };
        ExtHostTerminalService.prototype._getTerminalByIdEventually = function (id, retries) {
            var _this = this;
            if (retries === void 0) { retries = 5; }
            return new Promise(function (c) {
                if (retries === 0) {
                    c(undefined);
                    return;
                }
                var terminal = _this._getTerminalById(id);
                if (terminal) {
                    c(terminal);
                }
                else {
                    // This should only be needed immediately after createTerminalRenderer is called as
                    // the ExtHostTerminal has not yet been iniitalized
                    setTimeout(function () {
                        c(_this._getTerminalByIdEventually(id, retries - 1));
                    }, 200);
                }
            });
        };
        ExtHostTerminalService.prototype._getTerminalById = function (id) {
            return this._getTerminalObjectById(this._terminals, id);
        };
        ExtHostTerminalService.prototype._getTerminalRendererById = function (id) {
            return this._getTerminalObjectById(this._terminalRenderers, id);
        };
        ExtHostTerminalService.prototype._getTerminalObjectById = function (array, id) {
            var index = this._getTerminalObjectIndexById(array, id);
            return index !== null ? array[index] : null;
        };
        ExtHostTerminalService.prototype._getTerminalObjectIndexById = function (array, id) {
            var index = null;
            array.some(function (item, i) {
                var thisId = item._id;
                if (thisId === id) {
                    index = i;
                    return true;
                }
                return false;
            });
            return index;
        };
        return ExtHostTerminalService;
    }());
    exports.ExtHostTerminalService = ExtHostTerminalService;
    var ApiRequest = /** @class */ (function () {
        function ApiRequest(callback, args) {
            this._callback = callback;
            this._args = args;
        }
        ApiRequest.prototype.run = function (proxy, id) {
            this._callback.apply(proxy, [id].concat(this._args));
        };
        return ApiRequest;
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[210/*vs/workbench/api/node/extHostUrls*/], __M([0/*require*/,1/*exports*/,6/*vs/workbench/api/node/extHost.protocol*/,4/*vs/base/common/uri*/,2/*vs/base/common/winjs.base*/,9/*vs/base/common/lifecycle*/,12/*vs/base/common/async*/,14/*vs/base/common/errors*/]), function (require, exports, extHost_protocol_1, uri_1, winjs_base_1, lifecycle_1, async_1, errors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostUrls = /** @class */ (function () {
        function ExtHostUrls(mainContext) {
            this.handles = new Set();
            this.handlers = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadUrls);
        }
        ExtHostUrls.prototype.registerUriHandler = function (extensionId, handler) {
            var _this = this;
            if (this.handles.has(extensionId)) {
                throw new Error("Protocol handler already registered for extension " + extensionId);
            }
            var handle = ExtHostUrls.HandlePool++;
            this.handles.add(extensionId);
            this.handlers.set(handle, handler);
            this._proxy.$registerUriHandler(handle, extensionId);
            return lifecycle_1.toDisposable(function () {
                _this.handles.delete(extensionId);
                _this.handlers.delete(handle);
                _this._proxy.$unregisterUriHandler(handle);
            });
        };
        ExtHostUrls.prototype.$handleExternalUri = function (handle, uri) {
            var handler = this.handlers.get(handle);
            if (!handler) {
                return winjs_base_1.TPromise.as(null);
            }
            async_1.asWinJsPromise(function (_) { return handler.handleUri(uri_1.default.revive(uri)); })
                .done(null, errors_1.onUnexpectedError);
            return winjs_base_1.TPromise.as(null);
        };
        ExtHostUrls.HandlePool = 0;
        return ExtHostUrls;
    }());
    exports.ExtHostUrls = ExtHostUrls;
});









define(__m[211/*vs/workbench/api/node/extHostWindow*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,6/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, event_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostWindow = /** @class */ (function () {
        function ExtHostWindow(mainContext) {
            var _this = this;
            this._onDidChangeWindowState = new event_1.Emitter();
            this.onDidChangeWindowState = this._onDidChangeWindowState.event;
            this._state = ExtHostWindow.InitialState;
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadWindow);
            this._proxy.$getWindowVisibility().then(function (isFocused) { return _this.$onDidChangeWindowFocus(isFocused); });
        }
        Object.defineProperty(ExtHostWindow.prototype, "state", {
            get: function () { return this._state; },
            enumerable: true,
            configurable: true
        });
        ExtHostWindow.prototype.$onDidChangeWindowFocus = function (focused) {
            if (focused === this._state.focused) {
                return;
            }
            this._state = __assign({}, this._state, { focused: focused });
            this._onDidChangeWindowState.fire(this._state);
        };
        ExtHostWindow.InitialState = {
            focused: true
        };
        return ExtHostWindow;
    }());
    exports.ExtHostWindow = ExtHostWindow;
});











define(__m[212/*vs/workbench/api/node/extHostWorkspace*/], __M([0/*require*/,1/*exports*/,22/*path*/,13/*vs/base/common/arrays*/,3/*vs/base/common/event*/,21/*vs/base/common/map*/,16/*vs/base/common/paths*/,10/*vs/base/common/platform*/,26/*vs/base/common/resources*/,8/*vs/base/common/strings*/,4/*vs/base/common/uri*/,2/*vs/base/common/winjs.base*/,112/*vs/nls!vs/workbench/api/node/extHostWorkspace*/,134/*vs/platform/notification/common/notification*/,72/*vs/platform/workspace/common/workspace*/,5/*vs/workbench/api/node/extHostTypes*/,6/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, path_1, arrays_1, event_1, map_1, paths_1, platform_1, resources_1, strings_1, uri_1, winjs_base_1, nls_1, notification_1, workspace_1, extHostTypes_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function isFolderEqual(folderA, folderB) {
        return resources_1.isEqual(folderA, folderB, !platform_1.isLinux);
    }
    function compareWorkspaceFolderByUri(a, b) {
        return isFolderEqual(a.uri, b.uri) ? 0 : strings_1.compare(a.uri.toString(), b.uri.toString());
    }
    function compareWorkspaceFolderByUriAndNameAndIndex(a, b) {
        if (a.index !== b.index) {
            return a.index < b.index ? -1 : 1;
        }
        return isFolderEqual(a.uri, b.uri) ? strings_1.compare(a.name, b.name) : strings_1.compare(a.uri.toString(), b.uri.toString());
    }
    function delta(oldFolders, newFolders, compare) {
        var oldSortedFolders = oldFolders.slice(0).sort(compare);
        var newSortedFolders = newFolders.slice(0).sort(compare);
        return arrays_1.delta(oldSortedFolders, newSortedFolders, compare);
    }
    var ExtHostWorkspaceImpl = /** @class */ (function (_super) {
        __extends(ExtHostWorkspaceImpl, _super);
        function ExtHostWorkspaceImpl(id, name, folders) {
            var _this = _super.call(this, id, name, folders.map(function (f) { return new workspace_1.WorkspaceFolder(f); })) || this;
            _this._workspaceFolders = [];
            _this._structure = map_1.TernarySearchTree.forPaths();
            // setup the workspace folder data structure
            folders.forEach(function (folder) {
                _this._workspaceFolders.push(folder);
                _this._structure.set(folder.uri.toString(), folder);
            });
            return _this;
        }
        ExtHostWorkspaceImpl.toExtHostWorkspace = function (data, previousConfirmedWorkspace, previousUnconfirmedWorkspace) {
            if (!data) {
                return { workspace: null, added: [], removed: [] };
            }
            var id = data.id, name = data.name, folders = data.folders;
            var newWorkspaceFolders = [];
            // If we have an existing workspace, we try to find the folders that match our
            // data and update their properties. It could be that an extension stored them
            // for later use and we want to keep them "live" if they are still present.
            var oldWorkspace = previousConfirmedWorkspace;
            if (oldWorkspace) {
                folders.forEach(function (folderData, index) {
                    var folderUri = uri_1.default.revive(folderData.uri);
                    var existingFolder = ExtHostWorkspaceImpl._findFolder(previousUnconfirmedWorkspace || previousConfirmedWorkspace, folderUri);
                    if (existingFolder) {
                        existingFolder.name = folderData.name;
                        existingFolder.index = folderData.index;
                        newWorkspaceFolders.push(existingFolder);
                    }
                    else {
                        newWorkspaceFolders.push({ uri: folderUri, name: folderData.name, index: index });
                    }
                });
            }
            else {
                newWorkspaceFolders.push.apply(newWorkspaceFolders, folders.map(function (_a) {
                    var uri = _a.uri, name = _a.name, index = _a.index;
                    return ({ uri: uri_1.default.revive(uri), name: name, index: index });
                }));
            }
            // make sure to restore sort order based on index
            newWorkspaceFolders.sort(function (f1, f2) { return f1.index < f2.index ? -1 : 1; });
            var workspace = new ExtHostWorkspaceImpl(id, name, newWorkspaceFolders);
            var _a = delta(oldWorkspace ? oldWorkspace.workspaceFolders : [], workspace.workspaceFolders, compareWorkspaceFolderByUri), added = _a.added, removed = _a.removed;
            return { workspace: workspace, added: added, removed: removed };
        };
        ExtHostWorkspaceImpl._findFolder = function (workspace, folderUriToFind) {
            for (var i = 0; i < workspace.folders.length; i++) {
                var folder = workspace.workspaceFolders[i];
                if (isFolderEqual(folder.uri, folderUriToFind)) {
                    return folder;
                }
            }
            return undefined;
        };
        Object.defineProperty(ExtHostWorkspaceImpl.prototype, "workspaceFolders", {
            get: function () {
                return this._workspaceFolders.slice(0);
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWorkspaceImpl.prototype.getWorkspaceFolder = function (uri, resolveParent) {
            if (resolveParent && this._structure.get(uri.toString())) {
                // `uri` is a workspace folder so we check for its parent
                uri = uri.with({ path: path_1.posix.dirname(uri.path) });
            }
            return this._structure.findSubstr(uri.toString());
        };
        ExtHostWorkspaceImpl.prototype.resolveWorkspaceFolder = function (uri) {
            return this._structure.get(uri.toString());
        };
        return ExtHostWorkspaceImpl;
    }(workspace_1.Workspace));
    var ExtHostWorkspace = /** @class */ (function () {
        function ExtHostWorkspace(mainContext, data, _logService) {
            this._logService = _logService;
            this._onDidChangeWorkspace = new event_1.Emitter();
            this.onDidChangeWorkspace = this._onDidChangeWorkspace.event;
            this._activeSearchCallbacks = [];
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadWorkspace);
            this._messageService = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadMessageService);
            this._confirmedWorkspace = ExtHostWorkspaceImpl.toExtHostWorkspace(data).workspace;
        }
        Object.defineProperty(ExtHostWorkspace.prototype, "workspace", {
            // --- workspace ---
            get: function () {
                return this._actualWorkspace;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWorkspace.prototype, "_actualWorkspace", {
            get: function () {
                return this._unconfirmedWorkspace || this._confirmedWorkspace;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWorkspace.prototype.getWorkspaceFolders = function () {
            if (!this._actualWorkspace) {
                return undefined;
            }
            return this._actualWorkspace.workspaceFolders.slice(0);
        };
        ExtHostWorkspace.prototype.updateWorkspaceFolders = function (extension, index, deleteCount) {
            var _this = this;
            var workspaceFoldersToAdd = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                workspaceFoldersToAdd[_i - 3] = arguments[_i];
            }
            var validatedDistinctWorkspaceFoldersToAdd = [];
            if (Array.isArray(workspaceFoldersToAdd)) {
                workspaceFoldersToAdd.forEach(function (folderToAdd) {
                    if (uri_1.default.isUri(folderToAdd.uri) && !validatedDistinctWorkspaceFoldersToAdd.some(function (f) { return isFolderEqual(f.uri, folderToAdd.uri); })) {
                        validatedDistinctWorkspaceFoldersToAdd.push({ uri: folderToAdd.uri, name: folderToAdd.name || resources_1.basenameOrAuthority(folderToAdd.uri) });
                    }
                });
            }
            if (!!this._unconfirmedWorkspace) {
                return false; // prevent accumulated calls without a confirmed workspace
            }
            if ([index, deleteCount].some(function (i) { return typeof i !== 'number' || i < 0; })) {
                return false; // validate numbers
            }
            if (deleteCount === 0 && validatedDistinctWorkspaceFoldersToAdd.length === 0) {
                return false; // nothing to delete or add
            }
            var currentWorkspaceFolders = this._actualWorkspace ? this._actualWorkspace.workspaceFolders : [];
            if (index + deleteCount > currentWorkspaceFolders.length) {
                return false; // cannot delete more than we have
            }
            // Simulate the updateWorkspaceFolders method on our data to do more validation
            var newWorkspaceFolders = currentWorkspaceFolders.slice(0);
            newWorkspaceFolders.splice.apply(newWorkspaceFolders, [index, deleteCount].concat(validatedDistinctWorkspaceFoldersToAdd.map(function (f) { return ({ uri: f.uri, name: f.name || resources_1.basenameOrAuthority(f.uri), index: undefined }); })));
            var _loop_1 = function (i) {
                var folder = newWorkspaceFolders[i];
                if (newWorkspaceFolders.some(function (otherFolder, index) { return index !== i && isFolderEqual(folder.uri, otherFolder.uri); })) {
                    return { value: false };
                }
            };
            for (var i = 0; i < newWorkspaceFolders.length; i++) {
                var state_1 = _loop_1(i);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
            newWorkspaceFolders.forEach(function (f, index) { return f.index = index; }); // fix index
            var _a = delta(currentWorkspaceFolders, newWorkspaceFolders, compareWorkspaceFolderByUriAndNameAndIndex), added = _a.added, removed = _a.removed;
            if (added.length === 0 && removed.length === 0) {
                return false; // nothing actually changed
            }
            // Trigger on main side
            if (this._proxy) {
                var extName_1 = extension.displayName || extension.name;
                this._proxy.$updateWorkspaceFolders(extName_1, index, deleteCount, validatedDistinctWorkspaceFoldersToAdd).then(null, function (error) {
                    // in case of an error, make sure to clear out the unconfirmed workspace
                    // because we cannot expect the acknowledgement from the main side for this
                    _this._unconfirmedWorkspace = undefined;
                    // show error to user
                    _this._messageService.$showMessage(notification_1.Severity.Error, nls_1.localize(0, null, extName_1, error.toString()), { extension: extension }, []);
                });
            }
            // Try to accept directly
            this.trySetWorkspaceFolders(newWorkspaceFolders);
            return true;
        };
        ExtHostWorkspace.prototype.getWorkspaceFolder = function (uri, resolveParent) {
            if (!this._actualWorkspace) {
                return undefined;
            }
            return this._actualWorkspace.getWorkspaceFolder(uri, resolveParent);
        };
        ExtHostWorkspace.prototype.resolveWorkspaceFolder = function (uri) {
            if (!this._actualWorkspace) {
                return undefined;
            }
            return this._actualWorkspace.resolveWorkspaceFolder(uri);
        };
        ExtHostWorkspace.prototype.getPath = function () {
            // this is legacy from the days before having
            // multi-root and we keep it only alive if there
            // is just one workspace folder.
            if (!this._actualWorkspace) {
                return undefined;
            }
            var folders = this._actualWorkspace.folders;
            if (folders.length === 0) {
                return undefined;
            }
            // #54483 @Joh Why are we still using fsPath?
            return folders[0].uri.fsPath;
        };
        ExtHostWorkspace.prototype.getRelativePath = function (pathOrUri, includeWorkspace) {
            var path;
            if (typeof pathOrUri === 'string') {
                path = pathOrUri;
            }
            else if (typeof pathOrUri !== 'undefined') {
                path = pathOrUri.fsPath;
            }
            if (!path) {
                return path;
            }
            var folder = this.getWorkspaceFolder(typeof pathOrUri === 'string' ? uri_1.default.file(pathOrUri) : pathOrUri, true);
            if (!folder) {
                return path;
            }
            if (typeof includeWorkspace === 'undefined') {
                includeWorkspace = this._actualWorkspace.folders.length > 1;
            }
            var result = path_1.relative(folder.uri.fsPath, path);
            if (includeWorkspace) {
                result = folder.name + "/" + result;
            }
            return paths_1.normalize(result, true);
        };
        ExtHostWorkspace.prototype.trySetWorkspaceFolders = function (folders) {
            // Update directly here. The workspace is unconfirmed as long as we did not get an
            // acknowledgement from the main side (via $acceptWorkspaceData)
            if (this._actualWorkspace) {
                this._unconfirmedWorkspace = ExtHostWorkspaceImpl.toExtHostWorkspace({
                    id: this._actualWorkspace.id,
                    name: this._actualWorkspace.name,
                    configuration: this._actualWorkspace.configuration,
                    folders: folders
                }, this._actualWorkspace).workspace;
            }
        };
        ExtHostWorkspace.prototype.$acceptWorkspaceData = function (data) {
            var _a = ExtHostWorkspaceImpl.toExtHostWorkspace(data, this._confirmedWorkspace, this._unconfirmedWorkspace), workspace = _a.workspace, added = _a.added, removed = _a.removed;
            // Update our workspace object. We have a confirmed workspace, so we drop our
            // unconfirmed workspace.
            this._confirmedWorkspace = workspace;
            this._unconfirmedWorkspace = undefined;
            // Events
            // {{SQL CARBON EDIT}} - fix build break  Argument of type 'Readonly<...
            this._onDidChangeWorkspace.fire({
                added: added,
                removed: removed
            });
        };
        // --- search ---
        ExtHostWorkspace.prototype.findFiles = function (include, exclude, maxResults, extensionId, token) {
            var _this = this;
            this._logService.trace("extHostWorkspace#findFiles: fileSearch, extension: " + extensionId + ", entryPoint: findFiles");
            var requestId = ExtHostWorkspace._requestIdPool++;
            var includePattern;
            var includeFolder;
            if (include) {
                if (typeof include === 'string') {
                    includePattern = include;
                }
                else {
                    includePattern = include.pattern;
                    includeFolder = include.base;
                }
            }
            var excludePatternOrDisregardExcludes;
            if (exclude === null) {
                excludePatternOrDisregardExcludes = false;
            }
            else if (exclude) {
                if (typeof exclude === 'string') {
                    excludePatternOrDisregardExcludes = exclude;
                }
                else {
                    excludePatternOrDisregardExcludes = exclude.pattern;
                }
            }
            var result = this._proxy.$startFileSearch(includePattern, includeFolder, excludePatternOrDisregardExcludes, maxResults, requestId);
            if (token) {
                token.onCancellationRequested(function () { return _this._proxy.$cancelSearch(requestId); });
            }
            return result.then(function (data) { return Array.isArray(data) ? data.map(uri_1.default.revive) : []; });
        };
        ExtHostWorkspace.prototype.findTextInFiles = function (query, options, callback, extensionId, token) {
            var _this = this;
            this._logService.trace("extHostWorkspace#findTextInFiles: textSearch, extension: " + extensionId + ", entryPoint: findTextInFiles");
            var requestId = ExtHostWorkspace._requestIdPool++;
            var globPatternToString = function (pattern) {
                if (typeof pattern === 'string') {
                    return pattern;
                }
                return path_1.join(pattern.base, pattern.pattern);
            };
            var queryOptions = {
                ignoreSymlinks: typeof options.followSymlinks === 'boolean' ? !options.followSymlinks : undefined,
                disregardIgnoreFiles: typeof options.useIgnoreFiles === 'boolean' ? !options.useIgnoreFiles : undefined,
                disregardExcludeSettings: options.exclude === null,
                fileEncoding: options.encoding,
                maxResults: options.maxResults,
                includePattern: options.include && globPatternToString(options.include),
                excludePattern: options.exclude && globPatternToString(options.exclude)
            };
            var isCanceled = false;
            this._activeSearchCallbacks[requestId] = function (p) {
                if (isCanceled) {
                    return;
                }
                p.lineMatches.forEach(function (lineMatch) {
                    lineMatch.offsetAndLengths.forEach(function (offsetAndLength) {
                        var range = new extHostTypes_1.Range(lineMatch.lineNumber, offsetAndLength[0], lineMatch.lineNumber, offsetAndLength[0] + offsetAndLength[1]);
                        callback({
                            uri: uri_1.default.revive(p.resource),
                            preview: { text: lineMatch.preview, match: range },
                            range: range
                        });
                    });
                });
            };
            if (token) {
                token.onCancellationRequested(function () {
                    isCanceled = true;
                    _this._proxy.$cancelSearch(requestId);
                });
            }
            return this._proxy.$startTextSearch(query, queryOptions, requestId).then(function () {
                delete _this._activeSearchCallbacks[requestId];
            }, function (err) {
                delete _this._activeSearchCallbacks[requestId];
                return winjs_base_1.TPromise.wrapError(err);
            });
        };
        ExtHostWorkspace.prototype.$handleTextSearchResult = function (result, requestId) {
            if (this._activeSearchCallbacks[requestId]) {
                this._activeSearchCallbacks[requestId](result);
            }
        };
        ExtHostWorkspace.prototype.saveAll = function (includeUntitled) {
            return this._proxy.$saveAll(includeUntitled);
        };
        ExtHostWorkspace._requestIdPool = 0;
        return ExtHostWorkspace;
    }());
    exports.ExtHostWorkspace = ExtHostWorkspace;
});

define(__m[213/*vs/workbench/services/extensions/node/rpcProtocol*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,14/*vs/base/common/errors*/,174/*vs/workbench/services/extensions/node/lazyPromise*/,4/*vs/base/common/uri*/]), function (require, exports, winjs_base_1, errors, lazyPromise_1, uri_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function _transformOutgoingURIs(obj, transformer, depth) {
        if (!obj || depth > 200) {
            return null;
        }
        if (typeof obj === 'object') {
            if (obj instanceof uri_1.default) {
                return transformer.transformOutgoing(obj);
            }
            // walk object (or array)
            for (var key in obj) {
                if (Object.hasOwnProperty.call(obj, key)) {
                    var r = _transformOutgoingURIs(obj[key], transformer, depth + 1);
                    if (r !== null) {
                        obj[key] = r;
                    }
                }
            }
        }
        return null;
    }
    function transformOutgoingURIs(obj, transformer) {
        var result = _transformOutgoingURIs(obj, transformer, 0);
        if (result === null) {
            // no change
            return obj;
        }
        return result;
    }
    exports.transformOutgoingURIs = transformOutgoingURIs;
    function _transformIncomingURIs(obj, transformer, depth) {
        if (!obj || depth > 200) {
            return null;
        }
        if (typeof obj === 'object') {
            if (obj.$mid === 1) {
                return transformer.transformIncoming(obj);
            }
            // walk object (or array)
            for (var key in obj) {
                if (Object.hasOwnProperty.call(obj, key)) {
                    var r = _transformIncomingURIs(obj[key], transformer, depth + 1);
                    if (r !== null) {
                        obj[key] = r;
                    }
                }
            }
        }
        return null;
    }
    function transformIncomingURIs(obj, transformer) {
        var result = _transformIncomingURIs(obj, transformer, 0);
        if (result === null) {
            // no change
            return obj;
        }
        return result;
    }
    var RPCProtocol = /** @class */ (function () {
        function RPCProtocol(protocol, transformer) {
            if (transformer === void 0) { transformer = null; }
            var _this = this;
            this._uriTransformer = transformer;
            this._isDisposed = false;
            this._locals = Object.create(null);
            this._proxies = Object.create(null);
            this._lastMessageId = 0;
            this._invokedHandlers = Object.create(null);
            this._pendingRPCReplies = {};
            this._multiplexor = new RPCMultiplexer(protocol, function (msg) { return _this._receiveOneMessage(msg); });
        }
        RPCProtocol.prototype.dispose = function () {
            var _this = this;
            this._isDisposed = true;
            // Release all outstanding promises with a canceled error
            Object.keys(this._pendingRPCReplies).forEach(function (msgId) {
                var pending = _this._pendingRPCReplies[msgId];
                pending.resolveErr(errors.canceled());
            });
        };
        RPCProtocol.prototype.transformIncomingURIs = function (obj) {
            if (!this._uriTransformer) {
                return obj;
            }
            return transformIncomingURIs(obj, this._uriTransformer);
        };
        RPCProtocol.prototype.getProxy = function (identifier) {
            if (!this._proxies[identifier.id]) {
                this._proxies[identifier.id] = this._createProxy(identifier.id);
            }
            return this._proxies[identifier.id];
        };
        RPCProtocol.prototype._createProxy = function (proxyId) {
            var _this = this;
            var handler = {
                get: function (target, name) {
                    if (!target[name] && name.charCodeAt(0) === 36 /* DollarSign */) {
                        target[name] = function () {
                            var myArgs = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                myArgs[_i] = arguments[_i];
                            }
                            return _this._remoteCall(proxyId, name, myArgs);
                        };
                    }
                    return target[name];
                }
            };
            return new Proxy(Object.create(null), handler);
        };
        RPCProtocol.prototype.set = function (identifier, value) {
            this._locals[identifier.id] = value;
            return value;
        };
        RPCProtocol.prototype.assertRegistered = function (identifiers) {
            for (var i = 0, len = identifiers.length; i < len; i++) {
                var identifier = identifiers[i];
                if (!this._locals[identifier.id]) {
                    throw new Error("Missing actor " + identifier.id + " (isMain: " + identifier.isMain + ")");
                }
            }
        };
        RPCProtocol.prototype._receiveOneMessage = function (rawmsg) {
            if (this._isDisposed) {
                return;
            }
            var msg = JSON.parse(rawmsg);
            if (this._uriTransformer) {
                msg = transformIncomingURIs(msg, this._uriTransformer);
            }
            switch (msg.type) {
                case 1 /* Request */:
                    this._receiveRequest(msg);
                    break;
                case 2 /* Cancel */:
                    this._receiveCancel(msg);
                    break;
                case 3 /* Reply */:
                    this._receiveReply(msg);
                    break;
                case 4 /* ReplyErr */:
                    this._receiveReplyErr(msg);
                    break;
            }
        };
        RPCProtocol.prototype._receiveRequest = function (msg) {
            var _this = this;
            var callId = msg.id;
            var proxyId = msg.proxyId;
            this._invokedHandlers[callId] = this._invokeHandler(proxyId, msg.method, msg.args);
            this._invokedHandlers[callId].then(function (r) {
                delete _this._invokedHandlers[callId];
                if (_this._uriTransformer) {
                    r = transformOutgoingURIs(r, _this._uriTransformer);
                }
                _this._multiplexor.send(MessageFactory.replyOK(callId, r));
            }, function (err) {
                delete _this._invokedHandlers[callId];
                _this._multiplexor.send(MessageFactory.replyErr(callId, err));
            });
        };
        RPCProtocol.prototype._receiveCancel = function (msg) {
            var callId = msg.id;
            if (this._invokedHandlers[callId]) {
                this._invokedHandlers[callId].cancel();
            }
        };
        RPCProtocol.prototype._receiveReply = function (msg) {
            var callId = msg.id;
            if (!this._pendingRPCReplies.hasOwnProperty(callId)) {
                return;
            }
            var pendingReply = this._pendingRPCReplies[callId];
            delete this._pendingRPCReplies[callId];
            pendingReply.resolveOk(msg.res);
        };
        RPCProtocol.prototype._receiveReplyErr = function (msg) {
            var callId = msg.id;
            if (!this._pendingRPCReplies.hasOwnProperty(callId)) {
                return;
            }
            var pendingReply = this._pendingRPCReplies[callId];
            delete this._pendingRPCReplies[callId];
            var err = null;
            if (msg.err && msg.err.$isError) {
                err = new Error();
                err.name = msg.err.name;
                err.message = msg.err.message;
                err.stack = msg.err.stack;
            }
            pendingReply.resolveErr(err);
        };
        RPCProtocol.prototype._invokeHandler = function (proxyId, methodName, args) {
            try {
                return winjs_base_1.TPromise.as(this._doInvokeHandler(proxyId, methodName, args));
            }
            catch (err) {
                return winjs_base_1.TPromise.wrapError(err);
            }
        };
        RPCProtocol.prototype._doInvokeHandler = function (proxyId, methodName, args) {
            if (!this._locals[proxyId]) {
                throw new Error('Unknown actor ' + proxyId);
            }
            var actor = this._locals[proxyId];
            var method = actor[methodName];
            if (typeof method !== 'function') {
                throw new Error('Unknown method ' + methodName + ' on actor ' + proxyId);
            }
            return method.apply(actor, args);
        };
        RPCProtocol.prototype._remoteCall = function (proxyId, methodName, args) {
            var _this = this;
            if (this._isDisposed) {
                return winjs_base_1.TPromise.wrapError(errors.canceled());
            }
            var callId = String(++this._lastMessageId);
            var result = new lazyPromise_1.LazyPromise(function () {
                _this._multiplexor.send(MessageFactory.cancel(callId));
            });
            this._pendingRPCReplies[callId] = result;
            if (this._uriTransformer) {
                args = transformOutgoingURIs(args, this._uriTransformer);
            }
            this._multiplexor.send(MessageFactory.request(callId, proxyId, methodName, args));
            return result;
        };
        return RPCProtocol;
    }());
    exports.RPCProtocol = RPCProtocol;
    /**
     * Sends/Receives multiple messages in one go:
     *  - multiple messages to be sent from one stack get sent in bulk at `process.nextTick`.
     *  - each incoming message is handled in a separate `process.nextTick`.
     */
    var RPCMultiplexer = /** @class */ (function () {
        function RPCMultiplexer(protocol, onMessage) {
            this._protocol = protocol;
            this._sendAccumulatedBound = this._sendAccumulated.bind(this);
            this._messagesToSend = [];
            this._protocol.onMessage(function (data) {
                for (var i = 0, len = data.length; i < len; i++) {
                    onMessage(data[i]);
                }
            });
        }
        RPCMultiplexer.prototype._sendAccumulated = function () {
            var tmp = this._messagesToSend;
            this._messagesToSend = [];
            this._protocol.send(tmp);
        };
        RPCMultiplexer.prototype.send = function (msg) {
            if (this._messagesToSend.length === 0) {
                process.nextTick(this._sendAccumulatedBound);
            }
            this._messagesToSend.push(msg);
        };
        return RPCMultiplexer;
    }());
    var MessageFactory = /** @class */ (function () {
        function MessageFactory() {
        }
        MessageFactory.cancel = function (req) {
            return "{\"type\":" + 2 /* Cancel */ + ",\"id\":\"" + req + "\"}";
        };
        MessageFactory.request = function (req, rpcId, method, args) {
            return "{\"type\":" + 1 /* Request */ + ",\"id\":\"" + req + "\",\"proxyId\":\"" + rpcId + "\",\"method\":\"" + method + "\",\"args\":" + JSON.stringify(args) + "}";
        };
        MessageFactory.replyOK = function (req, res) {
            if (typeof res === 'undefined') {
                return "{\"type\":" + 3 /* Reply */ + ",\"id\":\"" + req + "\"}";
            }
            return "{\"type\":" + 3 /* Reply */ + ",\"id\":\"" + req + "\",\"res\":" + JSON.stringify(res) + "}";
        };
        MessageFactory.replyErr = function (req, err) {
            if (err instanceof Error) {
                return "{\"type\":" + 4 /* ReplyErr */ + ",\"id\":\"" + req + "\",\"err\":" + JSON.stringify(errors.transformErrorForSerialization(err)) + "}";
            }
            return "{\"type\":" + 4 /* ReplyErr */ + ",\"id\":\"" + req + "\",\"err\":null}";
        };
        return MessageFactory;
    }());
    var MessageType;
    (function (MessageType) {
        MessageType[MessageType["Request"] = 1] = "Request";
        MessageType[MessageType["Cancel"] = 2] = "Cancel";
        MessageType[MessageType["Reply"] = 3] = "Reply";
        MessageType[MessageType["ReplyErr"] = 4] = "ReplyErr";
    })(MessageType || (MessageType = {}));
    var RequestMessage = /** @class */ (function () {
        function RequestMessage() {
        }
        return RequestMessage;
    }());
    var CancelMessage = /** @class */ (function () {
        function CancelMessage() {
        }
        return CancelMessage;
    }());
    var ReplyMessage = /** @class */ (function () {
        function ReplyMessage() {
        }
        return ReplyMessage;
    }());
    var ReplyErrMessage = /** @class */ (function () {
        function ReplyErrMessage() {
        }
        return ReplyErrMessage;
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[214/*vs/workbench/services/hash/common/hashService*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IHashService = instantiation_1.createDecorator('hashService');
});

define(__m[215/*vs/workbench/services/progress/common/progress*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProgressLocation;
    (function (ProgressLocation) {
        ProgressLocation[ProgressLocation["Explorer"] = 1] = "Explorer";
        ProgressLocation[ProgressLocation["Scm"] = 3] = "Scm";
        ProgressLocation[ProgressLocation["Extensions"] = 5] = "Extensions";
        ProgressLocation[ProgressLocation["Window"] = 10] = "Window";
        ProgressLocation[ProgressLocation["Notification"] = 15] = "Notification";
    })(ProgressLocation = exports.ProgressLocation || (exports.ProgressLocation = {}));
    exports.IProgressService2 = instantiation_1.createDecorator('progressService2');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[216/*vs/workbench/services/search/node/search*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSerializedSearchComplete(arg) {
        if (arg.type === 'error') {
            return true;
        }
        else if (arg.type === 'success') {
            return true;
        }
        else {
            return false;
        }
    }
    exports.isSerializedSearchComplete = isSerializedSearchComplete;
    function isSerializedSearchSuccess(arg) {
        return arg.type === 'success';
    }
    exports.isSerializedSearchSuccess = isSerializedSearchSuccess;
    var FileMatch = /** @class */ (function () {
        function FileMatch(path) {
            this.path = path;
            this.lineMatches = [];
        }
        FileMatch.prototype.addMatch = function (lineMatch) {
            this.lineMatches.push(lineMatch);
        };
        FileMatch.prototype.serialize = function () {
            var lineMatches = [];
            var numMatches = 0;
            for (var i = 0; i < this.lineMatches.length; i++) {
                numMatches += this.lineMatches[i].offsetAndLengths.length;
                lineMatches.push(this.lineMatches[i].serialize());
            }
            return {
                path: this.path,
                lineMatches: lineMatches,
                numMatches: numMatches
            };
        };
        return FileMatch;
    }());
    exports.FileMatch = FileMatch;
    var LineMatch = /** @class */ (function () {
        function LineMatch(preview, lineNumber) {
            this.preview = preview.replace(/(\r|\n)*$/, '');
            this.lineNumber = lineNumber;
            this.offsetAndLengths = [];
        }
        LineMatch.prototype.addMatch = function (offset, length) {
            this.offsetAndLengths.push([offset, length]);
        };
        LineMatch.prototype.serialize = function () {
            var result = {
                preview: this.preview,
                lineNumber: this.lineNumber,
                offsetAndLengths: this.offsetAndLengths
            };
            return result;
        };
        return LineMatch;
    }());
    exports.LineMatch = LineMatch;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[217/*vs/workbench/services/search/node/searchIpc*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SearchChannel = /** @class */ (function () {
        function SearchChannel(service) {
            this.service = service;
        }
        SearchChannel.prototype.listen = function (event, arg) {
            switch (event) {
                case 'telemetry': return this.service.onTelemetry;
                case 'fileSearch': return this.service.fileSearch(arg);
                case 'textSearch': return this.service.textSearch(arg);
            }
            throw new Error('Event not found');
        };
        SearchChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'clearCache': return this.service.clearCache(arg);
            }
            throw new Error('Call not found');
        };
        return SearchChannel;
    }());
    exports.SearchChannel = SearchChannel;
    var SearchChannelClient = /** @class */ (function () {
        function SearchChannelClient(channel) {
            this.channel = channel;
        }
        Object.defineProperty(SearchChannelClient.prototype, "onTelemetry", {
            get: function () { return this.channel.listen('telemetry'); },
            enumerable: true,
            configurable: true
        });
        SearchChannelClient.prototype.fileSearch = function (search) {
            return this.channel.listen('fileSearch', search);
        };
        SearchChannelClient.prototype.textSearch = function (search) {
            return this.channel.listen('textSearch', search);
        };
        SearchChannelClient.prototype.clearCache = function (cacheKey) {
            return this.channel.call('clearCache', cacheKey);
        };
        return SearchChannelClient;
    }());
    exports.SearchChannelClient = SearchChannelClient;
});

define(__m[82/*vs/workbench/services/textfile/common/textfiles*/], __M([0/*require*/,1/*exports*/,7/*vs/platform/instantiation/common/instantiation*/,42/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, instantiation_1, contextkey_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * States the text text file editor model can be in.
     */
    var ModelState;
    (function (ModelState) {
        ModelState[ModelState["SAVED"] = 0] = "SAVED";
        ModelState[ModelState["DIRTY"] = 1] = "DIRTY";
        ModelState[ModelState["PENDING_SAVE"] = 2] = "PENDING_SAVE";
        /**
         * A model is in conflict mode when changes cannot be saved because the
         * underlying file has changed. Models in conflict mode are always dirty.
         */
        ModelState[ModelState["CONFLICT"] = 3] = "CONFLICT";
        /**
         * A model is in orphan state when the underlying file has been deleted.
         */
        ModelState[ModelState["ORPHAN"] = 4] = "ORPHAN";
        /**
         * Any error that happens during a save that is not causing the CONFLICT state.
         * Models in error mode are always diry.
         */
        ModelState[ModelState["ERROR"] = 5] = "ERROR";
    })(ModelState = exports.ModelState || (exports.ModelState = {}));
    var StateChange;
    (function (StateChange) {
        StateChange[StateChange["DIRTY"] = 0] = "DIRTY";
        StateChange[StateChange["SAVING"] = 1] = "SAVING";
        StateChange[StateChange["SAVE_ERROR"] = 2] = "SAVE_ERROR";
        StateChange[StateChange["SAVED"] = 3] = "SAVED";
        StateChange[StateChange["REVERTED"] = 4] = "REVERTED";
        StateChange[StateChange["ENCODING"] = 5] = "ENCODING";
        StateChange[StateChange["CONTENT_CHANGE"] = 6] = "CONTENT_CHANGE";
        StateChange[StateChange["ORPHANED_CHANGE"] = 7] = "ORPHANED_CHANGE";
    })(StateChange = exports.StateChange || (exports.StateChange = {}));
    var TextFileModelChangeEvent = /** @class */ (function () {
        function TextFileModelChangeEvent(model, kind) {
            this._resource = model.getResource();
            this._kind = kind;
        }
        Object.defineProperty(TextFileModelChangeEvent.prototype, "resource", {
            get: function () {
                return this._resource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileModelChangeEvent.prototype, "kind", {
            get: function () {
                return this._kind;
            },
            enumerable: true,
            configurable: true
        });
        return TextFileModelChangeEvent;
    }());
    exports.TextFileModelChangeEvent = TextFileModelChangeEvent;
    exports.TEXT_FILE_SERVICE_ID = 'textFileService';
    exports.AutoSaveContext = new contextkey_1.RawContextKey('config.files.autoSave', undefined);
    var AutoSaveMode;
    (function (AutoSaveMode) {
        AutoSaveMode[AutoSaveMode["OFF"] = 0] = "OFF";
        AutoSaveMode[AutoSaveMode["AFTER_SHORT_DELAY"] = 1] = "AFTER_SHORT_DELAY";
        AutoSaveMode[AutoSaveMode["AFTER_LONG_DELAY"] = 2] = "AFTER_LONG_DELAY";
        AutoSaveMode[AutoSaveMode["ON_FOCUS_CHANGE"] = 3] = "ON_FOCUS_CHANGE";
        AutoSaveMode[AutoSaveMode["ON_WINDOW_CHANGE"] = 4] = "ON_WINDOW_CHANGE";
    })(AutoSaveMode = exports.AutoSaveMode || (exports.AutoSaveMode = {}));
    var SaveReason;
    (function (SaveReason) {
        SaveReason[SaveReason["EXPLICIT"] = 1] = "EXPLICIT";
        SaveReason[SaveReason["AUTO"] = 2] = "AUTO";
        SaveReason[SaveReason["FOCUS_CHANGE"] = 3] = "FOCUS_CHANGE";
        SaveReason[SaveReason["WINDOW_CHANGE"] = 4] = "WINDOW_CHANGE";
    })(SaveReason = exports.SaveReason || (exports.SaveReason = {}));
    var LoadReason;
    (function (LoadReason) {
        LoadReason[LoadReason["EDITOR"] = 1] = "EDITOR";
        LoadReason[LoadReason["REFERENCE"] = 2] = "REFERENCE";
        LoadReason[LoadReason["OTHER"] = 3] = "OTHER";
    })(LoadReason = exports.LoadReason || (exports.LoadReason = {}));
    exports.ITextFileService = instantiation_1.createDecorator(exports.TEXT_FILE_SERVICE_ID);
});









define(__m[19/*vs/workbench/api/node/extHostTypeConverters*/], __M([0/*require*/,1/*exports*/,36/*vs/editor/common/modes*/,5/*vs/workbench/api/node/extHostTypes*/,25/*vs/editor/common/model*/,4/*vs/base/common/uri*/,215/*vs/workbench/services/progress/common/progress*/,82/*vs/workbench/services/textfile/common/textfiles*/,69/*vs/base/common/htmlContent*/,64/*vs/platform/markers/common/markers*/,171/*vs/workbench/services/editor/common/editorService*/]), function (require, exports, modes, types, model_1, uri_1, progress_1, textfiles_1, htmlContent, markers_1, editorService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Selection;
    (function (Selection) {
        function to(selection) {
            var selectionStartLineNumber = selection.selectionStartLineNumber, selectionStartColumn = selection.selectionStartColumn, positionLineNumber = selection.positionLineNumber, positionColumn = selection.positionColumn;
            var start = new types.Position(selectionStartLineNumber - 1, selectionStartColumn - 1);
            var end = new types.Position(positionLineNumber - 1, positionColumn - 1);
            return new types.Selection(start, end);
        }
        Selection.to = to;
        function from(selection) {
            var anchor = selection.anchor, active = selection.active;
            return {
                selectionStartLineNumber: anchor.line + 1,
                selectionStartColumn: anchor.character + 1,
                positionLineNumber: active.line + 1,
                positionColumn: active.character + 1
            };
        }
        Selection.from = from;
    })(Selection = exports.Selection || (exports.Selection = {}));
    var Range;
    (function (Range) {
        function from(range) {
            if (!range) {
                return undefined;
            }
            var start = range.start, end = range.end;
            return {
                startLineNumber: start.line + 1,
                startColumn: start.character + 1,
                endLineNumber: end.line + 1,
                endColumn: end.character + 1
            };
        }
        Range.from = from;
        function to(range) {
            if (!range) {
                return undefined;
            }
            var startLineNumber = range.startLineNumber, startColumn = range.startColumn, endLineNumber = range.endLineNumber, endColumn = range.endColumn;
            return new types.Range(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
        }
        Range.to = to;
    })(Range = exports.Range || (exports.Range = {}));
    var Position;
    (function (Position) {
        function to(position) {
            return new types.Position(position.lineNumber - 1, position.column - 1);
        }
        Position.to = to;
        function from(position) {
            return { lineNumber: position.line + 1, column: position.character + 1 };
        }
        Position.from = from;
    })(Position = exports.Position || (exports.Position = {}));
    var DiagnosticTag;
    (function (DiagnosticTag) {
        function from(value) {
            switch (value) {
                case types.DiagnosticTag.Unnecessary:
                    return markers_1.MarkerTag.Unnecessary;
            }
            return undefined;
        }
        DiagnosticTag.from = from;
    })(DiagnosticTag = exports.DiagnosticTag || (exports.DiagnosticTag = {}));
    var Diagnostic;
    (function (Diagnostic) {
        function from(value) {
            return __assign({}, Range.from(value.range), { message: value.message, source: value.source, code: String(value.code), severity: DiagnosticSeverity.from(value.severity), relatedInformation: value.relatedInformation && value.relatedInformation.map(DiagnosticRelatedInformation.from), tags: Array.isArray(value.tags) ? value.tags.map(DiagnosticTag.from) : undefined });
        }
        Diagnostic.from = from;
    })(Diagnostic = exports.Diagnostic || (exports.Diagnostic = {}));
    var DiagnosticRelatedInformation;
    (function (DiagnosticRelatedInformation) {
        function from(value) {
            return __assign({}, Range.from(value.location.range), { message: value.message, resource: value.location.uri });
        }
        DiagnosticRelatedInformation.from = from;
        function to(value) {
            return new types.DiagnosticRelatedInformation(new types.Location(value.resource, Range.to(value)), value.message);
        }
        DiagnosticRelatedInformation.to = to;
    })(DiagnosticRelatedInformation = exports.DiagnosticRelatedInformation || (exports.DiagnosticRelatedInformation = {}));
    var DiagnosticSeverity;
    (function (DiagnosticSeverity) {
        function from(value) {
            switch (value) {
                case types.DiagnosticSeverity.Error:
                    return markers_1.MarkerSeverity.Error;
                case types.DiagnosticSeverity.Warning:
                    return markers_1.MarkerSeverity.Warning;
                case types.DiagnosticSeverity.Information:
                    return markers_1.MarkerSeverity.Info;
                case types.DiagnosticSeverity.Hint:
                    return markers_1.MarkerSeverity.Hint;
            }
            return markers_1.MarkerSeverity.Error;
        }
        DiagnosticSeverity.from = from;
        function to(value) {
            switch (value) {
                case markers_1.MarkerSeverity.Info:
                    return types.DiagnosticSeverity.Information;
                case markers_1.MarkerSeverity.Warning:
                    return types.DiagnosticSeverity.Warning;
                case markers_1.MarkerSeverity.Error:
                    return types.DiagnosticSeverity.Error;
                case markers_1.MarkerSeverity.Hint:
                    return types.DiagnosticSeverity.Hint;
            }
            return types.DiagnosticSeverity.Error;
        }
        DiagnosticSeverity.to = to;
    })(DiagnosticSeverity = exports.DiagnosticSeverity || (exports.DiagnosticSeverity = {}));
    var ViewColumn;
    (function (ViewColumn) {
        function from(column) {
            if (typeof column === 'number' && column >= types.ViewColumn.One) {
                return column - 1; // adjust zero index (ViewColumn.ONE => 0)
            }
            if (column === types.ViewColumn.Beside) {
                return editorService_1.SIDE_GROUP;
            }
            return editorService_1.ACTIVE_GROUP; // default is always the active group
        }
        ViewColumn.from = from;
        function to(position) {
            if (typeof position === 'number' && position >= 0) {
                return position + 1; // adjust to index (ViewColumn.ONE => 1)
            }
            return undefined;
        }
        ViewColumn.to = to;
    })(ViewColumn = exports.ViewColumn || (exports.ViewColumn = {}));
    function isDecorationOptions(something) {
        return (typeof something.range !== 'undefined');
    }
    function isDecorationOptionsArr(something) {
        if (something.length === 0) {
            return true;
        }
        return isDecorationOptions(something[0]) ? true : false;
    }
    exports.isDecorationOptionsArr = isDecorationOptionsArr;
    var MarkdownString;
    (function (MarkdownString) {
        function fromMany(markup) {
            return markup.map(MarkdownString.from);
        }
        MarkdownString.fromMany = fromMany;
        function isCodeblock(thing) {
            return thing && typeof thing === 'object'
                && typeof thing.language === 'string'
                && typeof thing.value === 'string';
        }
        function from(markup) {
            if (isCodeblock(markup)) {
                var language = markup.language, value = markup.value;
                return { value: '```' + language + '\n' + value + '\n```\n' };
            }
            else if (htmlContent.isMarkdownString(markup)) {
                return markup;
            }
            else if (typeof markup === 'string') {
                return { value: markup };
            }
            else {
                return { value: '' };
            }
        }
        MarkdownString.from = from;
        function to(value) {
            var ret = new htmlContent.MarkdownString(value.value);
            ret.isTrusted = value.isTrusted;
            return ret;
        }
        MarkdownString.to = to;
        function fromStrict(value) {
            if (!value) {
                return undefined;
            }
            return typeof value === 'string' ? value : MarkdownString.from(value);
        }
        MarkdownString.fromStrict = fromStrict;
    })(MarkdownString = exports.MarkdownString || (exports.MarkdownString = {}));
    function fromRangeOrRangeWithMessage(ranges) {
        if (isDecorationOptionsArr(ranges)) {
            return ranges.map(function (r) {
                return {
                    range: Range.from(r.range),
                    hoverMessage: Array.isArray(r.hoverMessage) ? MarkdownString.fromMany(r.hoverMessage) : r.hoverMessage && MarkdownString.from(r.hoverMessage),
                    renderOptions: r.renderOptions
                };
            });
        }
        else {
            return ranges.map(function (r) {
                return {
                    range: Range.from(r)
                };
            });
        }
    }
    exports.fromRangeOrRangeWithMessage = fromRangeOrRangeWithMessage;
    exports.TextEdit = {
        from: function (edit) {
            return {
                text: edit.newText,
                eol: EndOfLine.from(edit.newEol),
                range: Range.from(edit.range)
            };
        },
        to: function (edit) {
            var result = new types.TextEdit(Range.to(edit.range), edit.text);
            result.newEol = EndOfLine.to(edit.eol);
            return result;
        }
    };
    var WorkspaceEdit;
    (function (WorkspaceEdit) {
        function from(value, documents) {
            var result = {
                edits: []
            };
            for (var _i = 0, _a = value._allEntries(); _i < _a.length; _i++) {
                var entry = _a[_i];
                var uri = entry[0], uriOrEdits = entry[1];
                if (Array.isArray(uriOrEdits)) {
                    // text edits
                    var doc = documents ? documents.getDocument(uri.toString()) : undefined;
                    result.edits.push({ resource: uri, modelVersionId: doc && doc.version, edits: uriOrEdits.map(exports.TextEdit.from) });
                }
                else {
                    // resource edits
                    result.edits.push({ oldUri: uri, newUri: uriOrEdits, options: entry[2] });
                }
            }
            return result;
        }
        WorkspaceEdit.from = from;
        function to(value) {
            var result = new types.WorkspaceEdit();
            for (var _i = 0, _a = value.edits; _i < _a.length; _i++) {
                var edit = _a[_i];
                if (Array.isArray(edit.edits)) {
                    result.set(uri_1.default.revive(edit.resource), edit.edits.map(exports.TextEdit.to));
                }
                else {
                    result.renameFile(uri_1.default.revive(edit.oldUri), uri_1.default.revive(edit.newUri), edit.options);
                }
            }
            return result;
        }
        WorkspaceEdit.to = to;
    })(WorkspaceEdit = exports.WorkspaceEdit || (exports.WorkspaceEdit = {}));
    var SymbolKind;
    (function (SymbolKind) {
        var _fromMapping = Object.create(null);
        _fromMapping[types.SymbolKind.File] = modes.SymbolKind.File;
        _fromMapping[types.SymbolKind.Module] = modes.SymbolKind.Module;
        _fromMapping[types.SymbolKind.Namespace] = modes.SymbolKind.Namespace;
        _fromMapping[types.SymbolKind.Package] = modes.SymbolKind.Package;
        _fromMapping[types.SymbolKind.Class] = modes.SymbolKind.Class;
        _fromMapping[types.SymbolKind.Method] = modes.SymbolKind.Method;
        _fromMapping[types.SymbolKind.Property] = modes.SymbolKind.Property;
        _fromMapping[types.SymbolKind.Field] = modes.SymbolKind.Field;
        _fromMapping[types.SymbolKind.Constructor] = modes.SymbolKind.Constructor;
        _fromMapping[types.SymbolKind.Enum] = modes.SymbolKind.Enum;
        _fromMapping[types.SymbolKind.Interface] = modes.SymbolKind.Interface;
        _fromMapping[types.SymbolKind.Function] = modes.SymbolKind.Function;
        _fromMapping[types.SymbolKind.Variable] = modes.SymbolKind.Variable;
        _fromMapping[types.SymbolKind.Constant] = modes.SymbolKind.Constant;
        _fromMapping[types.SymbolKind.String] = modes.SymbolKind.String;
        _fromMapping[types.SymbolKind.Number] = modes.SymbolKind.Number;
        _fromMapping[types.SymbolKind.Boolean] = modes.SymbolKind.Boolean;
        _fromMapping[types.SymbolKind.Array] = modes.SymbolKind.Array;
        _fromMapping[types.SymbolKind.Object] = modes.SymbolKind.Object;
        _fromMapping[types.SymbolKind.Key] = modes.SymbolKind.Key;
        _fromMapping[types.SymbolKind.Null] = modes.SymbolKind.Null;
        _fromMapping[types.SymbolKind.EnumMember] = modes.SymbolKind.EnumMember;
        _fromMapping[types.SymbolKind.Struct] = modes.SymbolKind.Struct;
        _fromMapping[types.SymbolKind.Event] = modes.SymbolKind.Event;
        _fromMapping[types.SymbolKind.Operator] = modes.SymbolKind.Operator;
        _fromMapping[types.SymbolKind.TypeParameter] = modes.SymbolKind.TypeParameter;
        function from(kind) {
            return _fromMapping[kind] || modes.SymbolKind.Property;
        }
        SymbolKind.from = from;
        function to(kind) {
            for (var k in _fromMapping) {
                if (_fromMapping[k] === kind) {
                    return Number(k);
                }
            }
            return types.SymbolKind.Property;
        }
        SymbolKind.to = to;
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    var WorkspaceSymbol;
    (function (WorkspaceSymbol) {
        function from(info) {
            return {
                name: info.name,
                kind: SymbolKind.from(info.kind),
                containerName: info.containerName,
                location: exports.location.from(info.location)
            };
        }
        WorkspaceSymbol.from = from;
        function to(info) {
            return new types.SymbolInformation(info.name, SymbolKind.to(info.kind), info.containerName, exports.location.to(info.location));
        }
        WorkspaceSymbol.to = to;
    })(WorkspaceSymbol = exports.WorkspaceSymbol || (exports.WorkspaceSymbol = {}));
    var DocumentSymbol;
    (function (DocumentSymbol) {
        function from(info) {
            var result = {
                name: info.name,
                detail: info.detail,
                range: Range.from(info.range),
                selectionRange: Range.from(info.selectionRange),
                kind: SymbolKind.from(info.kind)
            };
            if (info.children) {
                result.children = info.children.map(from);
            }
            return result;
        }
        DocumentSymbol.from = from;
        function to(info) {
            var result = new types.DocumentSymbol(info.name, info.detail, SymbolKind.to(info.kind), Range.to(info.range), Range.to(info.selectionRange));
            if (info.children) {
                result.children = info.children.map(to);
            }
            return result;
        }
        DocumentSymbol.to = to;
    })(DocumentSymbol = exports.DocumentSymbol || (exports.DocumentSymbol = {}));
    exports.location = {
        from: function (value) {
            return {
                range: value.range && Range.from(value.range),
                uri: value.uri
            };
        },
        to: function (value) {
            return new types.Location(value.uri, Range.to(value.range));
        }
    };
    var DefinitionLink;
    (function (DefinitionLink) {
        function from(value) {
            var definitionLink = value;
            var location = value;
            return {
                origin: definitionLink.originSelectionRange
                    ? Range.from(definitionLink.originSelectionRange)
                    : undefined,
                uri: definitionLink.targetUri ? definitionLink.targetUri : location.uri,
                range: Range.from(definitionLink.targetRange ? definitionLink.targetRange : location.range),
                selectionRange: definitionLink.targetSelectionRange
                    ? Range.from(definitionLink.targetSelectionRange)
                    : undefined,
            };
        }
        DefinitionLink.from = from;
    })(DefinitionLink = exports.DefinitionLink || (exports.DefinitionLink = {}));
    var Hover;
    (function (Hover) {
        function from(hover) {
            return {
                range: Range.from(hover.range),
                contents: MarkdownString.fromMany(hover.contents)
            };
        }
        Hover.from = from;
        function to(info) {
            return new types.Hover(info.contents.map(MarkdownString.to), Range.to(info.range));
        }
        Hover.to = to;
    })(Hover = exports.Hover || (exports.Hover = {}));
    var DocumentHighlight;
    (function (DocumentHighlight) {
        function from(documentHighlight) {
            return {
                range: Range.from(documentHighlight.range),
                kind: documentHighlight.kind
            };
        }
        DocumentHighlight.from = from;
        function to(occurrence) {
            return new types.DocumentHighlight(Range.to(occurrence.range), occurrence.kind);
        }
        DocumentHighlight.to = to;
    })(DocumentHighlight = exports.DocumentHighlight || (exports.DocumentHighlight = {}));
    var CompletionTriggerKind;
    (function (CompletionTriggerKind) {
        function from(kind) {
            switch (kind) {
                case modes.SuggestTriggerKind.TriggerCharacter:
                    return types.CompletionTriggerKind.TriggerCharacter;
                case modes.SuggestTriggerKind.TriggerForIncompleteCompletions:
                    return types.CompletionTriggerKind.TriggerForIncompleteCompletions;
                case modes.SuggestTriggerKind.Invoke:
                default:
                    return types.CompletionTriggerKind.Invoke;
            }
        }
        CompletionTriggerKind.from = from;
    })(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
    var CompletionContext;
    (function (CompletionContext) {
        function from(context) {
            return {
                triggerKind: CompletionTriggerKind.from(context.triggerKind),
                triggerCharacter: context.triggerCharacter
            };
        }
        CompletionContext.from = from;
    })(CompletionContext = exports.CompletionContext || (exports.CompletionContext = {}));
    exports.CompletionItemKind = {
        from: function (kind) {
            switch (kind) {
                case types.CompletionItemKind.Method: return 'method';
                case types.CompletionItemKind.Function: return 'function';
                case types.CompletionItemKind.Constructor: return 'constructor';
                case types.CompletionItemKind.Field: return 'field';
                case types.CompletionItemKind.Variable: return 'variable';
                case types.CompletionItemKind.Class: return 'class';
                case types.CompletionItemKind.Interface: return 'interface';
                case types.CompletionItemKind.Struct: return 'struct';
                case types.CompletionItemKind.Module: return 'module';
                case types.CompletionItemKind.Property: return 'property';
                case types.CompletionItemKind.Unit: return 'unit';
                case types.CompletionItemKind.Value: return 'value';
                case types.CompletionItemKind.Constant: return 'constant';
                case types.CompletionItemKind.Enum: return 'enum';
                case types.CompletionItemKind.EnumMember: return 'enum-member';
                case types.CompletionItemKind.Keyword: return 'keyword';
                case types.CompletionItemKind.Snippet: return 'snippet';
                case types.CompletionItemKind.Text: return 'text';
                case types.CompletionItemKind.Color: return 'color';
                case types.CompletionItemKind.File: return 'file';
                case types.CompletionItemKind.Reference: return 'reference';
                case types.CompletionItemKind.Folder: return 'folder';
                case types.CompletionItemKind.Event: return 'event';
                case types.CompletionItemKind.Operator: return 'operator';
                case types.CompletionItemKind.TypeParameter: return 'type-parameter';
            }
            return 'property';
        },
        to: function (type) {
            if (!type) {
                return types.CompletionItemKind.Property;
            }
            else {
                return types.CompletionItemKind[type.charAt(0).toUpperCase() + type.substr(1)];
            }
        }
    };
    var Suggest;
    (function (Suggest) {
        function to(position, suggestion) {
            var result = new types.CompletionItem(suggestion.label);
            result.insertText = suggestion.insertText;
            result.kind = exports.CompletionItemKind.to(suggestion.type);
            result.detail = suggestion.detail;
            result.documentation = htmlContent.isMarkdownString(suggestion.documentation) ? MarkdownString.to(suggestion.documentation) : suggestion.documentation;
            result.sortText = suggestion.sortText;
            result.filterText = suggestion.filterText;
            result.preselect = suggestion.preselect;
            // 'overwrite[Before|After]'-logic
            var overwriteBefore = (typeof suggestion.overwriteBefore === 'number') ? suggestion.overwriteBefore : 0;
            var startPosition = new types.Position(position.line, Math.max(0, position.character - overwriteBefore));
            var endPosition = position;
            if (typeof suggestion.overwriteAfter === 'number') {
                endPosition = new types.Position(position.line, position.character + suggestion.overwriteAfter);
            }
            result.range = new types.Range(startPosition, endPosition);
            // 'inserText'-logic
            if (suggestion.snippetType === 'textmate') {
                result.insertText = new types.SnippetString(suggestion.insertText);
            }
            else {
                result.insertText = suggestion.insertText;
                result.textEdit = new types.TextEdit(result.range, result.insertText);
            }
            // TODO additionalEdits, command
            return result;
        }
        Suggest.to = to;
    })(Suggest = exports.Suggest || (exports.Suggest = {}));
    var ParameterInformation;
    (function (ParameterInformation) {
        function from(info) {
            return {
                label: info.label,
                documentation: MarkdownString.fromStrict(info.documentation)
            };
        }
        ParameterInformation.from = from;
        function to(info) {
            return {
                label: info.label,
                documentation: htmlContent.isMarkdownString(info.documentation) ? MarkdownString.to(info.documentation) : info.documentation
            };
        }
        ParameterInformation.to = to;
    })(ParameterInformation = exports.ParameterInformation || (exports.ParameterInformation = {}));
    var SignatureInformation;
    (function (SignatureInformation) {
        function from(info) {
            return {
                label: info.label,
                documentation: MarkdownString.fromStrict(info.documentation),
                parameters: info.parameters && info.parameters.map(ParameterInformation.from)
            };
        }
        SignatureInformation.from = from;
        function to(info) {
            return {
                label: info.label,
                documentation: htmlContent.isMarkdownString(info.documentation) ? MarkdownString.to(info.documentation) : info.documentation,
                parameters: info.parameters && info.parameters.map(ParameterInformation.to)
            };
        }
        SignatureInformation.to = to;
    })(SignatureInformation = exports.SignatureInformation || (exports.SignatureInformation = {}));
    var SignatureHelp;
    (function (SignatureHelp) {
        function from(help) {
            return {
                activeSignature: help.activeSignature,
                activeParameter: help.activeParameter,
                signatures: help.signatures && help.signatures.map(SignatureInformation.from)
            };
        }
        SignatureHelp.from = from;
        function to(help) {
            return {
                activeSignature: help.activeSignature,
                activeParameter: help.activeParameter,
                signatures: help.signatures && help.signatures.map(SignatureInformation.to)
            };
        }
        SignatureHelp.to = to;
    })(SignatureHelp = exports.SignatureHelp || (exports.SignatureHelp = {}));
    var DocumentLink;
    (function (DocumentLink) {
        function from(link) {
            return {
                range: Range.from(link.range),
                url: link.target && link.target.toString()
            };
        }
        DocumentLink.from = from;
        function to(link) {
            return new types.DocumentLink(Range.to(link.range), link.url && uri_1.default.parse(link.url));
        }
        DocumentLink.to = to;
    })(DocumentLink = exports.DocumentLink || (exports.DocumentLink = {}));
    var ColorPresentation;
    (function (ColorPresentation) {
        function to(colorPresentation) {
            var cp = new types.ColorPresentation(colorPresentation.label);
            if (colorPresentation.textEdit) {
                cp.textEdit = exports.TextEdit.to(colorPresentation.textEdit);
            }
            if (colorPresentation.additionalTextEdits) {
                cp.additionalTextEdits = colorPresentation.additionalTextEdits.map(function (value) { return exports.TextEdit.to(value); });
            }
            return cp;
        }
        ColorPresentation.to = to;
        function from(colorPresentation) {
            return {
                label: colorPresentation.label,
                textEdit: colorPresentation.textEdit ? exports.TextEdit.from(colorPresentation.textEdit) : undefined,
                additionalTextEdits: colorPresentation.additionalTextEdits ? colorPresentation.additionalTextEdits.map(function (value) { return exports.TextEdit.from(value); }) : undefined
            };
        }
        ColorPresentation.from = from;
    })(ColorPresentation = exports.ColorPresentation || (exports.ColorPresentation = {}));
    var Color;
    (function (Color) {
        function to(c) {
            return new types.Color(c[0], c[1], c[2], c[3]);
        }
        Color.to = to;
        function from(color) {
            return [color.red, color.green, color.blue, color.alpha];
        }
        Color.from = from;
    })(Color = exports.Color || (exports.Color = {}));
    var TextDocumentSaveReason;
    (function (TextDocumentSaveReason) {
        function to(reason) {
            switch (reason) {
                case textfiles_1.SaveReason.AUTO:
                    return types.TextDocumentSaveReason.AfterDelay;
                case textfiles_1.SaveReason.EXPLICIT:
                    return types.TextDocumentSaveReason.Manual;
                case textfiles_1.SaveReason.FOCUS_CHANGE:
                case textfiles_1.SaveReason.WINDOW_CHANGE:
                    return types.TextDocumentSaveReason.FocusOut;
            }
        }
        TextDocumentSaveReason.to = to;
    })(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
    var EndOfLine;
    (function (EndOfLine) {
        function from(eol) {
            if (eol === types.EndOfLine.CRLF) {
                return model_1.EndOfLineSequence.CRLF;
            }
            else if (eol === types.EndOfLine.LF) {
                return model_1.EndOfLineSequence.LF;
            }
            return undefined;
        }
        EndOfLine.from = from;
        function to(eol) {
            if (eol === model_1.EndOfLineSequence.CRLF) {
                return types.EndOfLine.CRLF;
            }
            else if (eol === model_1.EndOfLineSequence.LF) {
                return types.EndOfLine.LF;
            }
            return undefined;
        }
        EndOfLine.to = to;
    })(EndOfLine = exports.EndOfLine || (exports.EndOfLine = {}));
    var ProgressLocation;
    (function (ProgressLocation) {
        function from(loc) {
            switch (loc) {
                case types.ProgressLocation.SourceControl: return progress_1.ProgressLocation.Scm;
                case types.ProgressLocation.Window: return progress_1.ProgressLocation.Window;
                case types.ProgressLocation.Notification: return progress_1.ProgressLocation.Notification;
            }
            return undefined;
        }
        ProgressLocation.from = from;
    })(ProgressLocation = exports.ProgressLocation || (exports.ProgressLocation = {}));
    var FoldingRange;
    (function (FoldingRange) {
        function from(r) {
            var range = { start: r.start + 1, end: r.end + 1 };
            if (r.kind) {
                range.kind = FoldingRangeKind.from(r.kind);
            }
            return range;
        }
        FoldingRange.from = from;
    })(FoldingRange = exports.FoldingRange || (exports.FoldingRange = {}));
    var FoldingRangeKind;
    (function (FoldingRangeKind) {
        function from(kind) {
            if (kind) {
                switch (kind) {
                    case types.FoldingRangeKind.Comment:
                        return modes.FoldingRangeKind.Comment;
                    case types.FoldingRangeKind.Imports:
                        return modes.FoldingRangeKind.Imports;
                    case types.FoldingRangeKind.Region:
                        return modes.FoldingRangeKind.Region;
                }
            }
            return void 0;
        }
        FoldingRangeKind.from = from;
    })(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
    var TextEditorOptions;
    (function (TextEditorOptions) {
        function from(options) {
            if (options) {
                return {
                    pinned: typeof options.preview === 'boolean' ? !options.preview : undefined,
                    preserveFocus: options.preserveFocus,
                    selection: typeof options.selection === 'object' ? Range.from(options.selection) : undefined
                };
            }
            return undefined;
        }
        TextEditorOptions.from = from;
    })(TextEditorOptions = exports.TextEditorOptions || (exports.TextEditorOptions = {}));
    var GlobPattern;
    (function (GlobPattern) {
        function from(pattern) {
            if (typeof pattern === 'string') {
                return pattern;
            }
            if (isRelativePattern(pattern)) {
                return new types.RelativePattern(pattern.base, pattern.pattern);
            }
            return pattern; // preserve `undefined` and `null`
        }
        GlobPattern.from = from;
        function isRelativePattern(obj) {
            var rp = obj;
            return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';
        }
    })(GlobPattern = exports.GlobPattern || (exports.GlobPattern = {}));
    var LanguageSelector;
    (function (LanguageSelector) {
        function from(selector) {
            if (!selector) {
                return undefined;
            }
            else if (Array.isArray(selector)) {
                return selector.map(from);
            }
            else if (typeof selector === 'string') {
                return selector;
            }
            else {
                return {
                    language: selector.language,
                    scheme: selector.scheme,
                    pattern: GlobPattern.from(selector.pattern),
                    exclusive: selector.exclusive
                };
            }
        }
        LanguageSelector.from = from;
    })(LanguageSelector = exports.LanguageSelector || (exports.LanguageSelector = {}));
});




































define(__m[220/*sql/workbench/api/node/extHostNotebookDocumentsAndEditors*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,9/*vs/base/common/lifecycle*/,4/*vs/base/common/uri*/,19/*vs/workbench/api/node/extHostTypeConverters*/,32/*vs/base/common/assert*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/,156/*sql/workbench/api/node/extHostNotebookDocumentData*/,157/*sql/workbench/api/node/extHostNotebookEditor*/]), function (require, exports, event_1, lifecycle_1, uri_1, typeConverters, assert_1, sqlExtHost_protocol_1, extHostNotebookDocumentData_1, extHostNotebookEditor_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostNotebookDocumentsAndEditors = /** @class */ (function () {
        function ExtHostNotebookDocumentsAndEditors(_mainContext) {
            this._mainContext = _mainContext;
            this._disposables = [];
            this._editors = new Map();
            this._documents = new Map();
            this._onDidChangeVisibleNotebookEditors = new event_1.Emitter();
            this._onDidChangeActiveNotebookEditor = new event_1.Emitter();
            this._onDidOpenNotebook = new event_1.Emitter();
            this._onDidChangeNotebookCell = new event_1.Emitter();
            this.onDidChangeVisibleNotebookEditors = this._onDidChangeVisibleNotebookEditors.event;
            this.onDidChangeActiveNotebookEditor = this._onDidChangeActiveNotebookEditor.event;
            this.onDidOpenNotebookDocument = this._onDidOpenNotebook.event;
            this.onDidChangeNotebookCell = this._onDidChangeNotebookCell.event;
            if (this._mainContext) {
                this._proxy = this._mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadNotebookDocumentsAndEditors);
            }
        }
        ExtHostNotebookDocumentsAndEditors.prototype.dispose = function () {
            this._disposables = lifecycle_1.dispose(this._disposables);
        };
        //#region Main Thread accessible methods
        ExtHostNotebookDocumentsAndEditors.prototype.$acceptDocumentsAndEditorsDelta = function (delta) {
            var _this = this;
            var removedDocuments = [];
            var addedDocuments = [];
            var removedEditors = [];
            if (delta.removedDocuments) {
                for (var _i = 0, _a = delta.removedDocuments; _i < _a.length; _i++) {
                    var uriComponent = _a[_i];
                    var uri = uri_1.default.revive(uriComponent);
                    var id = uri.toString();
                    var data = this._documents.get(id);
                    this._documents.delete(id);
                    removedDocuments.push(data);
                }
            }
            if (delta.addedDocuments) {
                for (var _b = 0, _c = delta.addedDocuments; _b < _c.length; _b++) {
                    var data = _c[_b];
                    var resource = uri_1.default.revive(data.uri);
                    assert_1.ok(!this._documents.has(resource.toString()), "document '" + resource + " already exists!'");
                    var documentData = new extHostNotebookDocumentData_1.ExtHostNotebookDocumentData(this._proxy, resource, data.providerId, data.isDirty, data.cells);
                    this._documents.set(resource.toString(), documentData);
                    addedDocuments.push(documentData);
                }
            }
            if (delta.removedEditors) {
                for (var _d = 0, _e = delta.removedEditors; _d < _e.length; _d++) {
                    var id = _e[_d];
                    var editor = this._editors.get(id);
                    this._editors.delete(id);
                    removedEditors.push(editor);
                }
            }
            if (delta.addedEditors) {
                for (var _f = 0, _g = delta.addedEditors; _f < _g.length; _f++) {
                    var data = _g[_f];
                    var resource = uri_1.default.revive(data.documentUri);
                    assert_1.ok(this._documents.has(resource.toString()), "document '" + resource + "' does not exist");
                    assert_1.ok(!this._editors.has(data.id), "editor '" + data.id + "' already exists!");
                    var documentData = this._documents.get(resource.toString());
                    var editor = new extHostNotebookEditor_1.ExtHostNotebookEditor(this._mainContext.getProxy(sqlExtHost_protocol_1.SqlMainContext.MainThreadNotebookDocumentsAndEditors), data.id, documentData, typeConverters.ViewColumn.to(data.editorPosition));
                    this._editors.set(data.id, editor);
                }
            }
            if (delta.newActiveEditor !== undefined) {
                assert_1.ok(delta.newActiveEditor === null || this._editors.has(delta.newActiveEditor), "active editor '" + delta.newActiveEditor + "' does not exist");
                this._activeEditorId = delta.newActiveEditor;
            }
            lifecycle_1.dispose(removedDocuments);
            lifecycle_1.dispose(removedEditors);
            // now that the internal state is complete, fire events
            if (removedDocuments) {
                // TODO add doc close event
            }
            if (addedDocuments) {
                addedDocuments.forEach(function (d) { return _this._onDidOpenNotebook.fire(d.document); });
            }
            if (delta.removedEditors || delta.addedEditors) {
                this._onDidChangeVisibleNotebookEditors.fire(this.getAllEditors());
            }
            if (delta.newActiveEditor !== undefined) {
                this._onDidChangeActiveNotebookEditor.fire(this.getActiveEditor());
            }
        };
        ExtHostNotebookDocumentsAndEditors.prototype.$acceptModelChanged = function (uriComponents, e) {
            var uri = uri_1.default.revive(uriComponents);
            var strURL = uri.toString();
            var data = this._documents.get(strURL);
            if (data) {
                data.onModelChanged(e);
                this._onDidChangeNotebookCell.fire({
                    cells: data.document.cells,
                    notebook: data.document,
                    kind: undefined
                });
            }
        };
        //#endregion
        //#region Extension accessible methods
        ExtHostNotebookDocumentsAndEditors.prototype.showNotebookDocument = function (uri, showOptions) {
            return this.doShowNotebookDocument(uri, showOptions);
        };
        ExtHostNotebookDocumentsAndEditors.prototype.doShowNotebookDocument = function (uri, showOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var options, id, editor;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            options = {};
                            if (showOptions) {
                                options.preserveFocus = showOptions.preserveFocus;
                                options.preview = showOptions.preview;
                                options.position = showOptions.viewColumn;
                                options.providerId = showOptions.providerId;
                                options.connectionId = showOptions.connectionId;
                                options.defaultKernel = showOptions.defaultKernel;
                            }
                            return [4 /*yield*/, this._proxy.$tryShowNotebookDocument(uri, options)];
                        case 1:
                            id = _a.sent();
                            editor = this.getEditor(id);
                            if (editor) {
                                return [2 /*return*/, editor];
                            }
                            else {
                                throw new Error("Failed to show notebook document " + uri.toString() + ", should show in editor #" + id);
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        ExtHostNotebookDocumentsAndEditors.prototype.getDocument = function (strUrl) {
            return this._documents.get(strUrl);
        };
        ExtHostNotebookDocumentsAndEditors.prototype.getAllDocuments = function () {
            var result = [];
            this._documents.forEach(function (data) { return result.push(data); });
            return result;
        };
        ExtHostNotebookDocumentsAndEditors.prototype.getEditor = function (id) {
            return this._editors.get(id);
        };
        ExtHostNotebookDocumentsAndEditors.prototype.getActiveEditor = function () {
            if (!this._activeEditorId) {
                return undefined;
            }
            else {
                return this._editors.get(this._activeEditorId);
            }
        };
        ExtHostNotebookDocumentsAndEditors.prototype.getAllEditors = function () {
            var result = [];
            this._editors.forEach(function (data) { return result.push(data); });
            return result;
        };
        return ExtHostNotebookDocumentsAndEditors;
    }());
    exports.ExtHostNotebookDocumentsAndEditors = ExtHostNotebookDocumentsAndEditors;
});

define(__m[221/*vs/workbench/api/node/apiCommands*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,19/*vs/workbench/api/node/extHostTypeConverters*/,124/*vs/platform/commands/common/commands*/,10/*vs/base/common/platform*/]), function (require, exports, uri_1, typeConverters, commands_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function adjustHandler(handler) {
        return function (accessor) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return handler.apply(void 0, [accessor.get(commands_1.ICommandService)].concat(args));
        };
    }
    var PreviewHTMLAPICommand = /** @class */ (function () {
        function PreviewHTMLAPICommand() {
        }
        PreviewHTMLAPICommand.execute = function (executor, uri, position, label, options) {
            return executor.executeCommand('_workbench.previewHtml', uri, typeof position === 'number' && typeConverters.ViewColumn.from(position), label, options);
        };
        PreviewHTMLAPICommand.ID = 'vscode.previewHtml';
        return PreviewHTMLAPICommand;
    }());
    exports.PreviewHTMLAPICommand = PreviewHTMLAPICommand;
    commands_1.CommandsRegistry.registerCommand(PreviewHTMLAPICommand.ID, adjustHandler(PreviewHTMLAPICommand.execute));
    var OpenFolderAPICommand = /** @class */ (function () {
        function OpenFolderAPICommand() {
        }
        OpenFolderAPICommand.execute = function (executor, uri, forceNewWindow) {
            if (!uri) {
                return executor.executeCommand('_files.pickFolderAndOpen', forceNewWindow);
            }
            if (!uri.scheme || platform_1.isWindows && uri.scheme.match(/^[a-zA-Z]$/)) {
                // workaround for #55916 and #55891, will be removed in 1.28
                console.warn("'vscode.openFolder' command invoked with an invalid URI (file:// scheme missing): '" + uri + "'. Converted to a 'file://' URI.");
                uri = uri_1.default.file((uri.scheme ? uri.scheme + ':' : '') + uri.path);
            }
            return executor.executeCommand('_files.windowOpen', [uri], forceNewWindow);
        };
        OpenFolderAPICommand.ID = 'vscode.openFolder';
        return OpenFolderAPICommand;
    }());
    exports.OpenFolderAPICommand = OpenFolderAPICommand;
    commands_1.CommandsRegistry.registerCommand(OpenFolderAPICommand.ID, adjustHandler(OpenFolderAPICommand.execute));
    var DiffAPICommand = /** @class */ (function () {
        function DiffAPICommand() {
        }
        DiffAPICommand.execute = function (executor, left, right, label, options) {
            return executor.executeCommand('_workbench.diff', [
                left, right,
                label,
                undefined,
                typeConverters.TextEditorOptions.from(options),
                options ? typeConverters.ViewColumn.from(options.viewColumn) : undefined
            ]);
        };
        DiffAPICommand.ID = 'vscode.diff';
        return DiffAPICommand;
    }());
    exports.DiffAPICommand = DiffAPICommand;
    commands_1.CommandsRegistry.registerCommand(DiffAPICommand.ID, adjustHandler(DiffAPICommand.execute));
    var OpenAPICommand = /** @class */ (function () {
        function OpenAPICommand() {
        }
        OpenAPICommand.execute = function (executor, resource, columnOrOptions) {
            var options;
            var position;
            if (columnOrOptions) {
                if (typeof columnOrOptions === 'number') {
                    position = typeConverters.ViewColumn.from(columnOrOptions);
                }
                else {
                    options = typeConverters.TextEditorOptions.from(columnOrOptions);
                    position = typeConverters.ViewColumn.from(columnOrOptions.viewColumn);
                }
            }
            return executor.executeCommand('_workbench.open', [
                resource,
                options,
                position
            ]);
        };
        OpenAPICommand.ID = 'vscode.open';
        return OpenAPICommand;
    }());
    exports.OpenAPICommand = OpenAPICommand;
    commands_1.CommandsRegistry.registerCommand(OpenAPICommand.ID, adjustHandler(OpenAPICommand.execute));
    var RemoveFromRecentlyOpenedAPICommand = /** @class */ (function () {
        function RemoveFromRecentlyOpenedAPICommand() {
        }
        RemoveFromRecentlyOpenedAPICommand.execute = function (executor, path) {
            return executor.executeCommand('_workbench.removeFromRecentlyOpened', path);
        };
        RemoveFromRecentlyOpenedAPICommand.ID = 'vscode.removeFromRecentlyOpened';
        return RemoveFromRecentlyOpenedAPICommand;
    }());
    exports.RemoveFromRecentlyOpenedAPICommand = RemoveFromRecentlyOpenedAPICommand;
    commands_1.CommandsRegistry.registerCommand(RemoveFromRecentlyOpenedAPICommand.ID, adjustHandler(RemoveFromRecentlyOpenedAPICommand.execute));
    var SetEditorLayoutAPICommand = /** @class */ (function () {
        function SetEditorLayoutAPICommand() {
        }
        SetEditorLayoutAPICommand.execute = function (executor, layout) {
            return executor.executeCommand('layoutEditorGroups', layout);
        };
        SetEditorLayoutAPICommand.ID = 'vscode.setEditorLayout';
        return SetEditorLayoutAPICommand;
    }());
    exports.SetEditorLayoutAPICommand = SetEditorLayoutAPICommand;
    commands_1.CommandsRegistry.registerCommand(SetEditorLayoutAPICommand.ID, adjustHandler(SetEditorLayoutAPICommand.execute));
});

define(__m[222/*vs/workbench/api/node/extHostApiCommands*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,2/*vs/base/common/winjs.base*/,19/*vs/workbench/api/node/extHostTypeConverters*/,5/*vs/workbench/api/node/extHostTypes*/,221/*vs/workbench/api/node/apiCommands*/,13/*vs/base/common/arrays*/]), function (require, exports, uri_1, winjs_base_1, typeConverters, types, apiCommands_1, arrays_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostApiCommands = /** @class */ (function () {
        function ExtHostApiCommands(commands) {
            this._disposables = [];
            this._commands = commands;
        }
        ExtHostApiCommands.register = function (commands) {
            return new ExtHostApiCommands(commands).registerCommands();
        };
        ExtHostApiCommands.prototype.registerCommands = function () {
            var _this = this;
            this._register('vscode.executeWorkspaceSymbolProvider', this._executeWorkspaceSymbolProvider, {
                description: 'Execute all workspace symbol provider.',
                args: [{ name: 'query', description: 'Search string', constraint: String }],
                returns: 'A promise that resolves to an array of SymbolInformation-instances.'
            });
            this._register('vscode.executeDefinitionProvider', this._executeDefinitionProvider, {
                description: 'Execute all definition provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instances.'
            });
            this._register('vscode.executeTypeDefinitionProvider', this._executeTypeDefinitionProvider, {
                description: 'Execute all type definition providers.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instances.'
            });
            this._register('vscode.executeImplementationProvider', this._executeImplementationProvider, {
                description: 'Execute all implementation providers.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instance.'
            });
            this._register('vscode.executeHoverProvider', this._executeHoverProvider, {
                description: 'Execute all hover provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Hover-instances.'
            });
            this._register('vscode.executeDocumentHighlights', this._executeDocumentHighlights, {
                description: 'Execute document highlight provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of DocumentHighlight-instances.'
            });
            this._register('vscode.executeReferenceProvider', this._executeReferenceProvider, {
                description: 'Execute reference provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instances.'
            });
            this._register('vscode.executeDocumentRenameProvider', this._executeDocumentRenameProvider, {
                description: 'Execute rename provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'newName', description: 'The new symbol name', constraint: String }
                ],
                returns: 'A promise that resolves to a WorkspaceEdit.'
            });
            this._register('vscode.executeSignatureHelpProvider', this._executeSignatureHelpProvider, {
                description: 'Execute signature help provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'triggerCharacter', description: '(optional) Trigger signature help when the user types the character, like `,` or `(`', constraint: function (value) { return value === void 0 || typeof value === 'string'; } }
                ],
                returns: 'A promise that resolves to SignatureHelp.'
            });
            this._register('vscode.executeDocumentSymbolProvider', this._executeDocumentSymbolProvider, {
                description: 'Execute document symbol provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default }
                ],
                returns: 'A promise that resolves to an array of SymbolInformation-instances.'
            });
            this._register('vscode.executeCompletionItemProvider', this._executeCompletionItemProvider, {
                description: 'Execute completion item provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'triggerCharacter', description: '(optional) Trigger completion when the user types the character, like `,` or `(`', constraint: function (value) { return value === void 0 || typeof value === 'string'; } },
                    { name: 'itemResolveCount', description: '(optional) Number of completions to resolve (too large numbers slow down completions)', constraint: function (value) { return value === void 0 || typeof value === 'number'; } }
                ],
                returns: 'A promise that resolves to a CompletionList-instance.'
            });
            this._register('vscode.executeCodeActionProvider', this._executeCodeActionProvider, {
                description: 'Execute code action provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'range', description: 'Range in a text document', constraint: types.Range }
                ],
                returns: 'A promise that resolves to an array of Command-instances.'
            });
            this._register('vscode.executeCodeLensProvider', this._executeCodeLensProvider, {
                description: 'Execute CodeLens provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'itemResolveCount', description: '(optional) Number of lenses that should be resolved and returned. Will only retrun resolved lenses, will impact performance)', constraint: function (value) { return value === void 0 || typeof value === 'number'; } }
                ],
                returns: 'A promise that resolves to an array of CodeLens-instances.'
            });
            this._register('vscode.executeFormatDocumentProvider', this._executeFormatDocumentProvider, {
                description: 'Execute document format provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'options', description: 'Formatting options' }
                ],
                returns: 'A promise that resolves to an array of TextEdits.'
            });
            this._register('vscode.executeFormatRangeProvider', this._executeFormatRangeProvider, {
                description: 'Execute range format provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'range', description: 'Range in a text document', constraint: types.Range },
                    { name: 'options', description: 'Formatting options' }
                ],
                returns: 'A promise that resolves to an array of TextEdits.'
            });
            this._register('vscode.executeFormatOnTypeProvider', this._executeFormatOnTypeProvider, {
                description: 'Execute document format provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'ch', description: 'Character that got typed', constraint: String },
                    { name: 'options', description: 'Formatting options' }
                ],
                returns: 'A promise that resolves to an array of TextEdits.'
            });
            this._register('vscode.executeLinkProvider', this._executeDocumentLinkProvider, {
                description: 'Execute document link provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default }
                ],
                returns: 'A promise that resolves to an array of DocumentLink-instances.'
            });
            this._register('vscode.executeDocumentColorProvider', this._executeDocumentColorProvider, {
                description: 'Execute document color provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                ],
                returns: 'A promise that resolves to an array of ColorInformation objects.'
            });
            this._register('vscode.executeColorPresentationProvider', this._executeColorPresentationProvider, {
                description: 'Execute color presentation provider.',
                args: [
                    { name: 'color', description: 'The color to show and insert', constraint: types.Color },
                    { name: 'context', description: 'Context object with uri and range' }
                ],
                returns: 'A promise that resolves to an array of ColorPresentation objects.'
            });
            var adjustHandler = function (handler) {
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return handler.apply(void 0, [_this._commands].concat(args));
                };
            };
            this._register(apiCommands_1.PreviewHTMLAPICommand.ID, adjustHandler(apiCommands_1.PreviewHTMLAPICommand.execute), {
                description: "\n\t\t\t\t\tRender the HTML of the resource in an editor view.\n\n\t\t\t\t\tSee [working with the HTML preview](https://code.visualstudio.com/docs/extensionAPI/vscode-api-commands#working-with-the-html-preview) for more information about the HTML preview's integration with the editor and for best practices for extension authors.\n\t\t\t\t",
                args: [
                    { name: 'uri', description: 'Uri of the resource to preview.', constraint: function (value) { return value instanceof uri_1.default || typeof value === 'string'; } },
                    { name: 'column', description: '(optional) Column in which to preview.', constraint: function (value) { return typeof value === 'undefined' || (typeof value === 'number' && typeof types.ViewColumn[value] === 'string'); } },
                    { name: 'label', description: '(optional) An human readable string that is used as title for the preview.', constraint: function (v) { return typeof v === 'string' || typeof v === 'undefined'; } },
                    { name: 'options', description: '(optional) Options for controlling webview environment.', constraint: function (v) { return typeof v === 'object' || typeof v === 'undefined'; } }
                ]
            });
            this._register(apiCommands_1.OpenFolderAPICommand.ID, adjustHandler(apiCommands_1.OpenFolderAPICommand.execute), {
                description: 'Open a folder or workspace in the current window or new window depending on the newWindow argument. Note that opening in the same window will shutdown the current extension host process and start a new one on the given folder/workspace unless the newWindow parameter is set to true.',
                args: [
                    { name: 'uri', description: '(optional) Uri of the folder or workspace file to open. If not provided, a native dialog will ask the user for the folder', constraint: function (value) { return value === void 0 || value instanceof uri_1.default; } },
                    { name: 'newWindow', description: '(optional) Whether to open the folder/workspace in a new window or the same. Defaults to opening in the same window.', constraint: function (value) { return value === void 0 || typeof value === 'boolean'; } }
                ]
            });
            this._register(apiCommands_1.DiffAPICommand.ID, adjustHandler(apiCommands_1.DiffAPICommand.execute), {
                description: 'Opens the provided resources in the diff editor to compare their contents.',
                args: [
                    { name: 'left', description: 'Left-hand side resource of the diff editor', constraint: uri_1.default },
                    { name: 'right', description: 'Right-hand side resource of the diff editor', constraint: uri_1.default },
                    { name: 'title', description: '(optional) Human readable title for the diff editor', constraint: function (v) { return v === void 0 || typeof v === 'string'; } },
                    { name: 'options', description: '(optional) Editor options, see vscode.TextDocumentShowOptions' }
                ]
            });
            this._register(apiCommands_1.OpenAPICommand.ID, adjustHandler(apiCommands_1.OpenAPICommand.execute), {
                description: 'Opens the provided resource in the editor. Can be a text or binary file, or a http(s) url. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.',
                args: [
                    { name: 'resource', description: 'Resource to open', constraint: uri_1.default },
                    { name: 'columnOrOptions', description: '(optional) Either the column in which to open or editor options, see vscode.TextDocumentShowOptions', constraint: function (v) { return v === void 0 || typeof v === 'number' || typeof v === 'object'; } }
                ]
            });
            this._register(apiCommands_1.RemoveFromRecentlyOpenedAPICommand.ID, adjustHandler(apiCommands_1.RemoveFromRecentlyOpenedAPICommand.execute), {
                description: 'Removes an entry with the given path from the recently opened list.',
                args: [
                    { name: 'path', description: 'Path to remove from recently opened.', constraint: function (value) { return typeof value === 'string'; } }
                ]
            });
            this._register(apiCommands_1.SetEditorLayoutAPICommand.ID, adjustHandler(apiCommands_1.SetEditorLayoutAPICommand.execute), {
                description: 'Sets the editor layout. The layout is described as object with an initial (optional) orientation (0 = horizontal, 1 = vertical) and an array of editor groups within. Each editor group can have a size and another array of editor groups that will be laid out orthogonal to the orientation. If editor group sizes are provided, their sum must be 1 to be applied per row or column. Example for a 2x2 grid: `{ orientation: 0, groups: [{ groups: [{}, {}], size: 0.5 }, { groups: [{}, {}], size: 0.5 }] }`',
                args: [
                    { name: 'layout', description: 'The editor layout to set.', constraint: function (value) { return typeof value === 'object' && Array.isArray(value.groups); } }
                ]
            });
        };
        // --- command impl
        ExtHostApiCommands.prototype._register = function (id, handler, description) {
            var disposable = this._commands.registerCommand(false, id, handler, this, description);
            this._disposables.push(disposable);
        };
        /**
         * Execute workspace symbol provider.
         *
         * @param query Search string to match query symbol names
         * @return A promise that resolves to an array of symbol information.
         */
        ExtHostApiCommands.prototype._executeWorkspaceSymbolProvider = function (query) {
            return this._commands.executeCommand('_executeWorkspaceSymbolProvider', { query: query }).then(function (value) {
                var result = [];
                if (Array.isArray(value)) {
                    for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                        var tuple = value_1[_i];
                        result.push.apply(result, tuple[1].map(typeConverters.WorkspaceSymbol.to));
                    }
                }
                return result;
            });
        };
        ExtHostApiCommands.prototype._executeDefinitionProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position)
            };
            return this._commands.executeCommand('_executeDefinitionProvider', args)
                .then(tryMapWith(typeConverters.location.to));
        };
        ExtHostApiCommands.prototype._executeTypeDefinitionProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position)
            };
            return this._commands.executeCommand('_executeTypeDefinitionProvider', args)
                .then(tryMapWith(typeConverters.location.to));
        };
        ExtHostApiCommands.prototype._executeImplementationProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position)
            };
            return this._commands.executeCommand('_executeImplementationProvider', args)
                .then(tryMapWith(typeConverters.location.to));
        };
        ExtHostApiCommands.prototype._executeHoverProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position)
            };
            return this._commands.executeCommand('_executeHoverProvider', args)
                .then(tryMapWith(typeConverters.Hover.to));
        };
        ExtHostApiCommands.prototype._executeDocumentHighlights = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position)
            };
            return this._commands.executeCommand('_executeDocumentHighlights', args)
                .then(tryMapWith(typeConverters.DocumentHighlight.to));
        };
        ExtHostApiCommands.prototype._executeReferenceProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position)
            };
            return this._commands.executeCommand('_executeReferenceProvider', args)
                .then(tryMapWith(typeConverters.location.to));
        };
        ExtHostApiCommands.prototype._executeDocumentRenameProvider = function (resource, position, newName) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position),
                newName: newName
            };
            return this._commands.executeCommand('_executeDocumentRenameProvider', args).then(function (value) {
                if (!value) {
                    return undefined;
                }
                if (value.rejectReason) {
                    return winjs_base_1.TPromise.wrapError(new Error(value.rejectReason));
                }
                return typeConverters.WorkspaceEdit.to(value);
            });
        };
        ExtHostApiCommands.prototype._executeSignatureHelpProvider = function (resource, position, triggerCharacter) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position),
                triggerCharacter: triggerCharacter
            };
            return this._commands.executeCommand('_executeSignatureHelpProvider', args).then(function (value) {
                if (value) {
                    return typeConverters.SignatureHelp.to(value);
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeCompletionItemProvider = function (resource, position, triggerCharacter, maxItemsToResolve) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position),
                triggerCharacter: triggerCharacter,
                maxItemsToResolve: maxItemsToResolve
            };
            return this._commands.executeCommand('_executeCompletionItemProvider', args).then(function (result) {
                if (result) {
                    var items = result.suggestions.map(function (suggestion) { return typeConverters.Suggest.to(position, suggestion); });
                    // {{SQL CARBON EDIT}}
                    return new types.CompletionList(items, result.incomplete);
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeDocumentColorProvider = function (resource) {
            var args = {
                resource: resource
            };
            return this._commands.executeCommand('_executeDocumentColorProvider', args).then(function (result) {
                if (result) {
                    return result.map(function (ci) { return ({ range: typeConverters.Range.to(ci.range), color: typeConverters.Color.to(ci.color) }); });
                }
                return [];
            });
        };
        ExtHostApiCommands.prototype._executeColorPresentationProvider = function (color, context) {
            var args = {
                resource: context.uri,
                color: typeConverters.Color.from(color),
                range: typeConverters.Range.from(context.range),
            };
            return this._commands.executeCommand('_executeColorPresentationProvider', args).then(function (result) {
                if (result) {
                    return result.map(typeConverters.ColorPresentation.to);
                }
                return [];
            });
        };
        ExtHostApiCommands.prototype._executeDocumentSymbolProvider = function (resource) {
            var args = {
                resource: resource
            };
            return this._commands.executeCommand('_executeDocumentSymbolProvider', args).then(function (value) {
                if (arrays_1.isFalsyOrEmpty(value)) {
                    return undefined;
                }
                var result = [];
                for (var _i = 0, value_2 = value; _i < value_2.length; _i++) {
                    var symbol = value_2[_i];
                    result.push(new types.SymbolInformation(symbol.name, typeConverters.SymbolKind.to(symbol.kind), symbol.containerName, new types.Location(resource, typeConverters.Range.to(symbol.range))));
                }
                return result;
            });
        };
        ExtHostApiCommands.prototype._executeCodeActionProvider = function (resource, range) {
            var _this = this;
            var args = {
                resource: resource,
                range: typeConverters.Range.from(range)
            };
            return this._commands.executeCommand('_executeCodeActionProvider', args)
                .then(tryMapWith(function (codeAction) {
                if (codeAction._isSynthetic) {
                    return _this._commands.converter.fromInternal(codeAction.command);
                }
                else {
                    var ret = new types.CodeAction(codeAction.title, codeAction.kind ? new types.CodeActionKind(codeAction.kind) : undefined);
                    if (codeAction.edit) {
                        ret.edit = typeConverters.WorkspaceEdit.to(codeAction.edit);
                    }
                    if (codeAction.command) {
                        ret.command = _this._commands.converter.fromInternal(codeAction.command);
                    }
                    return ret;
                }
            }));
        };
        ExtHostApiCommands.prototype._executeCodeLensProvider = function (resource, itemResolveCount) {
            var _this = this;
            var args = { resource: resource, itemResolveCount: itemResolveCount };
            return this._commands.executeCommand('_executeCodeLensProvider', args)
                .then(tryMapWith(function (item) {
                return new types.CodeLens(typeConverters.Range.to(item.range), _this._commands.converter.fromInternal(item.command));
            }));
        };
        ExtHostApiCommands.prototype._executeFormatDocumentProvider = function (resource, options) {
            var args = {
                resource: resource,
                options: options
            };
            return this._commands.executeCommand('_executeFormatDocumentProvider', args)
                .then(tryMapWith(function (edit) { return new types.TextEdit(typeConverters.Range.to(edit.range), edit.text); }));
        };
        ExtHostApiCommands.prototype._executeFormatRangeProvider = function (resource, range, options) {
            var args = {
                resource: resource,
                range: typeConverters.Range.from(range),
                options: options
            };
            return this._commands.executeCommand('_executeFormatRangeProvider', args)
                .then(tryMapWith(function (edit) { return new types.TextEdit(typeConverters.Range.to(edit.range), edit.text); }));
        };
        ExtHostApiCommands.prototype._executeFormatOnTypeProvider = function (resource, position, ch, options) {
            var args = {
                resource: resource,
                position: typeConverters.Position.from(position),
                ch: ch,
                options: options
            };
            return this._commands.executeCommand('_executeFormatOnTypeProvider', args)
                .then(tryMapWith(function (edit) { return new types.TextEdit(typeConverters.Range.to(edit.range), edit.text); }));
        };
        ExtHostApiCommands.prototype._executeDocumentLinkProvider = function (resource) {
            return this._commands.executeCommand('_executeLinkProvider', resource)
                .then(tryMapWith(typeConverters.DocumentLink.to));
        };
        return ExtHostApiCommands;
    }());
    exports.ExtHostApiCommands = ExtHostApiCommands;
    function tryMapWith(f) {
        return function (value) {
            if (Array.isArray(value)) {
                return value.map(f);
            }
            return undefined;
        };
    }
});

define(__m[223/*vs/workbench/api/node/extHostCommands*/], __M([0/*require*/,1/*exports*/,18/*vs/base/common/types*/,5/*vs/workbench/api/node/extHostTypes*/,19/*vs/workbench/api/node/extHostTypeConverters*/,20/*vs/base/common/objects*/,6/*vs/workbench/api/node/extHost.protocol*/,13/*vs/base/common/arrays*/,102/*vs/base/common/marshalling*/]), function (require, exports, types_1, extHostTypes, extHostTypeConverter, objects_1, extHost_protocol_1, arrays_1, marshalling_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostCommands = /** @class */ (function () {
        function ExtHostCommands(mainContext, heapService, logService) {
            this._commands = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadCommands);
            this._logService = logService;
            this._converter = new CommandsConverter(this, heapService);
            this._argumentProcessors = [{ processArgument: function (a) { return marshalling_1.revive(a, 0); } }];
        }
        Object.defineProperty(ExtHostCommands.prototype, "converter", {
            get: function () {
                return this._converter;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostCommands.prototype.registerArgumentProcessor = function (processor) {
            this._argumentProcessors.push(processor);
        };
        ExtHostCommands.prototype.registerCommand = function (global, id, callback, thisArg, description) {
            var _this = this;
            this._logService.trace('ExtHostCommands#registerCommand', id);
            if (!id.trim().length) {
                throw new Error('invalid id');
            }
            if (this._commands.has(id)) {
                throw new Error("command '" + id + "' already exists");
            }
            this._commands.set(id, { callback: callback, thisArg: thisArg, description: description });
            if (global) {
                this._proxy.$registerCommand(id);
            }
            return new extHostTypes.Disposable(function () {
                if (_this._commands.delete(id)) {
                    if (global) {
                        _this._proxy.$unregisterCommand(id);
                    }
                }
            });
        };
        ExtHostCommands.prototype.executeCommand = function (id) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            this._logService.trace('ExtHostCommands#executeCommand', id);
            if (this._commands.has(id)) {
                // we stay inside the extension host and support
                // to pass any kind of parameters around
                return this._executeContributedCommand(id, args);
            }
            else {
                // automagically convert some argument types
                args = objects_1.cloneAndChange(args, function (value) {
                    if (value instanceof extHostTypes.Position) {
                        return extHostTypeConverter.Position.from(value);
                    }
                    if (value instanceof extHostTypes.Range) {
                        return extHostTypeConverter.Range.from(value);
                    }
                    if (value instanceof extHostTypes.Location) {
                        return extHostTypeConverter.location.from(value);
                    }
                    if (!Array.isArray(value)) {
                        return value;
                    }
                });
                return this._proxy.$executeCommand(id, args).then(function (result) { return marshalling_1.revive(result, 0); });
            }
        };
        ExtHostCommands.prototype._executeContributedCommand = function (id, args) {
            var _a = this._commands.get(id), callback = _a.callback, thisArg = _a.thisArg, description = _a.description;
            if (description) {
                for (var i = 0; i < description.args.length; i++) {
                    try {
                        types_1.validateConstraint(args[i], description.args[i].constraint);
                    }
                    catch (err) {
                        // {{ SQL CARBON EDIT }} - Add type assertion to fix build break
                        return Promise.reject(new Error("Running the contributed command:'" + id + "' failed. Illegal argument '" + description.args[i].name + "' - " + description.args[i].description));
                    }
                }
            }
            try {
                var result = callback.apply(thisArg, args);
                return Promise.resolve(result);
            }
            catch (err) {
                this._logService.error(err, id);
                // {{ SQL CARBON EDIT }} - Add type assertion to fix build break
                return Promise.reject(new Error("Running the contributed command:'" + id + "' failed."));
            }
        };
        ExtHostCommands.prototype.$executeContributedCommand = function (id) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            this._logService.trace('ExtHostCommands#$executeContributedCommand', id);
            if (!this._commands.has(id)) {
                // {{ SQL CARBON EDIT }} - Add type assertion to fix build break
                return Promise.reject(new Error("Contributed command '" + id + "' does not exist."));
            }
            else {
                args = args.map(function (arg) { return _this._argumentProcessors.reduce(function (r, p) { return p.processArgument(r); }, arg); });
                return this._executeContributedCommand(id, args);
            }
        };
        ExtHostCommands.prototype.getCommands = function (filterUnderscoreCommands) {
            if (filterUnderscoreCommands === void 0) { filterUnderscoreCommands = false; }
            this._logService.trace('ExtHostCommands#getCommands', filterUnderscoreCommands);
            return this._proxy.$getCommands().then(function (result) {
                if (filterUnderscoreCommands) {
                    result = result.filter(function (command) { return command[0] !== '_'; });
                }
                return result;
            });
        };
        ExtHostCommands.prototype.$getContributedCommandHandlerDescriptions = function () {
            var result = Object.create(null);
            this._commands.forEach(function (command, id) {
                var description = command.description;
                if (description) {
                    result[id] = description;
                }
            });
            return Promise.resolve(result);
        };
        return ExtHostCommands;
    }());
    exports.ExtHostCommands = ExtHostCommands;
    var CommandsConverter = /** @class */ (function () {
        // --- conversion between internal and api commands
        function CommandsConverter(commands, heap) {
            this._delegatingCommandId = "_internal_command_delegation_" + Date.now();
            this._commands = commands;
            this._heap = heap;
            this._commands.registerCommand(true, this._delegatingCommandId, this._executeConvertedCommand, this);
        }
        CommandsConverter.prototype.toInternal = function (command) {
            if (!command) {
                return undefined;
            }
            var result = {
                id: command.command,
                title: command.title
            };
            if (command.command && !arrays_1.isFalsyOrEmpty(command.arguments)) {
                // we have a contributed command with arguments. that
                // means we don't want to send the arguments around
                var id = this._heap.keep(command);
                extHost_protocol_1.ObjectIdentifier.mixin(result, id);
                result.id = this._delegatingCommandId;
                result.arguments = [id];
            }
            if (command.tooltip) {
                result.tooltip = command.tooltip;
            }
            return result;
        };
        CommandsConverter.prototype.fromInternal = function (command) {
            if (!command) {
                return undefined;
            }
            var id = extHost_protocol_1.ObjectIdentifier.of(command);
            if (typeof id === 'number') {
                return this._heap.get(id);
            }
            else {
                return {
                    command: command.id,
                    title: command.title,
                    arguments: command.arguments
                };
            }
        };
        CommandsConverter.prototype._executeConvertedCommand = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _a;
            var actualCmd = this._heap.get(args[0]);
            return (_a = this._commands).executeCommand.apply(_a, [actualCmd.command].concat(actualCmd.arguments));
        };
        return CommandsConverter;
    }());
    exports.CommandsConverter = CommandsConverter;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[224/*vs/workbench/api/node/extHostComments*/], __M([0/*require*/,1/*exports*/,12/*vs/base/common/async*/,4/*vs/base/common/uri*/,2/*vs/base/common/winjs.base*/,19/*vs/workbench/api/node/extHostTypeConverters*/,6/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, async_1, uri_1, winjs_base_1, extHostTypeConverter, extHost_protocol_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostComments = /** @class */ (function () {
        function ExtHostComments(mainContext, _commandsConverter, _documents) {
            this._commandsConverter = _commandsConverter;
            this._documents = _documents;
            this._documentProviders = new Map();
            this._workspaceProviders = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadComments);
        }
        ExtHostComments.prototype.registerWorkspaceCommentProvider = function (provider) {
            var _this = this;
            var handle = ExtHostComments.handlePool++;
            this._workspaceProviders.set(handle, provider);
            this._proxy.$registerWorkspaceCommentProvider(handle);
            this.registerListeners(handle, provider);
            return {
                dispose: function () {
                    _this._proxy.$unregisterWorkspaceCommentProvider(handle);
                    _this._workspaceProviders.delete(handle);
                }
            };
        };
        ExtHostComments.prototype.registerDocumentCommentProvider = function (provider) {
            var _this = this;
            var handle = ExtHostComments.handlePool++;
            this._documentProviders.set(handle, provider);
            this._proxy.$registerDocumentCommentProvider(handle);
            this.registerListeners(handle, provider);
            return {
                dispose: function () {
                    _this._proxy.$unregisterDocumentCommentProvider(handle);
                    _this._documentProviders.delete(handle);
                }
            };
        };
        ExtHostComments.prototype.$createNewCommentThread = function (handle, uri, range, text) {
            var _this = this;
            var data = this._documents.getDocumentData(uri_1.default.revive(uri));
            var ran = extHostTypeConverter.Range.to(range);
            if (!data || !data.document) {
                return winjs_base_1.TPromise.as(null);
            }
            return async_1.asWinJsPromise(function (token) {
                var provider = _this._documentProviders.get(handle);
                return provider.createNewCommentThread(data.document, ran, text, token);
            }).then(function (commentThread) { return commentThread ? convertToCommentThread(commentThread, _this._commandsConverter) : null; });
        };
        ExtHostComments.prototype.$replyToCommentThread = function (handle, uri, range, thread, text) {
            var _this = this;
            var data = this._documents.getDocumentData(uri_1.default.revive(uri));
            var ran = extHostTypeConverter.Range.to(range);
            if (!data || !data.document) {
                return winjs_base_1.TPromise.as(null);
            }
            return async_1.asWinJsPromise(function (token) {
                var provider = _this._documentProviders.get(handle);
                return provider.replyToCommentThread(data.document, ran, convertFromCommentThread(thread), text, token);
            }).then(function (commentThread) { return commentThread ? convertToCommentThread(commentThread, _this._commandsConverter) : null; });
        };
        ExtHostComments.prototype.$provideDocumentComments = function (handle, uri) {
            var _this = this;
            var data = this._documents.getDocumentData(uri_1.default.revive(uri));
            if (!data || !data.document) {
                return winjs_base_1.TPromise.as(null);
            }
            return async_1.asWinJsPromise(function (token) {
                var provider = _this._documentProviders.get(handle);
                return provider.provideDocumentComments(data.document, token);
            })
                .then(function (commentInfo) { return commentInfo ? convertCommentInfo(handle, commentInfo, _this._commandsConverter) : null; });
        };
        ExtHostComments.prototype.$provideWorkspaceComments = function (handle) {
            var _this = this;
            var provider = this._workspaceProviders.get(handle);
            if (!provider) {
                return winjs_base_1.TPromise.as(null);
            }
            return async_1.asWinJsPromise(function (token) {
                return provider.provideWorkspaceComments(token);
            }).then(function (comments) {
                return comments.map(function (x) { return convertToCommentThread(x, _this._commandsConverter); });
            });
        };
        ExtHostComments.prototype.registerListeners = function (handle, provider) {
            var _this = this;
            provider.onDidChangeCommentThreads(function (event) {
                _this._proxy.$onDidCommentThreadsChange(handle, {
                    owner: handle,
                    changed: event.changed.map(function (x) { return convertToCommentThread(x, _this._commandsConverter); }),
                    added: event.added.map(function (x) { return convertToCommentThread(x, _this._commandsConverter); }),
                    removed: event.removed.map(function (x) { return convertToCommentThread(x, _this._commandsConverter); })
                });
            });
        };
        ExtHostComments.handlePool = 0;
        return ExtHostComments;
    }());
    exports.ExtHostComments = ExtHostComments;
    function convertCommentInfo(owner, vscodeCommentInfo, commandsConverter) {
        return {
            owner: owner,
            threads: vscodeCommentInfo.threads.map(function (x) { return convertToCommentThread(x, commandsConverter); }),
            commentingRanges: vscodeCommentInfo.commentingRanges ? vscodeCommentInfo.commentingRanges.map(function (range) { return extHostTypeConverter.Range.from(range); }) : []
        };
    }
    function convertToCommentThread(vscodeCommentThread, commandsConverter) {
        return {
            threadId: vscodeCommentThread.threadId,
            resource: vscodeCommentThread.resource.toString(),
            range: extHostTypeConverter.Range.from(vscodeCommentThread.range),
            comments: vscodeCommentThread.comments.map(function (comment) { return convertToComment(comment, commandsConverter); }),
            collapsibleState: vscodeCommentThread.collapsibleState
        };
    }
    function convertFromCommentThread(commentThread) {
        return {
            threadId: commentThread.threadId,
            resource: uri_1.default.parse(commentThread.resource),
            range: extHostTypeConverter.Range.to(commentThread.range),
            comments: commentThread.comments.map(convertFromComment),
            collapsibleState: commentThread.collapsibleState
        };
    }
    function convertFromComment(comment) {
        return {
            commentId: comment.commentId,
            body: extHostTypeConverter.MarkdownString.to(comment.body),
            userName: comment.userName,
            gravatar: comment.gravatar
        };
    }
    function convertToComment(vscodeComment, commandsConverter) {
        return {
            commentId: vscodeComment.commentId,
            body: extHostTypeConverter.MarkdownString.from(vscodeComment.body),
            userName: vscodeComment.userName,
            gravatar: vscodeComment.gravatar,
            command: vscodeComment.command ? commandsConverter.toInternal(vscodeComment.command) : null
        };
    }
});











define(__m[225/*vs/workbench/api/node/extHostDiagnostics*/], __M([0/*require*/,1/*exports*/,107/*vs/nls!vs/workbench/api/node/extHostDiagnostics*/,64/*vs/platform/markers/common/markers*/,4/*vs/base/common/uri*/,6/*vs/workbench/api/node/extHost.protocol*/,5/*vs/workbench/api/node/extHostTypes*/,19/*vs/workbench/api/node/extHostTypeConverters*/,13/*vs/base/common/arrays*/,3/*vs/base/common/event*/,21/*vs/base/common/map*/]), function (require, exports, nls_1, markers_1, uri_1, extHost_protocol_1, extHostTypes_1, converter, arrays_1, event_1, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var DiagnosticCollection = /** @class */ (function () {
        function DiagnosticCollection(name, owner, maxDiagnosticsPerFile, proxy, onDidChangeDiagnostics) {
            this._isDisposed = false;
            this._data = new Map();
            this._name = name;
            this._owner = owner;
            this._maxDiagnosticsPerFile = maxDiagnosticsPerFile;
            this._proxy = proxy;
            this._onDidChangeDiagnostics = onDidChangeDiagnostics;
        }
        DiagnosticCollection.prototype.dispose = function () {
            if (!this._isDisposed) {
                this._onDidChangeDiagnostics.fire(map_1.keys(this._data));
                this._proxy.$clear(this._owner);
                this._data = undefined;
                this._isDisposed = true;
            }
        };
        Object.defineProperty(DiagnosticCollection.prototype, "name", {
            get: function () {
                this._checkDisposed();
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        DiagnosticCollection.prototype.set = function (first, diagnostics) {
            var _a;
            if (!first) {
                // this set-call is a clear-call
                this.clear();
                return;
            }
            // the actual implementation for #set
            this._checkDisposed();
            var toSync;
            if (first instanceof uri_1.default) {
                if (!diagnostics) {
                    // remove this entry
                    this.delete(first);
                    return;
                }
                // update single row
                this._data.set(first.toString(), diagnostics);
                toSync = [first];
            }
            else if (Array.isArray(first)) {
                // update many rows
                toSync = [];
                var lastUri = void 0;
                // ensure stable-sort
                arrays_1.mergeSort(first, DiagnosticCollection._compareIndexedTuplesByUri);
                for (var _i = 0, first_1 = first; _i < first_1.length; _i++) {
                    var tuple = first_1[_i];
                    var uri = tuple[0], diagnostics_2 = tuple[1];
                    if (!lastUri || uri.toString() !== lastUri.toString()) {
                        if (lastUri && this._data.get(lastUri.toString()).length === 0) {
                            this._data.delete(lastUri.toString());
                        }
                        lastUri = uri;
                        toSync.push(uri);
                        this._data.set(uri.toString(), []);
                    }
                    if (!diagnostics_2) {
                        // [Uri, undefined] means clear this
                        this._data.get(uri.toString()).length = 0;
                    }
                    else {
                        (_a = this._data.get(uri.toString())).push.apply(_a, diagnostics_2);
                    }
                }
            }
            // compute change and send to main side
            var entries = [];
            for (var _b = 0, toSync_1 = toSync; _b < toSync_1.length; _b++) {
                var uri = toSync_1[_b];
                var marker = void 0;
                var diagnostics_3 = this._data.get(uri.toString());
                if (diagnostics_3) {
                    // no more than N diagnostics per file
                    if (diagnostics_3.length > this._maxDiagnosticsPerFile) {
                        marker = [];
                        var order = [extHostTypes_1.DiagnosticSeverity.Error, extHostTypes_1.DiagnosticSeverity.Warning, extHostTypes_1.DiagnosticSeverity.Information, extHostTypes_1.DiagnosticSeverity.Hint];
                        orderLoop: for (var i = 0; i < 4; i++) {
                            for (var _c = 0, diagnostics_1 = diagnostics_3; _c < diagnostics_1.length; _c++) {
                                var diagnostic = diagnostics_1[_c];
                                if (diagnostic.severity === order[i]) {
                                    var len = marker.push(converter.Diagnostic.from(diagnostic));
                                    if (len === this._maxDiagnosticsPerFile) {
                                        break orderLoop;
                                    }
                                }
                            }
                        }
                        // add 'signal' marker for showing omitted errors/warnings
                        marker.push({
                            severity: markers_1.MarkerSeverity.Info,
                            message: nls_1.localize(0, null, diagnostics_3.length - this._maxDiagnosticsPerFile),
                            startLineNumber: marker[marker.length - 1].startLineNumber,
                            startColumn: marker[marker.length - 1].startColumn,
                            endLineNumber: marker[marker.length - 1].endLineNumber,
                            endColumn: marker[marker.length - 1].endColumn
                        });
                    }
                    else {
                        marker = diagnostics_3.map(converter.Diagnostic.from);
                    }
                }
                entries.push([uri, marker]);
            }
            this._onDidChangeDiagnostics.fire(toSync);
            this._proxy.$changeMany(this._owner, entries);
        };
        DiagnosticCollection.prototype.delete = function (uri) {
            this._checkDisposed();
            this._onDidChangeDiagnostics.fire([uri]);
            this._data.delete(uri.toString());
            this._proxy.$changeMany(this._owner, [[uri, undefined]]);
        };
        DiagnosticCollection.prototype.clear = function () {
            this._checkDisposed();
            this._onDidChangeDiagnostics.fire(map_1.keys(this._data));
            this._data.clear();
            this._proxy.$clear(this._owner);
        };
        DiagnosticCollection.prototype.forEach = function (callback, thisArg) {
            var _this = this;
            this._checkDisposed();
            this._data.forEach(function (value, key) {
                var uri = uri_1.default.parse(key);
                callback.apply(thisArg, [uri, _this.get(uri), _this]);
            });
        };
        DiagnosticCollection.prototype.get = function (uri) {
            this._checkDisposed();
            var result = this._data.get(uri.toString());
            if (Array.isArray(result)) {
                return Object.freeze(result.slice(0));
            }
            return undefined;
        };
        DiagnosticCollection.prototype.has = function (uri) {
            this._checkDisposed();
            return Array.isArray(this._data.get(uri.toString()));
        };
        DiagnosticCollection.prototype._checkDisposed = function () {
            if (this._isDisposed) {
                throw new Error('illegal state - object is disposed');
            }
        };
        DiagnosticCollection._compareIndexedTuplesByUri = function (a, b) {
            if (a[0].toString() < b[0].toString()) {
                return -1;
            }
            else if (a[0].toString() > b[0].toString()) {
                return 1;
            }
            else {
                return 0;
            }
        };
        return DiagnosticCollection;
    }());
    exports.DiagnosticCollection = DiagnosticCollection;
    var ExtHostDiagnostics = /** @class */ (function () {
        function ExtHostDiagnostics(mainContext) {
            this._collections = new Map();
            this._onDidChangeDiagnostics = new event_1.Emitter();
            this.onDidChangeDiagnostics = event_1.mapEvent(event_1.debounceEvent(this._onDidChangeDiagnostics.event, ExtHostDiagnostics._debouncer, 50), ExtHostDiagnostics._mapper);
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDiagnostics);
        }
        ExtHostDiagnostics._debouncer = function (last, current) {
            if (!last) {
                return current;
            }
            else {
                return last.concat(current);
            }
        };
        ExtHostDiagnostics._mapper = function (last) {
            var uris = [];
            var map = new Set();
            for (var _i = 0, last_1 = last; _i < last_1.length; _i++) {
                var uri = last_1[_i];
                if (typeof uri === 'string') {
                    if (!map.has(uri)) {
                        map.add(uri);
                        uris.push(uri_1.default.parse(uri));
                    }
                }
                else {
                    if (!map.has(uri.toString())) {
                        map.add(uri.toString());
                        uris.push(uri);
                    }
                }
            }
            Object.freeze(uris);
            return { uris: uris };
        };
        ExtHostDiagnostics.prototype.createDiagnosticCollection = function (name) {
            var _a = this, _collections = _a._collections, _proxy = _a._proxy, _onDidChangeDiagnostics = _a._onDidChangeDiagnostics;
            var owner;
            if (!name) {
                name = '_generated_diagnostic_collection_name_#' + ExtHostDiagnostics._idPool++;
                owner = name;
            }
            else if (!_collections.has(name)) {
                owner = name;
            }
            else {
                console.warn("DiagnosticCollection with name '" + name + "' does already exist.");
                do {
                    owner = name + ExtHostDiagnostics._idPool++;
                } while (_collections.has(owner));
            }
            var result = new /** @class */ (function (_super) {
                __extends(class_1, _super);
                function class_1() {
                    var _this = _super.call(this, name, owner, ExtHostDiagnostics._maxDiagnosticsPerFile, _proxy, _onDidChangeDiagnostics) || this;
                    _collections.set(owner, _this);
                    return _this;
                }
                class_1.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    _collections.delete(owner);
                };
                return class_1;
            }(DiagnosticCollection));
            return result;
        };
        ExtHostDiagnostics.prototype.getDiagnostics = function (resource) {
            if (resource) {
                return this._getDiagnostics(resource);
            }
            else {
                var index_1 = new Map();
                var res_1 = [];
                this._collections.forEach(function (collection) {
                    collection.forEach(function (uri, diagnostics) {
                        var _a;
                        var idx = index_1.get(uri.toString());
                        if (typeof idx === 'undefined') {
                            idx = res_1.length;
                            index_1.set(uri.toString(), idx);
                            res_1.push([uri, []]);
                        }
                        res_1[idx][1] = (_a = res_1[idx][1]).concat.apply(_a, diagnostics);
                    });
                });
                return res_1;
            }
        };
        ExtHostDiagnostics.prototype._getDiagnostics = function (resource) {
            var res = [];
            this._collections.forEach(function (collection) {
                if (collection.has(resource)) {
                    res = res.concat(collection.get(resource));
                }
            });
            return res;
        };
        ExtHostDiagnostics._idPool = 0;
        ExtHostDiagnostics._maxDiagnosticsPerFile = 1000;
        return ExtHostDiagnostics;
    }());
    exports.ExtHostDiagnostics = ExtHostDiagnostics;
});

define(__m[226/*vs/workbench/api/node/extHostDocumentSaveParticipant*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,12/*vs/base/common/async*/,14/*vs/base/common/errors*/,5/*vs/workbench/api/node/extHostTypes*/,19/*vs/workbench/api/node/extHostTypeConverters*/,51/*vs/base/common/linkedList*/]), function (require, exports, uri_1, async_1, errors_1, extHostTypes_1, extHostTypeConverters_1, linkedList_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDocumentSaveParticipant = /** @class */ (function () {
        function ExtHostDocumentSaveParticipant(_logService, _documents, _mainThreadEditors, _thresholds) {
            if (_thresholds === void 0) { _thresholds = { timeout: 1500, errors: 3 }; }
            this._logService = _logService;
            this._documents = _documents;
            this._mainThreadEditors = _mainThreadEditors;
            this._thresholds = _thresholds;
            this._callbacks = new linkedList_1.LinkedList();
            this._badListeners = new WeakMap();
            //
        }
        ExtHostDocumentSaveParticipant.prototype.dispose = function () {
            this._callbacks.clear();
        };
        ExtHostDocumentSaveParticipant.prototype.getOnWillSaveTextDocumentEvent = function (extension) {
            var _this = this;
            return function (listener, thisArg, disposables) {
                var remove = _this._callbacks.push([listener, thisArg, extension]);
                var result = { dispose: remove };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        };
        ExtHostDocumentSaveParticipant.prototype.$participateInSave = function (data, reason) {
            var _this = this;
            var resource = uri_1.default.revive(data);
            var entries = this._callbacks.toArray();
            var didTimeout = false;
            var didTimeoutHandle = setTimeout(function () { return didTimeout = true; }, this._thresholds.timeout);
            var promise = async_1.sequence(entries.map(function (listener) {
                return function () {
                    if (didTimeout) {
                        // timeout - no more listeners
                        return undefined;
                    }
                    var document = _this._documents.getDocumentData(resource).document;
                    return _this._deliverEventAsyncAndBlameBadListeners(listener, { document: document, reason: extHostTypeConverters_1.TextDocumentSaveReason.to(reason) });
                };
            }));
            return async_1.always(promise, function () { return clearTimeout(didTimeoutHandle); });
        };
        ExtHostDocumentSaveParticipant.prototype._deliverEventAsyncAndBlameBadListeners = function (_a, stubEvent) {
            var _this = this;
            var listener = _a[0], thisArg = _a[1], extension = _a[2];
            var errors = this._badListeners.get(listener);
            if (errors > this._thresholds.errors) {
                // bad listener - ignore
                return Promise.resolve(false);
            }
            return this._deliverEventAsync(extension, listener, thisArg, stubEvent).then(function () {
                // don't send result across the wire
                return true;
            }, function (err) {
                _this._logService.error("onWillSaveTextDocument-listener from extension '" + extension.id + "' threw ERROR");
                _this._logService.error(err);
                if (!(err instanceof Error) || err.message !== 'concurrent_edits') {
                    var errors_2 = _this._badListeners.get(listener);
                    _this._badListeners.set(listener, !errors_2 ? 1 : errors_2 + 1);
                    if (errors_2 > _this._thresholds.errors) {
                        _this._logService.info("onWillSaveTextDocument-listener from extension '" + extension.id + "' will now be IGNORED because of timeouts and/or errors");
                    }
                }
                return false;
            });
        };
        ExtHostDocumentSaveParticipant.prototype._deliverEventAsync = function (extension, listener, thisArg, stubEvent) {
            var _this = this;
            var promises = [];
            var t1 = Date.now();
            var document = stubEvent.document, reason = stubEvent.reason;
            var version = document.version;
            var event = Object.freeze({
                document: document,
                reason: reason,
                waitUntil: function (p) {
                    if (Object.isFrozen(promises)) {
                        throw errors_1.illegalState('waitUntil can not be called async');
                    }
                    promises.push(Promise.resolve(p));
                }
            });
            try {
                // fire event
                listener.apply(thisArg, [event]);
            }
            catch (err) {
                return Promise.reject(err);
            }
            // freeze promises after event call
            Object.freeze(promises);
            return new Promise(function (resolve, reject) {
                // join on all listener promises, reject after timeout
                var handle = setTimeout(function () { return reject(new Error('timeout')); }, _this._thresholds.timeout);
                return Promise.all(promises).then(function (edits) {
                    _this._logService.debug("onWillSaveTextDocument-listener from extension '" + extension.id + "' finished after " + (Date.now() - t1) + "ms");
                    clearTimeout(handle);
                    resolve(edits);
                }).catch(function (err) {
                    clearTimeout(handle);
                    reject(err);
                });
            }).then(function (values) {
                var resourceEdit = {
                    resource: document.uri,
                    edits: []
                };
                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                    var value = values_1[_i];
                    if (Array.isArray(value) && value.every(function (e) { return e instanceof extHostTypes_1.TextEdit; })) {
                        for (var _a = 0, value_1 = value; _a < value_1.length; _a++) {
                            var _b = value_1[_a], newText = _b.newText, newEol = _b.newEol, range = _b.range;
                            resourceEdit.edits.push({
                                range: range && extHostTypeConverters_1.Range.from(range),
                                text: newText,
                                eol: extHostTypeConverters_1.EndOfLine.from(newEol)
                            });
                        }
                    }
                }
                // apply edits if any and if document
                // didn't change somehow in the meantime
                if (resourceEdit.edits.length === 0) {
                    return undefined;
                }
                if (version === document.version) {
                    return _this._mainThreadEditors.$tryApplyWorkspaceEdit({ edits: [resourceEdit] });
                }
                // TODO@joh bubble this to listener?
                return Promise.reject(new Error('concurrent_edits'));
            });
        };
        return ExtHostDocumentSaveParticipant;
    }());
    exports.ExtHostDocumentSaveParticipant = ExtHostDocumentSaveParticipant;
});

define(__m[227/*vs/workbench/api/node/extHostDocuments*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,4/*vs/base/common/uri*/,9/*vs/base/common/lifecycle*/,19/*vs/workbench/api/node/extHostTypeConverters*/,2/*vs/base/common/winjs.base*/,6/*vs/workbench/api/node/extHost.protocol*/,76/*vs/workbench/api/node/extHostDocumentData*/]), function (require, exports, event_1, uri_1, lifecycle_1, TypeConverters, winjs_base_1, extHost_protocol_1, extHostDocumentData_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDocuments = /** @class */ (function () {
        function ExtHostDocuments(mainContext, documentsAndEditors) {
            var _this = this;
            this._onDidAddDocument = new event_1.Emitter();
            this._onDidRemoveDocument = new event_1.Emitter();
            this._onDidChangeDocument = new event_1.Emitter();
            this._onDidSaveDocument = new event_1.Emitter();
            this.onDidAddDocument = this._onDidAddDocument.event;
            this.onDidRemoveDocument = this._onDidRemoveDocument.event;
            this.onDidChangeDocument = this._onDidChangeDocument.event;
            this.onDidSaveDocument = this._onDidSaveDocument.event;
            this._documentLoader = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDocuments);
            this._documentsAndEditors = documentsAndEditors;
            this._toDispose = [
                this._documentsAndEditors.onDidRemoveDocuments(function (documents) {
                    for (var _i = 0, documents_1 = documents; _i < documents_1.length; _i++) {
                        var data = documents_1[_i];
                        _this._onDidRemoveDocument.fire(data.document);
                    }
                }),
                this._documentsAndEditors.onDidAddDocuments(function (documents) {
                    for (var _i = 0, documents_2 = documents; _i < documents_2.length; _i++) {
                        var data = documents_2[_i];
                        _this._onDidAddDocument.fire(data.document);
                    }
                })
            ];
        }
        ExtHostDocuments.prototype.dispose = function () {
            lifecycle_1.dispose(this._toDispose);
        };
        ExtHostDocuments.prototype.getAllDocumentData = function () {
            return this._documentsAndEditors.allDocuments();
        };
        ExtHostDocuments.prototype.getDocumentData = function (resource) {
            if (!resource) {
                return undefined;
            }
            var data = this._documentsAndEditors.getDocument(resource.toString());
            if (data) {
                return data;
            }
            return undefined;
        };
        ExtHostDocuments.prototype.ensureDocumentData = function (uri) {
            var _this = this;
            var cached = this._documentsAndEditors.getDocument(uri.toString());
            if (cached) {
                return winjs_base_1.TPromise.as(cached);
            }
            var promise = this._documentLoader.get(uri.toString());
            if (!promise) {
                promise = this._proxy.$tryOpenDocument(uri).then(function () {
                    _this._documentLoader.delete(uri.toString());
                    return _this._documentsAndEditors.getDocument(uri.toString());
                }, function (err) {
                    _this._documentLoader.delete(uri.toString());
                    return winjs_base_1.TPromise.wrapError(err);
                });
                this._documentLoader.set(uri.toString(), promise);
            }
            return promise;
        };
        ExtHostDocuments.prototype.createDocumentData = function (options) {
            return this._proxy.$tryCreateDocument(options).then(function (data) { return uri_1.default.revive(data); });
        };
        ExtHostDocuments.prototype.$acceptModelModeChanged = function (uriComponents, oldModeId, newModeId) {
            var uri = uri_1.default.revive(uriComponents);
            var strURL = uri.toString();
            var data = this._documentsAndEditors.getDocument(strURL);
            // Treat a mode change as a remove + add
            this._onDidRemoveDocument.fire(data.document);
            data._acceptLanguageId(newModeId);
            this._onDidAddDocument.fire(data.document);
        };
        ExtHostDocuments.prototype.$acceptModelSaved = function (uriComponents) {
            var uri = uri_1.default.revive(uriComponents);
            var strURL = uri.toString();
            var data = this._documentsAndEditors.getDocument(strURL);
            this.$acceptDirtyStateChanged(uriComponents, false);
            this._onDidSaveDocument.fire(data.document);
        };
        ExtHostDocuments.prototype.$acceptDirtyStateChanged = function (uriComponents, isDirty) {
            var uri = uri_1.default.revive(uriComponents);
            var strURL = uri.toString();
            var data = this._documentsAndEditors.getDocument(strURL);
            data._acceptIsDirty(isDirty);
            this._onDidChangeDocument.fire({
                document: data.document,
                contentChanges: []
            });
        };
        ExtHostDocuments.prototype.$acceptModelChanged = function (uriComponents, events, isDirty) {
            var uri = uri_1.default.revive(uriComponents);
            var strURL = uri.toString();
            var data = this._documentsAndEditors.getDocument(strURL);
            data._acceptIsDirty(isDirty);
            data.onEvents(events);
            this._onDidChangeDocument.fire({
                document: data.document,
                contentChanges: events.changes.map(function (change) {
                    return {
                        range: TypeConverters.Range.to(change.range),
                        rangeOffset: change.rangeOffset,
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                })
            });
        };
        ExtHostDocuments.prototype.setWordDefinitionFor = function (modeId, wordDefinition) {
            extHostDocumentData_1.setWordDefinitionFor(modeId, wordDefinition);
        };
        return ExtHostDocuments;
    }());
    exports.ExtHostDocuments = ExtHostDocuments;
});

define(__m[228/*vs/workbench/api/node/extHostFileSystemEventService*/], __M([0/*require*/,1/*exports*/,13/*vs/base/common/arrays*/,3/*vs/base/common/event*/,33/*vs/base/common/glob*/,4/*vs/base/common/uri*/,2/*vs/base/common/winjs.base*/,6/*vs/workbench/api/node/extHost.protocol*/,19/*vs/workbench/api/node/extHostTypeConverters*/,5/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, arrays_1, event_1, glob_1, uri_1, winjs_base_1, extHost_protocol_1, typeConverter, extHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileSystemWatcher = /** @class */ (function () {
        function FileSystemWatcher(dispatcher, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
            var _this = this;
            this._onDidCreate = new event_1.Emitter();
            this._onDidChange = new event_1.Emitter();
            this._onDidDelete = new event_1.Emitter();
            this._config = 0;
            if (ignoreCreateEvents) {
                this._config += 1;
            }
            if (ignoreChangeEvents) {
                this._config += 2;
            }
            if (ignoreDeleteEvents) {
                this._config += 4;
            }
            var parsedPattern = glob_1.parse(globPattern);
            var subscription = dispatcher(function (events) {
                if (!ignoreCreateEvents) {
                    for (var _i = 0, _a = events.created; _i < _a.length; _i++) {
                        var created = _a[_i];
                        var uri = uri_1.default.revive(created);
                        if (parsedPattern(uri.fsPath)) {
                            _this._onDidCreate.fire(uri);
                        }
                    }
                }
                if (!ignoreChangeEvents) {
                    for (var _b = 0, _c = events.changed; _b < _c.length; _b++) {
                        var changed = _c[_b];
                        var uri = uri_1.default.revive(changed);
                        if (parsedPattern(uri.fsPath)) {
                            _this._onDidChange.fire(uri);
                        }
                    }
                }
                if (!ignoreDeleteEvents) {
                    for (var _d = 0, _e = events.deleted; _d < _e.length; _d++) {
                        var deleted = _e[_d];
                        var uri = uri_1.default.revive(deleted);
                        if (parsedPattern(uri.fsPath)) {
                            _this._onDidDelete.fire(uri);
                        }
                    }
                }
            });
            this._disposable = extHostTypes_1.Disposable.from(this._onDidCreate, this._onDidChange, this._onDidDelete, subscription);
        }
        Object.defineProperty(FileSystemWatcher.prototype, "ignoreCreateEvents", {
            get: function () {
                return Boolean(this._config & 1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "ignoreChangeEvents", {
            get: function () {
                return Boolean(this._config & 2);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "ignoreDeleteEvents", {
            get: function () {
                return Boolean(this._config & 4);
            },
            enumerable: true,
            configurable: true
        });
        FileSystemWatcher.prototype.dispose = function () {
            this._disposable.dispose();
        };
        Object.defineProperty(FileSystemWatcher.prototype, "onDidCreate", {
            get: function () {
                return this._onDidCreate.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "onDidDelete", {
            get: function () {
                return this._onDidDelete.event;
            },
            enumerable: true,
            configurable: true
        });
        return FileSystemWatcher;
    }());
    var ExtHostFileSystemEventService = /** @class */ (function () {
        function ExtHostFileSystemEventService(mainContext, _extHostDocumentsAndEditors, _mainThreadTextEditors) {
            if (_mainThreadTextEditors === void 0) { _mainThreadTextEditors = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTextEditors); }
            this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;
            this._mainThreadTextEditors = _mainThreadTextEditors;
            this._onFileEvent = new event_1.Emitter();
            this._onDidRenameFile = new event_1.Emitter();
            this._onWillRenameFile = new event_1.AsyncEmitter();
            this.onDidRenameFile = this._onDidRenameFile.event;
            //
        }
        ExtHostFileSystemEventService.prototype.createFileSystemWatcher = function (globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
            return new FileSystemWatcher(this._onFileEvent.event, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
        };
        ExtHostFileSystemEventService.prototype.$onFileEvent = function (events) {
            this._onFileEvent.fire(events);
        };
        ExtHostFileSystemEventService.prototype.$onFileRename = function (oldUri, newUri) {
            this._onDidRenameFile.fire(Object.freeze({ oldUri: uri_1.default.revive(oldUri), newUri: uri_1.default.revive(newUri) }));
        };
        ExtHostFileSystemEventService.prototype.getOnWillRenameFileEvent = function (extension) {
            var _this = this;
            return function (listener, thisArg, disposables) {
                var wrappedListener = function () {
                    listener.apply(thisArg, arguments);
                };
                wrappedListener.extension = extension;
                return _this._onWillRenameFile.event(wrappedListener, undefined, disposables);
            };
        };
        ExtHostFileSystemEventService.prototype.$onWillRename = function (oldUriDto, newUriDto) {
            var _this = this;
            var oldUri = uri_1.default.revive(oldUriDto);
            var newUri = uri_1.default.revive(newUriDto);
            var edits = [];
            return winjs_base_1.TPromise.wrap(this._onWillRenameFile.fireAsync(function (bucket, listener) {
                return {
                    oldUri: oldUri,
                    newUri: newUri,
                    waitUntil: function (thenable) {
                        if (Object.isFrozen(bucket)) {
                            throw new TypeError('waitUntil cannot be called async');
                        }
                        var index = bucket.length;
                        var wrappedThenable = winjs_base_1.TPromise.as(thenable).then(function (result) {
                            // ignore all results except for WorkspaceEdits. Those
                            // are stored in a spare array
                            if (result instanceof extHostTypes_1.WorkspaceEdit) {
                                edits[index] = result;
                            }
                        });
                        bucket.push(wrappedThenable);
                    }
                };
            }).then(function () {
                if (edits.length === 0) {
                    return undefined;
                }
                // flatten all WorkspaceEdits collected via waitUntil-call
                // and apply them in one go.
                var allEdits = new Array();
                for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
                    var edit = edits_1[_i];
                    if (edit) { // sparse array
                        var edits_2 = typeConverter.WorkspaceEdit.from(edit, _this._extHostDocumentsAndEditors).edits;
                        allEdits.push(edits_2);
                    }
                }
                return _this._mainThreadTextEditors.$tryApplyWorkspaceEdit({ edits: arrays_1.flatten(allEdits) });
            }));
        };
        return ExtHostFileSystemEventService;
    }());
    exports.ExtHostFileSystemEventService = ExtHostFileSystemEventService;
});

define(__m[229/*vs/workbench/api/node/extHostLanguageFeatures*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,2/*vs/base/common/winjs.base*/,20/*vs/base/common/objects*/,19/*vs/workbench/api/node/extHostTypeConverters*/,5/*vs/workbench/api/node/extHostTypes*/,12/*vs/base/common/async*/,6/*vs/workbench/api/node/extHost.protocol*/,8/*vs/base/common/strings*/,24/*vs/editor/common/core/range*/,13/*vs/base/common/arrays*/,18/*vs/base/common/types*/,54/*vs/editor/common/core/selection*/]), function (require, exports, uri_1, winjs_base_1, objects_1, typeConvert, extHostTypes_1, async_1, extHost_protocol_1, strings_1, range_1, arrays_1, types_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // --- adapter
    var OutlineAdapter = /** @class */ (function () {
        function OutlineAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        OutlineAdapter.prototype.provideDocumentSymbols = function (resource) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentSymbols(doc, token); }).then(function (value) {
                if (arrays_1.isFalsyOrEmpty(value)) {
                    return undefined;
                }
                if (value[0] instanceof extHostTypes_1.DocumentSymbol) {
                    return value.map(typeConvert.DocumentSymbol.from);
                }
                else {
                    return OutlineAdapter._asDocumentSymbolTree(resource, value);
                }
            });
        };
        OutlineAdapter._asDocumentSymbolTree = function (resource, info) {
            // first sort by start (and end) and then loop over all elements
            // and build a tree based on containment.
            info = info.slice(0).sort(function (a, b) {
                var res = a.location.range.start.compareTo(b.location.range.start);
                if (res === 0) {
                    res = b.location.range.end.compareTo(a.location.range.end);
                }
                return res;
            });
            var res = [];
            var parentStack = [];
            for (var i = 0; i < info.length; i++) {
                var element = {
                    name: info[i].name,
                    kind: typeConvert.SymbolKind.from(info[i].kind),
                    containerName: info[i].containerName,
                    range: typeConvert.Range.from(info[i].location.range),
                    selectionRange: typeConvert.Range.from(info[i].location.range),
                    children: []
                };
                while (true) {
                    if (parentStack.length === 0) {
                        parentStack.push(element);
                        res.push(element);
                        break;
                    }
                    var parent_1 = parentStack[parentStack.length - 1];
                    if (range_1.Range.containsRange(parent_1.range, element.range) && !range_1.Range.equalsRange(parent_1.range, element.range)) {
                        parent_1.children.push(element);
                        parentStack.push(element);
                        break;
                    }
                    parentStack.pop();
                }
            }
            return res;
        };
        return OutlineAdapter;
    }());
    var CodeLensAdapter = /** @class */ (function () {
        function CodeLensAdapter(_documents, _commands, _heapService, _provider) {
            this._documents = _documents;
            this._commands = _commands;
            this._heapService = _heapService;
            this._provider = _provider;
        }
        CodeLensAdapter.prototype.provideCodeLenses = function (resource) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideCodeLenses(doc, token); }).then(function (lenses) {
                if (Array.isArray(lenses)) {
                    return lenses.map(function (lens) {
                        var id = _this._heapService.keep(lens);
                        return extHost_protocol_1.ObjectIdentifier.mixin({
                            range: typeConvert.Range.from(lens.range),
                            command: _this._commands.toInternal(lens.command)
                        }, id);
                    });
                }
                return undefined;
            });
        };
        CodeLensAdapter.prototype.resolveCodeLens = function (resource, symbol) {
            var _this = this;
            var lens = this._heapService.get(extHost_protocol_1.ObjectIdentifier.of(symbol));
            if (!lens) {
                return undefined;
            }
            var resolve;
            if (typeof this._provider.resolveCodeLens !== 'function' || lens.isResolved) {
                resolve = winjs_base_1.TPromise.as(lens);
            }
            else {
                resolve = async_1.asWinJsPromise(function (token) { return _this._provider.resolveCodeLens(lens, token); });
            }
            return resolve.then(function (newLens) {
                newLens = newLens || lens;
                symbol.command = _this._commands.toInternal(newLens.command || CodeLensAdapter._badCmd);
                return symbol;
            });
        };
        CodeLensAdapter._badCmd = { command: 'missing', title: '<<MISSING COMMAND>>' };
        return CodeLensAdapter;
    }());
    function convertToDefinitionLinks(value) {
        if (Array.isArray(value)) {
            return value.map(typeConvert.DefinitionLink.from);
        }
        else if (value) {
            return [typeConvert.DefinitionLink.from(value)];
        }
        return undefined;
    }
    var DefinitionAdapter = /** @class */ (function () {
        function DefinitionAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        DefinitionAdapter.prototype.provideDefinition = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDefinition(doc, pos, token); }).then(convertToDefinitionLinks);
        };
        return DefinitionAdapter;
    }());
    var ImplementationAdapter = /** @class */ (function () {
        function ImplementationAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        ImplementationAdapter.prototype.provideImplementation = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideImplementation(doc, pos, token); }).then(convertToDefinitionLinks);
        };
        return ImplementationAdapter;
    }());
    var TypeDefinitionAdapter = /** @class */ (function () {
        function TypeDefinitionAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        TypeDefinitionAdapter.prototype.provideTypeDefinition = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideTypeDefinition(doc, pos, token); }).then(convertToDefinitionLinks);
        };
        return TypeDefinitionAdapter;
    }());
    var HoverAdapter = /** @class */ (function () {
        function HoverAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        HoverAdapter.prototype.provideHover = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideHover(doc, pos, token); }).then(function (value) {
                if (!value || arrays_1.isFalsyOrEmpty(value.contents)) {
                    return undefined;
                }
                if (!value.range) {
                    value.range = doc.getWordRangeAtPosition(pos);
                }
                if (!value.range) {
                    value.range = new extHostTypes_1.Range(pos, pos);
                }
                return typeConvert.Hover.from(value);
            });
        };
        return HoverAdapter;
    }());
    var DocumentHighlightAdapter = /** @class */ (function () {
        function DocumentHighlightAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        DocumentHighlightAdapter.prototype.provideDocumentHighlights = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentHighlights(doc, pos, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConvert.DocumentHighlight.from);
                }
                return undefined;
            });
        };
        return DocumentHighlightAdapter;
    }());
    var ReferenceAdapter = /** @class */ (function () {
        function ReferenceAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        ReferenceAdapter.prototype.provideReferences = function (resource, position, context) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideReferences(doc, pos, context, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConvert.location.from);
                }
                return undefined;
            });
        };
        return ReferenceAdapter;
    }());
    var CodeActionAdapter = /** @class */ (function () {
        function CodeActionAdapter(_documents, _commands, _diagnostics, _provider, _logService, _extensionId) {
            this._documents = _documents;
            this._commands = _commands;
            this._diagnostics = _diagnostics;
            this._provider = _provider;
            this._logService = _logService;
            this._extensionId = _extensionId;
        }
        CodeActionAdapter.prototype.provideCodeActions = function (resource, rangeOrSelection, context) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var ran = selection_1.Selection.isISelection(rangeOrSelection)
                ? typeConvert.Selection.to(rangeOrSelection)
                : typeConvert.Range.to(rangeOrSelection);
            var allDiagnostics = [];
            for (var _i = 0, _a = this._diagnostics.getDiagnostics(resource); _i < _a.length; _i++) {
                var diagnostic = _a[_i];
                if (ran.intersection(diagnostic.range)) {
                    allDiagnostics.push(diagnostic);
                }
            }
            var codeActionContext = {
                diagnostics: allDiagnostics,
                only: context.only ? new extHostTypes_1.CodeActionKind(context.only) : undefined
            };
            return async_1.asWinJsPromise(function (token) {
                return _this._provider.provideCodeActions(doc, ran, codeActionContext, token);
            }).then(function (commandsOrActions) {
                if (arrays_1.isFalsyOrEmpty(commandsOrActions)) {
                    return undefined;
                }
                var result = [];
                for (var _i = 0, commandsOrActions_1 = commandsOrActions; _i < commandsOrActions_1.length; _i++) {
                    var candidate = commandsOrActions_1[_i];
                    if (!candidate) {
                        continue;
                    }
                    if (CodeActionAdapter._isCommand(candidate)) {
                        // old school: synthetic code action
                        result.push({
                            _isSynthetic: true,
                            title: candidate.title,
                            command: _this._commands.toInternal(candidate),
                        });
                    }
                    else {
                        if (codeActionContext.only) {
                            if (!candidate.kind) {
                                _this._logService.warn(_this._extensionId + " - Code actions of kind '" + codeActionContext.only.value + " 'requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.");
                            }
                            else if (!codeActionContext.only.contains(candidate.kind)) {
                                _this._logService.warn(_this._extensionId + " -Code actions of kind '" + codeActionContext.only.value + " 'requested but returned code action is of kind '" + candidate.kind.value + "'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.");
                            }
                        }
                        // new school: convert code action
                        result.push({
                            title: candidate.title,
                            command: candidate.command && _this._commands.toInternal(candidate.command),
                            diagnostics: candidate.diagnostics && candidate.diagnostics.map(typeConvert.Diagnostic.from),
                            edit: candidate.edit && typeConvert.WorkspaceEdit.from(candidate.edit),
                            kind: candidate.kind && candidate.kind.value
                        });
                    }
                }
                return result;
            });
        };
        CodeActionAdapter._isCommand = function (thing) {
            return typeof thing.command === 'string' && typeof thing.title === 'string';
        };
        return CodeActionAdapter;
    }());
    var DocumentFormattingAdapter = /** @class */ (function () {
        function DocumentFormattingAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        DocumentFormattingAdapter.prototype.provideDocumentFormattingEdits = function (resource, options) {
            var _this = this;
            var document = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentFormattingEdits(document, options, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConvert.TextEdit.from);
                }
                return undefined;
            });
        };
        return DocumentFormattingAdapter;
    }());
    var RangeFormattingAdapter = /** @class */ (function () {
        function RangeFormattingAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        RangeFormattingAdapter.prototype.provideDocumentRangeFormattingEdits = function (resource, range, options) {
            var _this = this;
            var document = this._documents.getDocumentData(resource).document;
            var ran = typeConvert.Range.to(range);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentRangeFormattingEdits(document, ran, options, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConvert.TextEdit.from);
                }
                return undefined;
            });
        };
        return RangeFormattingAdapter;
    }());
    var OnTypeFormattingAdapter = /** @class */ (function () {
        function OnTypeFormattingAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
            this.autoFormatTriggerCharacters = []; // not here
        }
        OnTypeFormattingAdapter.prototype.provideOnTypeFormattingEdits = function (resource, position, ch, options) {
            var _this = this;
            var document = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideOnTypeFormattingEdits(document, pos, ch, options, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConvert.TextEdit.from);
                }
                return undefined;
            });
        };
        return OnTypeFormattingAdapter;
    }());
    var NavigateTypeAdapter = /** @class */ (function () {
        function NavigateTypeAdapter(provider) {
            this._symbolCache = Object.create(null);
            this._resultCache = Object.create(null);
            this._provider = provider;
        }
        NavigateTypeAdapter.prototype.provideWorkspaceSymbols = function (search) {
            var _this = this;
            var result = extHost_protocol_1.IdObject.mixin({ symbols: [] });
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideWorkspaceSymbols(search, token); }).then(function (value) {
                if (!arrays_1.isFalsyOrEmpty(value)) {
                    for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                        var item = value_1[_i];
                        if (!item) {
                            // drop
                            continue;
                        }
                        if (!item.name) {
                            console.warn('INVALID SymbolInformation, lacks name', item);
                            continue;
                        }
                        var symbol = extHost_protocol_1.IdObject.mixin(typeConvert.WorkspaceSymbol.from(item));
                        _this._symbolCache[symbol._id] = item;
                        result.symbols.push(symbol);
                    }
                }
            }).then(function () {
                if (result.symbols.length > 0) {
                    _this._resultCache[result._id] = [result.symbols[0]._id, result.symbols[result.symbols.length - 1]._id];
                }
                return result;
            });
        };
        NavigateTypeAdapter.prototype.resolveWorkspaceSymbol = function (symbol) {
            var _this = this;
            if (typeof this._provider.resolveWorkspaceSymbol !== 'function') {
                return winjs_base_1.TPromise.as(symbol);
            }
            var item = this._symbolCache[symbol._id];
            if (item) {
                return async_1.asWinJsPromise(function (token) { return _this._provider.resolveWorkspaceSymbol(item, token); }).then(function (value) {
                    return value && objects_1.mixin(symbol, typeConvert.WorkspaceSymbol.from(value), true);
                });
            }
            return undefined;
        };
        NavigateTypeAdapter.prototype.releaseWorkspaceSymbols = function (id) {
            var range = this._resultCache[id];
            if (range) {
                for (var from = range[0], to = range[1]; from <= to; from++) {
                    delete this._symbolCache[from];
                }
                delete this._resultCache[id];
            }
        };
        return NavigateTypeAdapter;
    }());
    var RenameAdapter = /** @class */ (function () {
        function RenameAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        RenameAdapter.supportsResolving = function (provider) {
            return typeof provider.prepareRename === 'function';
        };
        RenameAdapter.prototype.provideRenameEdits = function (resource, position, newName) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideRenameEdits(doc, pos, newName, token); }).then(function (value) {
                if (!value) {
                    return undefined;
                }
                return typeConvert.WorkspaceEdit.from(value);
            }, function (err) {
                if (typeof err === 'string') {
                    return {
                        edits: undefined,
                        rejectReason: err
                    };
                }
                else if (err instanceof Error && typeof err.message === 'string') {
                    return {
                        edits: undefined,
                        rejectReason: err.message
                    };
                }
                else {
                    // generic error
                    return winjs_base_1.TPromise.wrapError(err);
                }
            });
        };
        RenameAdapter.prototype.resolveRenameLocation = function (resource, position) {
            var _this = this;
            if (typeof this._provider.prepareRename !== 'function') {
                return winjs_base_1.TPromise.as(undefined);
            }
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.prepareRename(doc, pos, token); }).then(function (rangeOrLocation) {
                var range;
                var text;
                if (extHostTypes_1.Range.isRange(rangeOrLocation)) {
                    range = rangeOrLocation;
                    text = doc.getText(rangeOrLocation);
                }
                else if (types_1.isObject(rangeOrLocation)) {
                    range = rangeOrLocation.range;
                    text = rangeOrLocation.placeholder;
                }
                if (!range) {
                    return undefined;
                }
                if (!range.contains(pos)) {
                    console.warn('INVALID rename location: range must contain position');
                    return undefined;
                }
                return { range: typeConvert.Range.from(range), text: text };
            });
        };
        return RenameAdapter;
    }());
    var SuggestAdapter = /** @class */ (function () {
        function SuggestAdapter(documents, commands, provider) {
            this._cache = new Map();
            this._idPool = 0;
            this._documents = documents;
            this._commands = commands;
            this._provider = provider;
        }
        SuggestAdapter.supportsResolving = function (provider) {
            return typeof provider.resolveCompletionItem === 'function';
        };
        SuggestAdapter.prototype.provideCompletionItems = function (resource, position, context) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asWinJsPromise(function (token) {
                return _this._provider.provideCompletionItems(doc, pos, token, typeConvert.CompletionContext.from(context));
            }).then(function (value) {
                var _id = _this._idPool++;
                var result = {
                    _id: _id,
                    suggestions: [],
                };
                var list;
                if (!value) {
                    // undefined and null are valid results
                    return undefined;
                }
                else if (Array.isArray(value)) {
                    list = new extHostTypes_1.CompletionList(value);
                }
                else {
                    list = value;
                    result.incomplete = list.isIncomplete;
                }
                // the default text edit range
                var wordRangeBeforePos = (doc.getWordRangeAtPosition(pos) || new extHostTypes_1.Range(pos, pos))
                    .with({ end: pos });
                for (var i = 0; i < list.items.length; i++) {
                    var suggestion = _this._convertCompletionItem(list.items[i], pos, wordRangeBeforePos, i, _id);
                    // check for bad completion item
                    // for the converter did warn
                    if (suggestion) {
                        result.suggestions.push(suggestion);
                    }
                }
                _this._cache.set(_id, list.items);
                return result;
            });
        };
        SuggestAdapter.prototype.resolveCompletionItem = function (resource, position, suggestion) {
            var _this = this;
            if (typeof this._provider.resolveCompletionItem !== 'function') {
                return winjs_base_1.TPromise.as(suggestion);
            }
            var _a = suggestion, _parentId = _a._parentId, _id = _a._id;
            var item = this._cache.has(_parentId) && this._cache.get(_parentId)[_id];
            if (!item) {
                return winjs_base_1.TPromise.as(suggestion);
            }
            return async_1.asWinJsPromise(function (token) { return _this._provider.resolveCompletionItem(item, token); }).then(function (resolvedItem) {
                if (!resolvedItem) {
                    return suggestion;
                }
                var doc = _this._documents.getDocumentData(resource).document;
                var pos = typeConvert.Position.to(position);
                var wordRangeBeforePos = (doc.getWordRangeAtPosition(pos) || new extHostTypes_1.Range(pos, pos)).with({ end: pos });
                var newSuggestion = _this._convertCompletionItem(resolvedItem, pos, wordRangeBeforePos, _id, _parentId);
                if (newSuggestion) {
                    objects_1.mixin(suggestion, newSuggestion, true);
                }
                return suggestion;
            });
        };
        SuggestAdapter.prototype.releaseCompletionItems = function (id) {
            this._cache.delete(id);
        };
        SuggestAdapter.prototype._convertCompletionItem = function (item, position, defaultRange, _id, _parentId) {
            if (typeof item.label !== 'string' || item.label.length === 0) {
                console.warn('INVALID text edit -> must have at least a label');
                return undefined;
            }
            var result = {
                //
                _id: _id,
                _parentId: _parentId,
                //
                label: item.label,
                type: typeConvert.CompletionItemKind.from(item.kind),
                detail: item.detail,
                documentation: item.documentation,
                filterText: item.filterText,
                sortText: item.sortText,
                preselect: item.preselect,
                //
                insertText: undefined,
                additionalTextEdits: item.additionalTextEdits && item.additionalTextEdits.map(typeConvert.TextEdit.from),
                command: this._commands.toInternal(item.command),
                commitCharacters: item.commitCharacters
            };
            // 'insertText'-logic
            if (item.textEdit) {
                result.insertText = item.textEdit.newText;
                result.snippetType = 'internal';
            }
            else if (typeof item.insertText === 'string') {
                result.insertText = item.insertText;
                result.snippetType = 'internal';
            }
            else if (item.insertText instanceof extHostTypes_1.SnippetString) {
                result.insertText = item.insertText.value;
                result.snippetType = 'textmate';
            }
            else {
                result.insertText = item.label;
                result.snippetType = 'internal';
            }
            // 'overwrite[Before|After]'-logic
            var range;
            if (item.textEdit) {
                range = item.textEdit.range;
            }
            else if (item.range) {
                range = item.range;
            }
            else {
                range = defaultRange;
            }
            result.overwriteBefore = position.character - range.start.character;
            result.overwriteAfter = range.end.character - position.character;
            if (!range.isSingleLine || range.start.line !== position.line) {
                console.warn('INVALID text edit -> must be single line and on the same line');
                return undefined;
            }
            return result;
        };
        return SuggestAdapter;
    }());
    var SignatureHelpAdapter = /** @class */ (function () {
        function SignatureHelpAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        SignatureHelpAdapter.prototype.provideSignatureHelp = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideSignatureHelp(doc, pos, token); }).then(function (value) {
                if (value) {
                    return typeConvert.SignatureHelp.from(value);
                }
                return undefined;
            });
        };
        return SignatureHelpAdapter;
    }());
    var LinkProviderAdapter = /** @class */ (function () {
        function LinkProviderAdapter(_documents, _heapService, _provider) {
            this._documents = _documents;
            this._heapService = _heapService;
            this._provider = _provider;
        }
        LinkProviderAdapter.prototype.provideLinks = function (resource) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentLinks(doc, token); }).then(function (links) {
                if (!Array.isArray(links)) {
                    return undefined;
                }
                var result = [];
                for (var _i = 0, links_1 = links; _i < links_1.length; _i++) {
                    var link = links_1[_i];
                    var data = typeConvert.DocumentLink.from(link);
                    var id = _this._heapService.keep(link);
                    extHost_protocol_1.ObjectIdentifier.mixin(data, id);
                    result.push(data);
                }
                return result;
            });
        };
        LinkProviderAdapter.prototype.resolveLink = function (link) {
            var _this = this;
            if (typeof this._provider.resolveDocumentLink !== 'function') {
                return undefined;
            }
            var id = extHost_protocol_1.ObjectIdentifier.of(link);
            var item = this._heapService.get(id);
            if (!item) {
                return undefined;
            }
            return async_1.asWinJsPromise(function (token) { return _this._provider.resolveDocumentLink(item, token); }).then(function (value) {
                if (value) {
                    return typeConvert.DocumentLink.from(value);
                }
                return undefined;
            });
        };
        return LinkProviderAdapter;
    }());
    var ColorProviderAdapter = /** @class */ (function () {
        function ColorProviderAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        ColorProviderAdapter.prototype.provideColors = function (resource) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentColors(doc, token); }).then(function (colors) {
                if (!Array.isArray(colors)) {
                    return [];
                }
                var colorInfos = colors.map(function (ci) {
                    return {
                        color: typeConvert.Color.from(ci.color),
                        range: typeConvert.Range.from(ci.range)
                    };
                });
                return colorInfos;
            });
        };
        ColorProviderAdapter.prototype.provideColorPresentations = function (resource, raw) {
            var _this = this;
            var document = this._documents.getDocumentData(resource).document;
            var range = typeConvert.Range.to(raw.range);
            var color = typeConvert.Color.to(raw.color);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideColorPresentations(color, { document: document, range: range }, token); }).then(function (value) {
                return value.map(typeConvert.ColorPresentation.from);
            });
        };
        return ColorProviderAdapter;
    }());
    var FoldingProviderAdapter = /** @class */ (function () {
        function FoldingProviderAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        FoldingProviderAdapter.prototype.provideFoldingRanges = function (resource, context) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideFoldingRanges(doc, context, token); }).then(function (ranges) {
                if (!Array.isArray(ranges)) {
                    return void 0;
                }
                return ranges.map(typeConvert.FoldingRange.from);
            });
        };
        return FoldingProviderAdapter;
    }());
    var ExtHostLanguageFeatures = /** @class */ (function () {
        function ExtHostLanguageFeatures(mainContext, schemeTransformer, documents, commands, heapMonitor, diagnostics, logService) {
            this._adapter = new Map();
            this._schemeTransformer = schemeTransformer;
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadLanguageFeatures);
            this._documents = documents;
            this._commands = commands;
            this._heapService = heapMonitor;
            this._diagnostics = diagnostics;
            this._logService = logService;
        }
        ExtHostLanguageFeatures.prototype._transformDocumentSelector = function (selector) {
            var _this = this;
            if (Array.isArray(selector)) {
                return selector.map(function (sel) { return _this._doTransformDocumentSelector(sel); });
            }
            return [this._doTransformDocumentSelector(selector)];
        };
        ExtHostLanguageFeatures.prototype._doTransformDocumentSelector = function (selector) {
            if (typeof selector === 'string') {
                return {
                    $serialized: true,
                    language: selector
                };
            }
            if (selector) {
                return {
                    $serialized: true,
                    language: selector.language,
                    scheme: this._transformScheme(selector.scheme),
                    pattern: selector.pattern,
                    exclusive: selector.exclusive
                };
            }
            return undefined;
        };
        ExtHostLanguageFeatures.prototype._transformScheme = function (scheme) {
            if (this._schemeTransformer && typeof scheme === 'string') {
                return this._schemeTransformer.transformOutgoing(scheme);
            }
            return scheme;
        };
        ExtHostLanguageFeatures.prototype._createDisposable = function (handle) {
            var _this = this;
            return new extHostTypes_1.Disposable(function () {
                _this._adapter.delete(handle);
                _this._proxy.$unregister(handle);
            });
        };
        ExtHostLanguageFeatures.prototype._nextHandle = function () {
            return ExtHostLanguageFeatures._handlePool++;
        };
        ExtHostLanguageFeatures.prototype._withAdapter = function (handle, ctor, callback) {
            var adapter = this._adapter.get(handle);
            if (!(adapter instanceof ctor)) {
                return winjs_base_1.TPromise.wrapError(new Error('no adapter found'));
            }
            return callback(adapter);
        };
        ExtHostLanguageFeatures.prototype._addNewAdapter = function (adapter) {
            var handle = this._nextHandle();
            this._adapter.set(handle, adapter);
            return handle;
        };
        // --- outline
        ExtHostLanguageFeatures.prototype.registerDocumentSymbolProvider = function (selector, provider, extension) {
            var handle = this._addNewAdapter(new OutlineAdapter(this._documents, provider));
            this._proxy.$registerOutlineSupport(handle, this._transformDocumentSelector(selector), extension ? extension.displayName || extension.name : undefined);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentSymbols = function (handle, resource) {
            return this._withAdapter(handle, OutlineAdapter, function (adapter) { return adapter.provideDocumentSymbols(uri_1.default.revive(resource)); });
        };
        // --- code lens
        ExtHostLanguageFeatures.prototype.registerCodeLensProvider = function (selector, provider) {
            var _this = this;
            var handle = this._nextHandle();
            var eventHandle = typeof provider.onDidChangeCodeLenses === 'function' ? this._nextHandle() : undefined;
            this._adapter.set(handle, new CodeLensAdapter(this._documents, this._commands.converter, this._heapService, provider));
            this._proxy.$registerCodeLensSupport(handle, this._transformDocumentSelector(selector), eventHandle);
            var result = this._createDisposable(handle);
            if (eventHandle !== undefined) {
                var subscription = provider.onDidChangeCodeLenses(function (_) { return _this._proxy.$emitCodeLensEvent(eventHandle); });
                result = extHostTypes_1.Disposable.from(result, subscription);
            }
            return result;
        };
        ExtHostLanguageFeatures.prototype.$provideCodeLenses = function (handle, resource) {
            return this._withAdapter(handle, CodeLensAdapter, function (adapter) { return adapter.provideCodeLenses(uri_1.default.revive(resource)); });
        };
        ExtHostLanguageFeatures.prototype.$resolveCodeLens = function (handle, resource, symbol) {
            return this._withAdapter(handle, CodeLensAdapter, function (adapter) { return adapter.resolveCodeLens(uri_1.default.revive(resource), symbol); });
        };
        // --- declaration
        ExtHostLanguageFeatures.prototype.registerDefinitionProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new DefinitionAdapter(this._documents, provider));
            this._proxy.$registerDeclaractionSupport(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDefinition = function (handle, resource, position) {
            return this._withAdapter(handle, DefinitionAdapter, function (adapter) { return adapter.provideDefinition(uri_1.default.revive(resource), position); });
        };
        ExtHostLanguageFeatures.prototype.registerImplementationProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new ImplementationAdapter(this._documents, provider));
            this._proxy.$registerImplementationSupport(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideImplementation = function (handle, resource, position) {
            return this._withAdapter(handle, ImplementationAdapter, function (adapter) { return adapter.provideImplementation(uri_1.default.revive(resource), position); });
        };
        ExtHostLanguageFeatures.prototype.registerTypeDefinitionProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new TypeDefinitionAdapter(this._documents, provider));
            this._proxy.$registerTypeDefinitionSupport(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideTypeDefinition = function (handle, resource, position) {
            return this._withAdapter(handle, TypeDefinitionAdapter, function (adapter) { return adapter.provideTypeDefinition(uri_1.default.revive(resource), position); });
        };
        // --- extra info
        ExtHostLanguageFeatures.prototype.registerHoverProvider = function (selector, provider, extensionId) {
            var handle = this._addNewAdapter(new HoverAdapter(this._documents, provider));
            this._proxy.$registerHoverProvider(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideHover = function (handle, resource, position) {
            return this._withAdapter(handle, HoverAdapter, function (adpater) { return adpater.provideHover(uri_1.default.revive(resource), position); });
        };
        // --- occurrences
        ExtHostLanguageFeatures.prototype.registerDocumentHighlightProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new DocumentHighlightAdapter(this._documents, provider));
            this._proxy.$registerDocumentHighlightProvider(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentHighlights = function (handle, resource, position) {
            return this._withAdapter(handle, DocumentHighlightAdapter, function (adapter) { return adapter.provideDocumentHighlights(uri_1.default.revive(resource), position); });
        };
        // --- references
        ExtHostLanguageFeatures.prototype.registerReferenceProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new ReferenceAdapter(this._documents, provider));
            this._proxy.$registerReferenceSupport(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideReferences = function (handle, resource, position, context) {
            return this._withAdapter(handle, ReferenceAdapter, function (adapter) { return adapter.provideReferences(uri_1.default.revive(resource), position, context); });
        };
        // --- quick fix
        ExtHostLanguageFeatures.prototype.registerCodeActionProvider = function (selector, provider, extension, metadata) {
            var handle = this._addNewAdapter(new CodeActionAdapter(this._documents, this._commands.converter, this._diagnostics, provider, this._logService, extension ? extension.id : ''));
            this._proxy.$registerQuickFixSupport(handle, this._transformDocumentSelector(selector), metadata && metadata.providedCodeActionKinds ? metadata.providedCodeActionKinds.map(function (kind) { return kind.value; }) : undefined);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideCodeActions = function (handle, resource, rangeOrSelection, context) {
            return this._withAdapter(handle, CodeActionAdapter, function (adapter) { return adapter.provideCodeActions(uri_1.default.revive(resource), rangeOrSelection, context); });
        };
        // --- formatting
        ExtHostLanguageFeatures.prototype.registerDocumentFormattingEditProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new DocumentFormattingAdapter(this._documents, provider));
            this._proxy.$registerDocumentFormattingSupport(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentFormattingEdits = function (handle, resource, options) {
            return this._withAdapter(handle, DocumentFormattingAdapter, function (adapter) { return adapter.provideDocumentFormattingEdits(uri_1.default.revive(resource), options); });
        };
        ExtHostLanguageFeatures.prototype.registerDocumentRangeFormattingEditProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new RangeFormattingAdapter(this._documents, provider));
            this._proxy.$registerRangeFormattingSupport(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentRangeFormattingEdits = function (handle, resource, range, options) {
            return this._withAdapter(handle, RangeFormattingAdapter, function (adapter) { return adapter.provideDocumentRangeFormattingEdits(uri_1.default.revive(resource), range, options); });
        };
        ExtHostLanguageFeatures.prototype.registerOnTypeFormattingEditProvider = function (selector, provider, triggerCharacters) {
            var handle = this._addNewAdapter(new OnTypeFormattingAdapter(this._documents, provider));
            this._proxy.$registerOnTypeFormattingSupport(handle, this._transformDocumentSelector(selector), triggerCharacters);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideOnTypeFormattingEdits = function (handle, resource, position, ch, options) {
            return this._withAdapter(handle, OnTypeFormattingAdapter, function (adapter) { return adapter.provideOnTypeFormattingEdits(uri_1.default.revive(resource), position, ch, options); });
        };
        // --- navigate types
        ExtHostLanguageFeatures.prototype.registerWorkspaceSymbolProvider = function (provider) {
            var handle = this._addNewAdapter(new NavigateTypeAdapter(provider));
            this._proxy.$registerNavigateTypeSupport(handle);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideWorkspaceSymbols = function (handle, search) {
            return this._withAdapter(handle, NavigateTypeAdapter, function (adapter) { return adapter.provideWorkspaceSymbols(search); });
        };
        ExtHostLanguageFeatures.prototype.$resolveWorkspaceSymbol = function (handle, symbol) {
            return this._withAdapter(handle, NavigateTypeAdapter, function (adapter) { return adapter.resolveWorkspaceSymbol(symbol); });
        };
        ExtHostLanguageFeatures.prototype.$releaseWorkspaceSymbols = function (handle, id) {
            this._withAdapter(handle, NavigateTypeAdapter, function (adapter) { return adapter.releaseWorkspaceSymbols(id); });
        };
        // --- rename
        ExtHostLanguageFeatures.prototype.registerRenameProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new RenameAdapter(this._documents, provider));
            this._proxy.$registerRenameSupport(handle, this._transformDocumentSelector(selector), RenameAdapter.supportsResolving(provider));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideRenameEdits = function (handle, resource, position, newName) {
            return this._withAdapter(handle, RenameAdapter, function (adapter) { return adapter.provideRenameEdits(uri_1.default.revive(resource), position, newName); });
        };
        ExtHostLanguageFeatures.prototype.$resolveRenameLocation = function (handle, resource, position) {
            return this._withAdapter(handle, RenameAdapter, function (adapter) { return adapter.resolveRenameLocation(uri_1.default.revive(resource), position); });
        };
        // --- suggestion
        ExtHostLanguageFeatures.prototype.registerCompletionItemProvider = function (selector, provider, triggerCharacters) {
            var handle = this._addNewAdapter(new SuggestAdapter(this._documents, this._commands.converter, provider));
            this._proxy.$registerSuggestSupport(handle, this._transformDocumentSelector(selector), triggerCharacters, SuggestAdapter.supportsResolving(provider));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideCompletionItems = function (handle, resource, position, context) {
            return this._withAdapter(handle, SuggestAdapter, function (adapter) { return adapter.provideCompletionItems(uri_1.default.revive(resource), position, context); });
        };
        ExtHostLanguageFeatures.prototype.$resolveCompletionItem = function (handle, resource, position, suggestion) {
            return this._withAdapter(handle, SuggestAdapter, function (adapter) { return adapter.resolveCompletionItem(uri_1.default.revive(resource), position, suggestion); });
        };
        ExtHostLanguageFeatures.prototype.$releaseCompletionItems = function (handle, id) {
            this._withAdapter(handle, SuggestAdapter, function (adapter) { return adapter.releaseCompletionItems(id); });
        };
        // --- parameter hints
        ExtHostLanguageFeatures.prototype.registerSignatureHelpProvider = function (selector, provider, triggerCharacters) {
            var handle = this._addNewAdapter(new SignatureHelpAdapter(this._documents, provider));
            this._proxy.$registerSignatureHelpProvider(handle, this._transformDocumentSelector(selector), triggerCharacters);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideSignatureHelp = function (handle, resource, position) {
            return this._withAdapter(handle, SignatureHelpAdapter, function (adapter) { return adapter.provideSignatureHelp(uri_1.default.revive(resource), position); });
        };
        // --- links
        ExtHostLanguageFeatures.prototype.registerDocumentLinkProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new LinkProviderAdapter(this._documents, this._heapService, provider));
            this._proxy.$registerDocumentLinkProvider(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentLinks = function (handle, resource) {
            return this._withAdapter(handle, LinkProviderAdapter, function (adapter) { return adapter.provideLinks(uri_1.default.revive(resource)); });
        };
        ExtHostLanguageFeatures.prototype.$resolveDocumentLink = function (handle, link) {
            return this._withAdapter(handle, LinkProviderAdapter, function (adapter) { return adapter.resolveLink(link); });
        };
        ExtHostLanguageFeatures.prototype.registerColorProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new ColorProviderAdapter(this._documents, provider));
            this._proxy.$registerDocumentColorProvider(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentColors = function (handle, resource) {
            return this._withAdapter(handle, ColorProviderAdapter, function (adapter) { return adapter.provideColors(uri_1.default.revive(resource)); });
        };
        ExtHostLanguageFeatures.prototype.$provideColorPresentations = function (handle, resource, colorInfo) {
            return this._withAdapter(handle, ColorProviderAdapter, function (adapter) { return adapter.provideColorPresentations(uri_1.default.revive(resource), colorInfo); });
        };
        ExtHostLanguageFeatures.prototype.registerFoldingRangeProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new FoldingProviderAdapter(this._documents, provider));
            this._proxy.$registerFoldingRangeProvider(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideFoldingRanges = function (handle, resource, context) {
            return this._withAdapter(handle, FoldingProviderAdapter, function (adapter) { return adapter.provideFoldingRanges(uri_1.default.revive(resource), context); });
        };
        // --- configuration
        ExtHostLanguageFeatures._serializeRegExp = function (regExp) {
            if (typeof regExp === 'undefined') {
                return undefined;
            }
            if (regExp === null) {
                return null;
            }
            return {
                pattern: regExp.source,
                flags: (regExp.global ? 'g' : '') + (regExp.ignoreCase ? 'i' : '') + (regExp.multiline ? 'm' : ''),
            };
        };
        ExtHostLanguageFeatures._serializeIndentationRule = function (indentationRule) {
            if (typeof indentationRule === 'undefined') {
                return undefined;
            }
            if (indentationRule === null) {
                return null;
            }
            return {
                decreaseIndentPattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.decreaseIndentPattern),
                increaseIndentPattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.increaseIndentPattern),
                indentNextLinePattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.indentNextLinePattern),
                unIndentedLinePattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.unIndentedLinePattern),
            };
        };
        ExtHostLanguageFeatures._serializeOnEnterRule = function (onEnterRule) {
            return {
                beforeText: ExtHostLanguageFeatures._serializeRegExp(onEnterRule.beforeText),
                afterText: ExtHostLanguageFeatures._serializeRegExp(onEnterRule.afterText),
                action: onEnterRule.action
            };
        };
        ExtHostLanguageFeatures._serializeOnEnterRules = function (onEnterRules) {
            if (typeof onEnterRules === 'undefined') {
                return undefined;
            }
            if (onEnterRules === null) {
                return null;
            }
            return onEnterRules.map(ExtHostLanguageFeatures._serializeOnEnterRule);
        };
        ExtHostLanguageFeatures.prototype.setLanguageConfiguration = function (languageId, configuration) {
            var wordPattern = configuration.wordPattern;
            // check for a valid word pattern
            if (wordPattern && strings_1.regExpLeadsToEndlessLoop(wordPattern)) {
                throw new Error("Invalid language configuration: wordPattern '" + wordPattern + "' is not allowed to match the empty string.");
            }
            // word definition
            if (wordPattern) {
                this._documents.setWordDefinitionFor(languageId, wordPattern);
            }
            else {
                this._documents.setWordDefinitionFor(languageId, null);
            }
            var handle = this._nextHandle();
            var serializedConfiguration = {
                comments: configuration.comments,
                brackets: configuration.brackets,
                wordPattern: ExtHostLanguageFeatures._serializeRegExp(configuration.wordPattern),
                indentationRules: ExtHostLanguageFeatures._serializeIndentationRule(configuration.indentationRules),
                onEnterRules: ExtHostLanguageFeatures._serializeOnEnterRules(configuration.onEnterRules),
                __electricCharacterSupport: configuration.__electricCharacterSupport,
                __characterPairSupport: configuration.__characterPairSupport,
            };
            this._proxy.$setLanguageConfiguration(handle, languageId, serializedConfiguration);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures._handlePool = 0;
        return ExtHostLanguageFeatures;
    }());
    exports.ExtHostLanguageFeatures = ExtHostLanguageFeatures;
});

















define(__m[230/*vs/workbench/api/node/extHostProgress*/], __M([0/*require*/,1/*exports*/,19/*vs/workbench/api/node/extHostTypeConverters*/,135/*vs/platform/progress/common/progress*/,109/*vs/nls!vs/workbench/api/node/extHostProgress*/,29/*vs/base/common/cancellation*/,52/*vs/base/common/decorators*/]), function (require, exports, extHostTypeConverters_1, progress_1, nls_1, cancellation_1, decorators_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostProgress = /** @class */ (function () {
        function ExtHostProgress(proxy) {
            this._handles = 0;
            this._mapHandleToCancellationSource = new Map();
            this._proxy = proxy;
        }
        ExtHostProgress.prototype.withProgress = function (extension, options, task) {
            var handle = this._handles++;
            var title = options.title, location = options.location, cancellable = options.cancellable;
            var source = nls_1.localize(0, null, extension.displayName || extension.name);
            this._proxy.$startProgress(handle, { location: extHostTypeConverters_1.ProgressLocation.from(location), title: title, source: source, cancellable: cancellable });
            return this._withProgress(handle, task, cancellable);
        };
        ExtHostProgress.prototype._withProgress = function (handle, task, cancellable) {
            var _this = this;
            var source;
            if (cancellable) {
                source = new cancellation_1.CancellationTokenSource();
                this._mapHandleToCancellationSource.set(handle, source);
            }
            var progressEnd = function (handle) {
                _this._proxy.$progressEnd(handle);
                _this._mapHandleToCancellationSource.delete(handle);
                if (source) {
                    source.dispose();
                }
            };
            var p;
            try {
                p = task(new ProgressCallback(this._proxy, handle), cancellable ? source.token : cancellation_1.CancellationToken.None);
            }
            catch (err) {
                progressEnd(handle);
                throw err;
            }
            p.then(function (result) { return progressEnd(handle); }, function (err) { return progressEnd(handle); });
            return p;
        };
        ExtHostProgress.prototype.$acceptProgressCanceled = function (handle) {
            var source = this._mapHandleToCancellationSource.get(handle);
            if (source) {
                source.cancel();
                this._mapHandleToCancellationSource.delete(handle);
            }
        };
        return ExtHostProgress;
    }());
    exports.ExtHostProgress = ExtHostProgress;
    function mergeProgress(result, currentValue) {
        result.message = currentValue.message;
        if (typeof currentValue.increment === 'number') {
            if (typeof result.increment === 'number') {
                result.increment += currentValue.increment;
            }
            else {
                result.increment = currentValue.increment;
            }
        }
        return result;
    }
    var ProgressCallback = /** @class */ (function (_super) {
        __extends(ProgressCallback, _super);
        function ProgressCallback(_proxy, _handle) {
            var _this = _super.call(this, function (p) { return _this.throttledReport(p); }) || this;
            _this._proxy = _proxy;
            _this._handle = _handle;
            return _this;
        }
        ProgressCallback.prototype.throttledReport = function (p) {
            this._proxy.$progressReport(this._handle, p);
        };
        __decorate([
            decorators_1.debounce(100, function (result, currentValue) { return mergeProgress(result, currentValue); }, function () { return Object.create(null); })
        ], ProgressCallback.prototype, "throttledReport", null);
        return ProgressCallback;
    }(progress_1.Progress));
});







define(__m[84/*vs/workbench/api/node/extHostTextEditor*/], __M([0/*require*/,1/*exports*/,32/*vs/base/common/assert*/,14/*vs/base/common/errors*/,120/*vs/base/common/idGenerator*/,2/*vs/base/common/winjs.base*/,5/*vs/workbench/api/node/extHostTypes*/,19/*vs/workbench/api/node/extHostTypeConverters*/]), function (require, exports, assert_1, errors_1, idGenerator_1, winjs_base_1, extHostTypes_1, TypeConverters) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextEditorDecorationType = /** @class */ (function () {
        function TextEditorDecorationType(proxy, options) {
            this.key = TextEditorDecorationType._Keys.nextId();
            this._proxy = proxy;
            this._proxy.$registerTextEditorDecorationType(this.key, options);
        }
        TextEditorDecorationType.prototype.dispose = function () {
            this._proxy.$removeTextEditorDecorationType(this.key);
        };
        TextEditorDecorationType._Keys = new idGenerator_1.IdGenerator('TextEditorDecorationType');
        return TextEditorDecorationType;
    }());
    exports.TextEditorDecorationType = TextEditorDecorationType;
    var TextEditorEdit = /** @class */ (function () {
        function TextEditorEdit(document, options) {
            this._document = document;
            this._documentVersionId = document.version;
            this._collectedEdits = [];
            this._setEndOfLine = 0;
            this._undoStopBefore = options.undoStopBefore;
            this._undoStopAfter = options.undoStopAfter;
        }
        TextEditorEdit.prototype.finalize = function () {
            return {
                documentVersionId: this._documentVersionId,
                edits: this._collectedEdits,
                setEndOfLine: this._setEndOfLine,
                undoStopBefore: this._undoStopBefore,
                undoStopAfter: this._undoStopAfter
            };
        };
        TextEditorEdit.prototype.replace = function (location, value) {
            var range = null;
            if (location instanceof extHostTypes_1.Position) {
                range = new extHostTypes_1.Range(location, location);
            }
            else if (location instanceof extHostTypes_1.Range) {
                range = location;
            }
            else {
                throw new Error('Unrecognized location');
            }
            this._pushEdit(range, value, false);
        };
        TextEditorEdit.prototype.insert = function (location, value) {
            this._pushEdit(new extHostTypes_1.Range(location, location), value, true);
        };
        TextEditorEdit.prototype.delete = function (location) {
            var range = null;
            if (location instanceof extHostTypes_1.Range) {
                range = location;
            }
            else {
                throw new Error('Unrecognized location');
            }
            this._pushEdit(range, null, true);
        };
        TextEditorEdit.prototype._pushEdit = function (range, text, forceMoveMarkers) {
            var validRange = this._document.validateRange(range);
            this._collectedEdits.push({
                range: validRange,
                text: text,
                forceMoveMarkers: forceMoveMarkers
            });
        };
        TextEditorEdit.prototype.setEndOfLine = function (endOfLine) {
            if (endOfLine !== extHostTypes_1.EndOfLine.LF && endOfLine !== extHostTypes_1.EndOfLine.CRLF) {
                throw errors_1.illegalArgument('endOfLine');
            }
            this._setEndOfLine = endOfLine;
        };
        return TextEditorEdit;
    }());
    exports.TextEditorEdit = TextEditorEdit;
    function deprecated(name, message) {
        if (message === void 0) { message = 'Refer to the documentation for further details.'; }
        return function (target, key, descriptor) {
            var originalMethod = descriptor.value;
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                console.warn("[Deprecation Warning] method '" + name + "' is deprecated and should no longer be used. " + message);
                return originalMethod.apply(this, args);
            };
            return descriptor;
        };
    }
    var ExtHostTextEditorOptions = /** @class */ (function () {
        function ExtHostTextEditorOptions(proxy, id, source) {
            this._proxy = proxy;
            this._id = id;
            this._accept(source);
        }
        ExtHostTextEditorOptions.prototype._accept = function (source) {
            this._tabSize = source.tabSize;
            this._insertSpaces = source.insertSpaces;
            this._cursorStyle = source.cursorStyle;
            this._lineNumbers = source.lineNumbers;
        };
        Object.defineProperty(ExtHostTextEditorOptions.prototype, "tabSize", {
            get: function () {
                return this._tabSize;
            },
            set: function (value) {
                var tabSize = this._validateTabSize(value);
                if (tabSize === null) {
                    // ignore invalid call
                    return;
                }
                if (typeof tabSize === 'number') {
                    if (this._tabSize === tabSize) {
                        // nothing to do
                        return;
                    }
                    // reflect the new tabSize value immediately
                    this._tabSize = tabSize;
                }
                warnOnError(this._proxy.$trySetOptions(this._id, {
                    tabSize: tabSize
                }));
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditorOptions.prototype._validateTabSize = function (value) {
            if (value === 'auto') {
                return 'auto';
            }
            if (typeof value === 'number') {
                var r = Math.floor(value);
                return (r > 0 ? r : null);
            }
            if (typeof value === 'string') {
                var r = parseInt(value, 10);
                if (isNaN(r)) {
                    return null;
                }
                return (r > 0 ? r : null);
            }
            return null;
        };
        Object.defineProperty(ExtHostTextEditorOptions.prototype, "insertSpaces", {
            get: function () {
                return this._insertSpaces;
            },
            set: function (value) {
                var insertSpaces = this._validateInsertSpaces(value);
                if (typeof insertSpaces === 'boolean') {
                    if (this._insertSpaces === insertSpaces) {
                        // nothing to do
                        return;
                    }
                    // reflect the new insertSpaces value immediately
                    this._insertSpaces = insertSpaces;
                }
                warnOnError(this._proxy.$trySetOptions(this._id, {
                    insertSpaces: insertSpaces
                }));
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditorOptions.prototype._validateInsertSpaces = function (value) {
            if (value === 'auto') {
                return 'auto';
            }
            return (value === 'false' ? false : Boolean(value));
        };
        Object.defineProperty(ExtHostTextEditorOptions.prototype, "cursorStyle", {
            get: function () {
                return this._cursorStyle;
            },
            set: function (value) {
                if (this._cursorStyle === value) {
                    // nothing to do
                    return;
                }
                this._cursorStyle = value;
                warnOnError(this._proxy.$trySetOptions(this._id, {
                    cursorStyle: value
                }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTextEditorOptions.prototype, "lineNumbers", {
            get: function () {
                return this._lineNumbers;
            },
            set: function (value) {
                if (this._lineNumbers === value) {
                    // nothing to do
                    return;
                }
                this._lineNumbers = value;
                warnOnError(this._proxy.$trySetOptions(this._id, {
                    lineNumbers: value
                }));
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditorOptions.prototype.assign = function (newOptions) {
            var bulkConfigurationUpdate = {};
            var hasUpdate = false;
            if (typeof newOptions.tabSize !== 'undefined') {
                var tabSize = this._validateTabSize(newOptions.tabSize);
                if (tabSize === 'auto') {
                    hasUpdate = true;
                    bulkConfigurationUpdate.tabSize = tabSize;
                }
                else if (typeof tabSize === 'number' && this._tabSize !== tabSize) {
                    // reflect the new tabSize value immediately
                    this._tabSize = tabSize;
                    hasUpdate = true;
                    bulkConfigurationUpdate.tabSize = tabSize;
                }
            }
            if (typeof newOptions.insertSpaces !== 'undefined') {
                var insertSpaces = this._validateInsertSpaces(newOptions.insertSpaces);
                if (insertSpaces === 'auto') {
                    hasUpdate = true;
                    bulkConfigurationUpdate.insertSpaces = insertSpaces;
                }
                else if (this._insertSpaces !== insertSpaces) {
                    // reflect the new insertSpaces value immediately
                    this._insertSpaces = insertSpaces;
                    hasUpdate = true;
                    bulkConfigurationUpdate.insertSpaces = insertSpaces;
                }
            }
            if (typeof newOptions.cursorStyle !== 'undefined') {
                if (this._cursorStyle !== newOptions.cursorStyle) {
                    this._cursorStyle = newOptions.cursorStyle;
                    hasUpdate = true;
                    bulkConfigurationUpdate.cursorStyle = newOptions.cursorStyle;
                }
            }
            if (typeof newOptions.lineNumbers !== 'undefined') {
                if (this._lineNumbers !== newOptions.lineNumbers) {
                    this._lineNumbers = newOptions.lineNumbers;
                    hasUpdate = true;
                    bulkConfigurationUpdate.lineNumbers = newOptions.lineNumbers;
                }
            }
            if (hasUpdate) {
                warnOnError(this._proxy.$trySetOptions(this._id, bulkConfigurationUpdate));
            }
        };
        return ExtHostTextEditorOptions;
    }());
    exports.ExtHostTextEditorOptions = ExtHostTextEditorOptions;
    var ExtHostTextEditor = /** @class */ (function () {
        function ExtHostTextEditor(proxy, id, document, selections, options, visibleRanges, viewColumn) {
            this._disposed = false;
            this._proxy = proxy;
            this._id = id;
            this._documentData = document;
            this._selections = selections;
            this._options = new ExtHostTextEditorOptions(this._proxy, this._id, options);
            this._visibleRanges = visibleRanges;
            this._viewColumn = viewColumn;
        }
        Object.defineProperty(ExtHostTextEditor.prototype, "id", {
            get: function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype.dispose = function () {
            assert_1.ok(!this._disposed);
            this._disposed = true;
        };
        ExtHostTextEditor.prototype.show = function (column) {
            this._proxy.$tryShowEditor(this._id, TypeConverters.ViewColumn.from(column));
        };
        ExtHostTextEditor.prototype.hide = function () {
            this._proxy.$tryHideEditor(this._id);
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "document", {
            // ---- the document
            get: function () {
                return this._documentData.document;
            },
            set: function (value) {
                throw errors_1.readonly('document');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTextEditor.prototype, "options", {
            // ---- options
            get: function () {
                return this._options;
            },
            set: function (value) {
                if (!this._disposed) {
                    this._options.assign(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype._acceptOptions = function (options) {
            assert_1.ok(!this._disposed);
            this._options._accept(options);
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "visibleRanges", {
            // ---- visible ranges
            get: function () {
                return this._visibleRanges;
            },
            set: function (value) {
                throw errors_1.readonly('visibleRanges');
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype._acceptVisibleRanges = function (value) {
            assert_1.ok(!this._disposed);
            this._visibleRanges = value;
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "viewColumn", {
            // ---- view column
            get: function () {
                return this._viewColumn;
            },
            set: function (value) {
                throw errors_1.readonly('viewColumn');
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype._acceptViewColumn = function (value) {
            assert_1.ok(!this._disposed);
            this._viewColumn = value;
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "selection", {
            // ---- selections
            get: function () {
                return this._selections && this._selections[0];
            },
            set: function (value) {
                if (!(value instanceof extHostTypes_1.Selection)) {
                    throw errors_1.illegalArgument('selection');
                }
                this._selections = [value];
                this._trySetSelection();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTextEditor.prototype, "selections", {
            get: function () {
                return this._selections;
            },
            set: function (value) {
                if (!Array.isArray(value) || value.some(function (a) { return !(a instanceof extHostTypes_1.Selection); })) {
                    throw errors_1.illegalArgument('selections');
                }
                this._selections = value;
                this._trySetSelection();
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype.setDecorations = function (decorationType, ranges) {
            var _this = this;
            this._runOnProxy(function () {
                if (TypeConverters.isDecorationOptionsArr(ranges)) {
                    return _this._proxy.$trySetDecorations(_this._id, decorationType.key, TypeConverters.fromRangeOrRangeWithMessage(ranges));
                }
                else {
                    var _ranges = new Array(4 * ranges.length);
                    for (var i = 0, len = ranges.length; i < len; i++) {
                        var range = ranges[i];
                        _ranges[4 * i] = range.start.line + 1;
                        _ranges[4 * i + 1] = range.start.character + 1;
                        _ranges[4 * i + 2] = range.end.line + 1;
                        _ranges[4 * i + 3] = range.end.character + 1;
                    }
                    return _this._proxy.$trySetDecorationsFast(_this._id, decorationType.key, _ranges);
                }
            });
        };
        ExtHostTextEditor.prototype.revealRange = function (range, revealType) {
            var _this = this;
            this._runOnProxy(function () { return _this._proxy.$tryRevealRange(_this._id, TypeConverters.Range.from(range), (revealType || extHostTypes_1.TextEditorRevealType.Default)); });
        };
        ExtHostTextEditor.prototype._trySetSelection = function () {
            var _this = this;
            var selection = this._selections.map(TypeConverters.Selection.from);
            return this._runOnProxy(function () { return _this._proxy.$trySetSelections(_this._id, selection); });
        };
        ExtHostTextEditor.prototype._acceptSelections = function (selections) {
            assert_1.ok(!this._disposed);
            this._selections = selections;
        };
        // ---- editing
        ExtHostTextEditor.prototype.edit = function (callback, options) {
            if (options === void 0) { options = { undoStopBefore: true, undoStopAfter: true }; }
            if (this._disposed) {
                return winjs_base_1.TPromise.wrapError(new Error('TextEditor#edit not possible on closed editors'));
            }
            var edit = new TextEditorEdit(this._documentData.document, options);
            callback(edit);
            return this._applyEdit(edit);
        };
        ExtHostTextEditor.prototype._applyEdit = function (editBuilder) {
            var editData = editBuilder.finalize();
            // return when there is nothing to do
            if (editData.edits.length === 0 && !editData.setEndOfLine) {
                return winjs_base_1.TPromise.wrap(true);
            }
            // check that the edits are not overlapping (i.e. illegal)
            var editRanges = editData.edits.map(function (edit) { return edit.range; });
            // sort ascending (by end and then by start)
            editRanges.sort(function (a, b) {
                if (a.end.line === b.end.line) {
                    if (a.end.character === b.end.character) {
                        if (a.start.line === b.start.line) {
                            return a.start.character - b.start.character;
                        }
                        return a.start.line - b.start.line;
                    }
                    return a.end.character - b.end.character;
                }
                return a.end.line - b.end.line;
            });
            // check that no edits are overlapping
            for (var i = 0, count = editRanges.length - 1; i < count; i++) {
                var rangeEnd = editRanges[i].end;
                var nextRangeStart = editRanges[i + 1].start;
                if (nextRangeStart.isBefore(rangeEnd)) {
                    // overlapping ranges
                    return winjs_base_1.TPromise.wrapError(new Error('Overlapping ranges are not allowed!'));
                }
            }
            // prepare data for serialization
            var edits = editData.edits.map(function (edit) {
                return {
                    range: TypeConverters.Range.from(edit.range),
                    text: edit.text,
                    forceMoveMarkers: edit.forceMoveMarkers
                };
            });
            return this._proxy.$tryApplyEdits(this._id, editData.documentVersionId, edits, {
                setEndOfLine: editData.setEndOfLine,
                undoStopBefore: editData.undoStopBefore,
                undoStopAfter: editData.undoStopAfter
            });
        };
        ExtHostTextEditor.prototype.insertSnippet = function (snippet, where, options) {
            if (options === void 0) { options = { undoStopBefore: true, undoStopAfter: true }; }
            if (this._disposed) {
                return winjs_base_1.TPromise.wrapError(new Error('TextEditor#insertSnippet not possible on closed editors'));
            }
            var ranges;
            if (!where || (Array.isArray(where) && where.length === 0)) {
                ranges = this._selections.map(TypeConverters.Range.from);
            }
            else if (where instanceof extHostTypes_1.Position) {
                var _a = TypeConverters.Position.from(where), lineNumber = _a.lineNumber, column = _a.column;
                ranges = [{ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column }];
            }
            else if (where instanceof extHostTypes_1.Range) {
                ranges = [TypeConverters.Range.from(where)];
            }
            else {
                ranges = [];
                for (var _i = 0, where_1 = where; _i < where_1.length; _i++) {
                    var posOrRange = where_1[_i];
                    if (posOrRange instanceof extHostTypes_1.Range) {
                        ranges.push(TypeConverters.Range.from(posOrRange));
                    }
                    else {
                        var _b = TypeConverters.Position.from(posOrRange), lineNumber = _b.lineNumber, column = _b.column;
                        ranges.push({ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column });
                    }
                }
            }
            return this._proxy.$tryInsertSnippet(this._id, snippet.value, ranges, options);
        };
        // ---- util
        ExtHostTextEditor.prototype._runOnProxy = function (callback) {
            var _this = this;
            if (this._disposed) {
                console.warn('TextEditor is closed/disposed');
                return winjs_base_1.TPromise.as(undefined);
            }
            return callback().then(function () { return _this; }, function (err) {
                if (!(err instanceof Error && err.name === 'DISPOSED')) {
                    console.warn(err);
                }
                return null;
            });
        };
        __decorate([
            deprecated('TextEditor.show')
        ], ExtHostTextEditor.prototype, "show", null);
        __decorate([
            deprecated('TextEditor.hide')
        ], ExtHostTextEditor.prototype, "hide", null);
        return ExtHostTextEditor;
    }());
    exports.ExtHostTextEditor = ExtHostTextEditor;
    function warnOnError(promise) {
        promise.then(null, function (err) {
            console.warn(err);
        });
    }
});

define(__m[232/*vs/workbench/api/node/extHostDocumentsAndEditors*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,9/*vs/base/common/lifecycle*/,6/*vs/workbench/api/node/extHost.protocol*/,76/*vs/workbench/api/node/extHostDocumentData*/,84/*vs/workbench/api/node/extHostTextEditor*/,147/*assert*/,19/*vs/workbench/api/node/extHostTypeConverters*/,4/*vs/base/common/uri*/]), function (require, exports, event_1, lifecycle_1, extHost_protocol_1, extHostDocumentData_1, extHostTextEditor_1, assert, typeConverters, uri_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDocumentsAndEditors = /** @class */ (function () {
        function ExtHostDocumentsAndEditors(_mainContext) {
            this._mainContext = _mainContext;
            this._disposables = [];
            this._editors = new Map();
            this._documents = new Map();
            this._onDidAddDocuments = new event_1.Emitter();
            this._onDidRemoveDocuments = new event_1.Emitter();
            this._onDidChangeVisibleTextEditors = new event_1.Emitter();
            this._onDidChangeActiveTextEditor = new event_1.Emitter();
            this.onDidAddDocuments = this._onDidAddDocuments.event;
            this.onDidRemoveDocuments = this._onDidRemoveDocuments.event;
            this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
            this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
        }
        ExtHostDocumentsAndEditors.prototype.dispose = function () {
            this._disposables = lifecycle_1.dispose(this._disposables);
        };
        ExtHostDocumentsAndEditors.prototype.$acceptDocumentsAndEditorsDelta = function (delta) {
            var removedDocuments = [];
            var addedDocuments = [];
            var removedEditors = [];
            if (delta.removedDocuments) {
                for (var _i = 0, _a = delta.removedDocuments; _i < _a.length; _i++) {
                    var uriComponent = _a[_i];
                    var uri = uri_1.default.revive(uriComponent);
                    var id = uri.toString();
                    var data = this._documents.get(id);
                    this._documents.delete(id);
                    removedDocuments.push(data);
                }
            }
            if (delta.addedDocuments) {
                for (var _b = 0, _c = delta.addedDocuments; _b < _c.length; _b++) {
                    var data = _c[_b];
                    var resource = uri_1.default.revive(data.uri);
                    assert.ok(!this._documents.has(resource.toString()), "document '" + resource + " already exists!'");
                    var documentData = new extHostDocumentData_1.ExtHostDocumentData(this._mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDocuments), resource, data.lines, data.EOL, data.modeId, data.versionId, data.isDirty);
                    this._documents.set(resource.toString(), documentData);
                    addedDocuments.push(documentData);
                }
            }
            if (delta.removedEditors) {
                for (var _d = 0, _e = delta.removedEditors; _d < _e.length; _d++) {
                    var id = _e[_d];
                    var editor = this._editors.get(id);
                    this._editors.delete(id);
                    removedEditors.push(editor);
                }
            }
            if (delta.addedEditors) {
                for (var _f = 0, _g = delta.addedEditors; _f < _g.length; _f++) {
                    var data = _g[_f];
                    var resource = uri_1.default.revive(data.documentUri);
                    assert.ok(this._documents.has(resource.toString()), "document '" + resource + "' does not exist");
                    assert.ok(!this._editors.has(data.id), "editor '" + data.id + "' already exists!");
                    var documentData = this._documents.get(resource.toString());
                    var editor = new extHostTextEditor_1.ExtHostTextEditor(this._mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTextEditors), data.id, documentData, data.selections.map(typeConverters.Selection.to), data.options, data.visibleRanges.map(typeConverters.Range.to), typeConverters.ViewColumn.to(data.editorPosition));
                    this._editors.set(data.id, editor);
                }
            }
            if (delta.newActiveEditor !== undefined) {
                assert.ok(delta.newActiveEditor === null || this._editors.has(delta.newActiveEditor), "active editor '" + delta.newActiveEditor + "' does not exist");
                this._activeEditorId = delta.newActiveEditor;
            }
            lifecycle_1.dispose(removedDocuments);
            lifecycle_1.dispose(removedEditors);
            // now that the internal state is complete, fire events
            if (delta.removedDocuments) {
                this._onDidRemoveDocuments.fire(removedDocuments);
            }
            if (delta.addedDocuments) {
                this._onDidAddDocuments.fire(addedDocuments);
            }
            if (delta.removedEditors || delta.addedEditors) {
                this._onDidChangeVisibleTextEditors.fire(this.allEditors());
            }
            if (delta.newActiveEditor !== undefined) {
                this._onDidChangeActiveTextEditor.fire(this.activeEditor());
            }
        };
        ExtHostDocumentsAndEditors.prototype.getDocument = function (strUrl) {
            return this._documents.get(strUrl);
        };
        ExtHostDocumentsAndEditors.prototype.allDocuments = function () {
            var result = [];
            this._documents.forEach(function (data) { return result.push(data); });
            return result;
        };
        ExtHostDocumentsAndEditors.prototype.getEditor = function (id) {
            return this._editors.get(id);
        };
        ExtHostDocumentsAndEditors.prototype.activeEditor = function () {
            if (!this._activeEditorId) {
                return undefined;
            }
            else {
                return this._editors.get(this._activeEditorId);
            }
        };
        ExtHostDocumentsAndEditors.prototype.allEditors = function () {
            var result = [];
            this._editors.forEach(function (data) { return result.push(data); });
            return result;
        };
        return ExtHostDocumentsAndEditors;
    }());
    exports.ExtHostDocumentsAndEditors = ExtHostDocumentsAndEditors;
});

define(__m[233/*vs/workbench/api/node/extHostTextEditors*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,12/*vs/base/common/async*/,5/*vs/workbench/api/node/extHostTypes*/,19/*vs/workbench/api/node/extHostTypeConverters*/,84/*vs/workbench/api/node/extHostTextEditor*/,6/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, event_1, async_1, extHostTypes_1, TypeConverters, extHostTextEditor_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostEditors = /** @class */ (function () {
        function ExtHostEditors(mainContext, extHostDocumentsAndEditors) {
            var _this = this;
            this._onDidChangeTextEditorSelection = new event_1.Emitter();
            this._onDidChangeTextEditorOptions = new event_1.Emitter();
            this._onDidChangeTextEditorVisibleRanges = new event_1.Emitter();
            this._onDidChangeTextEditorViewColumn = new event_1.Emitter();
            this._onDidChangeActiveTextEditor = new event_1.Emitter();
            this._onDidChangeVisibleTextEditors = new event_1.Emitter();
            this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event;
            this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event;
            this.onDidChangeTextEditorVisibleRanges = this._onDidChangeTextEditorVisibleRanges.event;
            this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event;
            this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
            this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTextEditors);
            this._extHostDocumentsAndEditors = extHostDocumentsAndEditors;
            this._extHostDocumentsAndEditors.onDidChangeVisibleTextEditors(function (e) { return _this._onDidChangeVisibleTextEditors.fire(e); });
            this._extHostDocumentsAndEditors.onDidChangeActiveTextEditor(function (e) { return _this._onDidChangeActiveTextEditor.fire(e); });
        }
        ExtHostEditors.prototype.getActiveTextEditor = function () {
            return this._extHostDocumentsAndEditors.activeEditor();
        };
        ExtHostEditors.prototype.getVisibleTextEditors = function () {
            return this._extHostDocumentsAndEditors.allEditors();
        };
        ExtHostEditors.prototype.showTextDocument = function (document, columnOrOptions, preserveFocus) {
            var _this = this;
            var options;
            if (typeof columnOrOptions === 'number') {
                options = {
                    position: TypeConverters.ViewColumn.from(columnOrOptions),
                    preserveFocus: preserveFocus
                };
            }
            else if (typeof columnOrOptions === 'object') {
                options = {
                    position: TypeConverters.ViewColumn.from(columnOrOptions.viewColumn),
                    preserveFocus: columnOrOptions.preserveFocus,
                    selection: typeof columnOrOptions.selection === 'object' ? TypeConverters.Range.from(columnOrOptions.selection) : undefined,
                    pinned: typeof columnOrOptions.preview === 'boolean' ? !columnOrOptions.preview : undefined
                };
            }
            else {
                options = {
                    preserveFocus: false
                };
            }
            return this._proxy.$tryShowTextDocument(document.uri, options).then(function (id) {
                var editor = _this._extHostDocumentsAndEditors.getEditor(id);
                if (editor) {
                    return editor;
                }
                else {
                    throw new Error("Failed to show text document " + document.uri.toString() + ", should show in editor #" + id);
                }
            });
        };
        ExtHostEditors.prototype.createTextEditorDecorationType = function (options) {
            return new extHostTextEditor_1.TextEditorDecorationType(this._proxy, options);
        };
        ExtHostEditors.prototype.applyWorkspaceEdit = function (edit) {
            var dto = TypeConverters.WorkspaceEdit.from(edit, this._extHostDocumentsAndEditors);
            return this._proxy.$tryApplyWorkspaceEdit(dto);
        };
        // --- called from main thread
        ExtHostEditors.prototype.$acceptEditorPropertiesChanged = function (id, data) {
            var textEditor = this._extHostDocumentsAndEditors.getEditor(id);
            // (1) set all properties
            if (data.options) {
                textEditor._acceptOptions(data.options);
            }
            if (data.selections) {
                var selections = data.selections.selections.map(TypeConverters.Selection.to);
                textEditor._acceptSelections(selections);
            }
            if (data.visibleRanges) {
                var visibleRanges = data.visibleRanges.map(TypeConverters.Range.to);
                textEditor._acceptVisibleRanges(visibleRanges);
            }
            // (2) fire change events
            if (data.options) {
                this._onDidChangeTextEditorOptions.fire({
                    textEditor: textEditor,
                    options: data.options
                });
            }
            if (data.selections) {
                var kind = extHostTypes_1.TextEditorSelectionChangeKind.fromValue(data.selections.source);
                var selections = data.selections.selections.map(TypeConverters.Selection.to);
                this._onDidChangeTextEditorSelection.fire({
                    textEditor: textEditor,
                    selections: selections,
                    kind: kind
                });
            }
            if (data.visibleRanges) {
                var visibleRanges = data.visibleRanges.map(TypeConverters.Range.to);
                this._onDidChangeTextEditorVisibleRanges.fire({
                    textEditor: textEditor,
                    visibleRanges: visibleRanges
                });
            }
        };
        ExtHostEditors.prototype.$acceptEditorPositionData = function (data) {
            for (var id in data) {
                var textEditor = this._extHostDocumentsAndEditors.getEditor(id);
                var viewColumn = TypeConverters.ViewColumn.to(data[id]);
                if (textEditor.viewColumn !== viewColumn) {
                    textEditor._acceptViewColumn(viewColumn);
                    this._onDidChangeTextEditorViewColumn.fire({ textEditor: textEditor, viewColumn: viewColumn });
                }
            }
        };
        ExtHostEditors.prototype.getDiffInformation = function (id) {
            return async_1.toThenable(this._proxy.$getDiffInformation(id));
        };
        return ExtHostEditors;
    }());
    exports.ExtHostEditors = ExtHostEditors;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[234/*vs/workbench/api/node/extHostWebview*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,4/*vs/base/common/uri*/,2/*vs/base/common/winjs.base*/,19/*vs/workbench/api/node/extHostTypeConverters*/,6/*vs/workbench/api/node/extHost.protocol*/,5/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, event_1, uri_1, winjs_base_1, typeConverters, extHost_protocol_1, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostWebview = /** @class */ (function () {
        function ExtHostWebview(handle, proxy, options) {
            this._isDisposed = false;
            this._onMessageEmitter = new event_1.Emitter();
            this.onDidReceiveMessage = this._onMessageEmitter.event;
            this._handle = handle;
            this._proxy = proxy;
            this._options = options;
        }
        ExtHostWebview.prototype.dispose = function () {
            this._onMessageEmitter.dispose();
        };
        Object.defineProperty(ExtHostWebview.prototype, "html", {
            get: function () {
                this.assertNotDisposed();
                return this._html;
            },
            set: function (value) {
                this.assertNotDisposed();
                if (this._html !== value) {
                    this._html = value;
                    this._proxy.$setHtml(this._handle, value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWebview.prototype, "options", {
            get: function () {
                this.assertNotDisposed();
                return this._options;
            },
            set: function (newOptions) {
                this.assertNotDisposed();
                this._proxy.$setOptions(this._handle, newOptions);
                this._options = newOptions;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWebview.prototype.postMessage = function (message) {
            this.assertNotDisposed();
            return this._proxy.$postMessage(this._handle, message);
        };
        ExtHostWebview.prototype.assertNotDisposed = function () {
            if (this._isDisposed) {
                throw new Error('Webview is disposed');
            }
        };
        return ExtHostWebview;
    }());
    exports.ExtHostWebview = ExtHostWebview;
    var ExtHostWebviewPanel = /** @class */ (function () {
        function ExtHostWebviewPanel(handle, proxy, viewType, title, viewColumn, editorOptions, webview) {
            this._isDisposed = false;
            this._visible = true;
            this._active = true;
            this._onDisposeEmitter = new event_1.Emitter();
            this.onDidDispose = this._onDisposeEmitter.event;
            this._onDidChangeViewStateEmitter = new event_1.Emitter();
            this.onDidChangeViewState = this._onDidChangeViewStateEmitter.event;
            this._handle = handle;
            this._proxy = proxy;
            this._viewType = viewType;
            this._options = editorOptions;
            this._viewColumn = viewColumn;
            this._title = title;
            this._webview = webview;
        }
        ExtHostWebviewPanel.prototype.dispose = function () {
            if (this._isDisposed) {
                return;
            }
            this._isDisposed = true;
            this._onDisposeEmitter.fire();
            this._proxy.$disposeWebview(this._handle);
            this._webview.dispose();
            this._onDisposeEmitter.dispose();
            this._onDidChangeViewStateEmitter.dispose();
        };
        Object.defineProperty(ExtHostWebviewPanel.prototype, "webview", {
            get: function () {
                this.assertNotDisposed();
                return this._webview;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWebviewPanel.prototype, "viewType", {
            get: function () {
                this.assertNotDisposed();
                return this._viewType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWebviewPanel.prototype, "title", {
            get: function () {
                this.assertNotDisposed();
                return this._title;
            },
            set: function (value) {
                this.assertNotDisposed();
                if (this._title !== value) {
                    this._title = value;
                    this._proxy.$setTitle(this._handle, value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWebviewPanel.prototype, "iconPath", {
            get: function () {
                this.assertNotDisposed();
                return this._iconPath;
            },
            set: function (value) {
                this.assertNotDisposed();
                if (this._iconPath !== value) {
                    this._iconPath = value;
                    this._proxy.$setIconPath(this._handle, uri_1.default.isUri(value) ? { light: value, dark: value } : value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWebviewPanel.prototype, "options", {
            get: function () {
                return this._options;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWebviewPanel.prototype, "viewColumn", {
            get: function () {
                this.assertNotDisposed();
                return this._viewColumn;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWebviewPanel.prototype._setViewColumn = function (value) {
            this.assertNotDisposed();
            this._viewColumn = value;
        };
        Object.defineProperty(ExtHostWebviewPanel.prototype, "active", {
            get: function () {
                this.assertNotDisposed();
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWebviewPanel.prototype._setActive = function (value) {
            this.assertNotDisposed();
            this._active = value;
        };
        Object.defineProperty(ExtHostWebviewPanel.prototype, "visible", {
            get: function () {
                this.assertNotDisposed();
                return this._visible;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWebviewPanel.prototype._setVisible = function (value) {
            this.assertNotDisposed();
            this._visible = value;
        };
        ExtHostWebviewPanel.prototype.postMessage = function (message) {
            this.assertNotDisposed();
            return this._proxy.$postMessage(this._handle, message);
        };
        ExtHostWebviewPanel.prototype.reveal = function (viewColumn, preserveFocus) {
            this.assertNotDisposed();
            this._proxy.$reveal(this._handle, {
                viewColumn: viewColumn ? typeConverters.ViewColumn.from(viewColumn) : undefined,
                preserveFocus: !!preserveFocus
            });
        };
        ExtHostWebviewPanel.prototype.assertNotDisposed = function () {
            if (this._isDisposed) {
                throw new Error('Webview is disposed');
            }
        };
        return ExtHostWebviewPanel;
    }());
    exports.ExtHostWebviewPanel = ExtHostWebviewPanel;
    var ExtHostWebviews = /** @class */ (function () {
        function ExtHostWebviews(mainContext) {
            this._webviewPanels = new Map();
            this._serializers = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadWebviews);
        }
        ExtHostWebviews.newHandle = function () {
            return ExtHostWebviews.webviewHandlePool++ + '';
        };
        ExtHostWebviews.prototype.createWebview = function (extensionLocation, viewType, title, showOptions, options) {
            if (options === void 0) { options = {}; }
            var viewColumn = typeof showOptions === 'object' ? showOptions.viewColumn : showOptions;
            var webviewShowOptions = {
                viewColumn: typeConverters.ViewColumn.from(viewColumn),
                preserveFocus: typeof showOptions === 'object' && !!showOptions.preserveFocus
            };
            var handle = ExtHostWebviews.newHandle();
            this._proxy.$createWebviewPanel(handle, viewType, title, webviewShowOptions, options, extensionLocation);
            var webview = new ExtHostWebview(handle, this._proxy, options);
            var panel = new ExtHostWebviewPanel(handle, this._proxy, viewType, title, viewColumn, options, webview);
            this._webviewPanels.set(handle, panel);
            return panel;
        };
        ExtHostWebviews.prototype.registerWebviewPanelSerializer = function (viewType, serializer) {
            var _this = this;
            if (this._serializers.has(viewType)) {
                throw new Error("Serializer for '" + viewType + "' already registered");
            }
            this._serializers.set(viewType, serializer);
            this._proxy.$registerSerializer(viewType);
            return new extHostTypes_1.Disposable(function () {
                _this._serializers.delete(viewType);
                _this._proxy.$unregisterSerializer(viewType);
            });
        };
        ExtHostWebviews.prototype.$onMessage = function (handle, message) {
            var panel = this.getWebviewPanel(handle);
            if (panel) {
                panel.webview._onMessageEmitter.fire(message);
            }
        };
        ExtHostWebviews.prototype.$onDidChangeWebviewPanelViewState = function (handle, newState) {
            var panel = this.getWebviewPanel(handle);
            if (panel) {
                var viewColumn = typeConverters.ViewColumn.to(newState.position);
                if (panel.active !== newState.active || panel.visible !== newState.visible || panel.viewColumn !== viewColumn) {
                    panel._setActive(newState.active);
                    panel._setVisible(newState.visible);
                    panel._setViewColumn(viewColumn);
                    panel._onDidChangeViewStateEmitter.fire({ webviewPanel: panel });
                }
            }
        };
        ExtHostWebviews.prototype.$onDidDisposeWebviewPanel = function (handle) {
            var panel = this.getWebviewPanel(handle);
            if (panel) {
                panel.dispose();
                this._webviewPanels.delete(handle);
            }
            return winjs_base_1.TPromise.as(void 0);
        };
        ExtHostWebviews.prototype.$deserializeWebviewPanel = function (webviewHandle, viewType, title, state, position, options) {
            var serializer = this._serializers.get(viewType);
            if (!serializer) {
                return winjs_base_1.TPromise.wrapError(new Error("No serializer found for '" + viewType + "'"));
            }
            var webview = new ExtHostWebview(webviewHandle, this._proxy, options);
            var revivedPanel = new ExtHostWebviewPanel(webviewHandle, this._proxy, viewType, title, typeConverters.ViewColumn.to(position), options, webview);
            this._webviewPanels.set(webviewHandle, revivedPanel);
            return serializer.deserializeWebviewPanel(revivedPanel, state);
        };
        ExtHostWebviews.prototype.getWebviewPanel = function (handle) {
            return this._webviewPanels.get(handle);
        };
        ExtHostWebviews.webviewHandlePool = 1;
        return ExtHostWebviews;
    }());
    exports.ExtHostWebviews = ExtHostWebviews;
});




































define(__m[81/*vs/workbench/api/node/extHost.api.impl*/], __M([0/*require*/,1/*exports*/,3/*vs/base/common/event*/,66/*vs/editor/common/modes/languageSelector*/,10/*vs/base/common/platform*/,14/*vs/base/common/errors*/,133/*vs/platform/node/product*/,65/*vs/platform/node/package*/,228/*vs/workbench/api/node/extHostFileSystemEventService*/,232/*vs/workbench/api/node/extHostDocumentsAndEditors*/,227/*vs/workbench/api/node/extHostDocuments*/,198/*vs/workbench/api/node/extHostDocumentContentProviders*/,226/*vs/workbench/api/node/extHostDocumentSaveParticipant*/,225/*vs/workbench/api/node/extHostDiagnostics*/,77/*vs/workbench/api/node/extHostTreeViews*/,203/*vs/workbench/api/node/extHostQuickOpen*/,230/*vs/workbench/api/node/extHostProgress*/,204/*vs/workbench/api/node/extHostSCM*/,150/*vs/workbench/api/node/extHostHeapService*/,206/*vs/workbench/api/node/extHostStatusBar*/,223/*vs/workbench/api/node/extHostCommands*/,202/*vs/workbench/api/node/extHostOutputService*/,209/*vs/workbench/api/node/extHostTerminalService*/,201/*vs/workbench/api/node/extHostMessageService*/,233/*vs/workbench/api/node/extHostTextEditors*/,200/*vs/workbench/api/node/extHostLanguages*/,229/*vs/workbench/api/node/extHostLanguageFeatures*/,222/*vs/workbench/api/node/extHostApiCommands*/,208/*vs/workbench/api/node/extHostTask*/,211/*vs/workbench/api/node/extHostWindow*/,5/*vs/workbench/api/node/extHostTypes*/,4/*vs/base/common/uri*/,34/*vs/base/common/severity*/,2/*vs/base/common/winjs.base*/,29/*vs/base/common/cancellation*/,16/*vs/base/common/paths*/,43/*vs/platform/files/common/files*/,6/*vs/workbench/api/node/extHost.protocol*/,35/*vs/editor/common/modes/languageConfiguration*/,83/*vs/editor/common/config/editorOptions*/,197/*vs/workbench/api/node/extHostDialogs*/,199/*vs/workbench/api/node/extHostFileSystem*/,196/*vs/workbench/api/node/extHostDecorations*/,19/*vs/workbench/api/node/extHostTypeConverters*/,48/*vs/workbench/api/node/extHostExtensionActivator*/,25/*vs/editor/common/model*/,234/*vs/workbench/api/node/extHostWebview*/,224/*vs/workbench/api/node/extHostComments*/,205/*vs/workbench/api/node/extHostSearch*/,210/*vs/workbench/api/node/extHostUrls*/]), function (require, exports, event_1, languageSelector_1, platform, errors, product_1, package_1, extHostFileSystemEventService_1, extHostDocumentsAndEditors_1, extHostDocuments_1, extHostDocumentContentProviders_1, extHostDocumentSaveParticipant_1, extHostDiagnostics_1, extHostTreeViews_1, extHostQuickOpen_1, extHostProgress_1, extHostSCM_1, extHostHeapService_1, extHostStatusBar_1, extHostCommands_1, extHostOutputService_1, extHostTerminalService_1, extHostMessageService_1, extHostTextEditors_1, extHostLanguages_1, extHostLanguageFeatures_1, extHostApiCommands_1, extHostTask_1, extHostWindow_1, extHostTypes, uri_1, severity_1, winjs_base_1, cancellation_1, paths, files, extHost_protocol_1, languageConfiguration, editorOptions_1, extHostDialogs_1, extHostFileSystem_1, extHostDecorations_1, typeConverters, extHostExtensionActivator_1, model_1, extHostWebview_1, extHostComments_1, extHostSearch_1, extHostUrls_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function checkProposedApiEnabled(extension) {
        if (!extension.enableProposedApi) {
            throwProposedApiError(extension);
        }
    }
    exports.checkProposedApiEnabled = checkProposedApiEnabled;
    function throwProposedApiError(extension) {
        throw new Error("[" + extension.id + "]: Proposed API is only available when running out of dev or with the following command line switch: --enable-proposed-api " + extension.id);
    }
    function proposedApiFunction(extension, fn) {
        if (extension.enableProposedApi) {
            return fn;
        }
        else {
            return throwProposedApiError.bind(null, extension);
        }
    }
    /**
     * This method instantiates and returns the extension API surface
     */
    function createApiFactory(initData, rpcProtocol, extHostWorkspace, extHostConfiguration, extensionService, extHostLogService) {
        var schemeTransformer = null;
        // Addressable instances
        rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostLogService, extHostLogService);
        var extHostHeapService = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostHeapService, new extHostHeapService_1.ExtHostHeapService());
        var extHostDecorations = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDecorations, new extHostDecorations_1.ExtHostDecorations(rpcProtocol));
        var extHostWebviews = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostWebviews, new extHostWebview_1.ExtHostWebviews(rpcProtocol));
        var extHostUrls = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostUrls, new extHostUrls_1.ExtHostUrls(rpcProtocol));
        var extHostDocumentsAndEditors = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDocumentsAndEditors, new extHostDocumentsAndEditors_1.ExtHostDocumentsAndEditors(rpcProtocol));
        var extHostDocuments = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDocuments, new extHostDocuments_1.ExtHostDocuments(rpcProtocol, extHostDocumentsAndEditors));
        var extHostDocumentContentProviders = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDocumentContentProviders, new extHostDocumentContentProviders_1.ExtHostDocumentContentProvider(rpcProtocol, extHostDocumentsAndEditors, extHostLogService));
        var extHostDocumentSaveParticipant = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDocumentSaveParticipant, new extHostDocumentSaveParticipant_1.ExtHostDocumentSaveParticipant(extHostLogService, extHostDocuments, rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadTextEditors)));
        var extHostEditors = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostEditors, new extHostTextEditors_1.ExtHostEditors(rpcProtocol, extHostDocumentsAndEditors));
        var extHostCommands = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostCommands, new extHostCommands_1.ExtHostCommands(rpcProtocol, extHostHeapService, extHostLogService));
        var extHostTreeViews = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostTreeViews, new extHostTreeViews_1.ExtHostTreeViews(rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadTreeViews), extHostCommands, extHostLogService));
        rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostWorkspace, extHostWorkspace);
        rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostConfiguration, extHostConfiguration);
        var extHostDiagnostics = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDiagnostics, new extHostDiagnostics_1.ExtHostDiagnostics(rpcProtocol));
        var extHostLanguageFeatures = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostLanguageFeatures, new extHostLanguageFeatures_1.ExtHostLanguageFeatures(rpcProtocol, schemeTransformer, extHostDocuments, extHostCommands, extHostHeapService, extHostDiagnostics, extHostLogService));
        var extHostFileSystem = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostFileSystem, new extHostFileSystem_1.ExtHostFileSystem(rpcProtocol, extHostLanguageFeatures));
        var extHostFileSystemEvent = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostFileSystemEventService, new extHostFileSystemEventService_1.ExtHostFileSystemEventService(rpcProtocol, extHostDocumentsAndEditors));
        var extHostQuickOpen = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostQuickOpen, new extHostQuickOpen_1.ExtHostQuickOpen(rpcProtocol, extHostWorkspace, extHostCommands));
        var extHostTerminalService = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostTerminalService, new extHostTerminalService_1.ExtHostTerminalService(rpcProtocol, extHostConfiguration, extHostLogService));
        // {{SQL CARBON EDIT}}
        //const extHostDebugService = rpcProtocol.set(ExtHostContext.ExtHostDebugService, new ExtHostDebugService(rpcProtocol, extHostWorkspace, extensionService, extHostDocumentsAndEditors, extHostConfiguration, extHostTerminalService));
        var extHostSCM = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostSCM, new extHostSCM_1.ExtHostSCM(rpcProtocol, extHostCommands, extHostLogService));
        var extHostSearch = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostSearch, new extHostSearch_1.ExtHostSearch(rpcProtocol, schemeTransformer));
        var extHostTask = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostTask, new extHostTask_1.ExtHostTask(rpcProtocol, extHostWorkspace, extHostDocumentsAndEditors, extHostConfiguration));
        var extHostWindow = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostWindow, new extHostWindow_1.ExtHostWindow(rpcProtocol));
        rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostExtensionService, extensionService);
        var extHostProgress = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostProgress, new extHostProgress_1.ExtHostProgress(rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadProgress)));
        var exthostCommentProviders = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostComments, new extHostComments_1.ExtHostComments(rpcProtocol, extHostCommands.converter, extHostDocuments));
        // Check that no named customers are missing
        var expected = Object.keys(extHost_protocol_1.ExtHostContext).map(function (key) { return extHost_protocol_1.ExtHostContext[key]; });
        rpcProtocol.assertRegistered(expected);
        // Other instances
        var extHostMessageService = new extHostMessageService_1.ExtHostMessageService(rpcProtocol);
        var extHostDialogs = new extHostDialogs_1.ExtHostDialogs(rpcProtocol);
        var extHostStatusBar = new extHostStatusBar_1.ExtHostStatusBar(rpcProtocol);
        var extHostOutputService = new extHostOutputService_1.ExtHostOutputService(rpcProtocol);
        var extHostLanguages = new extHostLanguages_1.ExtHostLanguages(rpcProtocol);
        // Register API-ish commands
        extHostApiCommands_1.ExtHostApiCommands.register(extHostCommands);
        return function (extension) {
            var _this = this;
            // Check document selectors for being overly generic. Technically this isn't a problem but
            // in practice many extensions say they support `fooLang` but need fs-access to do so. Those
            // extension should specify then the `file`-scheme, e.g `{ scheme: 'fooLang', language: 'fooLang' }`
            // We only inform once, it is not a warning because we just want to raise awareness and because
            // we cannot say if the extension is doing it right or wrong...
            var checkSelector = (function () {
                var done = (!extension.isUnderDevelopment);
                function informOnce(selector) {
                    if (!done) {
                        console.info("Extension '" + extension.id + "' uses a document selector without scheme. Learn more about this: https://go.microsoft.com/fwlink/?linkid=872305");
                        done = true;
                    }
                }
                return function perform(selector) {
                    if (Array.isArray(selector)) {
                        selector.forEach(perform);
                    }
                    else if (typeof selector === 'string') {
                        informOnce(selector);
                    }
                    else {
                        if (typeof selector.scheme === 'undefined') {
                            informOnce(selector);
                        }
                        if (!extension.enableProposedApi && typeof selector.exclusive === 'boolean') {
                            throwProposedApiError(extension);
                        }
                    }
                    return selector;
                };
            })();
            // namespace: commands
            var commands = {
                registerCommand: function (id, command, thisArgs) {
                    return extHostCommands.registerCommand(true, id, command, thisArgs);
                },
                registerTextEditorCommand: function (id, callback, thisArg) {
                    return extHostCommands.registerCommand(true, id, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        var activeTextEditor = extHostEditors.getActiveTextEditor();
                        if (!activeTextEditor) {
                            console.warn('Cannot execute ' + id + ' because there is no active text editor.');
                            return undefined;
                        }
                        return activeTextEditor.edit(function (edit) {
                            args.unshift(activeTextEditor, edit);
                            callback.apply(thisArg, args);
                        }).then(function (result) {
                            if (!result) {
                                console.warn('Edits from command ' + id + ' were not applied.');
                            }
                        }, function (err) {
                            console.warn('An error occurred while running command ' + id, err);
                        });
                    });
                },
                registerDiffInformationCommand: proposedApiFunction(extension, function (id, callback, thisArg) {
                    return extHostCommands.registerCommand(true, id, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return __awaiter(_this, void 0, void 0, function () {
                            var activeTextEditor, diff;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        activeTextEditor = extHostEditors.getActiveTextEditor();
                                        if (!activeTextEditor) {
                                            console.warn('Cannot execute ' + id + ' because there is no active text editor.');
                                            return [2 /*return*/, undefined];
                                        }
                                        return [4 /*yield*/, extHostEditors.getDiffInformation(activeTextEditor.id)];
                                    case 1:
                                        diff = _a.sent();
                                        callback.apply(thisArg, [diff].concat(args));
                                        return [2 /*return*/];
                                }
                            });
                        });
                    });
                }),
                executeCommand: function (id) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    return extHostCommands.executeCommand.apply(extHostCommands, [id].concat(args));
                },
                getCommands: function (filterInternal) {
                    if (filterInternal === void 0) { filterInternal = false; }
                    return extHostCommands.getCommands(filterInternal);
                }
            };
            // namespace: env
            var env = Object.freeze({
                get machineId() { return initData.telemetryInfo.machineId; },
                get sessionId() { return initData.telemetryInfo.sessionId; },
                get language() { return platform.language; },
                get appName() { return product_1.default.nameLong; },
                get appRoot() { return initData.environment.appRoot; },
                get logLevel() { return extHostLogService.getLevel(); }
            });
            // namespace: extensions
            var extensions = {
                getExtension: function (extensionId) {
                    var desc = extensionService.getExtensionDescription(extensionId);
                    if (desc) {
                        return new Extension(extensionService, desc);
                    }
                    return undefined;
                },
                get all() {
                    return extensionService.getAllExtensionDescriptions().map(function (desc) { return new Extension(extensionService, desc); });
                }
            };
            // namespace: languages
            var languages = {
                createDiagnosticCollection: function (name) {
                    return extHostDiagnostics.createDiagnosticCollection(name);
                },
                get onDidChangeDiagnostics() {
                    return extHostDiagnostics.onDidChangeDiagnostics;
                },
                getDiagnostics: function (resource) {
                    return extHostDiagnostics.getDiagnostics(resource);
                },
                getLanguages: function () {
                    return extHostLanguages.getLanguages();
                },
                match: function (selector, document) {
                    return languageSelector_1.score(typeConverters.LanguageSelector.from(selector), document.uri, document.languageId, true);
                },
                registerCodeActionsProvider: function (selector, provider, metadata) {
                    return extHostLanguageFeatures.registerCodeActionProvider(checkSelector(selector), provider, extension, metadata);
                },
                registerCodeLensProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerCodeLensProvider(checkSelector(selector), provider);
                },
                registerDefinitionProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerDefinitionProvider(checkSelector(selector), provider);
                },
                registerImplementationProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerImplementationProvider(checkSelector(selector), provider);
                },
                registerTypeDefinitionProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerTypeDefinitionProvider(checkSelector(selector), provider);
                },
                registerHoverProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerHoverProvider(checkSelector(selector), provider, extension.id);
                },
                registerDocumentHighlightProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerDocumentHighlightProvider(checkSelector(selector), provider);
                },
                registerReferenceProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerReferenceProvider(checkSelector(selector), provider);
                },
                registerRenameProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerRenameProvider(checkSelector(selector), provider);
                },
                registerDocumentSymbolProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerDocumentSymbolProvider(checkSelector(selector), provider, extension);
                },
                registerWorkspaceSymbolProvider: function (provider) {
                    return extHostLanguageFeatures.registerWorkspaceSymbolProvider(provider);
                },
                registerDocumentFormattingEditProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerDocumentFormattingEditProvider(checkSelector(selector), provider);
                },
                registerDocumentRangeFormattingEditProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerDocumentRangeFormattingEditProvider(checkSelector(selector), provider);
                },
                registerOnTypeFormattingEditProvider: function (selector, provider, firstTriggerCharacter) {
                    var moreTriggerCharacters = [];
                    for (var _i = 3; _i < arguments.length; _i++) {
                        moreTriggerCharacters[_i - 3] = arguments[_i];
                    }
                    return extHostLanguageFeatures.registerOnTypeFormattingEditProvider(checkSelector(selector), provider, [firstTriggerCharacter].concat(moreTriggerCharacters));
                },
                registerSignatureHelpProvider: function (selector, provider) {
                    var triggerCharacters = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        triggerCharacters[_i - 2] = arguments[_i];
                    }
                    return extHostLanguageFeatures.registerSignatureHelpProvider(checkSelector(selector), provider, triggerCharacters);
                },
                registerCompletionItemProvider: function (selector, provider) {
                    var triggerCharacters = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        triggerCharacters[_i - 2] = arguments[_i];
                    }
                    return extHostLanguageFeatures.registerCompletionItemProvider(checkSelector(selector), provider, triggerCharacters);
                },
                registerDocumentLinkProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerDocumentLinkProvider(checkSelector(selector), provider);
                },
                registerColorProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerColorProvider(checkSelector(selector), provider);
                },
                registerFoldingRangeProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerFoldingRangeProvider(checkSelector(selector), provider);
                },
                setLanguageConfiguration: function (language, configuration) {
                    return extHostLanguageFeatures.setLanguageConfiguration(language, configuration);
                }
            };
            // namespace: window
            var window = {
                get activeTextEditor() {
                    return extHostEditors.getActiveTextEditor();
                },
                get visibleTextEditors() {
                    return extHostEditors.getVisibleTextEditors();
                },
                get activeTerminal() {
                    return proposedApiFunction(extension, extHostTerminalService.activeTerminal);
                },
                get terminals() {
                    return extHostTerminalService.terminals;
                },
                showTextDocument: function (documentOrUri, columnOrOptions, preserveFocus) {
                    var documentPromise;
                    if (uri_1.default.isUri(documentOrUri)) {
                        documentPromise = winjs_base_1.TPromise.wrap(workspace.openTextDocument(documentOrUri));
                    }
                    else {
                        documentPromise = winjs_base_1.TPromise.wrap(documentOrUri);
                    }
                    return documentPromise.then(function (document) {
                        return extHostEditors.showTextDocument(document, columnOrOptions, preserveFocus);
                    });
                },
                createTextEditorDecorationType: function (options) {
                    return extHostEditors.createTextEditorDecorationType(options);
                },
                onDidChangeActiveTextEditor: function (listener, thisArg, disposables) {
                    return extHostEditors.onDidChangeActiveTextEditor(listener, thisArg, disposables);
                },
                onDidChangeVisibleTextEditors: function (listener, thisArg, disposables) {
                    return extHostEditors.onDidChangeVisibleTextEditors(listener, thisArg, disposables);
                },
                onDidChangeTextEditorSelection: function (listener, thisArgs, disposables) {
                    return extHostEditors.onDidChangeTextEditorSelection(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorOptions: function (listener, thisArgs, disposables) {
                    return extHostEditors.onDidChangeTextEditorOptions(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorVisibleRanges: function (listener, thisArgs, disposables) {
                    return extHostEditors.onDidChangeTextEditorVisibleRanges(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorViewColumn: function (listener, thisArg, disposables) {
                    return extHostEditors.onDidChangeTextEditorViewColumn(listener, thisArg, disposables);
                },
                onDidCloseTerminal: function (listener, thisArg, disposables) {
                    return extHostTerminalService.onDidCloseTerminal(listener, thisArg, disposables);
                },
                onDidOpenTerminal: function (listener, thisArg, disposables) {
                    return extHostTerminalService.onDidOpenTerminal(listener, thisArg, disposables);
                },
                onDidChangeActiveTerminal: proposedApiFunction(extension, function (listener, thisArg, disposables) {
                    return extHostTerminalService.onDidChangeActiveTerminal(listener, thisArg, disposables);
                }),
                get state() {
                    return extHostWindow.state;
                },
                onDidChangeWindowState: function (listener, thisArg, disposables) {
                    return extHostWindow.onDidChangeWindowState(listener, thisArg, disposables);
                },
                showInformationMessage: function (message, first) {
                    var rest = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        rest[_i - 2] = arguments[_i];
                    }
                    return extHostMessageService.showMessage(extension, severity_1.default.Info, message, first, rest);
                },
                showWarningMessage: function (message, first) {
                    var rest = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        rest[_i - 2] = arguments[_i];
                    }
                    return extHostMessageService.showMessage(extension, severity_1.default.Warning, message, first, rest);
                },
                showErrorMessage: function (message, first) {
                    var rest = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        rest[_i - 2] = arguments[_i];
                    }
                    return extHostMessageService.showMessage(extension, severity_1.default.Error, message, first, rest);
                },
                showQuickPick: function (items, options, token) {
                    return extHostQuickOpen.showQuickPick(items, options, token);
                },
                showWorkspaceFolderPick: function (options) {
                    return extHostQuickOpen.showWorkspaceFolderPick(options);
                },
                showInputBox: function (options, token) {
                    return extHostQuickOpen.showInput(options, token);
                },
                showOpenDialog: function (options) {
                    return extHostDialogs.showOpenDialog(options);
                },
                showSaveDialog: function (options) {
                    return extHostDialogs.showSaveDialog(options);
                },
                createStatusBarItem: function (position, priority) {
                    return extHostStatusBar.createStatusBarEntry(extension.id, position, priority);
                },
                setStatusBarMessage: function (text, timeoutOrThenable) {
                    return extHostStatusBar.setStatusBarMessage(text, timeoutOrThenable);
                },
                withScmProgress: function (task) {
                    console.warn("[Deprecation Warning] function 'withScmProgress' is deprecated and should no longer be used. Use 'withProgress' instead.");
                    return extHostProgress.withProgress(extension, { location: extHostTypes.ProgressLocation.SourceControl }, function (progress, token) { return task({ report: function (n) { } }); });
                },
                withProgress: function (options, task) {
                    return extHostProgress.withProgress(extension, options, task);
                },
                createOutputChannel: function (name) {
                    return extHostOutputService.createOutputChannel(name);
                },
                createWebviewPanel: function (viewType, title, showOptions, options) {
                    return extHostWebviews.createWebview(extension.extensionLocation, viewType, title, showOptions, options);
                },
                createTerminal: function (nameOrOptions, shellPath, shellArgs) {
                    if (typeof nameOrOptions === 'object') {
                        return extHostTerminalService.createTerminalFromOptions(nameOrOptions);
                    }
                    return extHostTerminalService.createTerminal(nameOrOptions, shellPath, shellArgs);
                },
                createTerminalRenderer: function (name) {
                    return extHostTerminalService.createTerminalRenderer(name);
                },
                registerTreeDataProvider: function (viewId, treeDataProvider) {
                    return extHostTreeViews.registerTreeDataProvider(viewId, treeDataProvider);
                },
                createTreeView: function (viewId, options) {
                    return extHostTreeViews.createTreeView(viewId, options);
                },
                registerWebviewPanelSerializer: function (viewType, serializer) {
                    return extHostWebviews.registerWebviewPanelSerializer(viewType, serializer);
                },
                // proposed API
                sampleFunction: proposedApiFunction(extension, function () {
                    return extHostMessageService.showMessage(extension, severity_1.default.Info, 'Hello Proposed Api!', {}, []);
                }),
                registerDecorationProvider: proposedApiFunction(extension, function (provider) {
                    return extHostDecorations.registerDecorationProvider(provider, extension.id);
                }),
                registerUriHandler: function (handler) {
                    return extHostUrls.registerUriHandler(extension.id, handler);
                },
                createQuickPick: function () {
                    return extHostQuickOpen.createQuickPick(extension.id);
                },
                createInputBox: function () {
                    return extHostQuickOpen.createInputBox(extension.id);
                },
            };
            // namespace: workspace
            var workspace = {
                get rootPath() {
                    return extHostWorkspace.getPath();
                },
                set rootPath(value) {
                    throw errors.readonly();
                },
                getWorkspaceFolder: function (resource) {
                    return extHostWorkspace.getWorkspaceFolder(resource);
                },
                get workspaceFolders() {
                    return extHostWorkspace.getWorkspaceFolders();
                },
                get name() {
                    return extHostWorkspace.workspace ? extHostWorkspace.workspace.name : undefined;
                },
                set name(value) {
                    throw errors.readonly();
                },
                updateWorkspaceFolders: function (index, deleteCount) {
                    var workspaceFoldersToAdd = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        workspaceFoldersToAdd[_i - 2] = arguments[_i];
                    }
                    return extHostWorkspace.updateWorkspaceFolders.apply(extHostWorkspace, [extension, index, deleteCount || 0].concat(workspaceFoldersToAdd));
                },
                onDidChangeWorkspaceFolders: function (listener, thisArgs, disposables) {
                    return extHostWorkspace.onDidChangeWorkspace(listener, thisArgs, disposables);
                },
                asRelativePath: function (pathOrUri, includeWorkspace) {
                    return extHostWorkspace.getRelativePath(pathOrUri, includeWorkspace);
                },
                findFiles: function (include, exclude, maxResults, token) {
                    return extHostWorkspace.findFiles(typeConverters.GlobPattern.from(include), typeConverters.GlobPattern.from(exclude), maxResults, extension.id, token);
                },
                findTextInFiles: function (query, optionsOrCallback, callbackOrToken, token) {
                    var options;
                    var callback;
                    if (typeof optionsOrCallback === 'object') {
                        options = optionsOrCallback;
                        callback = callbackOrToken;
                    }
                    else {
                        options = {};
                        callback = optionsOrCallback;
                        token = callbackOrToken;
                    }
                    return extHostWorkspace.findTextInFiles(query, options || {}, callback, extension.id, token);
                },
                saveAll: function (includeUntitled) {
                    return extHostWorkspace.saveAll(includeUntitled);
                },
                applyEdit: function (edit) {
                    return extHostEditors.applyWorkspaceEdit(edit);
                },
                createFileSystemWatcher: function (pattern, ignoreCreate, ignoreChange, ignoreDelete) {
                    return extHostFileSystemEvent.createFileSystemWatcher(typeConverters.GlobPattern.from(pattern), ignoreCreate, ignoreChange, ignoreDelete);
                },
                get textDocuments() {
                    return extHostDocuments.getAllDocumentData().map(function (data) { return data.document; });
                },
                set textDocuments(value) {
                    throw errors.readonly();
                },
                openTextDocument: function (uriOrFileNameOrOptions) {
                    var uriPromise;
                    var options = uriOrFileNameOrOptions;
                    if (typeof uriOrFileNameOrOptions === 'string') {
                        uriPromise = winjs_base_1.TPromise.as(uri_1.default.file(uriOrFileNameOrOptions));
                    }
                    else if (uriOrFileNameOrOptions instanceof uri_1.default) {
                        uriPromise = winjs_base_1.TPromise.as(uriOrFileNameOrOptions);
                    }
                    else if (!options || typeof options === 'object') {
                        uriPromise = extHostDocuments.createDocumentData(options);
                    }
                    else {
                        throw new Error('illegal argument - uriOrFileNameOrOptions');
                    }
                    return uriPromise.then(function (uri) {
                        return extHostDocuments.ensureDocumentData(uri).then(function () {
                            var data = extHostDocuments.getDocumentData(uri);
                            return data && data.document;
                        });
                    });
                },
                onDidOpenTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidAddDocument(listener, thisArgs, disposables);
                },
                onDidCloseTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidRemoveDocument(listener, thisArgs, disposables);
                },
                onDidChangeTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidChangeDocument(listener, thisArgs, disposables);
                },
                onDidSaveTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidSaveDocument(listener, thisArgs, disposables);
                },
                onWillSaveTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocumentSaveParticipant.getOnWillSaveTextDocumentEvent(extension)(listener, thisArgs, disposables);
                },
                onDidChangeConfiguration: function (listener, thisArgs, disposables) {
                    return extHostConfiguration.onDidChangeConfiguration(listener, thisArgs, disposables);
                },
                getConfiguration: function (section, resource) {
                    resource = arguments.length === 1 ? void 0 : resource;
                    return extHostConfiguration.getConfiguration(section, resource, extension.id);
                },
                registerTextDocumentContentProvider: function (scheme, provider) {
                    return extHostDocumentContentProviders.registerTextDocumentContentProvider(scheme, provider);
                },
                registerTaskProvider: function (type, provider) {
                    return extHostTask.registerTaskProvider(extension, provider);
                },
                registerFileSystemProvider: function (scheme, provider, options) {
                    return extHostFileSystem.registerFileSystemProvider(scheme, provider, options);
                },
                registerFileSearchProvider: proposedApiFunction(extension, function (scheme, provider) {
                    return extHostSearch.registerFileSearchProvider(scheme, provider);
                }),
                registerSearchProvider: proposedApiFunction(extension, function () {
                    // Temp for live share in Insiders
                    return { dispose: function () { } };
                }),
                registerTextSearchProvider: proposedApiFunction(extension, function (scheme, provider) {
                    return extHostSearch.registerTextSearchProvider(scheme, provider);
                }),
                registerFileIndexProvider: proposedApiFunction(extension, function (scheme, provider) {
                    return extHostSearch.registerFileIndexProvider(scheme, provider);
                }),
                registerDocumentCommentProvider: proposedApiFunction(extension, function (provider) {
                    return exthostCommentProviders.registerDocumentCommentProvider(provider);
                }),
                registerWorkspaceCommentProvider: proposedApiFunction(extension, function (provider) {
                    return exthostCommentProviders.registerWorkspaceCommentProvider(provider);
                }),
                onDidRenameFile: proposedApiFunction(extension, function (listener, thisArg, disposables) {
                    return extHostFileSystemEvent.onDidRenameFile(listener, thisArg, disposables);
                }),
                onWillRenameFile: proposedApiFunction(extension, function (listener, thisArg, disposables) {
                    return extHostFileSystemEvent.getOnWillRenameFileEvent(extension)(listener, thisArg, disposables);
                })
            };
            // namespace: scm
            var scm = {
                get inputBox() {
                    return extHostSCM.getLastInputBox(extension);
                },
                createSourceControl: function (id, label, rootUri) {
                    return extHostSCM.createSourceControl(extension, id, label, rootUri);
                }
            };
            // {{SQL CARBON EDIT}}
            // delete namespace: debug
            var tasks = {
                registerTaskProvider: function (type, provider) {
                    return extHostTask.registerTaskProvider(extension, provider);
                },
                fetchTasks: function (filter) {
                    return extHostTask.fetchTasks(filter);
                },
                executeTask: function (task) {
                    return extHostTask.executeTask(extension, task);
                },
                get taskExecutions() {
                    return extHostTask.taskExecutions;
                },
                onDidStartTask: function (listeners, thisArgs, disposables) {
                    return extHostTask.onDidStartTask(listeners, thisArgs, disposables);
                },
                onDidEndTask: function (listeners, thisArgs, disposables) {
                    return extHostTask.onDidEndTask(listeners, thisArgs, disposables);
                },
                onDidStartTaskProcess: function (listeners, thisArgs, disposables) {
                    return extHostTask.onDidStartTaskProcess(listeners, thisArgs, disposables);
                },
                onDidEndTaskProcess: function (listeners, thisArgs, disposables) {
                    return extHostTask.onDidEndTaskProcess(listeners, thisArgs, disposables);
                }
            };
            return {
                version: package_1.default.version,
                // namespaces
                commands: commands,
                env: env,
                extensions: extensions,
                languages: languages,
                window: window,
                workspace: workspace,
                scm: scm,
                // {{SQL CARBON EDIT}}
                // debug,
                tasks: tasks,
                // types
                Breakpoint: extHostTypes.Breakpoint,
                CancellationTokenSource: cancellation_1.CancellationTokenSource,
                CodeAction: extHostTypes.CodeAction,
                CodeActionKind: extHostTypes.CodeActionKind,
                CodeLens: extHostTypes.CodeLens,
                Color: extHostTypes.Color,
                ColorPresentation: extHostTypes.ColorPresentation,
                ColorInformation: extHostTypes.ColorInformation,
                CodeActionTrigger: extHostTypes.CodeActionTrigger,
                EndOfLine: extHostTypes.EndOfLine,
                CompletionItem: extHostTypes.CompletionItem,
                CompletionItemKind: extHostTypes.CompletionItemKind,
                CompletionList: extHostTypes.CompletionList,
                CompletionTriggerKind: extHostTypes.CompletionTriggerKind,
                // {{SQL CARBON EDIT}}
                // DebugAdapterExecutable: extHostTypes.DebugAdapterExecutable,
                Diagnostic: extHostTypes.Diagnostic,
                DiagnosticRelatedInformation: extHostTypes.DiagnosticRelatedInformation,
                DiagnosticTag: extHostTypes.DiagnosticTag,
                DiagnosticSeverity: extHostTypes.DiagnosticSeverity,
                Disposable: extHostTypes.Disposable,
                DocumentHighlight: extHostTypes.DocumentHighlight,
                DocumentHighlightKind: extHostTypes.DocumentHighlightKind,
                DocumentLink: extHostTypes.DocumentLink,
                EventEmitter: event_1.Emitter,
                FunctionBreakpoint: extHostTypes.FunctionBreakpoint,
                Hover: extHostTypes.Hover,
                IndentAction: languageConfiguration.IndentAction,
                Location: extHostTypes.Location,
                LogLevel: extHostTypes.LogLevel,
                MarkdownString: extHostTypes.MarkdownString,
                OverviewRulerLane: model_1.OverviewRulerLane,
                ParameterInformation: extHostTypes.ParameterInformation,
                Position: extHostTypes.Position,
                QuickInputButtons: extHostTypes.QuickInputButtons,
                Range: extHostTypes.Range,
                Selection: extHostTypes.Selection,
                SignatureHelp: extHostTypes.SignatureHelp,
                SignatureInformation: extHostTypes.SignatureInformation,
                SnippetString: extHostTypes.SnippetString,
                SourceBreakpoint: extHostTypes.SourceBreakpoint,
                StatusBarAlignment: extHostTypes.StatusBarAlignment,
                SymbolInformation: extHostTypes.SymbolInformation,
                DocumentSymbol: extHostTypes.DocumentSymbol,
                SymbolKind: extHostTypes.SymbolKind,
                SourceControlInputBoxValidationType: extHostTypes.SourceControlInputBoxValidationType,
                TextDocumentSaveReason: extHostTypes.TextDocumentSaveReason,
                TextEdit: extHostTypes.TextEdit,
                TextEditorCursorStyle: editorOptions_1.TextEditorCursorStyle,
                TextEditorLineNumbersStyle: extHostTypes.TextEditorLineNumbersStyle,
                TextEditorRevealType: extHostTypes.TextEditorRevealType,
                TextEditorSelectionChangeKind: extHostTypes.TextEditorSelectionChangeKind,
                DecorationRangeBehavior: extHostTypes.DecorationRangeBehavior,
                Uri: uri_1.default,
                ViewColumn: extHostTypes.ViewColumn,
                WorkspaceEdit: extHostTypes.WorkspaceEdit,
                ProgressLocation: extHostTypes.ProgressLocation,
                TreeItemCollapsibleState: extHostTypes.TreeItemCollapsibleState,
                ThemeIcon: extHostTypes.ThemeIcon,
                TreeItem: extHostTypes.TreeItem,
                ThemeColor: extHostTypes.ThemeColor,
                // functions
                TaskRevealKind: extHostTypes.TaskRevealKind,
                TaskPanelKind: extHostTypes.TaskPanelKind,
                TaskGroup: extHostTypes.TaskGroup,
                ProcessExecution: extHostTypes.ProcessExecution,
                ShellExecution: extHostTypes.ShellExecution,
                ShellQuoting: extHostTypes.ShellQuoting,
                TaskScope: extHostTypes.TaskScope,
                Task: extHostTypes.Task,
                ConfigurationTarget: extHostTypes.ConfigurationTarget,
                RelativePattern: extHostTypes.RelativePattern,
                FileChangeType: extHostTypes.FileChangeType,
                FileType: files.FileType,
                FileSystemError: extHostTypes.FileSystemError,
                FoldingRange: extHostTypes.FoldingRange,
                FoldingRangeKind: extHostTypes.FoldingRangeKind,
                CommentThreadCollapsibleState: extHostTypes.CommentThreadCollapsibleState
            };
        };
    }
    exports.createApiFactory = createApiFactory;
    /**
     * Returns the original fs path (using the original casing for the drive letter)
     */
    function originalFSPath(uri) {
        var result = uri.fsPath;
        if (/^[a-zA-Z]:/.test(result) && uri.path.charAt(1).toLowerCase() === result.charAt(0)) {
            // Restore original drive letter casing
            return uri.path.charAt(1) + result.substr(1);
        }
        return result;
    }
    exports.originalFSPath = originalFSPath;
    var Extension = /** @class */ (function () {
        function Extension(extensionService, description) {
            this._extensionService = extensionService;
            this.id = description.id;
            this.extensionPath = paths.normalize(originalFSPath(description.extensionLocation), true);
            this.packageJSON = description;
        }
        Object.defineProperty(Extension.prototype, "isActive", {
            get: function () {
                return this._extensionService.isActivated(this.id);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Extension.prototype, "exports", {
            get: function () {
                return this._extensionService.getExtensionExports(this.id);
            },
            enumerable: true,
            configurable: true
        });
        Extension.prototype.activate = function () {
            var _this = this;
            return this._extensionService.activateByIdWithErrors(this.id, new extHostExtensionActivator_1.ExtensionActivatedByAPI(false)).then(function () { return _this.exports; });
        };
        return Extension;
    }());
    function initializeExtensionApi(extensionService, apiFactory) {
        return extensionService.getExtensionPathIndex().then(function (trie) { return defineAPI(apiFactory, trie); });
    }
    exports.initializeExtensionApi = initializeExtensionApi;
    function defineAPI(factory, extensionPaths) {
        // each extension is meant to get its own api implementation
        var extApiImpl = new Map();
        var defaultApiImpl;
        var node_module = require.__$__nodeRequire('module');
        var original = node_module._load;
        node_module._load = function load(request, parent, isMain) {
            if (request !== 'vscode') {
                return original.apply(this, arguments);
            }
            // get extension id from filename and api for extension
            var ext = extensionPaths.findSubstr(uri_1.default.file(parent.filename).fsPath);
            if (ext) {
                var apiImpl = extApiImpl.get(ext.id);
                if (!apiImpl) {
                    apiImpl = factory(ext);
                    extApiImpl.set(ext.id, apiImpl);
                }
                return apiImpl;
            }
            // fall back to a default implementation
            if (!defaultApiImpl) {
                var extensionPathsPretty_1 = '';
                extensionPaths.forEach(function (value, index) { return extensionPathsPretty_1 += "\t" + index + " -> " + value.id + "\n"; });
                console.warn("Could not identify extension for 'vscode' require call from " + parent.filename + ". These are the extension path mappings: \n" + extensionPathsPretty_1);
                defaultApiImpl = factory(nullExtensionDescription);
            }
            return defaultApiImpl;
        };
    }
    var nullExtensionDescription = {
        id: 'nullExtensionDescription',
        name: 'Null Extension Description',
        publisher: 'vscode',
        activationEvents: undefined,
        contributes: undefined,
        enableProposedApi: false,
        engines: undefined,
        extensionDependencies: undefined,
        extensionLocation: undefined,
        isBuiltin: false,
        isUnderDevelopment: false,
        main: undefined,
        version: undefined
    };
});

define(__m[236/*sql/workbench/api/node/sqlExtHost.api.impl*/], __M([0/*require*/,1/*exports*/,81/*vs/workbench/api/node/extHost.api.impl*/,159/*sql/base/common/map*/,2/*vs/base/common/winjs.base*/,49/*fs*/,4/*vs/base/common/uri*/,11/*sql/workbench/api/node/sqlExtHost.protocol*/,177/*sql/workbench/api/node/extHostAccountManagement*/,180/*sql/workbench/api/node/extHostCredentialManagement*/,183/*sql/workbench/api/node/extHostDataProtocol*/,193/*sql/workbench/api/node/extHostSerializationProvider*/,192/*sql/workbench/api/node/extHostResourceProvider*/,28/*sql/workbench/api/common/sqlExtHostTypes*/,185/*sql/workbench/api/node/extHostModalDialog*/,194/*sql/workbench/api/node/extHostTasks*/,182/*sql/workbench/api/node/extHostDashboardWebview*/,186/*sql/workbench/api/node/extHostModelView*/,179/*sql/workbench/api/node/extHostConnectionManagement*/,181/*sql/workbench/api/node/extHostDashboard*/,190/*sql/workbench/api/node/extHostObjectExplorer*/,187/*sql/workbench/api/node/extHostModelViewDialog*/,188/*sql/workbench/api/node/extHostModelViewTree*/,191/*sql/workbench/api/node/extHostQueryEditor*/,178/*sql/workbench/api/node/extHostBackgroundTaskManagement*/,189/*sql/workbench/api/node/extHostNotebook*/,220/*sql/workbench/api/node/extHostNotebookDocumentsAndEditors*/,184/*sql/workbench/api/node/extHostExtensionManagement*/]), function (require, exports, extHostApi, map_1, winjs_base_1, fs_1, uri_1, sqlExtHost_protocol_1, extHostAccountManagement_1, extHostCredentialManagement_1, extHostDataProtocol_1, extHostSerializationProvider_1, extHostResourceProvider_1, sqlExtHostTypes, extHostModalDialog_1, extHostTasks_1, extHostDashboardWebview_1, extHostModelView_1, extHostConnectionManagement_1, extHostDashboard_1, extHostObjectExplorer_1, extHostModelViewDialog_1, extHostModelViewTree_1, extHostQueryEditor_1, extHostBackgroundTaskManagement_1, extHostNotebook_1, extHostNotebookDocumentsAndEditors_1, extHostExtensionManagement_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This method instantiates and returns the extension API surface
     */
    function createApiFactory(initData, rpcProtocol, extHostWorkspace, extHostConfiguration, extensionService, logService) {
        var vsCodeFactory = extHostApi.createApiFactory(initData, rpcProtocol, extHostWorkspace, extHostConfiguration, extensionService, logService);
        // Addressable instances
        var extHostAccountManagement = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostAccountManagement, new extHostAccountManagement_1.ExtHostAccountManagement(rpcProtocol));
        var extHostConnectionManagement = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostConnectionManagement, new extHostConnectionManagement_1.ExtHostConnectionManagement(rpcProtocol));
        var extHostCredentialManagement = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostCredentialManagement, new extHostCredentialManagement_1.ExtHostCredentialManagement(rpcProtocol));
        var extHostDataProvider = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostDataProtocol, new extHostDataProtocol_1.ExtHostDataProtocol(rpcProtocol));
        var extHostObjectExplorer = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostObjectExplorer, new extHostObjectExplorer_1.ExtHostObjectExplorer(rpcProtocol));
        var extHostSerializationProvider = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostSerializationProvider, new extHostSerializationProvider_1.ExtHostSerializationProvider(rpcProtocol));
        var extHostResourceProvider = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostResourceProvider, new extHostResourceProvider_1.ExtHostResourceProvider(rpcProtocol));
        var extHostModalDialogs = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostModalDialogs, new extHostModalDialog_1.ExtHostModalDialogs(rpcProtocol));
        var extHostTasks = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostTasks, new extHostTasks_1.ExtHostTasks(rpcProtocol, logService));
        var extHostBackgroundTaskManagement = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostBackgroundTaskManagement, new extHostBackgroundTaskManagement_1.ExtHostBackgroundTaskManagement(rpcProtocol));
        var extHostWebviewWidgets = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostDashboardWebviews, new extHostDashboardWebview_1.ExtHostDashboardWebviews(rpcProtocol));
        var extHostModelViewTree = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostModelViewTreeViews, new extHostModelViewTree_1.ExtHostModelViewTreeViews(rpcProtocol));
        var extHostModelView = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostModelView, new extHostModelView_1.ExtHostModelView(rpcProtocol, extHostModelViewTree));
        var extHostDashboard = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostDashboard, new extHostDashboard_1.ExtHostDashboard(rpcProtocol));
        var extHostModelViewDialog = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostModelViewDialog, new extHostModelViewDialog_1.ExtHostModelViewDialog(rpcProtocol, extHostModelView, extHostBackgroundTaskManagement));
        var extHostQueryEditor = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostQueryEditor, new extHostQueryEditor_1.ExtHostQueryEditor(rpcProtocol));
        var extHostNotebook = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostNotebook, new extHostNotebook_1.ExtHostNotebook(rpcProtocol));
        var extHostNotebookDocumentsAndEditors = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostNotebookDocumentsAndEditors, new extHostNotebookDocumentsAndEditors_1.ExtHostNotebookDocumentsAndEditors(rpcProtocol));
        var extHostExtensionManagement = rpcProtocol.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostExtensionManagement, new extHostExtensionManagement_1.ExtHostExtensionManagement(rpcProtocol));
        return {
            vsCodeFactory: vsCodeFactory,
            sqlopsFactory: function (extension) {
                // namespace: accounts
                var accounts = {
                    registerAccountProvider: function (providerMetadata, provider) {
                        return extHostAccountManagement.$registerAccountProvider(providerMetadata, provider);
                    },
                    beginAutoOAuthDeviceCode: function (providerId, title, message, userCode, uri) {
                        return extHostAccountManagement.$beginAutoOAuthDeviceCode(providerId, title, message, userCode, uri);
                    },
                    endAutoOAuthDeviceCode: function () {
                        return extHostAccountManagement.$endAutoOAuthDeviceCode();
                    },
                    accountUpdated: function (updatedAccount) {
                        return extHostAccountManagement.$accountUpdated(updatedAccount);
                    },
                    getAllAccounts: function () {
                        return extHostAccountManagement.$getAllAccounts();
                    },
                    getSecurityToken: function (account, resource) {
                        return extHostAccountManagement.$getSecurityToken(account, resource);
                    },
                    onDidChangeAccounts: function (listener, thisArgs, disposables) {
                        return extHostAccountManagement.onDidChangeAccounts(listener, thisArgs, disposables);
                    }
                };
                // namespace: connection
                var connection = {
                    getActiveConnections: function () {
                        return extHostConnectionManagement.$getActiveConnections();
                    },
                    getCurrentConnection: function () {
                        return extHostConnectionManagement.$getCurrentConnection();
                    },
                    getCredentials: function (connectionId) {
                        return extHostConnectionManagement.$getCredentials(connectionId);
                    },
                    getServerInfo: function (connectionId) {
                        return extHostConnectionManagement.$getServerInfo(connectionId);
                    },
                    openConnectionDialog: function (providers, initialConnectionProfile, connectionCompletionOptions) {
                        return extHostConnectionManagement.$openConnectionDialog(providers, initialConnectionProfile, connectionCompletionOptions);
                    },
                    listDatabases: function (connectionId) {
                        return extHostConnectionManagement.$listDatabases(connectionId);
                    },
                    getConnectionString: function (connectionId, includePassword) {
                        return extHostConnectionManagement.$getConnectionString(connectionId, includePassword);
                    },
                    getUriForConnection: function (connectionId) {
                        return extHostConnectionManagement.$getUriForConnection(connectionId);
                    },
                    connect: function (connectionProfile) {
                        return extHostConnectionManagement.$connect(connectionProfile);
                    }
                };
                // namespace: credentials
                var credentials = {
                    registerProvider: function (provider) {
                        return extHostCredentialManagement.$registerCredentialProvider(provider);
                    },
                    getProvider: function (namespaceId) {
                        return extHostCredentialManagement.$getCredentialProvider(namespaceId);
                    }
                };
                // namespace: objectexplorer
                var objectExplorer = {
                    getNode: function (connectionId, nodePath) {
                        return extHostObjectExplorer.$getNode(connectionId, nodePath);
                    },
                    getActiveConnectionNodes: function () {
                        return extHostObjectExplorer.$getActiveConnectionNodes();
                    },
                    findNodes: function (connectionId, type, schema, name, database, parentObjectNames) {
                        return extHostObjectExplorer.$findNodes(connectionId, type, schema, name, database, parentObjectNames);
                    },
                    getNodeActions: function (connectionId, nodePath) {
                        return extHostObjectExplorer.$getNodeActions(connectionId, nodePath);
                    },
                    getSessionConnectionProfile: function (sessionId) {
                        return extHostObjectExplorer.$getSessionConnectionProfile(sessionId);
                    }
                };
                // namespace: serialization
                var serialization = {
                    registerProvider: function (provider) {
                        return extHostSerializationProvider.$registerSerializationProvider(provider);
                    },
                };
                // namespace: serialization
                var resources = {
                    registerResourceProvider: function (providerMetadata, provider) {
                        return extHostResourceProvider.$registerResourceProvider(providerMetadata, provider);
                    }
                };
                var registerConnectionProvider = function (provider) {
                    // Connection callbacks
                    provider.registerOnConnectionComplete(function (connSummary) {
                        extHostDataProvider.$onConnectComplete(provider.handle, connSummary);
                    });
                    provider.registerOnIntelliSenseCacheComplete(function (connectionUri) {
                        extHostDataProvider.$onIntelliSenseCacheComplete(provider.handle, connectionUri);
                    });
                    provider.registerOnConnectionChanged(function (changedConnInfo) {
                        extHostDataProvider.$onConnectionChanged(provider.handle, changedConnInfo);
                    });
                    return extHostDataProvider.$registerConnectionProvider(provider);
                };
                var registerQueryProvider = function (provider) {
                    provider.registerOnQueryComplete(function (result) {
                        extHostDataProvider.$onQueryComplete(provider.handle, result);
                    });
                    provider.registerOnBatchStart(function (batchInfo) {
                        extHostDataProvider.$onBatchStart(provider.handle, batchInfo);
                    });
                    provider.registerOnBatchComplete(function (batchInfo) {
                        extHostDataProvider.$onBatchComplete(provider.handle, batchInfo);
                    });
                    provider.registerOnResultSetAvailable(function (resultSetInfo) {
                        extHostDataProvider.$onResultSetAvailable(provider.handle, resultSetInfo);
                    });
                    provider.registerOnResultSetUpdated(function (resultSetInfo) {
                        extHostDataProvider.$onResultSetUpdated(provider.handle, resultSetInfo);
                    });
                    provider.registerOnMessage(function (message) {
                        extHostDataProvider.$onQueryMessage(provider.handle, message);
                    });
                    provider.registerOnEditSessionReady(function (ownerUri, success, message) {
                        extHostDataProvider.$onEditSessionReady(provider.handle, ownerUri, success, message);
                    });
                    return extHostDataProvider.$registerQueryProvider(provider);
                };
                var registerObjectExplorerProvider = function (provider) {
                    provider.registerOnSessionCreated(function (response) {
                        extHostDataProvider.$onObjectExplorerSessionCreated(provider.handle, response);
                    });
                    if (provider.registerOnSessionDisconnected) {
                        provider.registerOnSessionDisconnected(function (response) {
                            extHostDataProvider.$onObjectExplorerSessionDisconnected(provider.handle, response);
                        });
                    }
                    provider.registerOnExpandCompleted(function (response) {
                        extHostDataProvider.$onObjectExplorerNodeExpanded(provider.providerId, response);
                    });
                    return extHostDataProvider.$registerObjectExplorerProvider(provider);
                };
                var registerObjectExplorerNodeProvider = function (provider) {
                    provider.registerOnExpandCompleted(function (response) {
                        extHostDataProvider.$onObjectExplorerNodeExpanded(provider.providerId, response);
                    });
                    return extHostDataProvider.$registerObjectExplorerNodeProvider(provider);
                };
                var registerTaskServicesProvider = function (provider) {
                    provider.registerOnTaskCreated(function (response) {
                        extHostDataProvider.$onTaskCreated(provider.handle, response);
                    });
                    provider.registerOnTaskStatusChanged(function (response) {
                        extHostDataProvider.$onTaskStatusChanged(provider.handle, response);
                    });
                    return extHostDataProvider.$registerTaskServicesProvider(provider);
                };
                var registerFileBrowserProvider = function (provider) {
                    provider.registerOnFileBrowserOpened(function (response) {
                        extHostDataProvider.$onFileBrowserOpened(provider.handle, response);
                    });
                    provider.registerOnFolderNodeExpanded(function (response) {
                        extHostDataProvider.$onFolderNodeExpanded(provider.handle, response);
                    });
                    provider.registerOnFilePathsValidated(function (response) {
                        extHostDataProvider.$onFilePathsValidated(provider.handle, response);
                    });
                    return extHostDataProvider.$registerFileBrowserProvider(provider);
                };
                var registerScriptingProvider = function (provider) {
                    provider.registerOnScriptingComplete(function (response) {
                        extHostDataProvider.$onScriptingComplete(provider.handle, response);
                    });
                    return extHostDataProvider.$registerScriptingProvider(provider);
                };
                var registerProfilerProvider = function (provider) {
                    provider.registerOnSessionEventsAvailable(function (response) {
                        extHostDataProvider.$onSessionEventsAvailable(provider.handle, response);
                    });
                    provider.registerOnSessionStopped(function (response) {
                        extHostDataProvider.$onSessionStopped(provider.handle, response);
                    });
                    provider.registerOnProfilerSessionCreated(function (response) {
                        extHostDataProvider.$onProfilerSessionCreated(provider.handle, response);
                    });
                    return extHostDataProvider.$registerProfilerProvider(provider);
                };
                var registerBackupProvider = function (provider) {
                    return extHostDataProvider.$registerBackupProvider(provider);
                };
                var registerRestoreProvider = function (provider) {
                    return extHostDataProvider.$registerRestoreProvider(provider);
                };
                var registerMetadataProvider = function (provider) {
                    return extHostDataProvider.$registerMetadataProvider(provider);
                };
                var registerCapabilitiesServiceProvider = function (provider) {
                    return extHostDataProvider.$registerCapabilitiesServiceProvider(provider);
                };
                var registerAdminServicesProvider = function (provider) {
                    return extHostDataProvider.$registerAdminServicesProvider(provider);
                };
                var registerAgentServicesProvider = function (provider) {
                    provider.registerOnUpdated(function () {
                        extHostDataProvider.$onJobDataUpdated(provider.handle);
                    });
                    return extHostDataProvider.$registerAgentServiceProvider(provider);
                };
                var registerDacFxServicesProvider = function (provider) {
                    return extHostDataProvider.$registerDacFxServiceProvider(provider);
                };
                // namespace: dataprotocol
                var dataprotocol = {
                    registerBackupProvider: registerBackupProvider,
                    registerConnectionProvider: registerConnectionProvider,
                    registerFileBrowserProvider: registerFileBrowserProvider,
                    registerMetadataProvider: registerMetadataProvider,
                    registerObjectExplorerProvider: registerObjectExplorerProvider,
                    registerObjectExplorerNodeProvider: registerObjectExplorerNodeProvider,
                    registerProfilerProvider: registerProfilerProvider,
                    registerRestoreProvider: registerRestoreProvider,
                    registerScriptingProvider: registerScriptingProvider,
                    registerTaskServicesProvider: registerTaskServicesProvider,
                    registerQueryProvider: registerQueryProvider,
                    registerAdminServicesProvider: registerAdminServicesProvider,
                    registerAgentServicesProvider: registerAgentServicesProvider,
                    registerCapabilitiesServiceProvider: registerCapabilitiesServiceProvider,
                    registerDacFxServicesProvider: registerDacFxServicesProvider,
                    onDidChangeLanguageFlavor: function (listener, thisArgs, disposables) {
                        return extHostDataProvider.onDidChangeLanguageFlavor(listener, thisArgs, disposables);
                    },
                    getProvider: function (providerId, providerType) {
                        return extHostDataProvider.getProvider(providerId, providerType);
                    },
                    getProvidersByType: function (providerType) {
                        return extHostDataProvider.getProvidersByType(providerType);
                    }
                };
                var modelViewDialog = {
                    createDialog: function (title, dialogName) {
                        return extHostModelViewDialog.createDialog(title, dialogName, extension.extensionLocation);
                    },
                    createTab: function (title) {
                        return extHostModelViewDialog.createTab(title, extension.extensionLocation);
                    },
                    createButton: function (label) {
                        return extHostModelViewDialog.createButton(label);
                    },
                    openDialog: function (dialog) {
                        return extHostModelViewDialog.openDialog(dialog);
                    },
                    closeDialog: function (dialog) {
                        return extHostModelViewDialog.closeDialog(dialog);
                    },
                    createWizardPage: function (title) {
                        return extHostModelViewDialog.createWizardPage(title);
                    },
                    createWizard: function (title) {
                        return extHostModelViewDialog.createWizard(title);
                    },
                    MessageLevel: sqlExtHostTypes.MessageLevel
                };
                var window = {
                    createDialog: function (name) {
                        return extHostModalDialogs.createDialog(name);
                    },
                    modelviewdialog: modelViewDialog
                };
                var tasks = {
                    registerTask: function (id, task, thisArgs) {
                        return extHostTasks.registerTask(id, task, thisArgs);
                    },
                    startBackgroundOperation: function (operationInfo) {
                        extHostBackgroundTaskManagement.$registerTask(operationInfo);
                    }
                };
                var workspace = {
                    onDidOpenDashboard: extHostDashboard.onDidOpenDashboard,
                    onDidChangeToDashboard: extHostDashboard.onDidChangeToDashboard,
                    createModelViewEditor: function (title, options) {
                        return extHostModelViewDialog.createModelViewEditor(title, extension.extensionLocation, options);
                    }
                };
                var dashboard = {
                    registerWebviewProvider: function (widgetId, handler) {
                        extHostWebviewWidgets.$registerProvider(widgetId, handler);
                    }
                };
                var ui = {
                    registerModelViewProvider: function (modelViewId, handler) {
                        extHostModelView.$registerProvider(modelViewId, handler, extension.extensionLocation);
                    }
                };
                // namespace: queryeditor
                var queryEditor = {
                    connect: function (fileUri, connectionId) {
                        return extHostQueryEditor.$connect(fileUri, connectionId);
                    },
                    runQuery: function (fileUri) {
                        extHostQueryEditor.$runQuery(fileUri);
                    }
                };
                var extensions = {
                    install: function (vsixPath) {
                        return extHostExtensionManagement.$install(vsixPath);
                    }
                };
                var nb = {
                    get notebookDocuments() {
                        return extHostNotebookDocumentsAndEditors.getAllDocuments().map(function (doc) { return doc.document; });
                    },
                    get activeNotebookEditor() {
                        return extHostNotebookDocumentsAndEditors.getActiveEditor();
                    },
                    get visibleNotebookEditors() {
                        return extHostNotebookDocumentsAndEditors.getAllEditors();
                    },
                    get onDidOpenNotebookDocument() {
                        return extHostNotebookDocumentsAndEditors.onDidOpenNotebookDocument;
                    },
                    get onDidChangeNotebookCell() {
                        return extHostNotebookDocumentsAndEditors.onDidChangeNotebookCell;
                    },
                    showNotebookDocument: function (uri, showOptions) {
                        return extHostNotebookDocumentsAndEditors.showNotebookDocument(uri, showOptions);
                    },
                    registerNotebookProvider: function (provider) {
                        return extHostNotebook.registerNotebookProvider(provider);
                    },
                    CellRange: sqlExtHostTypes.CellRange
                };
                return {
                    accounts: accounts,
                    connection: connection,
                    credentials: credentials,
                    objectexplorer: objectExplorer,
                    resources: resources,
                    serialization: serialization,
                    dataprotocol: dataprotocol,
                    DataProviderType: sqlExtHostTypes.DataProviderType,
                    DeclarativeDataType: sqlExtHostTypes.DeclarativeDataType,
                    ServiceOptionType: sqlExtHostTypes.ServiceOptionType,
                    ConnectionOptionSpecialType: sqlExtHostTypes.ConnectionOptionSpecialType,
                    EditRowState: sqlExtHostTypes.EditRowState,
                    MetadataType: sqlExtHostTypes.MetadataType,
                    TaskStatus: sqlExtHostTypes.TaskStatus,
                    TaskExecutionMode: sqlExtHostTypes.TaskExecutionMode,
                    ScriptOperation: sqlExtHostTypes.ScriptOperation,
                    WeekDays: sqlExtHostTypes.WeekDays,
                    NotifyMethods: sqlExtHostTypes.NotifyMethods,
                    JobCompletionActionCondition: sqlExtHostTypes.JobCompletionActionCondition,
                    JobExecutionStatus: sqlExtHostTypes.JobExecutionStatus,
                    AlertType: sqlExtHostTypes.AlertType,
                    FrequencyTypes: sqlExtHostTypes.FrequencyTypes,
                    FrequencySubDayTypes: sqlExtHostTypes.FrequencySubDayTypes,
                    FrequencyRelativeIntervals: sqlExtHostTypes.FrequencyRelativeIntervals,
                    window: window,
                    tasks: tasks,
                    dashboard: dashboard,
                    workspace: workspace,
                    queryeditor: queryEditor,
                    ui: ui,
                    StatusIndicator: sqlExtHostTypes.StatusIndicator,
                    CardType: sqlExtHostTypes.CardType,
                    Orientation: sqlExtHostTypes.Orientation,
                    SqlThemeIcon: sqlExtHostTypes.SqlThemeIcon,
                    TreeComponentItem: sqlExtHostTypes.TreeComponentItem,
                    nb: nb,
                    AzureResource: sqlExtHostTypes.AzureResource,
                    extensions: extensions,
                };
            }
        };
    }
    exports.createApiFactory = createApiFactory;
    function initializeExtensionApi(extensionService, apiFactory) {
        return createExtensionPathIndex(extensionService).then(function (trie) { return defineAPI(apiFactory, trie); });
    }
    exports.initializeExtensionApi = initializeExtensionApi;
    function createExtensionPathIndex(extensionService) {
        // create trie to enable fast 'filename -> extension id' look up
        var trie = new map_1.TrieMap(map_1.TrieMap.PathSplitter);
        var extensions = extensionService.getAllExtensionDescriptions().map(function (ext) {
            if (!ext.main) {
                return undefined;
            }
            return new winjs_base_1.TPromise(function (resolve, reject) {
                fs_1.realpath(ext.extensionLocation.fsPath, function (err, path) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        trie.insert(path, ext);
                        resolve(void 0);
                    }
                });
            });
        });
        return winjs_base_1.TPromise.join(extensions).then(function () { return trie; });
    }
    function defineAPI(factory, extensionPaths) {
        // each extension is meant to get its own api implementation
        var extApiImpl = new Map();
        var dataExtApiImpl = new Map();
        var defaultApiImpl;
        var defaultDataApiImpl;
        // The module factory looks for an entry in the API map for an extension. If found, it reuses this.
        // If not, it loads it & saves it in the map
        var getModuleFactory = function (apiMap, createApi, defaultImpl, setDefaultApiImpl, parent) {
            // get extension id from filename and api for extension
            var ext = extensionPaths.findSubstr(uri_1.default.file(parent.filename).fsPath);
            if (ext) {
                var apiImpl = apiMap.get(ext.id);
                if (!apiImpl) {
                    apiImpl = createApi(ext);
                    apiMap.set(ext.id, apiImpl);
                }
                return apiImpl;
            }
            // fall back to a default implementation
            if (!defaultImpl) {
                console.warn("Could not identify extension for 'vscode' require call from " + parent.filename);
                defaultImpl = createApi(nullExtensionDescription);
                setDefaultApiImpl(defaultImpl);
            }
            return defaultImpl;
        };
        var node_module = require.__$__nodeRequire('module');
        var original = node_module._load;
        // TODO look into de-duplicating this code
        node_module._load = function load(request, parent, isMain) {
            if (request === 'vscode') {
                return getModuleFactory(extApiImpl, function (ext) { return factory.vsCodeFactory(ext); }, defaultApiImpl, function (impl) { return defaultApiImpl = impl; }, parent);
            }
            else if (request === 'sqlops') {
                return getModuleFactory(dataExtApiImpl, function (ext) { return factory.sqlopsFactory(ext); }, defaultDataApiImpl, function (impl) { return defaultDataApiImpl = impl; }, parent);
            }
            else {
                // Allow standard node_module load to occur
                return original.apply(this, arguments);
            }
        };
    }
    var nullExtensionDescription = {
        id: 'nullExtensionDescription',
        name: 'Null Extension Description',
        publisher: 'vscode',
        activationEvents: undefined,
        contributes: undefined,
        enableProposedApi: false,
        engines: undefined,
        extensionDependencies: undefined,
        extensionLocation: undefined,
        isBuiltin: false,
        main: undefined,
        version: undefined,
        isUnderDevelopment: true
    };
});




































define(__m[166/*vs/workbench/api/node/extHostExtensionService*/], __M([0/*require*/,1/*exports*/,9/*vs/base/common/lifecycle*/,22/*path*/,47/*vs/base/node/pfs*/,34/*vs/base/common/severity*/,2/*vs/base/common/winjs.base*/,173/*vs/workbench/services/extensions/node/extensionDescriptionRegistry*/,207/*vs/workbench/api/node/extHostStorage*/,236/*sql/workbench/api/node/sqlExtHost.api.impl*/,81/*vs/workbench/api/node/extHost.api.impl*/,6/*vs/workbench/api/node/extHost.protocol*/,48/*vs/workbench/api/node/extHostExtensionActivator*/,21/*vs/base/common/map*/,12/*vs/base/common/async*/,4/*vs/base/common/uri*/]), function (require, exports, lifecycle_1, path_1, pfs_1, severity_1, winjs_base_1, extensionDescriptionRegistry_1, extHostStorage_1, sqlExtHost_api_impl_1, extHost_api_impl_1, extHost_protocol_1, extHostExtensionActivator_1, map_1, async_1, uri_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtensionMemento = /** @class */ (function () {
        function ExtensionMemento(id, global, storage) {
            var _this = this;
            this._id = id;
            this._shared = global;
            this._storage = storage;
            this._init = this._storage.getValue(this._shared, this._id, Object.create(null)).then(function (value) {
                _this._value = value;
                return _this;
            });
        }
        Object.defineProperty(ExtensionMemento.prototype, "whenReady", {
            get: function () {
                return this._init;
            },
            enumerable: true,
            configurable: true
        });
        ExtensionMemento.prototype.get = function (key, defaultValue) {
            var value = this._value[key];
            if (typeof value === 'undefined') {
                value = defaultValue;
            }
            return value;
        };
        ExtensionMemento.prototype.update = function (key, value) {
            this._value[key] = value;
            return this._storage
                .setValue(this._shared, this._id, this._value)
                .then(function () { return true; });
        };
        return ExtensionMemento;
    }());
    var ExtensionStoragePath = /** @class */ (function () {
        function ExtensionStoragePath(workspace, environment) {
            var _this = this;
            this._workspace = workspace;
            this._environment = environment;
            this._ready = this._getOrCreateWorkspaceStoragePath().then(function (value) { return _this._value = value; });
        }
        Object.defineProperty(ExtensionStoragePath.prototype, "whenReady", {
            get: function () {
                return this._ready;
            },
            enumerable: true,
            configurable: true
        });
        ExtensionStoragePath.prototype.value = function (extension) {
            if (this._value) {
                return path_1.join(this._value, extension.id);
            }
            return undefined;
        };
        ExtensionStoragePath.prototype._getOrCreateWorkspaceStoragePath = function () {
            return __awaiter(this, void 0, void 0, function () {
                var storageName, storagePath, exists, e_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._workspace) {
                                return [2 /*return*/, winjs_base_1.TPromise.as(undefined)];
                            }
                            storageName = this._workspace.id;
                            storagePath = path_1.join(this._environment.appSettingsHome, 'workspaceStorage', storageName);
                            return [4 /*yield*/, pfs_1.dirExists(storagePath)];
                        case 1:
                            exists = _a.sent();
                            if (exists) {
                                return [2 /*return*/, storagePath];
                            }
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 5, , 6]);
                            return [4 /*yield*/, pfs_1.mkdirp(storagePath)];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, pfs_1.writeFile(path_1.join(storagePath, 'meta.json'), JSON.stringify({
                                    id: this._workspace.id,
                                    configuration: this._workspace.configuration && uri_1.default.revive(this._workspace.configuration).toString(),
                                    name: this._workspace.name
                                }, undefined, 2))];
                        case 4:
                            _a.sent();
                            return [2 /*return*/, storagePath];
                        case 5:
                            e_1 = _a.sent();
                            console.error(e_1);
                            return [2 /*return*/, undefined];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        return ExtensionStoragePath;
    }());
    var ExtHostExtensionService = /** @class */ (function () {
        /**
         * This class is constructed manually because it is a service, so it doesn't use any ctor injection
         */
        function ExtHostExtensionService(initData, extHostContext, extHostWorkspace, extHostConfiguration, extHostLogService) {
            var _this = this;
            this._barrier = new async_1.Barrier();
            this._registry = new extensionDescriptionRegistry_1.ExtensionDescriptionRegistry(initData.extensions);
            this._extHostLogService = extHostLogService;
            this._mainThreadTelemetry = extHostContext.getProxy(extHost_protocol_1.MainContext.MainThreadTelemetry);
            this._storage = new extHostStorage_1.ExtHostStorage(extHostContext);
            this._storagePath = new ExtensionStoragePath(initData.workspace, initData.environment);
            this._proxy = extHostContext.getProxy(extHost_protocol_1.MainContext.MainThreadExtensionService);
            this._activator = null;
            // initialize API first (i.e. do not release barrier until the API is initialized)
            var apiFactory = sqlExtHost_api_impl_1.createApiFactory(initData, extHostContext, extHostWorkspace, extHostConfiguration, this, this._extHostLogService);
            sqlExtHost_api_impl_1.initializeExtensionApi(this, apiFactory).then(function () {
                _this._activator = new extHostExtensionActivator_1.ExtensionsActivator(_this._registry, {
                    showMessage: function (severity, message) {
                        _this._proxy.$localShowMessage(severity, message);
                        switch (severity) {
                            case severity_1.default.Error:
                                console.error(message);
                                break;
                            case severity_1.default.Warning:
                                console.warn(message);
                                break;
                            default:
                                console.log(message);
                        }
                    },
                    actualActivateExtension: function (extensionDescription, reason) {
                        return _this._activateExtension(extensionDescription, reason);
                    }
                });
                _this._barrier.open();
            });
        }
        ExtHostExtensionService.prototype.onExtensionAPIReady = function () {
            return this._barrier.wait();
        };
        ExtHostExtensionService.prototype.isActivated = function (extensionId) {
            if (this._barrier.isOpen()) {
                return this._activator.isActivated(extensionId);
            }
            return false;
        };
        ExtHostExtensionService.prototype.activateByEvent = function (activationEvent, startup) {
            var _this = this;
            var reason = new extHostExtensionActivator_1.ExtensionActivatedByEvent(startup, activationEvent);
            if (this._barrier.isOpen()) {
                return this._activator.activateByEvent(activationEvent, reason);
            }
            else {
                return this._barrier.wait().then(function () { return _this._activator.activateByEvent(activationEvent, reason); });
            }
        };
        ExtHostExtensionService.prototype.activateById = function (extensionId, reason) {
            var _this = this;
            if (this._barrier.isOpen()) {
                return this._activator.activateById(extensionId, reason);
            }
            else {
                return this._barrier.wait().then(function () { return _this._activator.activateById(extensionId, reason); });
            }
        };
        ExtHostExtensionService.prototype.activateByIdWithErrors = function (extensionId, reason) {
            var _this = this;
            return this.activateById(extensionId, reason).then(function () {
                var extension = _this._activator.getActivatedExtension(extensionId);
                if (extension.activationFailed) {
                    // activation failed => bubble up the error as the promise result
                    return winjs_base_1.TPromise.wrapError(extension.activationFailedError);
                }
                return void 0;
            });
        };
        ExtHostExtensionService.prototype.getAllExtensionDescriptions = function () {
            return this._registry.getAllExtensionDescriptions();
        };
        ExtHostExtensionService.prototype.getExtensionDescription = function (extensionId) {
            return this._registry.getExtensionDescription(extensionId);
        };
        ExtHostExtensionService.prototype.getExtensionExports = function (extensionId) {
            if (this._barrier.isOpen()) {
                return this._activator.getActivatedExtension(extensionId).exports;
            }
            else {
                return null;
            }
        };
        // create trie to enable fast 'filename -> extension id' look up
        ExtHostExtensionService.prototype.getExtensionPathIndex = function () {
            if (!this._extensionPathIndex) {
                var tree_1 = map_1.TernarySearchTree.forPaths();
                var extensions = this.getAllExtensionDescriptions().map(function (ext) {
                    if (!ext.main) {
                        return undefined;
                    }
                    return pfs_1.realpath(ext.extensionLocation.fsPath).then(function (value) { return tree_1.set(value, ext); });
                });
                this._extensionPathIndex = winjs_base_1.TPromise.join(extensions).then(function () { return tree_1; });
            }
            return this._extensionPathIndex;
        };
        ExtHostExtensionService.prototype.deactivate = function (extensionId) {
            var result = winjs_base_1.TPromise.as(void 0);
            if (!this._barrier.isOpen()) {
                return result;
            }
            if (!this._activator.isActivated(extensionId)) {
                return result;
            }
            var extension = this._activator.getActivatedExtension(extensionId);
            if (!extension) {
                return result;
            }
            // call deactivate if available
            try {
                if (typeof extension.module.deactivate === 'function') {
                    result = winjs_base_1.TPromise.wrap(extension.module.deactivate()).then(null, function (err) {
                        // TODO: Do something with err if this is not the shutdown case
                        return winjs_base_1.TPromise.as(void 0);
                    });
                }
            }
            catch (err) {
                // TODO: Do something with err if this is not the shutdown case
            }
            // clean up subscriptions
            try {
                lifecycle_1.dispose(extension.subscriptions);
            }
            catch (err) {
                // TODO: Do something with err if this is not the shutdown case
            }
            return result;
        };
        ExtHostExtensionService.prototype.addMessage = function (extensionId, severity, message) {
            this._proxy.$addMessage(extensionId, severity, message);
        };
        // --- impl
        ExtHostExtensionService.prototype._activateExtension = function (extensionDescription, reason) {
            var _this = this;
            return this._doActivateExtension(extensionDescription, reason).then(function (activatedExtension) {
                var activationTimes = activatedExtension.activationTimes;
                var activationEvent = (reason instanceof extHostExtensionActivator_1.ExtensionActivatedByEvent ? reason.activationEvent : null);
                _this._proxy.$onExtensionActivated(extensionDescription.id, activationTimes.startup, activationTimes.codeLoadingTime, activationTimes.activateCallTime, activationTimes.activateResolvedTime, activationEvent);
                return activatedExtension;
            }, function (err) {
                _this._proxy.$onExtensionActivationFailed(extensionDescription.id);
                throw err;
            });
        };
        ExtHostExtensionService.prototype._doActivateExtension = function (extensionDescription, reason) {
            var _this = this;
            var event = getTelemetryActivationEvent(extensionDescription);
            /* __GDPR__
                "activatePlugin" : {
                    "${include}": [
                        "${TelemetryActivationEvent}"
                    ]
                }
            */
            this._mainThreadTelemetry.$publicLog('activatePlugin', event);
            if (!extensionDescription.main) {
                // Treat the extension as being empty => NOT AN ERROR CASE
                return winjs_base_1.TPromise.as(new extHostExtensionActivator_1.EmptyExtension(extHostExtensionActivator_1.ExtensionActivationTimes.NONE));
            }
            this._extHostLogService.info("ExtensionService#_doActivateExtension " + extensionDescription.id + " " + JSON.stringify(reason));
            var activationTimesBuilder = new extHostExtensionActivator_1.ExtensionActivationTimesBuilder(reason.startup);
            return winjs_base_1.TPromise.join([
                loadCommonJSModule(this._extHostLogService, extensionDescription.main, activationTimesBuilder),
                this._loadExtensionContext(extensionDescription)
            ]).then(function (values) {
                return ExtHostExtensionService._callActivate(_this._extHostLogService, extensionDescription.id, values[0], values[1], activationTimesBuilder);
            }, function (errors) {
                // Avoid failing with an array of errors, fail with a single error
                if (errors[0]) {
                    return winjs_base_1.TPromise.wrapError(errors[0]);
                }
                if (errors[1]) {
                    return winjs_base_1.TPromise.wrapError(errors[1]);
                }
                return undefined;
            });
        };
        ExtHostExtensionService.prototype._loadExtensionContext = function (extensionDescription) {
            var _this = this;
            var globalState = new ExtensionMemento(extensionDescription.id, true, this._storage);
            var workspaceState = new ExtensionMemento(extensionDescription.id, false, this._storage);
            this._extHostLogService.trace("ExtensionService#loadExtensionContext " + extensionDescription.id);
            return winjs_base_1.TPromise.join([
                globalState.whenReady,
                workspaceState.whenReady,
                this._storagePath.whenReady
            ]).then(function () {
                var that = _this;
                return Object.freeze({
                    globalState: globalState,
                    workspaceState: workspaceState,
                    subscriptions: [],
                    get extensionPath() { return extensionDescription.extensionLocation.fsPath; },
                    storagePath: _this._storagePath.value(extensionDescription),
                    asAbsolutePath: function (relativePath) { return path_1.join(extensionDescription.extensionLocation.fsPath, relativePath); },
                    get logger() {
                        extHost_api_impl_1.checkProposedApiEnabled(extensionDescription);
                        return that._extHostLogService.getExtLogger(extensionDescription.id);
                    },
                    get logDirectory() {
                        extHost_api_impl_1.checkProposedApiEnabled(extensionDescription);
                        return that._extHostLogService.getLogDirectory(extensionDescription.id);
                    }
                });
            });
        };
        ExtHostExtensionService._callActivate = function (logService, extensionId, extensionModule, context, activationTimesBuilder) {
            // Make sure the extension's surface is not undefined
            extensionModule = extensionModule || {
                activate: undefined,
                deactivate: undefined
            };
            return this._callActivateOptional(logService, extensionId, extensionModule, context, activationTimesBuilder).then(function (extensionExports) {
                return new extHostExtensionActivator_1.ActivatedExtension(false, null, activationTimesBuilder.build(), extensionModule, extensionExports, context.subscriptions);
            });
        };
        ExtHostExtensionService._callActivateOptional = function (logService, extensionId, extensionModule, context, activationTimesBuilder) {
            if (typeof extensionModule.activate === 'function') {
                try {
                    activationTimesBuilder.activateCallStart();
                    logService.trace("ExtensionService#_callActivateOptional " + extensionId);
                    var activateResult = extensionModule.activate.apply(global, [context]);
                    activationTimesBuilder.activateCallStop();
                    activationTimesBuilder.activateResolveStart();
                    return winjs_base_1.TPromise.as(activateResult).then(function (value) {
                        activationTimesBuilder.activateResolveStop();
                        return value;
                    });
                }
                catch (err) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
            }
            else {
                // No activate found => the module is the extension's exports
                return winjs_base_1.TPromise.as(extensionModule);
            }
        };
        // -- called by main thread
        ExtHostExtensionService.prototype.$activateByEvent = function (activationEvent) {
            return this.activateByEvent(activationEvent, false);
        };
        return ExtHostExtensionService;
    }());
    exports.ExtHostExtensionService = ExtHostExtensionService;
    function loadCommonJSModule(logService, modulePath, activationTimesBuilder) {
        var r = null;
        activationTimesBuilder.codeLoadingStart();
        logService.info("ExtensionService#loadCommonJSModule " + modulePath);
        try {
            r = require.__$__nodeRequire(modulePath);
        }
        catch (e) {
            return winjs_base_1.TPromise.wrapError(e);
        }
        finally {
            activationTimesBuilder.codeLoadingStop();
        }
        return winjs_base_1.TPromise.as(r);
    }
    function getTelemetryActivationEvent(extensionDescription) {
        /* __GDPR__FRAGMENT__
            "TelemetryActivationEvent" : {
                "id": { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" },
                "name": { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" },
                "publisherDisplayName": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                "activationEvents": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                "isBuiltin": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
            }
        */
        var event = {
            id: extensionDescription.id,
            name: extensionDescription.name,
            publisherDisplayName: extensionDescription.publisher,
            activationEvents: extensionDescription.activationEvents ? extensionDescription.activationEvents.join(',') : null,
            isBuiltin: extensionDescription.isBuiltin
        };
        return event;
    }
});




















define(__m[154/*vs/workbench/common/editor/untitledEditorInput*/], __M([0/*require*/,1/*exports*/,2/*vs/base/common/winjs.base*/,74/*vs/base/common/mime*/,52/*vs/base/common/decorators*/,67/*vs/editor/common/modes/modesRegistry*/,16/*vs/base/common/paths*/,26/*vs/base/common/resources*/,78/*vs/workbench/common/editor*/,168/*vs/workbench/common/editor/untitledEditorModel*/,7/*vs/platform/instantiation/common/instantiation*/,3/*vs/base/common/event*/,82/*vs/workbench/services/textfile/common/textfiles*/,145/*vs/platform/telemetry/common/telemetryUtils*/,214/*vs/workbench/services/hash/common/hashService*/,148/*vs/platform/uriDisplay/common/uriDisplay*/]), function (require, exports, winjs_base_1, mime_1, decorators_1, modesRegistry_1, paths, resources, editor_1, untitledEditorModel_1, instantiation_1, event_1, textfiles_1, telemetryUtils_1, hashService_1, uriDisplay_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An editor input to be used for untitled text buffers.
     */
    var UntitledEditorInput = /** @class */ (function (_super) {
        __extends(UntitledEditorInput, _super);
        function UntitledEditorInput(resource, hasAssociatedFilePath, modeId, initialValue, preferredEncoding, instantiationService, textFileService, hashService, uriDisplayService) {
            var _this = _super.call(this) || this;
            _this.resource = resource;
            _this.modeId = modeId;
            _this.initialValue = initialValue;
            _this.preferredEncoding = preferredEncoding;
            _this.instantiationService = instantiationService;
            _this.textFileService = textFileService;
            _this.hashService = hashService;
            _this.uriDisplayService = uriDisplayService;
            _this._onDidModelChangeContent = _this._register(new event_1.Emitter());
            _this._onDidModelChangeEncoding = _this._register(new event_1.Emitter());
            _this._hasAssociatedFilePath = hasAssociatedFilePath;
            return _this;
        }
        Object.defineProperty(UntitledEditorInput.prototype, "onDidModelChangeContent", {
            get: function () { return this._onDidModelChangeContent.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "onDidModelChangeEncoding", {
            get: function () { return this._onDidModelChangeEncoding.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "hasAssociatedFilePath", {
            get: function () {
                return this._hasAssociatedFilePath;
            },
            enumerable: true,
            configurable: true
        });
        UntitledEditorInput.prototype.getTypeId = function () {
            return UntitledEditorInput.ID;
        };
        UntitledEditorInput.prototype.getResource = function () {
            return this.resource;
        };
        UntitledEditorInput.prototype.getModeId = function () {
            if (this.cachedModel) {
                return this.cachedModel.getModeId();
            }
            return this.modeId;
        };
        UntitledEditorInput.prototype.getName = function () {
            return this.hasAssociatedFilePath ? resources.basenameOrAuthority(this.resource) : this.resource.path;
        };
        Object.defineProperty(UntitledEditorInput.prototype, "shortDescription", {
            get: function () {
                return paths.basename(this.uriDisplayService.getLabel(resources.dirname(this.resource)));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "mediumDescription", {
            get: function () {
                return this.uriDisplayService.getLabel(resources.dirname(this.resource), true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "longDescription", {
            get: function () {
                return this.uriDisplayService.getLabel(resources.dirname(this.resource));
            },
            enumerable: true,
            configurable: true
        });
        UntitledEditorInput.prototype.getDescription = function (verbosity) {
            if (verbosity === void 0) { verbosity = editor_1.Verbosity.MEDIUM; }
            if (!this.hasAssociatedFilePath) {
                return null;
            }
            var description;
            switch (verbosity) {
                case editor_1.Verbosity.SHORT:
                    description = this.shortDescription;
                    break;
                case editor_1.Verbosity.LONG:
                    description = this.longDescription;
                    break;
                case editor_1.Verbosity.MEDIUM:
                default:
                    description = this.mediumDescription;
                    break;
            }
            return description;
        };
        Object.defineProperty(UntitledEditorInput.prototype, "shortTitle", {
            get: function () {
                return this.getName();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "mediumTitle", {
            get: function () {
                return this.uriDisplayService.getLabel(this.resource, true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "longTitle", {
            get: function () {
                return this.uriDisplayService.getLabel(this.resource);
            },
            enumerable: true,
            configurable: true
        });
        UntitledEditorInput.prototype.getTitle = function (verbosity) {
            if (!this.hasAssociatedFilePath) {
                return this.getName();
            }
            var title;
            switch (verbosity) {
                case editor_1.Verbosity.SHORT:
                    title = this.shortTitle;
                    break;
                case editor_1.Verbosity.MEDIUM:
                    title = this.mediumTitle;
                    break;
                case editor_1.Verbosity.LONG:
                    title = this.longTitle;
                    break;
            }
            return title;
        };
        UntitledEditorInput.prototype.isDirty = function () {
            // {{SQL CARBON EDIT}}
            if (!this.savingSupported) {
                return false;
            }
            if (this.cachedModel) {
                return this.cachedModel.isDirty();
            }
            // A disposed input is never dirty, even if it was restored from backup
            if (this.isDisposed()) {
                return false;
            }
            // untitled files with an associated path or associated resource
            return this.hasAssociatedFilePath;
        };
        UntitledEditorInput.prototype.confirmSave = function () {
            return this.textFileService.confirmSave([this.resource]);
        };
        UntitledEditorInput.prototype.save = function () {
            return this.textFileService.save(this.resource);
        };
        UntitledEditorInput.prototype.revert = function () {
            if (this.cachedModel) {
                this.cachedModel.revert();
            }
            this.dispose(); // a reverted untitled editor is no longer valid, so we dispose it
            return winjs_base_1.TPromise.as(true);
        };
        UntitledEditorInput.prototype.suggestFileName = function () {
            if (!this.hasAssociatedFilePath) {
                if (this.cachedModel) {
                    var modeId = this.cachedModel.getModeId();
                    if (modeId !== modesRegistry_1.PLAINTEXT_MODE_ID) { // do not suggest when the mode ID is simple plain text
                        return mime_1.suggestFilename(modeId, this.getName());
                    }
                }
            }
            return this.getName();
        };
        UntitledEditorInput.prototype.getEncoding = function () {
            if (this.cachedModel) {
                return this.cachedModel.getEncoding();
            }
            return this.preferredEncoding;
        };
        UntitledEditorInput.prototype.setEncoding = function (encoding, mode /* ignored, we only have Encode */) {
            this.preferredEncoding = encoding;
            if (this.cachedModel) {
                this.cachedModel.setEncoding(encoding);
            }
        };
        UntitledEditorInput.prototype.resolve = function () {
            // Join a model resolve if we have had one before
            if (this.modelResolve) {
                return this.modelResolve;
            }
            // Otherwise Create Model and load
            this.cachedModel = this.createModel();
            this.modelResolve = this.cachedModel.load();
            return this.modelResolve;
        };
        UntitledEditorInput.prototype.createModel = function () {
            var _this = this;
            var model = this._register(this.instantiationService.createInstance(untitledEditorModel_1.UntitledEditorModel, this.modeId, this.resource, this.hasAssociatedFilePath, this.initialValue, this.preferredEncoding));
            // re-emit some events from the model
            this._register(model.onDidChangeContent(function () { return _this._onDidModelChangeContent.fire(); }));
            this._register(model.onDidChangeDirty(function () { return _this._onDidChangeDirty.fire(); }));
            this._register(model.onDidChangeEncoding(function () { return _this._onDidModelChangeEncoding.fire(); }));
            return model;
        };
        UntitledEditorInput.prototype.getTelemetryDescriptor = function () {
            var _this = this;
            var descriptor = _super.prototype.getTelemetryDescriptor.call(this);
            descriptor['resource'] = telemetryUtils_1.telemetryURIDescriptor(this.getResource(), function (path) { return _this.hashService.createSHA1(path); });
            /* __GDPR__FRAGMENT__
                "EditorTelemetryDescriptor" : {
                    "resource": { "${inline}": [ "${URIDescriptor}" ] }
                }
            */
            return descriptor;
        };
        UntitledEditorInput.prototype.matches = function (otherInput) {
            if (_super.prototype.matches.call(this, otherInput) === true) {
                return true;
            }
            if (otherInput instanceof UntitledEditorInput) {
                var otherUntitledEditorInput = otherInput;
                // Otherwise compare by properties
                return otherUntitledEditorInput.resource.toString() === this.resource.toString();
            }
            return false;
        };
        UntitledEditorInput.prototype.dispose = function () {
            this.modelResolve = void 0;
            _super.prototype.dispose.call(this);
        };
        UntitledEditorInput.ID = 'workbench.editors.untitledEditorInput';
        __decorate([
            decorators_1.memoize
        ], UntitledEditorInput.prototype, "shortDescription", null);
        __decorate([
            decorators_1.memoize
        ], UntitledEditorInput.prototype, "mediumDescription", null);
        __decorate([
            decorators_1.memoize
        ], UntitledEditorInput.prototype, "longDescription", null);
        __decorate([
            decorators_1.memoize
        ], UntitledEditorInput.prototype, "shortTitle", null);
        __decorate([
            decorators_1.memoize
        ], UntitledEditorInput.prototype, "mediumTitle", null);
        __decorate([
            decorators_1.memoize
        ], UntitledEditorInput.prototype, "longTitle", null);
        UntitledEditorInput = __decorate([
            __param(5, instantiation_1.IInstantiationService),
            __param(6, textfiles_1.ITextFileService),
            __param(7, hashService_1.IHashService),
            __param(8, uriDisplay_1.IUriDisplayService)
        ], UntitledEditorInput);
        return UntitledEditorInput;
    }(editor_1.EditorInput));
    exports.UntitledEditorInput = UntitledEditorInput;
});




















define(__m[97/*vs/workbench/services/untitled/common/untitledEditorService*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/uri*/,7/*vs/platform/instantiation/common/instantiation*/,13/*vs/base/common/arrays*/,154/*vs/workbench/common/editor/untitledEditorInput*/,30/*vs/platform/configuration/common/configuration*/,3/*vs/base/common/event*/,21/*vs/base/common/map*/,23/*vs/base/common/network*/,9/*vs/base/common/lifecycle*/]), function (require, exports, uri_1, instantiation_1, arrays, untitledEditorInput_1, configuration_1, event_1, map_1, network_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IUntitledEditorService = instantiation_1.createDecorator('untitledEditorService');
    var UntitledEditorService = /** @class */ (function (_super) {
        __extends(UntitledEditorService, _super);
        function UntitledEditorService(instantiationService, configurationService) {
            var _this = _super.call(this) || this;
            _this.instantiationService = instantiationService;
            _this.configurationService = configurationService;
            _this.mapResourceToInput = new map_1.ResourceMap();
            _this.mapResourceToAssociatedFilePath = new map_1.ResourceMap();
            _this._onDidChangeContent = _this._register(new event_1.Emitter());
            _this._onDidChangeDirty = _this._register(new event_1.Emitter());
            _this._onDidChangeEncoding = _this._register(new event_1.Emitter());
            _this._onDidDisposeModel = _this._register(new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(UntitledEditorService.prototype, "onDidChangeContent", {
            get: function () { return this._onDidChangeContent.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorService.prototype, "onDidChangeDirty", {
            get: function () { return this._onDidChangeDirty.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorService.prototype, "onDidChangeEncoding", {
            get: function () { return this._onDidChangeEncoding.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorService.prototype, "onDidDisposeModel", {
            get: function () { return this._onDidDisposeModel.event; },
            enumerable: true,
            configurable: true
        });
        UntitledEditorService.prototype.get = function (resource) {
            return this.mapResourceToInput.get(resource);
        };
        // {{SQL CARBON EDIT}}
        UntitledEditorService.prototype.getAll = function (resources) {
            var _this = this;
            if (resources) {
                return arrays.coalesce(resources.map(function (r) { return _this.get(r); }));
            }
            return this.mapResourceToInput.values();
        };
        UntitledEditorService.prototype.exists = function (resource) {
            return this.mapResourceToInput.has(resource);
        };
        UntitledEditorService.prototype.revertAll = function (resources, force) {
            var reverted = [];
            var untitledInputs = this.getAll(resources);
            untitledInputs.forEach(function (input) {
                if (input) {
                    input.revert();
                    input.dispose();
                    reverted.push(input.getResource());
                }
            });
            return reverted;
        };
        UntitledEditorService.prototype.isDirty = function (resource) {
            var input = this.get(resource);
            return input && input.isDirty();
        };
        UntitledEditorService.prototype.getDirty = function (resources) {
            var _this = this;
            var inputs;
            if (resources) {
                inputs = resources.map(function (r) { return _this.get(r); }).filter(function (i) { return !!i; });
            }
            else {
                inputs = this.mapResourceToInput.values();
            }
            return inputs
                .filter(function (i) { return i.isDirty(); })
                .map(function (i) { return i.getResource(); });
        };
        UntitledEditorService.prototype.loadOrCreate = function (options) {
            if (options === void 0) { options = Object.create(null); }
            return this.createOrGet(options.resource, options.modeId, options.initialValue, options.encoding, options.useResourcePath).resolve();
        };
        UntitledEditorService.prototype.createOrGet = function (resource, modeId, initialValue, encoding, hasAssociatedFilePath) {
            if (hasAssociatedFilePath === void 0) { hasAssociatedFilePath = false; }
            if (resource) {
                // Massage resource if it comes with a file:// scheme
                if (resource.scheme === network_1.Schemas.file) {
                    hasAssociatedFilePath = true;
                    resource = resource.with({ scheme: network_1.Schemas.untitled }); // ensure we have the right scheme
                }
                if (hasAssociatedFilePath) {
                    this.mapResourceToAssociatedFilePath.set(resource, true); // remember for future lookups
                }
            }
            // Return existing instance if asked for it
            if (resource && this.mapResourceToInput.has(resource)) {
                return this.mapResourceToInput.get(resource);
            }
            // Create new otherwise
            return this.doCreate(resource, hasAssociatedFilePath, modeId, initialValue, encoding);
        };
        UntitledEditorService.prototype.doCreate = function (resource, hasAssociatedFilePath, modeId, initialValue, encoding) {
            var _this = this;
            if (!resource) {
                // Create new taking a resource URI that is not already taken
                var counter = this.mapResourceToInput.size + 1;
                do {
                    resource = uri_1.default.from({ scheme: network_1.Schemas.untitled, path: "Untitled-" + counter });
                    counter++;
                } while (this.mapResourceToInput.has(resource));
            }
            // Look up default language from settings if any
            if (!modeId && !hasAssociatedFilePath) {
                var configuration = this.configurationService.getValue();
                if (configuration.files && configuration.files.defaultLanguage) {
                    modeId = configuration.files.defaultLanguage;
                }
            }
            var input = this.instantiationService.createInstance(untitledEditorInput_1.UntitledEditorInput, resource, hasAssociatedFilePath, modeId, initialValue, encoding);
            var contentListener = input.onDidModelChangeContent(function () {
                _this._onDidChangeContent.fire(resource);
            });
            var dirtyListener = input.onDidChangeDirty(function () {
                _this._onDidChangeDirty.fire(resource);
            });
            var encodingListener = input.onDidModelChangeEncoding(function () {
                _this._onDidChangeEncoding.fire(resource);
            });
            var disposeListener = input.onDispose(function () {
                _this._onDidDisposeModel.fire(resource);
            });
            // Remove from cache on dispose
            var onceDispose = event_1.once(input.onDispose);
            onceDispose(function () {
                _this.mapResourceToInput.delete(input.getResource());
                _this.mapResourceToAssociatedFilePath.delete(input.getResource());
                contentListener.dispose();
                dirtyListener.dispose();
                encodingListener.dispose();
                disposeListener.dispose();
            });
            // Add to cache
            this.mapResourceToInput.set(resource, input);
            return input;
        };
        UntitledEditorService.prototype.hasAssociatedFilePath = function (resource) {
            return this.mapResourceToAssociatedFilePath.has(resource);
        };
        UntitledEditorService.prototype.suggestFileName = function (resource) {
            var input = this.get(resource);
            return input ? input.suggestFileName() : void 0;
        };
        UntitledEditorService.prototype.getEncoding = function (resource) {
            var input = this.get(resource);
            return input ? input.getEncoding() : void 0;
        };
        UntitledEditorService = __decorate([
            __param(0, instantiation_1.IInstantiationService),
            __param(1, configuration_1.IConfigurationService)
        ], UntitledEditorService);
        return UntitledEditorService;
    }(lifecycle_1.Disposable));
    exports.UntitledEditorService = UntitledEditorService;
});




























define(__m[95/*vs/workbench/services/search/node/searchService*/], __M([0/*require*/,1/*exports*/,13/*vs/base/common/arrays*/,9/*vs/base/common/lifecycle*/,21/*vs/base/common/map*/,23/*vs/base/common/network*/,20/*vs/base/common/objects*/,8/*vs/base/common/strings*/,4/*vs/base/common/uri*/,2/*vs/base/common/winjs.base*/,47/*vs/base/node/pfs*/,53/*vs/base/parts/ipc/common/ipc*/,100/*vs/base/parts/ipc/node/ipc.cp*/,39/*vs/editor/common/services/modelService*/,30/*vs/platform/configuration/common/configuration*/,61/*vs/platform/environment/common/environment*/,38/*vs/platform/log/common/log*/,71/*vs/platform/search/common/search*/,144/*vs/platform/telemetry/common/telemetry*/,172/*vs/workbench/services/extensions/common/extensions*/,97/*vs/workbench/services/untitled/common/untitledEditorService*/,216/*vs/workbench/services/search/node/search*/,217/*vs/workbench/services/search/node/searchIpc*/]), function (require, exports, arrays, lifecycle_1, map_1, network_1, objects, strings, uri_1, winjs_base_1, pfs, ipc_1, ipc_cp_1, modelService_1, configuration_1, environment_1, log_1, search_1, telemetry_1, extensions_1, untitledEditorService_1, search_2, searchIpc_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SearchService = /** @class */ (function (_super) {
        __extends(SearchService, _super);
        function SearchService(modelService, untitledEditorService, environmentService, telemetryService, configurationService, logService, extensionService) {
            var _this = _super.call(this) || this;
            _this.modelService = modelService;
            _this.untitledEditorService = untitledEditorService;
            _this.telemetryService = telemetryService;
            _this.configurationService = configurationService;
            _this.logService = logService;
            _this.extensionService = extensionService;
            _this.fileSearchProviders = new Map();
            _this.textSearchProviders = new Map();
            _this.fileIndexProviders = new Map();
            _this.diskSearch = new DiskSearch(!environmentService.isBuilt || environmentService.verbose, /*timeout=*/ undefined, environmentService.debugSearch);
            _this._register(_this.diskSearch.onTelemetry(function (event) {
                _this.telemetryService.publicLog(event.eventName, event.data);
            }));
            return _this;
        }
        SearchService.prototype.registerSearchResultProvider = function (scheme, type, provider) {
            var list;
            if (type === search_1.SearchProviderType.file) {
                list = this.fileSearchProviders;
            }
            else if (type === search_1.SearchProviderType.text) {
                list = this.textSearchProviders;
            }
            else if (type === search_1.SearchProviderType.fileIndex) {
                list = this.fileIndexProviders;
            }
            list.set(scheme, provider);
            return lifecycle_1.toDisposable(function () {
                list.delete(scheme);
            });
        };
        SearchService.prototype.extendQuery = function (query) {
            var configuration = this.configurationService.getValue();
            // Configuration: Encoding
            if (!query.fileEncoding) {
                var fileEncoding = configuration && configuration.files && configuration.files.encoding;
                query.fileEncoding = fileEncoding;
            }
            // Configuration: File Excludes
            if (!query.disregardExcludeSettings) {
                var fileExcludes = objects.deepClone(configuration && configuration.files && configuration.files.exclude);
                if (fileExcludes) {
                    if (!query.excludePattern) {
                        query.excludePattern = fileExcludes;
                    }
                    else {
                        objects.mixin(query.excludePattern, fileExcludes, false /* no overwrite */);
                    }
                }
            }
        };
        SearchService.prototype.search = function (query, onProgress) {
            var _this = this;
            var combinedPromise;
            return new winjs_base_1.TPromise(function (onComplete, onError) {
                // Get local results from dirty/untitled
                var localResults = _this.getLocalResults(query);
                if (onProgress) {
                    localResults.values().filter(function (res) { return !!res; }).forEach(onProgress);
                }
                _this.logService.trace('SearchService#search', JSON.stringify(query));
                var onProviderProgress = function (progress) {
                    if (progress.resource) {
                        // Match
                        if (!localResults.has(progress.resource) && onProgress) { // don't override local results
                            onProgress(progress);
                        }
                    }
                    else if (onProgress) {
                        // Progress
                        onProgress(progress);
                    }
                    if (progress.message) {
                        _this.logService.debug('SearchService#search', progress.message);
                    }
                };
                var startTime = Date.now();
                var schemesInQuery = query.folderQueries.map(function (fq) { return fq.folder.scheme; });
                var providerActivations = schemesInQuery.map(function (scheme) { return _this.extensionService.activateByEvent("onSearch:" + scheme); });
                var providerPromise = winjs_base_1.TPromise.join(providerActivations)
                    .then(function () { return _this.searchWithProviders(query, onProviderProgress); })
                    .then(function (completes) {
                    completes = completes.filter(function (c) { return !!c; });
                    if (!completes.length) {
                        return null;
                    }
                    return {
                        limitHit: completes[0] && completes[0].limitHit,
                        stats: completes[0].stats,
                        results: arrays.flatten(completes.map(function (c) { return c.results; }))
                    };
                }, function (errs) {
                    if (!Array.isArray(errs)) {
                        errs = [errs];
                    }
                    errs = errs.filter(function (e) { return !!e; });
                    return winjs_base_1.TPromise.wrapError(errs[0]);
                });
                combinedPromise = providerPromise.then(function (value) {
                    _this.logService.debug("SearchService#search: " + (Date.now() - startTime) + "ms");
                    var values = [value];
                    var result = {
                        limitHit: false,
                        results: [],
                        stats: undefined
                    };
                    // TODO@joh
                    // sorting, disjunct results
                    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                        var value_1 = values_1[_i];
                        if (!value_1) {
                            continue;
                        }
                        // TODO@joh individual stats/limit
                        result.stats = value_1.stats || result.stats;
                        result.limitHit = value_1.limitHit || result.limitHit;
                        for (var _a = 0, _b = value_1.results; _a < _b.length; _a++) {
                            var match = _b[_a];
                            if (!localResults.has(match.resource)) {
                                result.results.push(match);
                            }
                        }
                    }
                    return result;
                }).then(onComplete, onError);
            }, function () { return combinedPromise && combinedPromise.cancel(); });
        };
        SearchService.prototype.searchWithProviders = function (query, onProviderProgress) {
            var _this = this;
            var diskSearchQueries = [];
            var searchPs = [];
            query.folderQueries.forEach(function (fq) {
                var provider = query.type === search_1.QueryType.File ?
                    _this.fileSearchProviders.get(fq.folder.scheme) || _this.fileIndexProviders.get(fq.folder.scheme) :
                    _this.textSearchProviders.get(fq.folder.scheme);
                if (!provider && fq.folder.scheme === 'file') {
                    diskSearchQueries.push(fq);
                }
                else if (!provider) {
                    throw new Error('No search provider registered for scheme: ' + fq.folder.scheme);
                }
                else {
                    var oneFolderQuery = __assign({}, query, {
                        folderQueries: [fq]
                    });
                    searchPs.push(provider.search(oneFolderQuery, onProviderProgress));
                }
            });
            var diskSearchExtraFileResources = query.extraFileResources && query.extraFileResources.filter(function (res) { return res.scheme === 'file'; });
            if (diskSearchQueries.length || diskSearchExtraFileResources) {
                var diskSearchQuery = __assign({}, query, {
                    folderQueries: diskSearchQueries
                }, { extraFileResources: diskSearchExtraFileResources });
                searchPs.push(this.diskSearch.search(diskSearchQuery, onProviderProgress));
            }
            return winjs_base_1.TPromise.join(searchPs);
        };
        SearchService.prototype.getLocalResults = function (query) {
            var _this = this;
            var localResults = new map_1.ResourceMap();
            if (query.type === search_1.QueryType.Text) {
                var models = this.modelService.getModels();
                models.forEach(function (model) {
                    var resource = model.uri;
                    if (!resource) {
                        return;
                    }
                    // Support untitled files
                    if (resource.scheme === network_1.Schemas.untitled) {
                        if (!_this.untitledEditorService.exists(resource)) {
                            return;
                        }
                    }
                    // Don't support other resource schemes than files for now
                    // todo@remote
                    // why is that? we should search for resources from other
                    // schemes
                    else if (resource.scheme !== network_1.Schemas.file) {
                        return;
                    }
                    if (!_this.matches(resource, query)) {
                        return; // respect user filters
                    }
                    // Use editor API to find matches
                    var matches = model.findMatches(query.contentPattern.pattern, false, query.contentPattern.isRegExp, query.contentPattern.isCaseSensitive, query.contentPattern.isWordMatch ? query.contentPattern.wordSeparators : null, false, query.maxResults);
                    if (matches.length) {
                        var fileMatch_1 = new search_1.FileMatch(resource);
                        localResults.set(resource, fileMatch_1);
                        matches.forEach(function (match) {
                            fileMatch_1.lineMatches.push(new search_1.LineMatch(model.getLineContent(match.range.startLineNumber), match.range.startLineNumber - 1, [[match.range.startColumn - 1, match.range.endColumn - match.range.startColumn]]));
                        });
                    }
                    else {
                        localResults.set(resource, null);
                    }
                });
            }
            return localResults;
        };
        SearchService.prototype.matches = function (resource, query) {
            // file pattern
            if (query.filePattern) {
                if (resource.scheme !== network_1.Schemas.file) {
                    return false; // if we match on file pattern, we have to ignore non file resources
                }
                if (!strings.fuzzyContains(resource.fsPath, strings.stripWildcards(query.filePattern).toLowerCase())) {
                    return false;
                }
            }
            // includes
            if (query.includePattern) {
                if (resource.scheme !== network_1.Schemas.file) {
                    return false; // if we match on file patterns, we have to ignore non file resources
                }
            }
            return search_1.pathIncludedInQuery(query, resource.fsPath);
        };
        SearchService.prototype.clearCache = function (cacheKey) {
            var clearPs = [
                this.diskSearch
            ].concat(map_1.values(this.fileIndexProviders)).map(function (provider) { return provider && provider.clearCache(cacheKey); });
            return winjs_base_1.TPromise.join(clearPs)
                .then(function () { });
        };
        SearchService = __decorate([
            __param(0, modelService_1.IModelService),
            __param(1, untitledEditorService_1.IUntitledEditorService),
            __param(2, environment_1.IEnvironmentService),
            __param(3, telemetry_1.ITelemetryService),
            __param(4, configuration_1.IConfigurationService),
            __param(5, log_1.ILogService),
            __param(6, extensions_1.IExtensionService)
        ], SearchService);
        return SearchService;
    }(lifecycle_1.Disposable));
    exports.SearchService = SearchService;
    var DiskSearch = /** @class */ (function () {
        function DiskSearch(verboseLogging, timeout, searchDebug) {
            if (timeout === void 0) { timeout = 60 * 60 * 1000; }
            var opts = {
                serverName: 'Search',
                timeout: timeout,
                args: ['--type=searchService'],
                // See https://github.com/Microsoft/vscode/issues/27665
                // Pass in fresh execArgv to the forked process such that it doesn't inherit them from `process.execArgv`.
                // e.g. Launching the extension host process with `--inspect-brk=xxx` and then forking a process from the extension host
                // results in the forked process inheriting `--inspect-brk=xxx`.
                freshExecArgv: true,
                env: {
                    AMD_ENTRYPOINT: 'vs/workbench/services/search/node/searchApp',
                    PIPE_LOGGING: 'true',
                    VERBOSE_LOGGING: verboseLogging
                }
            };
            if (searchDebug) {
                if (searchDebug.break && searchDebug.port) {
                    opts.debugBrk = searchDebug.port;
                }
                else if (!searchDebug.break && searchDebug.port) {
                    opts.debug = searchDebug.port;
                }
            }
            var client = new ipc_cp_1.Client(uri_1.default.parse(require.toUrl('bootstrap')).fsPath, opts);
            var channel = ipc_1.getNextTickChannel(client.getChannel('search'));
            this.raw = new searchIpc_1.SearchChannelClient(channel);
        }
        Object.defineProperty(DiskSearch.prototype, "onTelemetry", {
            get: function () {
                return this.raw.onTelemetry;
            },
            enumerable: true,
            configurable: true
        });
        DiskSearch.prototype.search = function (query, onProgress) {
            var _this = this;
            var folderQueries = query.folderQueries || [];
            return winjs_base_1.TPromise.join(folderQueries.map(function (q) { return q.folder.scheme === network_1.Schemas.file && pfs.exists(q.folder.fsPath); }))
                .then(function (exists) {
                var existingFolders = folderQueries.filter(function (q, index) { return exists[index]; });
                var rawSearch = _this.rawSearchQuery(query, existingFolders);
                var event;
                if (query.type === search_1.QueryType.File) {
                    event = _this.raw.fileSearch(rawSearch);
                }
                else {
                    event = _this.raw.textSearch(rawSearch);
                }
                return DiskSearch.collectResultsFromEvent(event, onProgress);
            });
        };
        DiskSearch.prototype.rawSearchQuery = function (query, existingFolders) {
            var rawSearch = {
                folderQueries: [],
                extraFiles: [],
                filePattern: query.filePattern,
                excludePattern: query.excludePattern,
                includePattern: query.includePattern,
                maxResults: query.maxResults,
                exists: query.exists,
                sortByScore: query.sortByScore,
                cacheKey: query.cacheKey,
                useRipgrep: query.useRipgrep,
                disregardIgnoreFiles: query.disregardIgnoreFiles,
                ignoreSymlinks: query.ignoreSymlinks
            };
            for (var _i = 0, existingFolders_1 = existingFolders; _i < existingFolders_1.length; _i++) {
                var q = existingFolders_1[_i];
                rawSearch.folderQueries.push({
                    excludePattern: q.excludePattern,
                    includePattern: q.includePattern,
                    fileEncoding: q.fileEncoding,
                    disregardIgnoreFiles: q.disregardIgnoreFiles,
                    folder: q.folder.fsPath
                });
            }
            if (query.extraFileResources) {
                for (var _a = 0, _b = query.extraFileResources; _a < _b.length; _a++) {
                    var r = _b[_a];
                    if (r.scheme === network_1.Schemas.file) {
                        rawSearch.extraFiles.push(r.fsPath);
                    }
                }
            }
            if (query.type === search_1.QueryType.Text) {
                rawSearch.contentPattern = query.contentPattern;
            }
            return rawSearch;
        };
        DiskSearch.collectResultsFromEvent = function (event, onProgress) {
            var _this = this;
            var result = [];
            var listener;
            return new winjs_base_1.TPromise(function (c, e) {
                listener = event(function (ev) {
                    if (search_2.isSerializedSearchComplete(ev)) {
                        if (search_2.isSerializedSearchSuccess(ev)) {
                            c({
                                limitHit: ev.limitHit,
                                results: result,
                                stats: ev.stats
                            });
                        }
                        else {
                            e(ev.error);
                        }
                        listener.dispose();
                    }
                    else {
                        // Matches
                        if (Array.isArray(ev)) {
                            var fileMatches = ev.map(function (d) { return _this.createFileMatch(d); });
                            result = result.concat(fileMatches);
                            if (onProgress) {
                                fileMatches.forEach(onProgress);
                            }
                        }
                        // Match
                        else if (ev.path) {
                            var fileMatch = _this.createFileMatch(ev);
                            result.push(fileMatch);
                            if (onProgress) {
                                onProgress(fileMatch);
                            }
                        }
                        // Progress
                        else if (onProgress) {
                            onProgress(ev);
                        }
                    }
                });
            }, function () { return listener && listener.dispose(); });
        };
        DiskSearch.createFileMatch = function (data) {
            var fileMatch = new search_1.FileMatch(uri_1.default.file(data.path));
            if (data.lineMatches) {
                for (var j = 0; j < data.lineMatches.length; j++) {
                    fileMatch.lineMatches.push(new search_1.LineMatch(data.lineMatches[j].preview, data.lineMatches[j].lineNumber, data.lineMatches[j].offsetAndLengths));
                }
            }
            return fileMatch;
        };
        DiskSearch.prototype.clearCache = function (cacheKey) {
            return this.raw.clearCache(cacheKey);
        };
        return DiskSearch;
    }());
    exports.DiskSearch = DiskSearch;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



































define(__m[132/*vs/workbench/node/extensionHostMain*/], __M([0/*require*/,1/*exports*/,113/*vs/nls!vs/workbench/node/extensionHostMain*/,47/*vs/base/node/pfs*/,2/*vs/base/common/winjs.base*/,22/*path*/,166/*vs/workbench/api/node/extHostExtensionService*/,170/*vs/workbench/api/node/extHostConfiguration*/,212/*vs/workbench/api/node/extHostWorkspace*/,71/*vs/platform/search/common/search*/,95/*vs/workbench/services/search/node/searchService*/,6/*vs/workbench/api/node/extHost.protocol*/,14/*vs/base/common/errors*/,48/*vs/workbench/api/node/extHostExtensionActivator*/,9/*vs/base/common/lifecycle*/,213/*vs/workbench/services/extensions/node/rpcProtocol*/,4/*vs/base/common/uri*/,151/*vs/workbench/api/node/extHostLogService*/]), function (require, exports, nls, pfs, winjs_base_1, path_1, extHostExtensionService_1, extHostConfiguration_1, extHostWorkspace_1, search_1, searchService_1, extHost_protocol_1, errors, extHostExtensionActivator_1, lifecycle_1, rpcProtocol_1, uri_1, extHostLogService_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var nativeExit = process.exit.bind(process);
    function patchProcess(allowExit) {
        process.exit = function (code) {
            if (allowExit) {
                exit(code);
            }
            else {
                var err = new Error('An extension called process.exit() and this was prevented.');
                console.warn(err.stack);
            }
        };
        process.crash = function () {
            var err = new Error('An extension called process.crash() and this was prevented.');
            console.warn(err.stack);
        };
    }
    function exit(code) {
        // See https://github.com/Microsoft/vscode/issues/32990
        // calling process.exit() does not exit the process when the process is being debugged
        // It waits for the debugger to disconnect, but in our version, the debugger does not
        // receive an event that the process desires to exit such that it can disconnect.
        var watchdog = null;
        try {
            watchdog = require.__$__nodeRequire('native-watchdog');
        }
        catch (err) {
            nativeExit(code);
            return;
        }
        // Do exactly what node.js would have done, minus the wait for the debugger part
        if (code || code === 0) {
            process.exitCode = code;
        }
        if (!process._exiting) {
            process._exiting = true;
            process.emit('exit', process.exitCode || 0);
        }
        watchdog.exit(process.exitCode || 0);
    }
    exports.exit = exit;
    var ExtensionHostMain = /** @class */ (function () {
        function ExtensionHostMain(protocol, initData) {
            this._isTerminating = false;
            this.disposables = [];
            this._environment = initData.environment;
            var allowExit = !!this._environment.extensionTestsPath; // to support other test frameworks like Jasmin that use process.exit (https://github.com/Microsoft/vscode/issues/37708)
            patchProcess(allowExit);
            // services
            var rpcProtocol = new rpcProtocol_1.RPCProtocol(protocol);
            this._workspace = rpcProtocol.transformIncomingURIs(initData.workspace);
            // ensure URIs are revived
            initData.extensions.forEach(function (ext) { return ext.extensionLocation = uri_1.default.revive(ext.extensionLocation); });
            this._extHostLogService = new extHostLogService_1.ExtHostLogService(initData.windowId, initData.logLevel, initData.logsPath);
            this.disposables.push(this._extHostLogService);
            var extHostWorkspace = new extHostWorkspace_1.ExtHostWorkspace(rpcProtocol, initData.workspace, this._extHostLogService);
            this._extHostLogService.info('extension host started');
            this._extHostLogService.trace('initData', initData);
            this._extHostConfiguration = new extHostConfiguration_1.ExtHostConfiguration(rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadConfiguration), extHostWorkspace, initData.configuration);
            this._extensionService = new extHostExtensionService_1.ExtHostExtensionService(initData, rpcProtocol, extHostWorkspace, this._extHostConfiguration, this._extHostLogService);
            // error forwarding and stack trace scanning
            Error.stackTraceLimit = 100; // increase number of stack frames (from 10, https://github.com/v8/v8/wiki/Stack-Trace-API)
            var extensionErrors = new WeakMap();
            this._extensionService.getExtensionPathIndex().then(function (map) {
                Error.prepareStackTrace = function (error, stackTrace) {
                    var stackTraceMessage = '';
                    var extension;
                    var fileName;
                    for (var _i = 0, stackTrace_1 = stackTrace; _i < stackTrace_1.length; _i++) {
                        var call = stackTrace_1[_i];
                        stackTraceMessage += "\n\tat " + call.toString();
                        fileName = call.getFileName();
                        if (!extension && fileName) {
                            extension = map.findSubstr(fileName);
                        }
                    }
                    extensionErrors.set(error, extension);
                    return (error.name || 'Error') + ": " + (error.message || '') + stackTraceMessage;
                };
            });
            var mainThreadExtensions = rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadExtensionService);
            var mainThreadErrors = rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadErrors);
            errors.setUnexpectedErrorHandler(function (err) {
                var data = errors.transformErrorForSerialization(err);
                var extension = extensionErrors.get(err);
                if (extension) {
                    mainThreadExtensions.$onExtensionRuntimeError(extension.id, data);
                }
                else {
                    mainThreadErrors.$onUnexpectedError(data);
                }
            });
        }
        ExtensionHostMain.prototype.start = function () {
            var _this = this;
            return this._extensionService.onExtensionAPIReady()
                .then(function () { return _this.handleEagerExtensions(); })
                .then(function () { return _this.handleExtensionTests(); })
                .then(function () {
                _this._extHostLogService.info("eager extensions activated");
            });
        };
        ExtensionHostMain.prototype.terminate = function () {
            var _this = this;
            if (this._isTerminating) {
                // we are already shutting down...
                return;
            }
            this._isTerminating = true;
            this.disposables = lifecycle_1.dispose(this.disposables);
            errors.setUnexpectedErrorHandler(function (err) {
                // TODO: write to log once we have one
            });
            var allPromises = [];
            try {
                var allExtensions = this._extensionService.getAllExtensionDescriptions();
                var allExtensionsIds = allExtensions.map(function (ext) { return ext.id; });
                var activatedExtensions = allExtensionsIds.filter(function (id) { return _this._extensionService.isActivated(id); });
                allPromises = activatedExtensions.map(function (extensionId) {
                    return _this._extensionService.deactivate(extensionId);
                });
            }
            catch (err) {
                // TODO: write to log once we have one
            }
            var extensionsDeactivated = winjs_base_1.TPromise.join(allPromises).then(function () { return void 0; });
            // Give extensions 1 second to wrap up any async dispose, then exit
            setTimeout(function () {
                winjs_base_1.TPromise.any([winjs_base_1.TPromise.timeout(4000), extensionsDeactivated]).then(function () { return exit(); }, function () { return exit(); });
            }, 1000);
        };
        // Handle "eager" activation extensions
        ExtensionHostMain.prototype.handleEagerExtensions = function () {
            this._extensionService.activateByEvent('*', true).then(null, function (err) {
                console.error(err);
            });
            return this.handleWorkspaceContainsEagerExtensions();
        };
        ExtensionHostMain.prototype.handleWorkspaceContainsEagerExtensions = function () {
            var _this = this;
            if (!this._workspace || this._workspace.folders.length === 0) {
                return winjs_base_1.TPromise.as(null);
            }
            return winjs_base_1.TPromise.join(this._extensionService.getAllExtensionDescriptions().map(function (desc) {
                return _this.handleWorkspaceContainsEagerExtension(desc);
            })).then(function () { });
        };
        ExtensionHostMain.prototype.handleWorkspaceContainsEagerExtension = function (desc) {
            var _this = this;
            var activationEvents = desc.activationEvents;
            if (!activationEvents) {
                return winjs_base_1.TPromise.as(void 0);
            }
            var fileNames = [];
            var globPatterns = [];
            for (var i = 0; i < activationEvents.length; i++) {
                if (/^workspaceContains:/.test(activationEvents[i])) {
                    var fileNameOrGlob = activationEvents[i].substr('workspaceContains:'.length);
                    if (fileNameOrGlob.indexOf('*') >= 0 || fileNameOrGlob.indexOf('?') >= 0) {
                        globPatterns.push(fileNameOrGlob);
                    }
                    else {
                        fileNames.push(fileNameOrGlob);
                    }
                }
            }
            if (fileNames.length === 0 && globPatterns.length === 0) {
                return winjs_base_1.TPromise.as(void 0);
            }
            var fileNamePromise = winjs_base_1.TPromise.join(fileNames.map(function (fileName) { return _this.activateIfFileName(desc.id, fileName); })).then(function () { });
            var globPatternPromise = this.activateIfGlobPatterns(desc.id, globPatterns);
            return winjs_base_1.TPromise.join([fileNamePromise, globPatternPromise]).then(function () { });
        };
        ExtensionHostMain.prototype.activateIfFileName = function (extensionId, fileName) {
            return __awaiter(this, void 0, void 0, function () {
                var _i, _a, uri;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _i = 0, _a = this._workspace.folders;
                            _b.label = 1;
                        case 1:
                            if (!(_i < _a.length)) return [3 /*break*/, 4];
                            uri = _a[_i].uri;
                            return [4 /*yield*/, pfs.exists(path_1.join(uri_1.default.revive(uri).fsPath, fileName))];
                        case 2:
                            if (_b.sent()) {
                                // the file was found
                                return [2 /*return*/, (this._extensionService.activateById(extensionId, new extHostExtensionActivator_1.ExtensionActivatedByEvent(true, "workspaceContains:" + fileName))
                                        .done(null, function (err) { return console.error(err); }))];
                            }
                            _b.label = 3;
                        case 3:
                            _i++;
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/, undefined];
                    }
                });
            });
        };
        ExtensionHostMain.prototype.activateIfGlobPatterns = function (extensionId, globPatterns) {
            return __awaiter(this, void 0, void 0, function () {
                var includes, folderQueries, config, useRipgrep, followSymlinks, query, result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._extHostLogService.trace("extensionHostMain#activateIfGlobPatterns: fileSearch, extension: " + extensionId + ", entryPoint: workspaceContains");
                            if (globPatterns.length === 0) {
                                return [2 /*return*/, winjs_base_1.TPromise.as(void 0)];
                            }
                            if (!this._diskSearch) {
                                // Shut down this search process after 1s
                                this._diskSearch = new searchService_1.DiskSearch(false, 1000);
                            }
                            includes = {};
                            globPatterns.forEach(function (globPattern) {
                                includes[globPattern] = true;
                            });
                            folderQueries = this._workspace.folders.map(function (folder) { return ({ folder: uri_1.default.revive(folder.uri) }); });
                            config = this._extHostConfiguration.getConfiguration('search');
                            useRipgrep = config.get('useRipgrep', true);
                            followSymlinks = config.get('followSymlinks', true);
                            query = {
                                folderQueries: folderQueries,
                                type: search_1.QueryType.File,
                                exists: true,
                                includePattern: includes,
                                useRipgrep: useRipgrep,
                                ignoreSymlinks: !followSymlinks
                            };
                            return [4 /*yield*/, this._diskSearch.search(query)];
                        case 1:
                            result = _a.sent();
                            if (result.limitHit) {
                                // a file was found matching one of the glob patterns
                                return [2 /*return*/, (this._extensionService.activateById(extensionId, new extHostExtensionActivator_1.ExtensionActivatedByEvent(true, "workspaceContains:" + globPatterns.join(',')))
                                        .done(null, function (err) { return console.error(err); }))];
                            }
                            return [2 /*return*/, winjs_base_1.TPromise.as(void 0)];
                    }
                });
            });
        };
        ExtensionHostMain.prototype.handleExtensionTests = function () {
            var _this = this;
            if (!this._environment.extensionTestsPath || !this._environment.extensionDevelopmentPath) {
                return winjs_base_1.TPromise.as(null);
            }
            // Require the test runner via node require from the provided path
            var testRunner;
            var requireError;
            try {
                testRunner = require.__$__nodeRequire(this._environment.extensionTestsPath);
            }
            catch (error) {
                requireError = error;
            }
            // Execute the runner if it follows our spec
            if (testRunner && typeof testRunner.run === 'function') {
                return new winjs_base_1.TPromise(function (c, e) {
                    testRunner.run(_this._environment.extensionTestsPath, function (error, failures) {
                        if (error) {
                            e(error.toString());
                        }
                        else {
                            c(null);
                        }
                        // after tests have run, we shutdown the host
                        _this.gracefulExit(failures && failures > 0 ? 1 /* ERROR */ : 0 /* OK */);
                    });
                });
            }
            // Otherwise make sure to shutdown anyway even in case of an error
            else {
                this.gracefulExit(1 /* ERROR */);
            }
            return winjs_base_1.TPromise.wrapError(new Error(requireError ? requireError.toString() : nls.localize(0, null, this._environment.extensionTestsPath)));
        };
        ExtensionHostMain.prototype.gracefulExit = function (code) {
            // to give the PH process a chance to flush any outstanding console
            // messages to the main process, we delay the exit() by some time
            setTimeout(function () { return exit(code); }, 500);
        };
        return ExtensionHostMain;
    }());
    exports.ExtensionHostMain = ExtensionHostMain;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[242/*vs/workbench/node/extensionHostProcess*/], __M([0/*require*/,1/*exports*/,14/*vs/base/common/errors*/,132/*vs/workbench/node/extensionHostMain*/,116/*vs/base/parts/ipc/node/ipc.net*/,57/*net*/,3/*vs/base/common/event*/]), function (require, exports, errors_1, extensionHostMain_1, ipc_net_1, net_1, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // With Electron 2.x and node.js 8.x the "natives" module
    // can cause a native crash (see https://github.com/nodejs/node/issues/19891 and
    // https://github.com/electron/electron/issues/10905). To prevent this from
    // happening we essentially blocklist this module from getting loaded in any
    // extension by patching the node require() function.
    (function () {
        var Module = require.__$__nodeRequire('module');
        var originalLoad = Module._load;
        Module._load = function (request) {
            if (request === 'natives') {
                throw new Error('Either the extension or a NPM dependency is using the "natives" node module which is unsupported as it can cause a crash of the extension host. Click [here](https://go.microsoft.com/fwlink/?linkid=871887) to find out more');
            }
            return originalLoad.apply(this, arguments);
        };
    })();
    // This calls exit directly in case the initialization is not finished and we need to exit
    // Otherwise, if initialization completed we go to extensionHostMain.terminate()
    var onTerminate = function () {
        extensionHostMain_1.exit();
    };
    function createExtHostProtocol() {
        var pipeName = process.env.VSCODE_IPC_HOOK_EXTHOST;
        return new Promise(function (resolve, reject) {
            var socket = net_1.createConnection(pipeName, function () {
                socket.removeListener('error', reject);
                resolve(new ipc_net_1.Protocol(socket));
            });
            socket.once('error', reject);
        }).then(function (protocol) {
            return new /** @class */ (function () {
                function class_1() {
                    var _this = this;
                    this._terminating = false;
                    this.onMessage = event_1.filterEvent(protocol.onMessage, function (msg) {
                        if (msg.type !== '__$terminate') {
                            return true;
                        }
                        _this._terminating = true;
                        onTerminate();
                        return false;
                    });
                }
                class_1.prototype.send = function (msg) {
                    if (!this._terminating) {
                        protocol.send(msg);
                    }
                };
                return class_1;
            }());
        });
    }
    function connectToRenderer(protocol) {
        return new Promise(function (c, e) {
            // Listen init data message
            var first = protocol.onMessage(function (raw) {
                first.dispose();
                var initData = JSON.parse(raw);
                // Print a console message when rejection isn't handled within N seconds. For details:
                // see https://nodejs.org/api/process.html#process_event_unhandledrejection
                // and https://nodejs.org/api/process.html#process_event_rejectionhandled
                var unhandledPromises = [];
                process.on('unhandledRejection', function (reason, promise) {
                    unhandledPromises.push(promise);
                    setTimeout(function () {
                        var idx = unhandledPromises.indexOf(promise);
                        if (idx >= 0) {
                            unhandledPromises.splice(idx, 1);
                            console.warn('rejected promise not handled within 1 second');
                            errors_1.onUnexpectedError(reason);
                        }
                    }, 1000);
                });
                process.on('rejectionHandled', function (promise) {
                    var idx = unhandledPromises.indexOf(promise);
                    if (idx >= 0) {
                        unhandledPromises.splice(idx, 1);
                    }
                });
                // Print a console message when an exception isn't handled.
                process.on('uncaughtException', function (err) {
                    errors_1.onUnexpectedError(err);
                });
                process.on('SIGPIPE', function () {
                    errors_1.onUnexpectedError(new Error('Unexpected SIGPIPE'));
                });
                // Kill oneself if one's parent dies. Much drama.
                setInterval(function () {
                    try {
                        process.kill(initData.parentPid, 0); // throws an exception if the main process doesn't exist anymore.
                    }
                    catch (e) {
                        onTerminate();
                    }
                }, 5000);
                // Tell the outside that we are initialized
                protocol.send('initialized');
                c({ protocol: protocol, initData: initData });
            });
            // Tell the outside that we are ready to receive messages
            protocol.send('ready');
        });
    }
    patchExecArgv();
    createExtHostProtocol().then(function (protocol) {
        // connect to main side
        return connectToRenderer(protocol);
    }).then(function (renderer) {
        // setup things
        var extensionHostMain = new extensionHostMain_1.ExtensionHostMain(renderer.protocol, renderer.initData);
        onTerminate = function () { return extensionHostMain.terminate(); };
        return extensionHostMain.start();
    }).catch(function (err) { return console.error(err); });
    function patchExecArgv() {
        // when encountering the prevent-inspect flag we delete this
        // and the prior flag
        if (process.env.VSCODE_PREVENT_FOREIGN_INSPECT) {
            for (var i = 0; i < process.execArgv.length; i++) {
                if (process.execArgv[i].match(/--inspect-brk=\d+|--inspect=\d+/)) {
                    process.execArgv.splice(i, 1);
                    break;
                }
            }
        }
    }
});

}).call(this);
//# sourceMappingURL=extensionHostProcess.js.map
